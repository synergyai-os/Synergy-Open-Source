/**
 * Style Dictionary Configuration - Phase 4
 *
 * DTCG is source of truth, CSS is generated artifact.
 *
 * Architecture Decision (SYOS-434):
 * - Phase 4 (Current): DTCG becomes source of truth
 *   - Style Dictionary reads design-tokens-base.json (DTCG format)
 *   - Style Dictionary generates CSS from DTCG
 *   - CSS becomes generated artifact
 *
 * Usage:
 *   npm run tokens:build            # Generate CSS from DTCG
 *   npm run tokens:validate        # Validates CSS tokens
 *   npm run tokens:validate-dtcg   # Validates DTCG format
 */

import StyleDictionary from 'style-dictionary';
import { convertDTCGToSD } from './scripts/style-dictionary/prepare-tokens.js';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Pre-process DTCG to Style Dictionary format
// Read both base and semantic token files, merge them into single SD format
const baseDtcgPath = path.join(__dirname, 'design-tokens-base.json');
const semanticDtcgPath = path.join(__dirname, 'design-tokens-semantic.json');
const tokensPath = path.join(__dirname, 'tokens.json');

// Convert DTCG files to SD format before Style Dictionary runs
const dtcgPaths = [];
if (fs.existsSync(baseDtcgPath)) {
	dtcgPaths.push(baseDtcgPath);
}
if (fs.existsSync(semanticDtcgPath)) {
	dtcgPaths.push(semanticDtcgPath);
}

if (dtcgPaths.length > 0) {
	convertDTCGToSD(dtcgPaths, tokensPath);
}

import {
	transformTailwindTheme,
	transformTailwindUtility,
	transformValidateSemanticReference
} from './scripts/style-dictionary/transforms.js';

// Register custom transforms
StyleDictionary.registerTransform({
	name: 'tailwind/theme',
	type: 'value',
	transitive: false,
	transform: transformTailwindTheme
});

StyleDictionary.registerTransform({
	name: 'tailwind/utility',
	type: 'value',
	transitive: false,
	transform: transformTailwindUtility
});

StyleDictionary.registerTransform({
	name: 'validate/semantic-reference',
	type: 'value',
	transitive: false,
	transform: transformValidateSemanticReference
});

// Register custom format for @theme blocks
StyleDictionary.registerFormat({
	name: 'tailwind/theme',
	format: ({ dictionary }) => {
		const transformedTokens = dictionary.allTokens
			.map((token) => transformTailwindTheme(token))
			.filter(Boolean);

		// Separate conditional tokens from regular tokens
		const regularTokens = [];
		const conditionalTokens = [];

		for (const transformed of transformedTokens) {
			if (transformed && typeof transformed === 'object' && transformed.isConditional) {
				conditionalTokens.push(transformed);
			} else {
				regularTokens.push(transformed);
			}
		}

		const header = `/**
 * AUTO-GENERATED - DO NOT EDIT
 * 
 * This file is automatically generated from design-tokens-base.json (DTCG format).
 * To modify tokens, edit design-tokens-base.json and run: npm run tokens:build
 * 
 * Generated: ${new Date().toISOString()}
 */
`;

		// Build output: @theme block for regular tokens, then conditional tokens outside
		let output = header;

		// Regular tokens in @theme block
		if (regularTokens.length > 0) {
			output += `@theme {\n${regularTokens.join('\n')}\n}\n\n`;
		}

		// Conditional tokens: Default values (light mode)
		if (conditionalTokens.length > 0) {
			output += `/* Conditional tokens - Light mode default */\n:root {\n`;
			output += conditionalTokens.map((t) => t.default).join('\n');
			output += `\n}\n\n`;

			// Media query for dark mode (system preference)
			output += `/* Dark mode (system preference) */\n`;
			output += conditionalTokens.map((t) => t.mediaQuery).join('\n\n');
			output += `\n\n`;

			// Class-based overrides (user preference)
			output += `/* Light mode override (user preference) */\n`;
			output += conditionalTokens.map((t) => t.lightClass).join('\n');
			output += `\n\n`;

			output += `/* Dark mode override (user preference) */\n`;
			output += conditionalTokens.map((t) => t.darkClass).join('\n');
			output += `\n`;
		}

		return output;
	}
});

// Register custom format for @utility blocks
StyleDictionary.registerFormat({
	name: 'tailwind/utility',
	format: ({ dictionary }) => {
		const utilities = dictionary.allTokens
			.map((token) => transformTailwindUtility(token))
			.filter(Boolean)
			.join('\n\n');

		const header = `/**
 * AUTO-GENERATED - DO NOT EDIT
 * 
 * This file is automatically generated from design-tokens-base.json (DTCG format).
 * To modify tokens, edit design-tokens-base.json and run: npm run tokens:build
 * 
 * Generated: ${new Date().toISOString()}
 */
`;

		return `${header}${utilities}`;
	}
});

export default {
	// Source: Pre-processed tokens (converted from DTCG)
	source: ['tokens.json'],

	// Platforms: Generate CSS files
	platforms: {
		css: {
			transformGroup: 'css',
			buildPath: 'src/styles/tokens/',
			files: [
				{
					destination: 'spacing.css',
					format: 'tailwind/theme',
					filter: (token) => token.path[0] === 'spacing'
				},
				{
					destination: 'colors.css',
					format: 'tailwind/theme',
					filter: (token) => token.path[0] === 'color'
				},
				{
					destination: 'typography.css',
					format: 'tailwind/theme',
					filter: (token) => token.path[0] === 'typography'
				},
				{
					destination: 'fonts.css',
					format: 'tailwind/theme',
					filter: (token) => token.path[0] === 'fonts'
				},
				{
					destination: 'effects.css',
					format: 'tailwind/theme',
					filter: (token) =>
						token.path[0] === 'shadow' ||
						token.path[0] === 'borderRadius' ||
						token.path[0] === 'transition' ||
						token.path[0] === 'zIndex'
				},
				{
					destination: 'sizes.css',
					format: 'tailwind/theme',
					filter: (token) => token.path[0] === 'sizing'
				},
				{
					destination: 'breakpoints.css',
					format: 'tailwind/theme',
					filter: (token) => token.path[0] === 'breakpoints'
				},
				{
					destination: 'opacity.css',
					format: 'tailwind/theme',
					filter: (token) => token.path[0] === 'opacity'
				}
			]
		},
		utilities: {
			transformGroup: 'css',
			buildPath: 'src/styles/utilities/',
			files: [
				{
					destination: 'spacing-utils.css',
					format: 'tailwind/utility',
					filter: (token) => token.path[0] === 'spacing'
				},
				{
					destination: 'color-utils.css',
					format: 'tailwind/utility',
					filter: (token) => token.path[0] === 'color'
				},
				{
					destination: 'typography-utils.css',
					format: 'tailwind/utility',
					filter: (token) => token.path[0] === 'typography'
				},
				{
					destination: 'fonts-utils.css',
					format: 'tailwind/utility',
					filter: (token) => token.path[0] === 'fonts'
				},
				{
					destination: 'component-utils.css',
					format: 'tailwind/utility',
					filter: (token) =>
						token.path[0] === 'shadow' ||
						token.path[0] === 'borderRadius' ||
						token.path[0] === 'sizing'
				},
				{
					destination: 'opacity-utils.css',
					format: 'tailwind/utility',
					filter: (token) => token.path[0] === 'opacity'
				}
			]
		}
	}
};
