import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { ConvexHttpClient } from 'convex/browser';
import { env as publicEnv } from '$env/dynamic/public';
import { api } from '$convex/_generated/api';
import { getActiveSessionRecordForUser } from '$lib/infrastructure/auth/server/sessionStore';
import { generateRandomToken } from '$lib/infrastructure/auth/server/crypto';

export const GET: RequestHandler = async ({ locals }) => {
	const { auth } = locals;

	console.log('üîç [/auth/linked-sessions] Request received:', {
		hasAuth: !!auth,
		hasSessionId: !!auth?.sessionId,
		hasUser: !!auth?.user,
		currentUserId: auth?.user?.userId,
		currentUserEmail: auth?.user?.email
	});

	if (!auth?.sessionId || !auth.user) {
		console.error('‚ùå [/auth/linked-sessions] Not authenticated');
		return json({ error: 'Not authenticated' }, { status: 401 });
	}

	if (!publicEnv.PUBLIC_CONVEX_URL) {
		throw new Error('PUBLIC_CONVEX_URL must be configured.');
	}

	const convex = new ConvexHttpClient(publicEnv.PUBLIC_CONVEX_URL);

	try {
		// Get all linked accounts for the current user
		console.log('üîç [/auth/linked-sessions] Fetching linked accounts...');
		const linkedAccounts = await convex.query(api.users.listLinkedAccounts, {
			sessionId: auth.sessionId
		});
		console.log('‚úÖ [/auth/linked-sessions] Linked accounts fetched:', {
			count: linkedAccounts.length,
			accounts: linkedAccounts.map((a) => ({
				userId: a.userId,
				email: a.email,
				name: a.name
			}))
		});

		// Get active sessions and organizations for each linked account
		const linkedSessions: Array<{
			userId: string;
			sessionId: string;
			csrfToken: string;
			expiresAt: number;
			userEmail: string;
			userName?: string;
			organizations: Array<{
				organizationId: string;
				name: string;
				initials: string | null;
				slug: string | null;
				role: string;
			}>;
		}> = [];

		for (const account of linkedAccounts) {
			try {
				console.log(`üîç [/auth/linked-sessions] Fetching session for account:`, {
					userId: account.userId,
					email: account.email
				});
				const sessionRecord = await getActiveSessionRecordForUser({
					sessionId: auth.sessionId,
					targetUserId: account.userId
				});
				console.log(`üìã [/auth/linked-sessions] Session record result:`, {
					userId: account.userId,
					hasSession: !!sessionRecord,
					expiresAt: sessionRecord?.expiresAt,
					isExpired: sessionRecord ? sessionRecord.expiresAt <= Date.now() : null,
					now: Date.now()
				});

				if (sessionRecord && sessionRecord.expiresAt > Date.now()) {
					// Generate a new CSRF token for localStorage (will be validated/updated on switch)
					// Note: The actual CSRF token is hashed in Convex, so we generate a placeholder
					// that will be properly set when the account is switched to
					const csrfToken = generateRandomToken(32);

					// Fetch organizations for this account using their sessionId
					console.log(`üîç [/auth/linked-sessions] Fetching organizations for account:`, {
						userId: account.userId,
						email: account.email,
						sessionId: sessionRecord.sessionId
					});
					const accountOrganizations = await convex.query(api.organizations.listOrganizations, {
						sessionId: sessionRecord.sessionId
					});
					console.log(`‚úÖ [/auth/linked-sessions] Organizations fetched:`, {
						userId: account.userId,
						email: account.email,
						orgCount: accountOrganizations.length,
						orgs: accountOrganizations.map((o) => ({
							id: o.organizationId,
							name: o.name,
							role: o.role
						}))
					});

					const sessionData = {
						userId: account.userId,
						sessionId: sessionRecord.sessionId,
						csrfToken,
						expiresAt: sessionRecord.expiresAt,
						userEmail: account.email ?? '',
						userName: account.name ?? undefined,
						organizations: accountOrganizations.map((org) => ({
							organizationId: org.organizationId,
							name: org.name,
							initials: org.initials,
							slug: org.slug,
							role: org.role
						}))
					};

					linkedSessions.push(sessionData);
					console.log(`‚úÖ [/auth/linked-sessions] Added session for account:`, {
						userId: account.userId,
						email: account.email,
						sessionId: sessionRecord.sessionId,
						orgCount: sessionData.organizations.length
					});
				} else {
					console.warn(`‚ö†Ô∏è [/auth/linked-sessions] Skipping account (no valid session):`, {
						userId: account.userId,
						email: account.email,
						reason: !sessionRecord ? 'no session record' : 'session expired'
					});
				}
			} catch (error) {
				console.error(
					`‚ùå [/auth/linked-sessions] Failed to get session for linked account ${account.userId}:`,
					error
				);
				// Continue with other accounts
			}
		}

		console.log('‚úÖ [/auth/linked-sessions] Returning sessions:', {
			count: linkedSessions.length,
			sessions: linkedSessions.map((s) => ({
				userId: s.userId,
				email: s.userEmail,
				sessionId: s.sessionId,
				orgCount: s.organizations.length
			}))
		});

		return json({ sessions: linkedSessions });
	} catch (error) {
		console.error('‚ùå [/auth/linked-sessions] Failed to fetch linked account sessions:', error);
		return json({ error: 'Failed to fetch linked account sessions' }, { status: 500 });
	}
};
