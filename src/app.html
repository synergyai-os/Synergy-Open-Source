<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
		/>
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="theme-color" content="#000000" />
		<!-- Conditional color tokens - loaded via link to bypass Tailwind parser -->
		<!-- Tailwind v4's parser cannot handle CSS selectors (@media, .light, .dark) outside @theme blocks -->
		<link rel="stylesheet" href="/css/colors-conditional.css" />
		<!-- Google Fonts: Plus Jakarta Sans + JetBrains Mono -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:ital,wght@0,200..800;1,200..800&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
			rel="stylesheet"
		/>
		<style>
			/* CRITICAL: Hide any stale overlays immediately (before JavaScript runs) */
			/* This prevents "Loading Randy Hereman" from cached HTML from showing */
			#__switching-overlay:not([data-valid='true']) {
				display: none !important;
				visibility: hidden !important;
				opacity: 0 !important;
			}
		</style>
		<script>
			// CRITICAL: Remove any stale overlays IMMEDIATELY (before anything else renders)
			// This must run synchronously before any other scripts to catch cached HTML overlays
			(function removeStaleOverlays() {
				try {
					function checkAndRemove() {
						if (!document.body) return;

						// ONLY remove the specific overlay element by ID (don't scan all elements - too aggressive)
						const overlayById = document.getElementById('__switching-overlay');
						if (overlayById) {
							const headingText = overlayById.querySelector('h1, h2, h3')?.textContent || '';
							const text = overlayById.textContent || '';
							const hasValidAttr = overlayById.getAttribute('data-valid') === 'true';

							// Remove if it has wrong text AND doesn't have valid attribute
							if (
								!hasValidAttr &&
								headingText.includes('Loading') &&
								(headingText.includes('Randy') ||
									headingText.includes('Hereman') ||
									(headingText !== 'Switching account' && headingText !== 'Loading workspace'))
							) {
								overlayById.remove();
							} else if (!hasValidAttr) {
								// Remove any overlay without valid attribute (CSS will hide it, but remove it too)
								overlayById.remove();
							}
						}
					}

					// Check immediately if body exists
					if (document.body) {
						checkAndRemove();
					} else {
						// Wait for DOMContentLoaded if body doesn't exist yet
						if (document.readyState === 'loading') {
							document.addEventListener('DOMContentLoaded', checkAndRemove, { once: true });
						}
					}
				} catch (e) {
					// Silently fail if cleanup fails
				}
			})();

			// Prevent FOUC (Flash of Unstyled Content) by applying theme immediately
			(function () {
				try {
					const stored = localStorage.getItem('synergyos-theme');
					const theme = stored === 'light' || stored === 'dark' ? stored : 'light'; // Default to light mode

					if (theme === 'dark') {
						document.documentElement.classList.add('dark');
						document.documentElement.classList.remove('light');
					} else {
						document.documentElement.classList.add('light');
						document.documentElement.classList.remove('dark');
					}
				} catch (e) {
					// Fallback to light mode if localStorage access fails
					document.documentElement.classList.add('light');
					document.documentElement.classList.remove('dark');
				}
			})();

			// Prevent overlay flash during account/workspace switching
			(function () {
				try {
					// CRITICAL: Remove any existing overlays IMMEDIATELY (before DOMContentLoaded)
					// This handles browser-cached HTML with old overlay content
					// Run synchronously before any async operations
					(function removeExistingOverlays() {
						function checkAndRemoveOverlays() {
							// Check for overlay in document
							const existingOverlay = document.getElementById('__switching-overlay');
							if (existingOverlay) {
								existingOverlay.remove();
							}

							// Also check for any elements with overlay-like content
							// This catches old overlays that might have different IDs
							const allOverlays = Array.from(
								document.querySelectorAll('[id*="overlay"], [class*="overlay"]')
							);
							const suspiciousOverlays = allOverlays.filter((el) => {
								const text = el.textContent || '';
								const heading = el.querySelector('h2')?.textContent || '';
								// Check for "Loading [Name]" pattern with account names
								return (
									(text.includes('Loading') || heading.includes('Loading')) &&
									(text.includes('Randy') ||
										text.includes('Hereman') ||
										heading.includes('Randy') ||
										heading.includes('Hereman') ||
										(heading.includes('Loading') &&
											heading !== 'Switching account' &&
											heading !== 'Loading workspace'))
								);
							});

							if (suspiciousOverlays.length > 0) {
								suspiciousOverlays.forEach((el) => el.remove());
							}
						}

						// Check immediately if DOM is ready
						if (document.body) {
							checkAndRemoveOverlays();
						}

						// Also check when DOM becomes ready (if script runs before DOMContentLoaded)
						if (document.readyState === 'loading') {
							document.addEventListener('DOMContentLoaded', checkAndRemoveOverlays, { once: true });
						}

						// Watch for any overlays added after script runs (catches late additions)
						// Only observe if document.body exists and is a valid Node
						if (
							document.body &&
							document.body.nodeType === 1 &&
							typeof MutationObserver !== 'undefined'
						) {
							try {
								const observer = new MutationObserver(function (mutations) {
									mutations.forEach(function (mutation) {
										mutation.addedNodes.forEach(function (node) {
											if (node.nodeType === 1) {
												// Element node
												const el = node;
												// ONLY check the specific overlay ID (don't check all overlays - too aggressive)
												if (el.id === '__switching-overlay') {
													const headingText = el.querySelector('h1, h2, h3')?.textContent || '';
													const text = el.textContent || '';
													const hasValidAttr = el.getAttribute('data-valid') === 'true';

													if (
														!hasValidAttr &&
														headingText.includes('Loading') &&
														(headingText.includes('Randy') ||
															headingText.includes('Hereman') ||
															(headingText !== 'Switching account' &&
																headingText !== 'Loading workspace'))
													) {
														el.remove();
														observer.disconnect();
													}
												}
											}
										});
									});
								});

								observer.observe(document.body, {
									childList: true,
									subtree: true
								});

								// Disconnect after 5 seconds (overlays should be created within this time)
								setTimeout(() => {
									try {
										observer.disconnect();
									} catch (e) {
										// Ignore errors when disconnecting
									}
								}, 5000);
							} catch (e) {
								// Silently fail if MutationObserver setup fails
							}
						}
					})();

					const switchingData = sessionStorage.getItem('switchingAccount');

					if (switchingData) {
						const data = JSON.parse(switchingData);

						// EXPERIMENT: Commented out static overlay to test if it eliminates duplicate "Switching account" message
						// If Svelte loads fast enough, we don't need the static overlay
						// If there's a noticeable blank/flash during reload, we'll need to keep it but fix the timing
						/*
						// Sanitize accountName to prevent XSS
						const rawAccountName = data.accountName || 'workspace';
						const accountName = String(rawAccountName).replace(/[<>"'&]/g, function (char) {
							switch (char) {
								case '<':
									return '&lt;';
								case '>':
									return '&gt;';
								case '"':
									return '&quot;';
								case "'":
									return '&#39;';
								case '&':
									return '&amp;';
								default:
									return char;
							}
						});

						// Inject overlay HTML immediately (before Svelte loads)
						document.addEventListener('DOMContentLoaded', function () {
							// Check for existing overlay first
							const existingOverlay = document.getElementById('__switching-overlay');
							if (existingOverlay) {
								existingOverlay.remove();
							}

							const overlay = document.createElement('div');
							overlay.id = '__switching-overlay';

							// Create elements safely without innerHTML
							const container = document.createElement('div');
							container.style.cssText =
								'position:fixed;inset:0;z-index:9999;display:flex;align-items:center;justify-content:center;background:linear-gradient(to bottom right,rgba(37,99,235,0.1),var(--color-bg-base,#ffffff),rgba(37,99,235,0.05));backdrop-filter:blur(24px);-webkit-backdrop-filter:blur(24px)';

							const innerDiv = document.createElement('div');
							innerDiv.style.cssText =
								'display:flex;flex-direction:column;align-items:center;gap:2rem';

							const spinnerWrapper = document.createElement('div');
							spinnerWrapper.style.cssText = 'position:relative;width:48px;height:48px';

							const spinner = document.createElement('div');
							spinner.style.cssText =
								'position:absolute;inset:0;border-radius:9999px;border:4px solid var(--color-border-base,rgba(0,0,0,0.1));border-top-color:var(--color-accent-primary,rgb(37,99,235));animation:__spin 1s linear infinite';

							const textWrapper = document.createElement('div');
							textWrapper.style.cssText = 'text-align:center;max-width:28rem';

							const heading = document.createElement('h2');
							heading.style.cssText =
								'font-size:1.5rem;font-weight:600;color:var(--color-text-primary,rgb(17,24,39))';
							const headingText = 'Switching account'; // Safe: uses textContent
							heading.textContent = headingText;

							const subTextWrapper = document.createElement('div');
							subTextWrapper.style.cssText = 'text-align:center';

							const subText = document.createElement('p');
							subText.style.cssText =
								'font-size:0.875rem;color:var(--color-text-secondary,rgb(107,114,128))';
							subText.textContent = 'Gathering user data';

							const style = document.createElement('style');
							style.textContent = '@keyframes __spin { to { transform: rotate(360deg); } }';

							spinnerWrapper.appendChild(spinner);
							textWrapper.appendChild(heading);
							subTextWrapper.appendChild(subText);
							innerDiv.appendChild(spinnerWrapper);
							innerDiv.appendChild(textWrapper);
							innerDiv.appendChild(subTextWrapper);
							container.appendChild(innerDiv);
							overlay.appendChild(container);
							overlay.appendChild(style);
							// Mark as valid so CSS doesn't hide it (prevents CSS from hiding our correct overlay)
							overlay.setAttribute('data-valid', 'true');
							document.body.appendChild(overlay);

							// Set a marker so Svelte knows to clean this up
							window.__hasStaticOverlay = true;
						});
						*/
					}
				} catch (e) {
					// Silently fail if sessionStorage isn't available
				}
			})();
		</script>
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
