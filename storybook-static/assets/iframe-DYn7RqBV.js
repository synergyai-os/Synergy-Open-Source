const __vite__mapDeps = (
	i,
	m = __vite__mapDeps,
	d = m.f ||
		(m.f = [
			'./AspectRatio.stories-DLSwTcuM.js',
			'./create-runtime-stories-2rm03jka.js',
			'./index-QxUtaCdU.js',
			'./attributes-D2XuSyo_.js',
			'./class-BLXIZATI.js',
			'./style-MviLiK55.js',
			'./create-id-CD7dpc57.js',
			'./preload-helper-PPVm8Dsz.js',
			'./Avatar.stories-s2Yo3Vo8.js',
			'./Avatar-v8gaQbw7.js',
			'./Badge.stories-ByIlSobt.js',
			'./Badge-Bhcc4KqB.js',
			'./Button.stories-CuXy82RP.js',
			'./Button-2sxpTgAx.js',
			'./this-Hz0nHxQJ.js',
			'./Card.stories-BjzbGYQf.js',
			'./Card-BkEjQl_7.js',
			'./Checkbox.stories-CT2gzcze.js',
			'./watch.svelte-CYSsdG2H.js',
			'./context-DWcBTeuX.js',
			'./is-DtD5rb4o.js',
			'./kbd-constants-Duhtze-4.js',
			'./hidden-input-1T3DLxGL.js',
			'./input-XwGP8Xvd.js',
			'./Label-BXv2dhHR.js',
			'./Chip.stories-HbmuNntz.js',
			'./Chip-D9RR8mAy.js',
			'./FormInput.stories-D4SUjneU.js',
			'./FormInput-CwvyCBJx.js',
			'./FormTextarea.stories-BpLJCSMg.js',
			'./FormTextarea-DT7j-4wT.js',
			'./Heading.stories-CknTxXt_.js',
			'./Heading-C09xnpWF.js',
			'./Icon.stories-Pl0LsnSH.js',
			'./Icon-nf143nWr.js',
			'./IconButton.stories-CZVfYJS1.js',
			'./IconButton-BjKeipeo.js',
			'./KeyboardShortcut.stories-DykHV1xA.js',
			'./KeyboardShortcut-CeSHTUfy.js',
			'./each-DHv61wEY.js',
			'./Label.stories-CAeMGELq.js',
			'./Loading.stories-DTBDRL9w.js',
			'./Loading-D_6SL4r8.js',
			'./LoadingOverlay.stories-DvC68hSl.js',
			'./LoadingOverlay-Bob-KG3J.js',
			'./LoadingOverlay-CL11lvhX.css',
			'./Meter.stories-KrrQloTg.js',
			'./PinInput.stories-DX-ccyOe.js',
			'./PinInput-qBurm280.js',
			'./previous.svelte-BRBO0xyC.js',
			'./dom-context.svelte-Cee2qr-t.js',
			'./noop-DX6rZLP_.js',
			'./Progress.stories-dAN89FFo.js',
			'./RadioGroup.stories-YxsuGkkH.js',
			'./roving-focus-group-B-fCEnqo.js',
			'./ScrollArea.stories-9nf11pH9.js',
			'./is-BGFdVicR.js',
			'./use-id-C09Eugg1.js',
			'./ScrollArea-bHHIbcsu.css',
			'./Separator.stories-s9AoVv4d.js',
			'./Slider.stories-LzSAGrQm.js',
			'./arrays-C786ZheV.js',
			'./on-mount-effect.svelte-DajC3xwp.js',
			'./SplitButton.stories-O5kFaZuO.js',
			'./SplitButton-DPEFMT_j.js',
			'./Text-D3pLiP_j.js',
			'./StatusPill-DGMja1Ui.js',
			'./is-using-keyboard.svelte-qppEaaQk.js',
			'./popper-layer-force-mount-B5n7-529.js',
			'./portal-c1AsCbfc.js',
			'./ToggleGroup-tftps56f.css',
			'./StatusPill.stories-CLnBhhl8.js',
			'./Switch.stories-BkYPAsFZ.js',
			'./Text.stories-CNAGVoNW.js',
			'./Toggle.stories-DRUuQLOM.js',
			'./ToggleGroup.stories-QqWbJsRc.js',
			'./Tooltip.stories-DxRYWHip.js',
			'./Dialog.stories-CYuy5rO-.js',
			'./dialog-content-orwc9n3O.js',
			'./InboxCard.stories-Brf8F2Sk.js',
			'./ActionItemsList.stories-9Jr0dLlq.js',
			'./AgendaItemView.stories-B-6gwCpT.js',
			'./AttendeeSelector.stories-DuJsRcbJ.js',
			'./CreateMeetingModal.stories-DLXRU5sL.js',
			'./DecisionsList.stories-BwXIKDEQ.js',
			'./MeetingCard.stories-CJJ1d3hL.js',
			'./SecretaryConfirmationDialog.stories-C8lB6Bpa.js',
			'./SecretarySelector.stories-Bd3LNQaN.js',
			'./TodayMeetingCard.stories-B_X5eh0a.js',
			'./CategoryHeader.stories-BFUg6THq.js',
			'./PanelBreadcrumbs-BJkhzZET.js',
			'./CircleDetailHeader.stories-CN5j4fki.js',
			'./CircleDetailPanel.stories-CBTgvMgo.js',
			'./CircleMembersPanel.stories-CjEb7HOF.js',
			'./CircleRolesPanel.stories-Bkh7uqWn.js',
			'./CreateCircleModal.stories-BlzAbEhx.js',
			'./OrgChart.stories-CT2HEemn.js',
			'./PanelBreadcrumbBar.stories-Du-ee3g6.js',
			'./RoleCard.stories-B2w7XVD-.js',
			'./RoleDetailHeader.stories-D4dQ7PMK.js',
			'./RoleDetailPanel.stories-BJ3v613_.js',
			'./Introduction-CA4zggUZ.js',
			'./WithTooltip-SK46ZJ2J-CmyzQ6a2.js',
			'./index-CpSrf8b4.js',
			'./TokenReference-Bs-CDuYl.js',
			'./DocsRenderer-HT7GNKAR-DtRZCYoH.js'
		])
) => i.map((i) => d[i]);
import { _ as se } from './preload-helper-PPVm8Dsz.js';
(function () {
	const t = document.createElement('link').relList;
	if (t && t.supports && t.supports('modulepreload')) return;
	for (const o of document.querySelectorAll('link[rel="modulepreload"]')) n(o);
	new MutationObserver((o) => {
		for (const s of o)
			if (s.type === 'childList')
				for (const a of s.addedNodes) a.tagName === 'LINK' && a.rel === 'modulepreload' && n(a);
	}).observe(document, { childList: !0, subtree: !0 });
	function r(o) {
		const s = {};
		return (
			o.integrity && (s.integrity = o.integrity),
			o.referrerPolicy && (s.referrerPolicy = o.referrerPolicy),
			o.crossOrigin === 'use-credentials'
				? (s.credentials = 'include')
				: o.crossOrigin === 'anonymous'
					? (s.credentials = 'omit')
					: (s.credentials = 'same-origin'),
			s
		);
	}
	function n(o) {
		if (o.ep) return;
		o.ep = !0;
		const s = r(o);
		fetch(o.href, s);
	}
})();
var Id = {},
	Mj = Object.create,
	cu = Object.defineProperty,
	qj = Object.getOwnPropertyDescriptor,
	kE = Object.getOwnPropertyNames,
	jj = Object.getPrototypeOf,
	Dj = Object.prototype.hasOwnProperty,
	i = (e, t) => cu(e, 'name', { value: t, configurable: !0 }),
	Fa = ((e) =>
		typeof require < 'u'
			? require
			: typeof Proxy < 'u'
				? new Proxy(e, { get: (t, r) => (typeof require < 'u' ? require : t)[r] })
				: e)(function (e) {
		if (typeof require < 'u') return require.apply(this, arguments);
		throw Error('Dynamic require of "' + e + '" is not supported');
	}),
	J = (e, t) =>
		function () {
			return (t || (0, e[kE(e)[0]])((t = { exports: {} }).exports, t), t.exports);
		},
	Lt = (e, t) => {
		for (var r in t) cu(e, r, { get: t[r], enumerable: !0 });
	},
	kj = (e, t, r, n) => {
		if ((t && typeof t == 'object') || typeof t == 'function')
			for (let o of kE(t))
				!Dj.call(e, o) &&
					o !== r &&
					cu(e, o, { get: () => t[o], enumerable: !(n = qj(t, o)) || n.enumerable });
		return e;
	},
	et = (e, t, r) => (
		(r = e != null ? Mj(jj(e)) : {}),
		kj(t || !e || !e.__esModule ? cu(r, 'default', { value: e, enumerable: !0 }) : r, e)
	),
	Lj = J({
		'../node_modules/@ngard/tiny-isequal/index.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.isEqual = (function () {
					var t = Object.prototype.toString,
						r = Object.getPrototypeOf,
						n = Object.getOwnPropertySymbols
							? function (o) {
									return Object.keys(o).concat(Object.getOwnPropertySymbols(o));
								}
							: Object.keys;
					return function (o, s) {
						return i(function a(u, c, d) {
							var p,
								f,
								m,
								y = t.call(u),
								g = t.call(c);
							if (u === c) return !0;
							if (u == null || c == null) return !1;
							if (d.indexOf(u) > -1 && d.indexOf(c) > -1) return !0;
							if (
								(d.push(u, c),
								y != g ||
									((p = n(u)),
									(f = n(c)),
									p.length != f.length ||
										p.some(function (E) {
											return !a(u[E], c[E], d);
										})))
							)
								return !1;
							switch (y.slice(8, -1)) {
								case 'Symbol':
									return u.valueOf() == c.valueOf();
								case 'Date':
								case 'Number':
									return +u == +c || (+u != +u && +c != +c);
								case 'RegExp':
								case 'Function':
								case 'String':
								case 'Boolean':
									return '' + u == '' + c;
								case 'Set':
								case 'Map':
									((p = u.entries()), (f = c.entries()));
									do if (!a((m = p.next()).value, f.next().value, d)) return !1;
									while (!m.done);
									return !0;
								case 'ArrayBuffer':
									((u = new Uint8Array(u)), (c = new Uint8Array(c)));
								case 'DataView':
									((u = new Uint8Array(u.buffer)), (c = new Uint8Array(c.buffer)));
								case 'Float32Array':
								case 'Float64Array':
								case 'Int8Array':
								case 'Int16Array':
								case 'Int32Array':
								case 'Uint8Array':
								case 'Uint16Array':
								case 'Uint32Array':
								case 'Uint8ClampedArray':
								case 'Arguments':
								case 'Array':
									if (u.length != c.length) return !1;
									for (m = 0; m < u.length; m++)
										if ((m in u || m in c) && (m in u != m in c || !a(u[m], c[m], d))) return !1;
									return !0;
								case 'Object':
									return a(r(u), r(c), d);
								default:
									return !1;
							}
						}, 'n')(o, s, []);
					};
				})()));
		}
	}),
	Fj = J({
		'../node_modules/min-indent/index.js'(e, t) {
			t.exports = (r) => {
				const n = r.match(/^[ \t]*(?=\S)/gm);
				return n ? n.reduce((o, s) => Math.min(o, s.length), 1 / 0) : 0;
			};
		}
	}),
	Bj = J({
		'../node_modules/strip-indent/index.js'(e, t) {
			var r = Fj();
			t.exports = (n) => {
				const o = r(n);
				if (o === 0) return n;
				const s = new RegExp(`^[ \\t]{${o}}`, 'gm');
				return n.replace(s, '');
			};
		}
	}),
	Jj = J({
		'../node_modules/indent-string/index.js'(e, t) {
			t.exports = (r, n = 1, o) => {
				if (((o = { indent: ' ', includeEmptyLines: !1, ...o }), typeof r != 'string'))
					throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof r}\``);
				if (typeof n != 'number')
					throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof n}\``);
				if (typeof o.indent != 'string')
					throw new TypeError(
						`Expected \`options.indent\` to be a \`string\`, got \`${typeof o.indent}\``
					);
				if (n === 0) return r;
				const s = o.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
				return r.replace(s, o.indent.repeat(n));
			};
		}
	}),
	LE = J({
		'../node_modules/redent/index.js'(e, t) {
			var r = Bj(),
				n = Jj();
			t.exports = (o, s = 0, a) => n(r(o), s, a);
		}
	}),
	$j = J({
		'../node_modules/aria-query/lib/util/iteratorProxy.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			function t() {
				var r = this,
					n = 0,
					o = {
						'@@iterator': i(function () {
							return o;
						}, 'iterator'),
						next: i(function () {
							if (n < r.length) {
								var a = r[n];
								return ((n = n + 1), { done: !1, value: a });
							} else return { done: !0 };
						}, 'next')
					};
				return o;
			}
			(i(t, 'iteratorProxy'), (e.default = t));
		}
	}),
	fa = J({
		'../node_modules/aria-query/lib/util/iterationDecorator.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = o));
			var t = r($j());
			function r(s) {
				return s && s.__esModule ? s : { default: s };
			}
			i(r, '_interopRequireDefault');
			function n(s) {
				'@babel/helpers - typeof';
				return (
					(n =
						typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
							? function (a) {
									return typeof a;
								}
							: function (a) {
									return a &&
										typeof Symbol == 'function' &&
										a.constructor === Symbol &&
										a !== Symbol.prototype
										? 'symbol'
										: typeof a;
								}),
					n(s)
				);
			}
			i(n, '_typeof');
			function o(s, a) {
				return (
					typeof Symbol == 'function' &&
						n(Symbol.iterator) === 'symbol' &&
						Object.defineProperty(s, Symbol.iterator, { value: t.default.bind(a) }),
					s
				);
			}
			i(o, 'iterationDecorator');
		}
	}),
	Uj = J({
		'../node_modules/aria-query/lib/ariaPropsMap.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = r(fa());
			function r(f) {
				return f && f.__esModule ? f : { default: f };
			}
			i(r, '_interopRequireDefault');
			function n(f, m) {
				return c(f) || u(f, m) || s(f, m) || o();
			}
			i(n, '_slicedToArray');
			function o() {
				throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
			}
			i(o, '_nonIterableRest');
			function s(f, m) {
				if (f) {
					if (typeof f == 'string') return a(f, m);
					var y = {}.toString.call(f).slice(8, -1);
					return (
						y === 'Object' && f.constructor && (y = f.constructor.name),
						y === 'Map' || y === 'Set'
							? Array.from(f)
							: y === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y)
								? a(f, m)
								: void 0
					);
				}
			}
			i(s, '_unsupportedIterableToArray');
			function a(f, m) {
				(m == null || m > f.length) && (m = f.length);
				for (var y = 0, g = Array(m); y < m; y++) g[y] = f[y];
				return g;
			}
			i(a, '_arrayLikeToArray');
			function u(f, m) {
				var y = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
				if (y != null) {
					var g,
						E,
						T,
						b,
						w = [],
						P = !0,
						I = !1;
					try {
						if (((T = (y = y.call(f)).next), m === 0)) {
							if (Object(y) !== y) return;
							P = !1;
						} else for (; !(P = (g = T.call(y)).done) && (w.push(g.value), w.length !== m); P = !0);
					} catch (q) {
						((I = !0), (E = q));
					} finally {
						try {
							if (!P && y.return != null && ((b = y.return()), Object(b) !== b)) return;
						} finally {
							if (I) throw E;
						}
					}
					return w;
				}
			}
			i(u, '_iterableToArrayLimit');
			function c(f) {
				if (Array.isArray(f)) return f;
			}
			i(c, '_arrayWithHoles');
			var d = [
					['aria-activedescendant', { type: 'id' }],
					['aria-atomic', { type: 'boolean' }],
					['aria-autocomplete', { type: 'token', values: ['inline', 'list', 'both', 'none'] }],
					['aria-braillelabel', { type: 'string' }],
					['aria-brailleroledescription', { type: 'string' }],
					['aria-busy', { type: 'boolean' }],
					['aria-checked', { type: 'tristate' }],
					['aria-colcount', { type: 'integer' }],
					['aria-colindex', { type: 'integer' }],
					['aria-colspan', { type: 'integer' }],
					['aria-controls', { type: 'idlist' }],
					[
						'aria-current',
						{ type: 'token', values: ['page', 'step', 'location', 'date', 'time', !0, !1] }
					],
					['aria-describedby', { type: 'idlist' }],
					['aria-description', { type: 'string' }],
					['aria-details', { type: 'id' }],
					['aria-disabled', { type: 'boolean' }],
					[
						'aria-dropeffect',
						{ type: 'tokenlist', values: ['copy', 'execute', 'link', 'move', 'none', 'popup'] }
					],
					['aria-errormessage', { type: 'id' }],
					['aria-expanded', { type: 'boolean', allowundefined: !0 }],
					['aria-flowto', { type: 'idlist' }],
					['aria-grabbed', { type: 'boolean', allowundefined: !0 }],
					[
						'aria-haspopup',
						{ type: 'token', values: [!1, !0, 'menu', 'listbox', 'tree', 'grid', 'dialog'] }
					],
					['aria-hidden', { type: 'boolean', allowundefined: !0 }],
					['aria-invalid', { type: 'token', values: ['grammar', !1, 'spelling', !0] }],
					['aria-keyshortcuts', { type: 'string' }],
					['aria-label', { type: 'string' }],
					['aria-labelledby', { type: 'idlist' }],
					['aria-level', { type: 'integer' }],
					['aria-live', { type: 'token', values: ['assertive', 'off', 'polite'] }],
					['aria-modal', { type: 'boolean' }],
					['aria-multiline', { type: 'boolean' }],
					['aria-multiselectable', { type: 'boolean' }],
					['aria-orientation', { type: 'token', values: ['vertical', 'undefined', 'horizontal'] }],
					['aria-owns', { type: 'idlist' }],
					['aria-placeholder', { type: 'string' }],
					['aria-posinset', { type: 'integer' }],
					['aria-pressed', { type: 'tristate' }],
					['aria-readonly', { type: 'boolean' }],
					[
						'aria-relevant',
						{ type: 'tokenlist', values: ['additions', 'all', 'removals', 'text'] }
					],
					['aria-required', { type: 'boolean' }],
					['aria-roledescription', { type: 'string' }],
					['aria-rowcount', { type: 'integer' }],
					['aria-rowindex', { type: 'integer' }],
					['aria-rowspan', { type: 'integer' }],
					['aria-selected', { type: 'boolean', allowundefined: !0 }],
					['aria-setsize', { type: 'integer' }],
					['aria-sort', { type: 'token', values: ['ascending', 'descending', 'none', 'other'] }],
					['aria-valuemax', { type: 'number' }],
					['aria-valuemin', { type: 'number' }],
					['aria-valuenow', { type: 'number' }],
					['aria-valuetext', { type: 'string' }]
				],
				p = {
					entries: i(function () {
						return d;
					}, 'entries'),
					forEach: i(function (m) {
						for (
							var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
								g = 0,
								E = d;
							g < E.length;
							g++
						) {
							var T = n(E[g], 2),
								b = T[0],
								w = T[1];
							m.call(y, w, b, d);
						}
					}, 'forEach'),
					get: i(function (m) {
						var y = d.filter(function (g) {
							return g[0] === m;
						})[0];
						return y && y[1];
					}, 'get'),
					has: i(function (m) {
						return !!p.get(m);
					}, 'has'),
					keys: i(function () {
						return d.map(function (m) {
							var y = n(m, 1),
								g = y[0];
							return g;
						});
					}, 'keys'),
					values: i(function () {
						return d.map(function (m) {
							var y = n(m, 2),
								g = y[1];
							return g;
						});
					}, 'values')
				};
			e.default = (0, t.default)(p, p.entries());
		}
	}),
	Vj = J({
		'../node_modules/aria-query/lib/domMap.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = r(fa());
			function r(f) {
				return f && f.__esModule ? f : { default: f };
			}
			i(r, '_interopRequireDefault');
			function n(f, m) {
				return c(f) || u(f, m) || s(f, m) || o();
			}
			i(n, '_slicedToArray');
			function o() {
				throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
			}
			i(o, '_nonIterableRest');
			function s(f, m) {
				if (f) {
					if (typeof f == 'string') return a(f, m);
					var y = {}.toString.call(f).slice(8, -1);
					return (
						y === 'Object' && f.constructor && (y = f.constructor.name),
						y === 'Map' || y === 'Set'
							? Array.from(f)
							: y === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y)
								? a(f, m)
								: void 0
					);
				}
			}
			i(s, '_unsupportedIterableToArray');
			function a(f, m) {
				(m == null || m > f.length) && (m = f.length);
				for (var y = 0, g = Array(m); y < m; y++) g[y] = f[y];
				return g;
			}
			i(a, '_arrayLikeToArray');
			function u(f, m) {
				var y = f == null ? null : (typeof Symbol < 'u' && f[Symbol.iterator]) || f['@@iterator'];
				if (y != null) {
					var g,
						E,
						T,
						b,
						w = [],
						P = !0,
						I = !1;
					try {
						if (((T = (y = y.call(f)).next), m === 0)) {
							if (Object(y) !== y) return;
							P = !1;
						} else for (; !(P = (g = T.call(y)).done) && (w.push(g.value), w.length !== m); P = !0);
					} catch (q) {
						((I = !0), (E = q));
					} finally {
						try {
							if (!P && y.return != null && ((b = y.return()), Object(b) !== b)) return;
						} finally {
							if (I) throw E;
						}
					}
					return w;
				}
			}
			i(u, '_iterableToArrayLimit');
			function c(f) {
				if (Array.isArray(f)) return f;
			}
			i(c, '_arrayWithHoles');
			var d = [
					['a', { reserved: !1 }],
					['abbr', { reserved: !1 }],
					['acronym', { reserved: !1 }],
					['address', { reserved: !1 }],
					['applet', { reserved: !1 }],
					['area', { reserved: !1 }],
					['article', { reserved: !1 }],
					['aside', { reserved: !1 }],
					['audio', { reserved: !1 }],
					['b', { reserved: !1 }],
					['base', { reserved: !0 }],
					['bdi', { reserved: !1 }],
					['bdo', { reserved: !1 }],
					['big', { reserved: !1 }],
					['blink', { reserved: !1 }],
					['blockquote', { reserved: !1 }],
					['body', { reserved: !1 }],
					['br', { reserved: !1 }],
					['button', { reserved: !1 }],
					['canvas', { reserved: !1 }],
					['caption', { reserved: !1 }],
					['center', { reserved: !1 }],
					['cite', { reserved: !1 }],
					['code', { reserved: !1 }],
					['col', { reserved: !0 }],
					['colgroup', { reserved: !0 }],
					['content', { reserved: !1 }],
					['data', { reserved: !1 }],
					['datalist', { reserved: !1 }],
					['dd', { reserved: !1 }],
					['del', { reserved: !1 }],
					['details', { reserved: !1 }],
					['dfn', { reserved: !1 }],
					['dialog', { reserved: !1 }],
					['dir', { reserved: !1 }],
					['div', { reserved: !1 }],
					['dl', { reserved: !1 }],
					['dt', { reserved: !1 }],
					['em', { reserved: !1 }],
					['embed', { reserved: !1 }],
					['fieldset', { reserved: !1 }],
					['figcaption', { reserved: !1 }],
					['figure', { reserved: !1 }],
					['font', { reserved: !1 }],
					['footer', { reserved: !1 }],
					['form', { reserved: !1 }],
					['frame', { reserved: !1 }],
					['frameset', { reserved: !1 }],
					['h1', { reserved: !1 }],
					['h2', { reserved: !1 }],
					['h3', { reserved: !1 }],
					['h4', { reserved: !1 }],
					['h5', { reserved: !1 }],
					['h6', { reserved: !1 }],
					['head', { reserved: !0 }],
					['header', { reserved: !1 }],
					['hgroup', { reserved: !1 }],
					['hr', { reserved: !1 }],
					['html', { reserved: !0 }],
					['i', { reserved: !1 }],
					['iframe', { reserved: !1 }],
					['img', { reserved: !1 }],
					['input', { reserved: !1 }],
					['ins', { reserved: !1 }],
					['kbd', { reserved: !1 }],
					['keygen', { reserved: !1 }],
					['label', { reserved: !1 }],
					['legend', { reserved: !1 }],
					['li', { reserved: !1 }],
					['link', { reserved: !0 }],
					['main', { reserved: !1 }],
					['map', { reserved: !1 }],
					['mark', { reserved: !1 }],
					['marquee', { reserved: !1 }],
					['menu', { reserved: !1 }],
					['menuitem', { reserved: !1 }],
					['meta', { reserved: !0 }],
					['meter', { reserved: !1 }],
					['nav', { reserved: !1 }],
					['noembed', { reserved: !0 }],
					['noscript', { reserved: !0 }],
					['object', { reserved: !1 }],
					['ol', { reserved: !1 }],
					['optgroup', { reserved: !1 }],
					['option', { reserved: !1 }],
					['output', { reserved: !1 }],
					['p', { reserved: !1 }],
					['param', { reserved: !0 }],
					['picture', { reserved: !0 }],
					['pre', { reserved: !1 }],
					['progress', { reserved: !1 }],
					['q', { reserved: !1 }],
					['rp', { reserved: !1 }],
					['rt', { reserved: !1 }],
					['rtc', { reserved: !1 }],
					['ruby', { reserved: !1 }],
					['s', { reserved: !1 }],
					['samp', { reserved: !1 }],
					['script', { reserved: !0 }],
					['section', { reserved: !1 }],
					['select', { reserved: !1 }],
					['small', { reserved: !1 }],
					['source', { reserved: !0 }],
					['spacer', { reserved: !1 }],
					['span', { reserved: !1 }],
					['strike', { reserved: !1 }],
					['strong', { reserved: !1 }],
					['style', { reserved: !0 }],
					['sub', { reserved: !1 }],
					['summary', { reserved: !1 }],
					['sup', { reserved: !1 }],
					['table', { reserved: !1 }],
					['tbody', { reserved: !1 }],
					['td', { reserved: !1 }],
					['textarea', { reserved: !1 }],
					['tfoot', { reserved: !1 }],
					['th', { reserved: !1 }],
					['thead', { reserved: !1 }],
					['time', { reserved: !1 }],
					['title', { reserved: !0 }],
					['tr', { reserved: !1 }],
					['track', { reserved: !0 }],
					['tt', { reserved: !1 }],
					['u', { reserved: !1 }],
					['ul', { reserved: !1 }],
					['var', { reserved: !1 }],
					['video', { reserved: !1 }],
					['wbr', { reserved: !1 }],
					['xmp', { reserved: !1 }]
				],
				p = {
					entries: i(function () {
						return d;
					}, 'entries'),
					forEach: i(function (m) {
						for (
							var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
								g = 0,
								E = d;
							g < E.length;
							g++
						) {
							var T = n(E[g], 2),
								b = T[0],
								w = T[1];
							m.call(y, w, b, d);
						}
					}, 'forEach'),
					get: i(function (m) {
						var y = d.filter(function (g) {
							return g[0] === m;
						})[0];
						return y && y[1];
					}, 'get'),
					has: i(function (m) {
						return !!p.get(m);
					}, 'has'),
					keys: i(function () {
						return d.map(function (m) {
							var y = n(m, 1),
								g = y[0];
							return g;
						});
					}, 'keys'),
					values: i(function () {
						return d.map(function (m) {
							var y = n(m, 2),
								g = y[1];
							return g;
						});
					}, 'values')
				};
			e.default = (0, t.default)(p, p.entries());
		}
	}),
	Hj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/commandRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget']]
			};
			e.default = t;
		}
	}),
	Gj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-activedescendant': null, 'aria-disabled': null },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget']]
			};
			e.default = t;
		}
	}),
	zj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/inputRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-disabled': null },
				relatedConcepts: [{ concept: { name: 'input' }, module: 'XForms' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget']]
			};
			e.default = t;
		}
	}),
	Wj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	Kj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-valuemax': null, 'aria-valuemin': null, 'aria-valuenow': null },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	Yj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {
					'aria-atomic': null,
					'aria-busy': null,
					'aria-controls': null,
					'aria-current': null,
					'aria-describedby': null,
					'aria-details': null,
					'aria-dropeffect': null,
					'aria-flowto': null,
					'aria-grabbed': null,
					'aria-hidden': null,
					'aria-keyshortcuts': null,
					'aria-label': null,
					'aria-labelledby': null,
					'aria-live': null,
					'aria-owns': null,
					'aria-relevant': null,
					'aria-roledescription': null
				},
				relatedConcepts: [
					{ concept: { name: 'role' }, module: 'XHTML' },
					{ concept: { name: 'type' }, module: 'Dublin Core' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: []
			};
			e.default = t;
		}
	}),
	Xj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{ concept: { name: 'frontmatter' }, module: 'DTB' },
					{ concept: { name: 'level' }, module: 'DTB' },
					{ concept: { name: 'level' }, module: 'SMIL' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	Qj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	Zj = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/selectRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-orientation': null },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite'],
					['roletype', 'structure', 'section', 'group']
				]
			};
			e.default = t;
		}
	}),
	eD = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/structureRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype']]
			};
			e.default = t;
		}
	}),
	tD = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype']]
			};
			e.default = t;
		}
	}),
	rD = J({
		'../node_modules/aria-query/lib/etc/roles/abstract/windowRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !0,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-modal': null },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype']]
			};
			e.default = t;
		}
	}),
	nD = J({
		'../node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = y(Hj()),
				r = y(Gj()),
				n = y(zj()),
				o = y(Wj()),
				s = y(Kj()),
				a = y(Yj()),
				u = y(Xj()),
				c = y(Qj()),
				d = y(Zj()),
				p = y(eD()),
				f = y(tD()),
				m = y(rD());
			function y(E) {
				return E && E.__esModule ? E : { default: E };
			}
			i(y, '_interopRequireDefault');
			var g = [
				['command', t.default],
				['composite', r.default],
				['input', n.default],
				['landmark', o.default],
				['range', s.default],
				['roletype', a.default],
				['section', u.default],
				['sectionhead', c.default],
				['select', d.default],
				['structure', p.default],
				['widget', f.default],
				['window', m.default]
			];
			e.default = g;
		}
	}),
	oD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/alertRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-atomic': 'true', 'aria-live': 'assertive' },
				relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	iD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'alert' }, module: 'XForms' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'structure', 'section', 'alert'],
					['roletype', 'window', 'dialog']
				]
			};
			e.default = t;
		}
	}),
	sD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/applicationRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-activedescendant': null,
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'Device Independence Delivery Unit' } }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	aD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/articleRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-posinset': null, 'aria-setsize': null },
				relatedConcepts: [{ concept: { name: 'article' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'document']]
			};
			e.default = t;
		}
	}),
	lD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/bannerRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: { constraints: ['scoped to the body element'], name: 'header' },
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	uD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'blockquote' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	cD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/buttonRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-pressed': null
				},
				relatedConcepts: [
					{
						concept: { attributes: [{ name: 'type', value: 'button' }], name: 'input' },
						module: 'HTML'
					},
					{
						concept: { attributes: [{ name: 'type', value: 'image' }], name: 'input' },
						module: 'HTML'
					},
					{
						concept: { attributes: [{ name: 'type', value: 'reset' }], name: 'input' },
						module: 'HTML'
					},
					{
						concept: { attributes: [{ name: 'type', value: 'submit' }], name: 'input' },
						module: 'HTML'
					},
					{ concept: { name: 'button' }, module: 'HTML' },
					{ concept: { name: 'trigger' }, module: 'XForms' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'command']]
			};
			e.default = t;
		}
	}),
	dD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/captionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'caption' }, module: 'HTML' }],
				requireContextRole: ['figure', 'grid', 'table'],
				requiredContextRole: ['figure', 'grid', 'table'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	pD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/cellRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-colindex': null,
					'aria-colspan': null,
					'aria-rowindex': null,
					'aria-rowspan': null
				},
				relatedConcepts: [
					{
						concept: { constraints: ['ancestor table element has table role'], name: 'td' },
						module: 'HTML'
					}
				],
				requireContextRole: ['row'],
				requiredContextRole: ['row'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	fD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-checked': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-invalid': null,
					'aria-readonly': null,
					'aria-required': null
				},
				relatedConcepts: [
					{
						concept: { attributes: [{ name: 'type', value: 'checkbox' }], name: 'input' },
						module: 'HTML'
					},
					{ concept: { name: 'option' }, module: 'ARIA' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-checked': null },
				superClass: [['roletype', 'widget', 'input']]
			};
			e.default = t;
		}
	}),
	mD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/codeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'code' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	hD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-sort': null },
				relatedConcepts: [
					{ concept: { name: 'th' }, module: 'HTML' },
					{
						concept: { attributes: [{ name: 'scope', value: 'col' }], name: 'th' },
						module: 'HTML'
					},
					{
						concept: { attributes: [{ name: 'scope', value: 'colgroup' }], name: 'th' },
						module: 'HTML'
					}
				],
				requireContextRole: ['row'],
				requiredContextRole: ['row'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'structure', 'section', 'cell'],
					['roletype', 'structure', 'section', 'cell', 'gridcell'],
					['roletype', 'widget', 'gridcell'],
					['roletype', 'structure', 'sectionhead']
				]
			};
			e.default = t;
		}
	}),
	yD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-activedescendant': null,
					'aria-autocomplete': null,
					'aria-errormessage': null,
					'aria-invalid': null,
					'aria-readonly': null,
					'aria-required': null,
					'aria-expanded': 'false',
					'aria-haspopup': 'listbox'
				},
				relatedConcepts: [
					{
						concept: {
							attributes: [
								{ constraints: ['set'], name: 'list' },
								{ name: 'type', value: 'email' }
							],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['set'], name: 'list' },
								{ name: 'type', value: 'search' }
							],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['set'], name: 'list' },
								{ name: 'type', value: 'tel' }
							],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['set'], name: 'list' },
								{ name: 'type', value: 'text' }
							],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['set'], name: 'list' },
								{ name: 'type', value: 'url' }
							],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['set'], name: 'list' },
								{ name: 'type', value: 'url' }
							],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['undefined'], name: 'multiple' },
								{ constraints: ['undefined'], name: 'size' }
							],
							constraints: [
								'the multiple attribute is not set and the size attribute does not have a value greater than 1'
							],
							name: 'select'
						},
						module: 'HTML'
					},
					{ concept: { name: 'select' }, module: 'XForms' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-controls': null, 'aria-expanded': 'false' },
				superClass: [['roletype', 'widget', 'input']]
			};
			e.default = t;
		}
	}),
	gD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: {
							constraints: ['scoped to the body element', 'scoped to the main element'],
							name: 'aside'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [{ constraints: ['set'], name: 'aria-label' }],
							constraints: [
								'scoped to a sectioning content element',
								'scoped to a sectioning root element other than body'
							],
							name: 'aside'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
							constraints: [
								'scoped to a sectioning content element',
								'scoped to a sectioning root element other than body'
							],
							name: 'aside'
						},
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	bD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: { constraints: ['scoped to the body element'], name: 'footer' },
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	vD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/definitionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'dd' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	ED = J({
		'../node_modules/aria-query/lib/etc/roles/literal/deletionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'del' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	TD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/dialogRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'dialog' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'window']]
			};
			e.default = t;
		}
	}),
	_D = J({
		'../node_modules/aria-query/lib/etc/roles/literal/directoryRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ module: 'DAISY Guide' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'list']]
			};
			e.default = t;
		}
	}),
	wD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/documentRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{ concept: { name: 'Device Independence Delivery Unit' } },
					{ concept: { name: 'html' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	SD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'em' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	RD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/feedRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['article']],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'list']]
			};
			e.default = t;
		}
	}),
	PD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/figureRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'figure' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	AD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/formRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: { attributes: [{ constraints: ['set'], name: 'aria-label' }], name: 'form' },
						module: 'HTML'
					},
					{
						concept: {
							attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
							name: 'form'
						},
						module: 'HTML'
					},
					{
						concept: { attributes: [{ constraints: ['set'], name: 'name' }], name: 'form' },
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	OD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/genericRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [
					{ concept: { name: 'a' }, module: 'HTML' },
					{ concept: { name: 'area' }, module: 'HTML' },
					{ concept: { name: 'aside' }, module: 'HTML' },
					{ concept: { name: 'b' }, module: 'HTML' },
					{ concept: { name: 'bdo' }, module: 'HTML' },
					{ concept: { name: 'body' }, module: 'HTML' },
					{ concept: { name: 'data' }, module: 'HTML' },
					{ concept: { name: 'div' }, module: 'HTML' },
					{
						concept: {
							constraints: [
								'scoped to the main element',
								'scoped to a sectioning content element',
								'scoped to a sectioning root element other than body'
							],
							name: 'footer'
						},
						module: 'HTML'
					},
					{
						concept: {
							constraints: [
								'scoped to the main element',
								'scoped to a sectioning content element',
								'scoped to a sectioning root element other than body'
							],
							name: 'header'
						},
						module: 'HTML'
					},
					{ concept: { name: 'hgroup' }, module: 'HTML' },
					{ concept: { name: 'i' }, module: 'HTML' },
					{ concept: { name: 'pre' }, module: 'HTML' },
					{ concept: { name: 'q' }, module: 'HTML' },
					{ concept: { name: 'samp' }, module: 'HTML' },
					{ concept: { name: 'section' }, module: 'HTML' },
					{ concept: { name: 'small' }, module: 'HTML' },
					{ concept: { name: 'span' }, module: 'HTML' },
					{ concept: { name: 'u' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	CD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/gridRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-multiselectable': null, 'aria-readonly': null },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['row'], ['row', 'rowgroup']],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite'],
					['roletype', 'structure', 'section', 'table']
				]
			};
			e.default = t;
		}
	}),
	xD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null,
					'aria-readonly': null,
					'aria-required': null,
					'aria-selected': null
				},
				relatedConcepts: [
					{
						concept: {
							constraints: [
								'ancestor table element has grid role',
								'ancestor table element has treegrid role'
							],
							name: 'td'
						},
						module: 'HTML'
					}
				],
				requireContextRole: ['row'],
				requiredContextRole: ['row'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'structure', 'section', 'cell'],
					['roletype', 'widget']
				]
			};
			e.default = t;
		}
	}),
	ID = J({
		'../node_modules/aria-query/lib/etc/roles/literal/groupRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-activedescendant': null, 'aria-disabled': null },
				relatedConcepts: [
					{ concept: { name: 'details' }, module: 'HTML' },
					{ concept: { name: 'fieldset' }, module: 'HTML' },
					{ concept: { name: 'optgroup' }, module: 'HTML' },
					{ concept: { name: 'address' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	ND = J({
		'../node_modules/aria-query/lib/etc/roles/literal/headingRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-level': '2' },
				relatedConcepts: [
					{ concept: { name: 'h1' }, module: 'HTML' },
					{ concept: { name: 'h2' }, module: 'HTML' },
					{ concept: { name: 'h3' }, module: 'HTML' },
					{ concept: { name: 'h4' }, module: 'HTML' },
					{ concept: { name: 'h5' }, module: 'HTML' },
					{ concept: { name: 'h6' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-level': '2' },
				superClass: [['roletype', 'structure', 'sectionhead']]
			};
			e.default = t;
		}
	}),
	MD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/imgRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: { attributes: [{ constraints: ['set'], name: 'alt' }], name: 'img' },
						module: 'HTML'
					},
					{
						concept: { attributes: [{ constraints: ['undefined'], name: 'alt' }], name: 'img' },
						module: 'HTML'
					},
					{ concept: { name: 'imggroup' }, module: 'DTB' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	qD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/insertionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'ins' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	jD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/linkRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-disabled': null, 'aria-expanded': null, 'aria-haspopup': null },
				relatedConcepts: [
					{
						concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'a' },
						module: 'HTML'
					},
					{
						concept: { attributes: [{ constraints: ['set'], name: 'href' }], name: 'area' },
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'command']]
			};
			e.default = t;
		}
	}),
	DD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/listRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{ concept: { name: 'menu' }, module: 'HTML' },
					{ concept: { name: 'ol' }, module: 'HTML' },
					{ concept: { name: 'ul' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['listitem']],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	kD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/listboxRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-invalid': null,
					'aria-multiselectable': null,
					'aria-readonly': null,
					'aria-required': null,
					'aria-orientation': 'vertical'
				},
				relatedConcepts: [
					{
						concept: {
							attributes: [{ constraints: ['>1'], name: 'size' }],
							constraints: ['the size attribute value is greater than 1'],
							name: 'select'
						},
						module: 'HTML'
					},
					{ concept: { attributes: [{ name: 'multiple' }], name: 'select' }, module: 'HTML' },
					{ concept: { name: 'datalist' }, module: 'HTML' },
					{ concept: { name: 'list' }, module: 'ARIA' },
					{ concept: { name: 'select' }, module: 'XForms' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['option', 'group'], ['option']],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite', 'select'],
					['roletype', 'structure', 'section', 'group', 'select']
				]
			};
			e.default = t;
		}
	}),
	LD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/listitemRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-level': null, 'aria-posinset': null, 'aria-setsize': null },
				relatedConcepts: [
					{
						concept: {
							constraints: [
								'direct descendant of ol',
								'direct descendant of ul',
								'direct descendant of menu'
							],
							name: 'li'
						},
						module: 'HTML'
					},
					{ concept: { name: 'item' }, module: 'XForms' }
				],
				requireContextRole: ['directory', 'list'],
				requiredContextRole: ['directory', 'list'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	FD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/logRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-live': 'polite' },
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	BD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/mainRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'main' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	JD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/markRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: [],
				props: {
					'aria-braillelabel': null,
					'aria-brailleroledescription': null,
					'aria-description': null
				},
				relatedConcepts: [{ concept: { name: 'mark' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	$D = J({
		'../node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	UD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/mathRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'math' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	VD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/menuRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-orientation': 'vertical' },
				relatedConcepts: [
					{ concept: { name: 'MENU' }, module: 'JAPI' },
					{ concept: { name: 'list' }, module: 'ARIA' },
					{ concept: { name: 'select' }, module: 'XForms' },
					{ concept: { name: 'sidebar' }, module: 'DTB' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [
					['menuitem', 'group'],
					['menuitemradio', 'group'],
					['menuitemcheckbox', 'group'],
					['menuitem'],
					['menuitemcheckbox'],
					['menuitemradio']
				],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite', 'select'],
					['roletype', 'structure', 'section', 'group', 'select']
				]
			};
			e.default = t;
		}
	}),
	HD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/menubarRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-orientation': 'horizontal' },
				relatedConcepts: [{ concept: { name: 'toolbar' }, module: 'ARIA' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [
					['menuitem', 'group'],
					['menuitemradio', 'group'],
					['menuitemcheckbox', 'group'],
					['menuitem'],
					['menuitemcheckbox'],
					['menuitemradio']
				],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite', 'select', 'menu'],
					['roletype', 'structure', 'section', 'group', 'select', 'menu']
				]
			};
			e.default = t;
		}
	}),
	GD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-posinset': null,
					'aria-setsize': null
				},
				relatedConcepts: [
					{ concept: { name: 'MENU_ITEM' }, module: 'JAPI' },
					{ concept: { name: 'listitem' }, module: 'ARIA' },
					{ concept: { name: 'option' }, module: 'ARIA' }
				],
				requireContextRole: ['group', 'menu', 'menubar'],
				requiredContextRole: ['group', 'menu', 'menubar'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'command']]
			};
			e.default = t;
		}
	}),
	zD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
				requireContextRole: ['group', 'menu', 'menubar'],
				requiredContextRole: ['group', 'menu', 'menubar'],
				requiredOwnedElements: [],
				requiredProps: { 'aria-checked': null },
				superClass: [
					['roletype', 'widget', 'input', 'checkbox'],
					['roletype', 'widget', 'command', 'menuitem']
				]
			};
			e.default = t;
		}
	}),
	WD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'menuitem' }, module: 'ARIA' }],
				requireContextRole: ['group', 'menu', 'menubar'],
				requiredContextRole: ['group', 'menu', 'menubar'],
				requiredOwnedElements: [],
				requiredProps: { 'aria-checked': null },
				superClass: [
					['roletype', 'widget', 'input', 'checkbox', 'menuitemcheckbox'],
					['roletype', 'widget', 'command', 'menuitem', 'menuitemcheckbox'],
					['roletype', 'widget', 'input', 'radio']
				]
			};
			e.default = t;
		}
	}),
	KD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/meterRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-valuetext': null, 'aria-valuemax': '100', 'aria-valuemin': '0' },
				relatedConcepts: [{ concept: { name: 'meter' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-valuenow': null },
				superClass: [['roletype', 'structure', 'range']]
			};
			e.default = t;
		}
	}),
	YD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/navigationRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'nav' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	XD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/noneRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: [],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: []
			};
			e.default = t;
		}
	}),
	QD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/noteRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	ZD = J({
		'../node_modules/aria-query/lib/etc/roles/literal/optionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-checked': null,
					'aria-posinset': null,
					'aria-setsize': null,
					'aria-selected': 'false'
				},
				relatedConcepts: [
					{ concept: { name: 'item' }, module: 'XForms' },
					{ concept: { name: 'listitem' }, module: 'ARIA' },
					{ concept: { name: 'option' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-selected': 'false' },
				superClass: [['roletype', 'widget', 'input']]
			};
			e.default = t;
		}
	}),
	ek = J({
		'../node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'p' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	tk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/presentationRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [
					{ concept: { attributes: [{ name: 'alt', value: '' }], name: 'img' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	rk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-valuetext': null },
				relatedConcepts: [
					{ concept: { name: 'progress' }, module: 'HTML' },
					{ concept: { name: 'status' }, module: 'ARIA' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'structure', 'range'],
					['roletype', 'widget']
				]
			};
			e.default = t;
		}
	}),
	nk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/radioRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-checked': null, 'aria-posinset': null, 'aria-setsize': null },
				relatedConcepts: [
					{
						concept: { attributes: [{ name: 'type', value: 'radio' }], name: 'input' },
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-checked': null },
				superClass: [['roletype', 'widget', 'input']]
			};
			e.default = t;
		}
	}),
	ok = J({
		'../node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-errormessage': null,
					'aria-invalid': null,
					'aria-readonly': null,
					'aria-required': null
				},
				relatedConcepts: [{ concept: { name: 'list' }, module: 'ARIA' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['radio']],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite', 'select'],
					['roletype', 'structure', 'section', 'group', 'select']
				]
			};
			e.default = t;
		}
	}),
	ik = J({
		'../node_modules/aria-query/lib/etc/roles/literal/regionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: {
							attributes: [{ constraints: ['set'], name: 'aria-label' }],
							name: 'section'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [{ constraints: ['set'], name: 'aria-labelledby' }],
							name: 'section'
						},
						module: 'HTML'
					},
					{ concept: { name: 'Device Independence Glossart perceivable unit' } }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	sk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/rowRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-colindex': null,
					'aria-expanded': null,
					'aria-level': null,
					'aria-posinset': null,
					'aria-rowindex': null,
					'aria-selected': null,
					'aria-setsize': null
				},
				relatedConcepts: [{ concept: { name: 'tr' }, module: 'HTML' }],
				requireContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
				requiredContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
				requiredOwnedElements: [['cell'], ['columnheader'], ['gridcell'], ['rowheader']],
				requiredProps: {},
				superClass: [
					['roletype', 'structure', 'section', 'group'],
					['roletype', 'widget']
				]
			};
			e.default = t;
		}
	}),
	ak = J({
		'../node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{ concept: { name: 'tbody' }, module: 'HTML' },
					{ concept: { name: 'tfoot' }, module: 'HTML' },
					{ concept: { name: 'thead' }, module: 'HTML' }
				],
				requireContextRole: ['grid', 'table', 'treegrid'],
				requiredContextRole: ['grid', 'table', 'treegrid'],
				requiredOwnedElements: [['row']],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	lk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-sort': null },
				relatedConcepts: [
					{
						concept: { attributes: [{ name: 'scope', value: 'row' }], name: 'th' },
						module: 'HTML'
					},
					{
						concept: { attributes: [{ name: 'scope', value: 'rowgroup' }], name: 'th' },
						module: 'HTML'
					}
				],
				requireContextRole: ['row', 'rowgroup'],
				requiredContextRole: ['row', 'rowgroup'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'structure', 'section', 'cell'],
					['roletype', 'structure', 'section', 'cell', 'gridcell'],
					['roletype', 'widget', 'gridcell'],
					['roletype', 'structure', 'sectionhead']
				]
			};
			e.default = t;
		}
	}),
	uk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-valuetext': null,
					'aria-orientation': 'vertical',
					'aria-valuemax': '100',
					'aria-valuemin': '0'
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-controls': null, 'aria-valuenow': null },
				superClass: [
					['roletype', 'structure', 'range'],
					['roletype', 'widget']
				]
			};
			e.default = t;
		}
	}),
	ck = J({
		'../node_modules/aria-query/lib/etc/roles/literal/searchRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	dk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{
						concept: {
							attributes: [
								{ constraints: ['undefined'], name: 'list' },
								{ name: 'type', value: 'search' }
							],
							constraints: ['the list attribute is not set'],
							name: 'input'
						},
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'input', 'textbox']]
			};
			e.default = t;
		}
	}),
	pk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/separatorRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-orientation': 'horizontal',
					'aria-valuemax': '100',
					'aria-valuemin': '0',
					'aria-valuenow': null,
					'aria-valuetext': null
				},
				relatedConcepts: [{ concept: { name: 'hr' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure']]
			};
			e.default = t;
		}
	}),
	fk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/sliderRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-errormessage': null,
					'aria-haspopup': null,
					'aria-invalid': null,
					'aria-readonly': null,
					'aria-valuetext': null,
					'aria-orientation': 'horizontal',
					'aria-valuemax': '100',
					'aria-valuemin': '0'
				},
				relatedConcepts: [
					{
						concept: { attributes: [{ name: 'type', value: 'range' }], name: 'input' },
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-valuenow': null },
				superClass: [
					['roletype', 'widget', 'input'],
					['roletype', 'structure', 'range']
				]
			};
			e.default = t;
		}
	}),
	mk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-errormessage': null,
					'aria-invalid': null,
					'aria-readonly': null,
					'aria-required': null,
					'aria-valuetext': null,
					'aria-valuenow': '0'
				},
				relatedConcepts: [
					{
						concept: { attributes: [{ name: 'type', value: 'number' }], name: 'input' },
						module: 'HTML'
					}
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite'],
					['roletype', 'widget', 'input'],
					['roletype', 'structure', 'range']
				]
			};
			e.default = t;
		}
	}),
	hk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/statusRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-atomic': 'true', 'aria-live': 'polite' },
				relatedConcepts: [{ concept: { name: 'output' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	yk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/strongRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'strong' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	gk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'sub' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	bk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: ['aria-label', 'aria-labelledby'],
				props: {},
				relatedConcepts: [{ concept: { name: 'sup' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	vk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/switchRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'button' }, module: 'ARIA' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: { 'aria-checked': null },
				superClass: [['roletype', 'widget', 'input', 'checkbox']]
			};
			e.default = t;
		}
	}),
	Ek = J({
		'../node_modules/aria-query/lib/etc/roles/literal/tabRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-posinset': null,
					'aria-setsize': null,
					'aria-selected': 'false'
				},
				relatedConcepts: [],
				requireContextRole: ['tablist'],
				requiredContextRole: ['tablist'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [
					['roletype', 'structure', 'sectionhead'],
					['roletype', 'widget']
				]
			};
			e.default = t;
		}
	}),
	Tk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/tableRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-colcount': null, 'aria-rowcount': null },
				relatedConcepts: [{ concept: { name: 'table' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['row'], ['row', 'rowgroup']],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	_k = J({
		'../node_modules/aria-query/lib/etc/roles/literal/tablistRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-level': null,
					'aria-multiselectable': null,
					'aria-orientation': 'horizontal'
				},
				relatedConcepts: [{ module: 'DAISY', concept: { name: 'guide' } }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['tab']],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'composite']]
			};
			e.default = t;
		}
	}),
	wk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	Sk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/termRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [
					{ concept: { name: 'dfn' }, module: 'HTML' },
					{ concept: { name: 'dt' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	Rk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/textboxRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-activedescendant': null,
					'aria-autocomplete': null,
					'aria-errormessage': null,
					'aria-haspopup': null,
					'aria-invalid': null,
					'aria-multiline': null,
					'aria-placeholder': null,
					'aria-readonly': null,
					'aria-required': null
				},
				relatedConcepts: [
					{
						concept: {
							attributes: [
								{ constraints: ['undefined'], name: 'type' },
								{ constraints: ['undefined'], name: 'list' }
							],
							constraints: ['the list attribute is not set'],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['undefined'], name: 'list' },
								{ name: 'type', value: 'email' }
							],
							constraints: ['the list attribute is not set'],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['undefined'], name: 'list' },
								{ name: 'type', value: 'tel' }
							],
							constraints: ['the list attribute is not set'],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['undefined'], name: 'list' },
								{ name: 'type', value: 'text' }
							],
							constraints: ['the list attribute is not set'],
							name: 'input'
						},
						module: 'HTML'
					},
					{
						concept: {
							attributes: [
								{ constraints: ['undefined'], name: 'list' },
								{ name: 'type', value: 'url' }
							],
							constraints: ['the list attribute is not set'],
							name: 'input'
						},
						module: 'HTML'
					},
					{ concept: { name: 'input' }, module: 'XForms' },
					{ concept: { name: 'textarea' }, module: 'HTML' }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'input']]
			};
			e.default = t;
		}
	}),
	Pk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/timeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'time' }, module: 'HTML' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	Ak = J({
		'../node_modules/aria-query/lib/etc/roles/literal/timerRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'status']]
			};
			e.default = t;
		}
	}),
	Ok = J({
		'../node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: { 'aria-orientation': 'horizontal' },
				relatedConcepts: [{ concept: { name: 'menubar' }, module: 'ARIA' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'group']]
			};
			e.default = t;
		}
	}),
	Ck = J({
		'../node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	xk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/treeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-errormessage': null,
					'aria-invalid': null,
					'aria-multiselectable': null,
					'aria-required': null,
					'aria-orientation': 'vertical'
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['treeitem', 'group'], ['treeitem']],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite', 'select'],
					['roletype', 'structure', 'section', 'group', 'select']
				]
			};
			e.default = t;
		}
	}),
	Ik = J({
		'../node_modules/aria-query/lib/etc/roles/literal/treegridRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['row'], ['row', 'rowgroup']],
				requiredProps: {},
				superClass: [
					['roletype', 'widget', 'composite', 'grid'],
					['roletype', 'structure', 'section', 'table', 'grid'],
					['roletype', 'widget', 'composite', 'select', 'tree'],
					['roletype', 'structure', 'section', 'group', 'select', 'tree']
				]
			};
			e.default = t;
		}
	}),
	Nk = J({
		'../node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-expanded': null, 'aria-haspopup': null },
				relatedConcepts: [],
				requireContextRole: ['group', 'tree'],
				requiredContextRole: ['group', 'tree'],
				requiredOwnedElements: [],
				requiredProps: { 'aria-selected': null },
				superClass: [
					['roletype', 'structure', 'section', 'listitem'],
					['roletype', 'widget', 'input', 'option']
				]
			};
			e.default = t;
		}
	}),
	Mk = J({
		'../node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = Y(oD()),
				r = Y(iD()),
				n = Y(sD()),
				o = Y(aD()),
				s = Y(lD()),
				a = Y(uD()),
				u = Y(cD()),
				c = Y(dD()),
				d = Y(pD()),
				p = Y(fD()),
				f = Y(mD()),
				m = Y(hD()),
				y = Y(yD()),
				g = Y(gD()),
				E = Y(bD()),
				T = Y(vD()),
				b = Y(ED()),
				w = Y(TD()),
				P = Y(_D()),
				I = Y(wD()),
				q = Y(SD()),
				C = Y(RD()),
				R = Y(PD()),
				_ = Y(AD()),
				S = Y(OD()),
				D = Y(CD()),
				N = Y(xD()),
				V = Y(ID()),
				H = Y(ND()),
				A = Y(MD()),
				L = Y(qD()),
				B = Y(jD()),
				k = Y(DD()),
				K = Y(kD()),
				X = Y(LD()),
				ie = Y(FD()),
				ae = Y(BD()),
				W = Y(JD()),
				le = Y($D()),
				ve = Y(UD()),
				de = Y(VD()),
				ee = Y(HD()),
				xe = Y(GD()),
				Ie = Y(zD()),
				Xe = Y(WD()),
				rt = Y(KD()),
				$ = Y(YD()),
				Q = Y(XD()),
				re = Y(QD()),
				oe = Y(ZD()),
				ne = Y(ek()),
				pe = Y(tk()),
				ye = Y(rk()),
				fe = Y(nk()),
				ze = Y(ok()),
				pt = Y(ik()),
				vt = Y(sk()),
				Ft = Y(ak()),
				ft = Y(lk()),
				Et = Y(uk()),
				Tt = Y(ck()),
				_t = Y(dk()),
				Un = Y(pk()),
				Bi = Y(fk()),
				Vn = Y(mk()),
				Ji = Y(hk()),
				$i = Y(yk()),
				Ui = Y(gk()),
				Hn = Y(bk()),
				Vi = Y(vk()),
				Hi = Y(Ek()),
				Gi = Y(Tk()),
				zi = Y(_k()),
				Wi = Y(wk()),
				Ki = Y(Sk()),
				Yi = Y(Rk()),
				Xi = Y(Pk()),
				Qi = Y(Ak()),
				Zi = Y(Ok()),
				es = Y(Ck()),
				ts = Y(xk()),
				kr = Y(Ik()),
				Gn = Y(Nk());
			function Y(Xt) {
				return Xt && Xt.__esModule ? Xt : { default: Xt };
			}
			i(Y, '_interopRequireDefault');
			var ue = [
				['alert', t.default],
				['alertdialog', r.default],
				['application', n.default],
				['article', o.default],
				['banner', s.default],
				['blockquote', a.default],
				['button', u.default],
				['caption', c.default],
				['cell', d.default],
				['checkbox', p.default],
				['code', f.default],
				['columnheader', m.default],
				['combobox', y.default],
				['complementary', g.default],
				['contentinfo', E.default],
				['definition', T.default],
				['deletion', b.default],
				['dialog', w.default],
				['directory', P.default],
				['document', I.default],
				['emphasis', q.default],
				['feed', C.default],
				['figure', R.default],
				['form', _.default],
				['generic', S.default],
				['grid', D.default],
				['gridcell', N.default],
				['group', V.default],
				['heading', H.default],
				['img', A.default],
				['insertion', L.default],
				['link', B.default],
				['list', k.default],
				['listbox', K.default],
				['listitem', X.default],
				['log', ie.default],
				['main', ae.default],
				['mark', W.default],
				['marquee', le.default],
				['math', ve.default],
				['menu', de.default],
				['menubar', ee.default],
				['menuitem', xe.default],
				['menuitemcheckbox', Ie.default],
				['menuitemradio', Xe.default],
				['meter', rt.default],
				['navigation', $.default],
				['none', Q.default],
				['note', re.default],
				['option', oe.default],
				['paragraph', ne.default],
				['presentation', pe.default],
				['progressbar', ye.default],
				['radio', fe.default],
				['radiogroup', ze.default],
				['region', pt.default],
				['row', vt.default],
				['rowgroup', Ft.default],
				['rowheader', ft.default],
				['scrollbar', Et.default],
				['search', Tt.default],
				['searchbox', _t.default],
				['separator', Un.default],
				['slider', Bi.default],
				['spinbutton', Vn.default],
				['status', Ji.default],
				['strong', $i.default],
				['subscript', Ui.default],
				['superscript', Hn.default],
				['switch', Vi.default],
				['tab', Hi.default],
				['table', Gi.default],
				['tablist', zi.default],
				['tabpanel', Wi.default],
				['term', Ki.default],
				['textbox', Yi.default],
				['time', Xi.default],
				['timer', Qi.default],
				['toolbar', Zi.default],
				['tooltip', es.default],
				['tree', ts.default],
				['treegrid', kr.default],
				['treeitem', Gn.default]
			];
			e.default = ue;
		}
	}),
	qk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'abstract [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	jk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'acknowledgments [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Dk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'afterword [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	kk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'appendix [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Lk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-errormessage': null, 'aria-invalid': null },
				relatedConcepts: [{ concept: { name: 'referrer [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'command', 'link']]
			};
			e.default = t;
		}
	}),
	Fk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'EPUB biblioentry [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: ['doc-bibliography'],
				requiredContextRole: ['doc-bibliography'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'listitem']]
			};
			e.default = t;
		}
	}),
	Bk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'bibliography [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['doc-biblioentry']],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Jk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-errormessage': null, 'aria-invalid': null },
				relatedConcepts: [{ concept: { name: 'biblioref [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'command', 'link']]
			};
			e.default = t;
		}
	}),
	$k = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'chapter [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Uk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'colophon [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	Vk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'conclusion [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Hk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'cover [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'img']]
			};
			e.default = t;
		}
	}),
	Gk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'credit [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	zk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'credits [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Wk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'dedication [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	Kk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'rearnote [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: ['doc-endnotes'],
				requiredContextRole: ['doc-endnotes'],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'listitem']]
			};
			e.default = t;
		}
	}),
	Yk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'rearnotes [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['doc-endnote']],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Xk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'epigraph [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	Qk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'epilogue [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	Zk = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'errata [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	eL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	tL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'footnote [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	rL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'foreword [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	nL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'glossary [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [['definition'], ['term']],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	oL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-errormessage': null, 'aria-invalid': null },
				relatedConcepts: [{ concept: { name: 'glossref [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'command', 'link']]
			};
			e.default = t;
		}
	}),
	iL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'index [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
			};
			e.default = t;
		}
	}),
	sL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'introduction [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	aL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: { 'aria-errormessage': null, 'aria-invalid': null },
				relatedConcepts: [{ concept: { name: 'noteref [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'widget', 'command', 'link']]
			};
			e.default = t;
		}
	}),
	lL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'notice [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'note']]
			};
			e.default = t;
		}
	}),
	uL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'pagebreak [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'separator']]
			};
			e.default = t;
		}
	}),
	cL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: [],
				props: {
					'aria-braillelabel': null,
					'aria-brailleroledescription': null,
					'aria-description': null,
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	dL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['prohibited'],
				prohibitedProps: [],
				props: {
					'aria-braillelabel': null,
					'aria-brailleroledescription': null,
					'aria-description': null,
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	pL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'page-list [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
			};
			e.default = t;
		}
	}),
	fL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'part [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	mL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'preface [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	hL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'prologue [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark']]
			};
			e.default = t;
		}
	}),
	yL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {},
				relatedConcepts: [{ concept: { name: 'pullquote [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['none']]
			};
			e.default = t;
		}
	}),
	gL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'qna [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section']]
			};
			e.default = t;
		}
	}),
	bL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'subtitle [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'sectionhead']]
			};
			e.default = t;
		}
	}),
	vL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'help [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'note']]
			};
			e.default = t;
		}
	}),
	EL = J({
		'../node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [{ concept: { name: 'toc [EPUB-SSV]' }, module: 'EPUB' }],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
			};
			e.default = t;
		}
	}),
	TL = J({
		'../node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = ee(qk()),
				r = ee(jk()),
				n = ee(Dk()),
				o = ee(kk()),
				s = ee(Lk()),
				a = ee(Fk()),
				u = ee(Bk()),
				c = ee(Jk()),
				d = ee($k()),
				p = ee(Uk()),
				f = ee(Vk()),
				m = ee(Hk()),
				y = ee(Gk()),
				g = ee(zk()),
				E = ee(Wk()),
				T = ee(Kk()),
				b = ee(Yk()),
				w = ee(Xk()),
				P = ee(Qk()),
				I = ee(Zk()),
				q = ee(eL()),
				C = ee(tL()),
				R = ee(rL()),
				_ = ee(nL()),
				S = ee(oL()),
				D = ee(iL()),
				N = ee(sL()),
				V = ee(aL()),
				H = ee(lL()),
				A = ee(uL()),
				L = ee(cL()),
				B = ee(dL()),
				k = ee(pL()),
				K = ee(fL()),
				X = ee(mL()),
				ie = ee(hL()),
				ae = ee(yL()),
				W = ee(gL()),
				le = ee(bL()),
				ve = ee(vL()),
				de = ee(EL());
			function ee(Ie) {
				return Ie && Ie.__esModule ? Ie : { default: Ie };
			}
			i(ee, '_interopRequireDefault');
			var xe = [
				['doc-abstract', t.default],
				['doc-acknowledgments', r.default],
				['doc-afterword', n.default],
				['doc-appendix', o.default],
				['doc-backlink', s.default],
				['doc-biblioentry', a.default],
				['doc-bibliography', u.default],
				['doc-biblioref', c.default],
				['doc-chapter', d.default],
				['doc-colophon', p.default],
				['doc-conclusion', f.default],
				['doc-cover', m.default],
				['doc-credit', y.default],
				['doc-credits', g.default],
				['doc-dedication', E.default],
				['doc-endnote', T.default],
				['doc-endnotes', b.default],
				['doc-epigraph', w.default],
				['doc-epilogue', P.default],
				['doc-errata', I.default],
				['doc-example', q.default],
				['doc-footnote', C.default],
				['doc-foreword', R.default],
				['doc-glossary', _.default],
				['doc-glossref', S.default],
				['doc-index', D.default],
				['doc-introduction', N.default],
				['doc-noteref', V.default],
				['doc-notice', H.default],
				['doc-pagebreak', A.default],
				['doc-pagefooter', L.default],
				['doc-pageheader', B.default],
				['doc-pagelist', k.default],
				['doc-part', K.default],
				['doc-preface', X.default],
				['doc-prologue', ie.default],
				['doc-pullquote', ae.default],
				['doc-qna', W.default],
				['doc-subtitle', le.default],
				['doc-tip', ve.default],
				['doc-toc', de.default]
			];
			e.default = xe;
		}
	}),
	_L = J({
		'../node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [
					{ module: 'GRAPHICS', concept: { name: 'graphics-object' } },
					{ module: 'ARIA', concept: { name: 'img' } },
					{ module: 'ARIA', concept: { name: 'article' } }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'document']]
			};
			e.default = t;
		}
	}),
	wL = J({
		'../node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !1,
				baseConcepts: [],
				childrenPresentational: !1,
				nameFrom: ['author', 'contents'],
				prohibitedProps: [],
				props: {
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [
					{ module: 'GRAPHICS', concept: { name: 'graphics-document' } },
					{ module: 'ARIA', concept: { name: 'group' } },
					{ module: 'ARIA', concept: { name: 'img' } },
					{ module: 'GRAPHICS', concept: { name: 'graphics-symbol' } }
				],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'group']]
			};
			e.default = t;
		}
	}),
	SL = J({
		'../node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = {
				abstract: !1,
				accessibleNameRequired: !0,
				baseConcepts: [],
				childrenPresentational: !0,
				nameFrom: ['author'],
				prohibitedProps: [],
				props: {
					'aria-disabled': null,
					'aria-errormessage': null,
					'aria-expanded': null,
					'aria-haspopup': null,
					'aria-invalid': null
				},
				relatedConcepts: [],
				requireContextRole: [],
				requiredContextRole: [],
				requiredOwnedElements: [],
				requiredProps: {},
				superClass: [['roletype', 'structure', 'section', 'img']]
			};
			e.default = t;
		}
	}),
	RL = J({
		'../node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = o(_L()),
				r = o(wL()),
				n = o(SL());
			function o(a) {
				return a && a.__esModule ? a : { default: a };
			}
			i(o, '_interopRequireDefault');
			var s = [
				['graphics-document', t.default],
				['graphics-object', r.default],
				['graphics-symbol', n.default]
			];
			e.default = s;
		}
	}),
	Jf = J({
		'../node_modules/aria-query/lib/rolesMap.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = a(nD()),
				r = a(Mk()),
				n = a(TL()),
				o = a(RL()),
				s = a(fa());
			function a(T) {
				return T && T.__esModule ? T : { default: T };
			}
			i(a, '_interopRequireDefault');
			function u(T, b) {
				var w = (typeof Symbol < 'u' && T[Symbol.iterator]) || T['@@iterator'];
				if (!w) {
					if (Array.isArray(T) || (w = p(T)) || (b && T && typeof T.length == 'number')) {
						w && (T = w);
						var P = 0,
							I = i(function () {}, 'F');
						return {
							s: I,
							n: i(function () {
								return P >= T.length ? { done: !0 } : { done: !1, value: T[P++] };
							}, 'n'),
							e: i(function (S) {
								throw S;
							}, 'e'),
							f: I
						};
					}
					throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
				}
				var q,
					C = !0,
					R = !1;
				return {
					s: i(function () {
						w = w.call(T);
					}, 's'),
					n: i(function () {
						var S = w.next();
						return ((C = S.done), S);
					}, 'n'),
					e: i(function (S) {
						((R = !0), (q = S));
					}, 'e'),
					f: i(function () {
						try {
							C || w.return == null || w.return();
						} finally {
							if (R) throw q;
						}
					}, 'f')
				};
			}
			i(u, '_createForOfIteratorHelper');
			function c(T, b) {
				return y(T) || m(T, b) || p(T, b) || d();
			}
			i(c, '_slicedToArray');
			function d() {
				throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
			}
			i(d, '_nonIterableRest');
			function p(T, b) {
				if (T) {
					if (typeof T == 'string') return f(T, b);
					var w = {}.toString.call(T).slice(8, -1);
					return (
						w === 'Object' && T.constructor && (w = T.constructor.name),
						w === 'Map' || w === 'Set'
							? Array.from(T)
							: w === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w)
								? f(T, b)
								: void 0
					);
				}
			}
			i(p, '_unsupportedIterableToArray');
			function f(T, b) {
				(b == null || b > T.length) && (b = T.length);
				for (var w = 0, P = Array(b); w < b; w++) P[w] = T[w];
				return P;
			}
			i(f, '_arrayLikeToArray');
			function m(T, b) {
				var w = T == null ? null : (typeof Symbol < 'u' && T[Symbol.iterator]) || T['@@iterator'];
				if (w != null) {
					var P,
						I,
						q,
						C,
						R = [],
						_ = !0,
						S = !1;
					try {
						if (((q = (w = w.call(T)).next), b === 0)) {
							if (Object(w) !== w) return;
							_ = !1;
						} else for (; !(_ = (P = q.call(w)).done) && (R.push(P.value), R.length !== b); _ = !0);
					} catch (D) {
						((S = !0), (I = D));
					} finally {
						try {
							if (!_ && w.return != null && ((C = w.return()), Object(C) !== C)) return;
						} finally {
							if (S) throw I;
						}
					}
					return R;
				}
			}
			i(m, '_iterableToArrayLimit');
			function y(T) {
				if (Array.isArray(T)) return T;
			}
			i(y, '_arrayWithHoles');
			var g = [].concat(t.default, r.default, n.default, o.default);
			g.forEach(function (T) {
				var b = c(T, 2),
					w = b[1],
					P = u(w.superClass),
					I;
				try {
					for (P.s(); !(I = P.n()).done; ) {
						var q = I.value,
							C = u(q),
							R;
						try {
							var _ = i(function () {
								var D = R.value,
									N = g.filter(function (B) {
										var k = c(B, 1),
											K = k[0];
										return K === D;
									})[0];
								if (N)
									for (var V = N[1], H = 0, A = Object.keys(V.props); H < A.length; H++) {
										var L = A[H];
										Object.prototype.hasOwnProperty.call(w.props, L) || (w.props[L] = V.props[L]);
									}
							}, '_loop');
							for (C.s(); !(R = C.n()).done; ) _();
						} catch (S) {
							C.e(S);
						} finally {
							C.f();
						}
					}
				} catch (S) {
					P.e(S);
				} finally {
					P.f();
				}
			});
			var E = {
				entries: i(function () {
					return g;
				}, 'entries'),
				forEach: i(function (b) {
					var w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
						P = u(g),
						I;
					try {
						for (P.s(); !(I = P.n()).done; ) {
							var q = c(I.value, 2),
								C = q[0],
								R = q[1];
							b.call(w, R, C, g);
						}
					} catch (_) {
						P.e(_);
					} finally {
						P.f();
					}
				}, 'forEach'),
				get: i(function (b) {
					var w = g.filter(function (P) {
						return P[0] === b;
					})[0];
					return w && w[1];
				}, 'get'),
				has: i(function (b) {
					return !!E.get(b);
				}, 'has'),
				keys: i(function () {
					return g.map(function (b) {
						var w = c(b, 1),
							P = w[0];
						return P;
					});
				}, 'keys'),
				values: i(function () {
					return g.map(function (b) {
						var w = c(b, 2),
							P = w[1];
						return P;
					});
				}, 'values')
			};
			e.default = (0, s.default)(E, E.entries());
		}
	}),
	PL = J({
		'../node_modules/aria-query/lib/elementRoleMap.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = n(fa()),
				r = n(Jf());
			function n(C) {
				return C && C.__esModule ? C : { default: C };
			}
			i(n, '_interopRequireDefault');
			function o(C, R) {
				return d(C) || c(C, R) || a(C, R) || s();
			}
			i(o, '_slicedToArray');
			function s() {
				throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
			}
			i(s, '_nonIterableRest');
			function a(C, R) {
				if (C) {
					if (typeof C == 'string') return u(C, R);
					var _ = {}.toString.call(C).slice(8, -1);
					return (
						_ === 'Object' && C.constructor && (_ = C.constructor.name),
						_ === 'Map' || _ === 'Set'
							? Array.from(C)
							: _ === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_)
								? u(C, R)
								: void 0
					);
				}
			}
			i(a, '_unsupportedIterableToArray');
			function u(C, R) {
				(R == null || R > C.length) && (R = C.length);
				for (var _ = 0, S = Array(R); _ < R; _++) S[_] = C[_];
				return S;
			}
			i(u, '_arrayLikeToArray');
			function c(C, R) {
				var _ = C == null ? null : (typeof Symbol < 'u' && C[Symbol.iterator]) || C['@@iterator'];
				if (_ != null) {
					var S,
						D,
						N,
						V,
						H = [],
						A = !0,
						L = !1;
					try {
						if (((N = (_ = _.call(C)).next), R === 0)) {
							if (Object(_) !== _) return;
							A = !1;
						} else for (; !(A = (S = N.call(_)).done) && (H.push(S.value), H.length !== R); A = !0);
					} catch (B) {
						((L = !0), (D = B));
					} finally {
						try {
							if (!A && _.return != null && ((V = _.return()), Object(V) !== V)) return;
						} finally {
							if (L) throw D;
						}
					}
					return H;
				}
			}
			i(c, '_iterableToArrayLimit');
			function d(C) {
				if (Array.isArray(C)) return C;
			}
			i(d, '_arrayWithHoles');
			var p = [],
				f = r.default.keys();
			for (b = 0; b < f.length; b++)
				if (((m = f[b]), (y = r.default.get(m)), y))
					for (
						g = [].concat(y.baseConcepts, y.relatedConcepts),
							E = i(function () {
								var R = g[T];
								if (R.module === 'HTML') {
									var _ = R.concept;
									if (_) {
										var S = p.filter(function (H) {
												return P(H[0], _);
											})[0],
											D;
										S ? (D = S[1]) : (D = []);
										for (var N = !0, V = 0; V < D.length; V++)
											if (D[V] === m) {
												N = !1;
												break;
											}
										(N && D.push(m), S || p.push([_, D]));
									}
								}
							}, '_loop'),
							T = 0;
						T < g.length;
						T++
					)
						E();
			var m,
				y,
				g,
				E,
				T,
				b,
				w = {
					entries: i(function () {
						return p;
					}, 'entries'),
					forEach: i(function (R) {
						for (
							var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
								S = 0,
								D = p;
							S < D.length;
							S++
						) {
							var N = o(D[S], 2),
								V = N[0],
								H = N[1];
							R.call(_, H, V, p);
						}
					}, 'forEach'),
					get: i(function (R) {
						var _ = p.filter(function (S) {
							return R.name === S[0].name && q(R.attributes, S[0].attributes);
						})[0];
						return _ && _[1];
					}, 'get'),
					has: i(function (R) {
						return !!w.get(R);
					}, 'has'),
					keys: i(function () {
						return p.map(function (R) {
							var _ = o(R, 1),
								S = _[0];
							return S;
						});
					}, 'keys'),
					values: i(function () {
						return p.map(function (R) {
							var _ = o(R, 2),
								S = _[1];
							return S;
						});
					}, 'values')
				};
			function P(C, R) {
				return (
					C.name === R.name && I(C.constraints, R.constraints) && q(C.attributes, R.attributes)
				);
			}
			i(P, 'ariaRoleRelationConceptEquals');
			function I(C, R) {
				if ((C === void 0 && R !== void 0) || (C !== void 0 && R === void 0)) return !1;
				if (C !== void 0 && R !== void 0) {
					if (C.length !== R.length) return !1;
					for (var _ = 0; _ < C.length; _++) if (C[_] !== R[_]) return !1;
				}
				return !0;
			}
			i(I, 'ariaRoleRelationConstraintsEquals');
			function q(C, R) {
				if ((C === void 0 && R !== void 0) || (C !== void 0 && R === void 0)) return !1;
				if (C !== void 0 && R !== void 0) {
					if (C.length !== R.length) return !1;
					for (var _ = 0; _ < C.length; _++) {
						if (
							C[_].name !== R[_].name ||
							C[_].value !== R[_].value ||
							(C[_].constraints === void 0 && R[_].constraints !== void 0) ||
							(C[_].constraints !== void 0 && R[_].constraints === void 0)
						)
							return !1;
						if (C[_].constraints !== void 0 && R[_].constraints !== void 0) {
							if (C[_].constraints.length !== R[_].constraints.length) return !1;
							for (var S = 0; S < C[_].constraints.length; S++)
								if (C[_].constraints[S] !== R[_].constraints[S]) return !1;
						}
					}
				}
				return !0;
			}
			(i(q, 'ariaRoleRelationConceptAttributeEquals'),
				(e.default = (0, t.default)(w, w.entries())));
		}
	}),
	AL = J({
		'../node_modules/aria-query/lib/roleElementMap.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0));
			var t = n(fa()),
				r = n(Jf());
			function n(q) {
				return q && q.__esModule ? q : { default: q };
			}
			i(n, '_interopRequireDefault');
			function o(q, C) {
				return d(q) || c(q, C) || a(q, C) || s();
			}
			i(o, '_slicedToArray');
			function s() {
				throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
			}
			i(s, '_nonIterableRest');
			function a(q, C) {
				if (q) {
					if (typeof q == 'string') return u(q, C);
					var R = {}.toString.call(q).slice(8, -1);
					return (
						R === 'Object' && q.constructor && (R = q.constructor.name),
						R === 'Map' || R === 'Set'
							? Array.from(q)
							: R === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(R)
								? u(q, C)
								: void 0
					);
				}
			}
			i(a, '_unsupportedIterableToArray');
			function u(q, C) {
				(C == null || C > q.length) && (C = q.length);
				for (var R = 0, _ = Array(C); R < C; R++) _[R] = q[R];
				return _;
			}
			i(u, '_arrayLikeToArray');
			function c(q, C) {
				var R = q == null ? null : (typeof Symbol < 'u' && q[Symbol.iterator]) || q['@@iterator'];
				if (R != null) {
					var _,
						S,
						D,
						N,
						V = [],
						H = !0,
						A = !1;
					try {
						if (((D = (R = R.call(q)).next), C === 0)) {
							if (Object(R) !== R) return;
							H = !1;
						} else for (; !(H = (_ = D.call(R)).done) && (V.push(_.value), V.length !== C); H = !0);
					} catch (L) {
						((A = !0), (S = L));
					} finally {
						try {
							if (!H && R.return != null && ((N = R.return()), Object(N) !== N)) return;
						} finally {
							if (A) throw S;
						}
					}
					return V;
				}
			}
			i(c, '_iterableToArrayLimit');
			function d(q) {
				if (Array.isArray(q)) return q;
			}
			i(d, '_arrayWithHoles');
			var p = [],
				f = r.default.keys();
			for (P = 0; P < f.length; P++)
				if (((m = f[P]), (y = r.default.get(m)), (g = []), y)) {
					for (E = [].concat(y.baseConcepts, y.relatedConcepts), w = 0; w < E.length; w++)
						((T = E[w]), T.module === 'HTML' && ((b = T.concept), b != null && g.push(b)));
					g.length > 0 && p.push([m, g]);
				}
			var m,
				y,
				g,
				E,
				T,
				b,
				w,
				P,
				I = {
					entries: i(function () {
						return p;
					}, 'entries'),
					forEach: i(function (C) {
						for (
							var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
								_ = 0,
								S = p;
							_ < S.length;
							_++
						) {
							var D = o(S[_], 2),
								N = D[0],
								V = D[1];
							C.call(R, V, N, p);
						}
					}, 'forEach'),
					get: i(function (C) {
						var R = p.filter(function (_) {
							return _[0] === C;
						})[0];
						return R && R[1];
					}, 'get'),
					has: i(function (C) {
						return !!I.get(C);
					}, 'has'),
					keys: i(function () {
						return p.map(function (C) {
							var R = o(C, 1),
								_ = R[0];
							return _;
						});
					}, 'keys'),
					values: i(function () {
						return p.map(function (C) {
							var R = o(C, 2),
								_ = R[1];
							return _;
						});
					}, 'values')
				};
			e.default = (0, t.default)(I, I.entries());
		}
	}),
	$f = J({
		'../node_modules/aria-query/lib/index.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.roles = e.roleElements = e.elementRoles = e.dom = e.aria = void 0));
			var t = a(Uj()),
				r = a(Vj()),
				n = a(Jf()),
				o = a(PL()),
				s = a(AL());
			function a(u) {
				return u && u.__esModule ? u : { default: u };
			}
			(i(a, '_interopRequireDefault'),
				(e.aria = t.default),
				(e.dom = r.default),
				(e.roles = n.default),
				(e.elementRoles = o.default),
				(e.roleElements = s.default));
		}
	}),
	FE = J({
		'../node_modules/picocolors/picocolors.browser.js'(e, t) {
			var r = String,
				n = i(function () {
					return {
						isColorSupported: !1,
						reset: r,
						bold: r,
						dim: r,
						italic: r,
						underline: r,
						inverse: r,
						hidden: r,
						strikethrough: r,
						black: r,
						red: r,
						green: r,
						yellow: r,
						blue: r,
						magenta: r,
						cyan: r,
						white: r,
						gray: r,
						bgBlack: r,
						bgRed: r,
						bgGreen: r,
						bgYellow: r,
						bgBlue: r,
						bgMagenta: r,
						bgCyan: r,
						bgWhite: r,
						blackBright: r,
						redBright: r,
						greenBright: r,
						yellowBright: r,
						blueBright: r,
						magentaBright: r,
						cyanBright: r,
						whiteBright: r,
						bgBlackBright: r,
						bgRedBright: r,
						bgGreenBright: r,
						bgYellowBright: r,
						bgBlueBright: r,
						bgMagentaBright: r,
						bgCyanBright: r,
						bgWhiteBright: r
					};
				}, 'create');
			((t.exports = n()), (t.exports.createColors = n));
		}
	}),
	BE = J({
		'../node_modules/css.escape/css.escape.js'(e, t) {
			(function (r, n) {
				typeof e == 'object'
					? (t.exports = n(r))
					: typeof define == 'function' && define.amd
						? define([], n.bind(r, r))
						: n(r);
			})(typeof global < 'u' ? global : e, function (r) {
				if (r.CSS && r.CSS.escape) return r.CSS.escape;
				var n = i(function (o) {
					if (arguments.length == 0) throw new TypeError('`CSS.escape` requires an argument.');
					for (var s = String(o), a = s.length, u = -1, c, d = '', p = s.charCodeAt(0); ++u < a; ) {
						if (((c = s.charCodeAt(u)), c == 0)) {
							d += '';
							continue;
						}
						if (
							(c >= 1 && c <= 31) ||
							c == 127 ||
							(u == 0 && c >= 48 && c <= 57) ||
							(u == 1 && c >= 48 && c <= 57 && p == 45)
						) {
							d += '\\' + c.toString(16) + ' ';
							continue;
						}
						if (u == 0 && a == 1 && c == 45) {
							d += '\\' + s.charAt(u);
							continue;
						}
						if (
							c >= 128 ||
							c == 45 ||
							c == 95 ||
							(c >= 48 && c <= 57) ||
							(c >= 65 && c <= 90) ||
							(c >= 97 && c <= 122)
						) {
							d += s.charAt(u);
							continue;
						}
						d += '\\' + s.charAt(u);
					}
					return d;
				}, 'cssEscape');
				return (r.CSS || (r.CSS = {}), (r.CSS.escape = n), n);
			});
		}
	}),
	JE = J({
		'../node_modules/pretty-format/node_modules/ansi-styles/index.js'(e, t) {
			var r = 10,
				n = i(
					(a = 0) =>
						(u) =>
							`\x1B[${38 + a};5;${u}m`,
					'wrapAnsi256'
				),
				o = i(
					(a = 0) =>
						(u, c, d) =>
							`\x1B[${38 + a};2;${u};${c};${d}m`,
					'wrapAnsi16m'
				);
			function s() {
				const a = new Map(),
					u = {
						modifier: {
							reset: [0, 0],
							bold: [1, 22],
							dim: [2, 22],
							italic: [3, 23],
							underline: [4, 24],
							overline: [53, 55],
							inverse: [7, 27],
							hidden: [8, 28],
							strikethrough: [9, 29]
						},
						color: {
							black: [30, 39],
							red: [31, 39],
							green: [32, 39],
							yellow: [33, 39],
							blue: [34, 39],
							magenta: [35, 39],
							cyan: [36, 39],
							white: [37, 39],
							blackBright: [90, 39],
							redBright: [91, 39],
							greenBright: [92, 39],
							yellowBright: [93, 39],
							blueBright: [94, 39],
							magentaBright: [95, 39],
							cyanBright: [96, 39],
							whiteBright: [97, 39]
						},
						bgColor: {
							bgBlack: [40, 49],
							bgRed: [41, 49],
							bgGreen: [42, 49],
							bgYellow: [43, 49],
							bgBlue: [44, 49],
							bgMagenta: [45, 49],
							bgCyan: [46, 49],
							bgWhite: [47, 49],
							bgBlackBright: [100, 49],
							bgRedBright: [101, 49],
							bgGreenBright: [102, 49],
							bgYellowBright: [103, 49],
							bgBlueBright: [104, 49],
							bgMagentaBright: [105, 49],
							bgCyanBright: [106, 49],
							bgWhiteBright: [107, 49]
						}
					};
				((u.color.gray = u.color.blackBright),
					(u.bgColor.bgGray = u.bgColor.bgBlackBright),
					(u.color.grey = u.color.blackBright),
					(u.bgColor.bgGrey = u.bgColor.bgBlackBright));
				for (const [c, d] of Object.entries(u)) {
					for (const [p, f] of Object.entries(d))
						((u[p] = { open: `\x1B[${f[0]}m`, close: `\x1B[${f[1]}m` }),
							(d[p] = u[p]),
							a.set(f[0], f[1]));
					Object.defineProperty(u, c, { value: d, enumerable: !1 });
				}
				return (
					Object.defineProperty(u, 'codes', { value: a, enumerable: !1 }),
					(u.color.close = '\x1B[39m'),
					(u.bgColor.close = '\x1B[49m'),
					(u.color.ansi256 = n()),
					(u.color.ansi16m = o()),
					(u.bgColor.ansi256 = n(r)),
					(u.bgColor.ansi16m = o(r)),
					Object.defineProperties(u, {
						rgbToAnsi256: {
							value: i(
								(c, d, p) =>
									c === d && d === p
										? c < 8
											? 16
											: c > 248
												? 231
												: Math.round(((c - 8) / 247) * 24) + 232
										: 16 +
											36 * Math.round((c / 255) * 5) +
											6 * Math.round((d / 255) * 5) +
											Math.round((p / 255) * 5),
								'value'
							),
							enumerable: !1
						},
						hexToRgb: {
							value: i((c) => {
								const d = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(c.toString(16));
								if (!d) return [0, 0, 0];
								let { colorString: p } = d.groups;
								p.length === 3 &&
									(p = p
										.split('')
										.map((m) => m + m)
										.join(''));
								const f = Number.parseInt(p, 16);
								return [(f >> 16) & 255, (f >> 8) & 255, f & 255];
							}, 'value'),
							enumerable: !1
						},
						hexToAnsi256: {
							value: i((c) => u.rgbToAnsi256(...u.hexToRgb(c)), 'value'),
							enumerable: !1
						}
					}),
					u
				);
			}
			(i(s, 'assembleStyles'), Object.defineProperty(t, 'exports', { enumerable: !0, get: s }));
		}
	}),
	du = J({
		'../node_modules/pretty-format/build/collections.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.printIteratorEntries = r),
				(e.printIteratorValues = n),
				(e.printListItems = o),
				(e.printObjectProperties = s));
			var t = i((a, u) => {
				const c = Object.keys(a).sort(u);
				return (
					Object.getOwnPropertySymbols &&
						Object.getOwnPropertySymbols(a).forEach((d) => {
							Object.getOwnPropertyDescriptor(a, d).enumerable && c.push(d);
						}),
					c
				);
			}, 'getKeysOfEnumerableProperties');
			function r(a, u, c, d, p, f, m = ': ') {
				let y = '',
					g = a.next();
				if (!g.done) {
					y += u.spacingOuter;
					const E = c + u.indent;
					for (; !g.done; ) {
						const T = f(g.value[0], u, E, d, p),
							b = f(g.value[1], u, E, d, p);
						((y += E + T + m + b),
							(g = a.next()),
							g.done ? u.min || (y += ',') : (y += ',' + u.spacingInner));
					}
					y += u.spacingOuter + c;
				}
				return y;
			}
			i(r, 'printIteratorEntries');
			function n(a, u, c, d, p, f) {
				let m = '',
					y = a.next();
				if (!y.done) {
					m += u.spacingOuter;
					const g = c + u.indent;
					for (; !y.done; )
						((m += g + f(y.value, u, g, d, p)),
							(y = a.next()),
							y.done ? u.min || (m += ',') : (m += ',' + u.spacingInner));
					m += u.spacingOuter + c;
				}
				return m;
			}
			i(n, 'printIteratorValues');
			function o(a, u, c, d, p, f) {
				let m = '';
				if (a.length) {
					m += u.spacingOuter;
					const y = c + u.indent;
					for (let g = 0; g < a.length; g++)
						((m += y),
							g in a && (m += f(a[g], u, y, d, p)),
							g < a.length - 1 ? (m += ',' + u.spacingInner) : u.min || (m += ','));
					m += u.spacingOuter + c;
				}
				return m;
			}
			i(o, 'printListItems');
			function s(a, u, c, d, p, f) {
				let m = '';
				const y = t(a, u.compareKeys);
				if (y.length) {
					m += u.spacingOuter;
					const g = c + u.indent;
					for (let E = 0; E < y.length; E++) {
						const T = y[E],
							b = f(T, u, g, d, p),
							w = f(a[T], u, g, d, p);
						((m += g + b + ': ' + w),
							E < y.length - 1 ? (m += ',' + u.spacingInner) : u.min || (m += ','));
					}
					m += u.spacingOuter + c;
				}
				return m;
			}
			i(s, 'printObjectProperties');
		}
	}),
	OL = J({
		'../node_modules/pretty-format/build/plugins/AsymmetricMatcher.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.test = e.serialize = e.default = void 0));
			var t = du(),
				r = (function () {
					return typeof globalThis < 'u'
						? globalThis
						: typeof r < 'u'
							? r
							: typeof self < 'u'
								? self
								: typeof window < 'u'
									? window
									: Function('return this')();
				})(),
				n = r['jest-symbol-do-not-touch'] || r.Symbol,
				o = typeof n == 'function' && n.for ? n.for('jest.asymmetricMatcher') : 1267621,
				s = ' ',
				a = i((p, f, m, y, g, E) => {
					const T = p.toString();
					return T === 'ArrayContaining' || T === 'ArrayNotContaining'
						? ++y > f.maxDepth
							? '[' + T + ']'
							: T + s + '[' + (0, t.printListItems)(p.sample, f, m, y, g, E) + ']'
						: T === 'ObjectContaining' || T === 'ObjectNotContaining'
							? ++y > f.maxDepth
								? '[' + T + ']'
								: T + s + '{' + (0, t.printObjectProperties)(p.sample, f, m, y, g, E) + '}'
							: T === 'StringMatching' ||
								  T === 'StringNotMatching' ||
								  T === 'StringContaining' ||
								  T === 'StringNotContaining'
								? T + s + E(p.sample, f, m, y, g)
								: p.toAsymmetricMatcher();
				}, 'serialize');
			e.serialize = a;
			var u = i((p) => p && p.$$typeof === o, 'test');
			e.test = u;
			var c = { serialize: a, test: u },
				d = c;
			e.default = d;
		}
	}),
	CL = J({
		'../node_modules/pretty-format/node_modules/ansi-regex/index.js'(e, t) {
			t.exports = ({ onlyFirst: r = !1 } = {}) => {
				const n = [
					'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
					'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
				].join('|');
				return new RegExp(n, r ? void 0 : 'g');
			};
		}
	}),
	xL = J({
		'../node_modules/pretty-format/build/plugins/ConvertAnsi.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.test = e.serialize = e.default = void 0));
			var t = n(CL()),
				r = n(JE());
			function n(d) {
				return d && d.__esModule ? d : { default: d };
			}
			i(n, '_interopRequireDefault');
			var o = i(
					(d) =>
						d.replace((0, t.default)(), (p) => {
							switch (p) {
								case r.default.red.close:
								case r.default.green.close:
								case r.default.cyan.close:
								case r.default.gray.close:
								case r.default.white.close:
								case r.default.yellow.close:
								case r.default.bgRed.close:
								case r.default.bgGreen.close:
								case r.default.bgYellow.close:
								case r.default.inverse.close:
								case r.default.dim.close:
								case r.default.bold.close:
								case r.default.reset.open:
								case r.default.reset.close:
									return '</>';
								case r.default.red.open:
									return '<red>';
								case r.default.green.open:
									return '<green>';
								case r.default.cyan.open:
									return '<cyan>';
								case r.default.gray.open:
									return '<gray>';
								case r.default.white.open:
									return '<white>';
								case r.default.yellow.open:
									return '<yellow>';
								case r.default.bgRed.open:
									return '<bgRed>';
								case r.default.bgGreen.open:
									return '<bgGreen>';
								case r.default.bgYellow.open:
									return '<bgYellow>';
								case r.default.inverse.open:
									return '<inverse>';
								case r.default.dim.open:
									return '<dim>';
								case r.default.bold.open:
									return '<bold>';
								default:
									return '';
							}
						}),
					'toHumanReadableAnsi'
				),
				s = i((d) => typeof d == 'string' && !!d.match((0, t.default)()), 'test');
			e.test = s;
			var a = i((d, p, f, m, y, g) => g(o(d), p, f, m, y), 'serialize');
			e.serialize = a;
			var u = { serialize: a, test: s },
				c = u;
			e.default = c;
		}
	}),
	IL = J({
		'../node_modules/pretty-format/build/plugins/DOMCollection.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.test = e.serialize = e.default = void 0));
			var t = du(),
				r = ' ',
				n = ['DOMStringMap', 'NamedNodeMap'],
				o = /^(HTML\w*Collection|NodeList)$/,
				s = i((f) => n.indexOf(f) !== -1 || o.test(f), 'testName'),
				a = i((f) => f && f.constructor && !!f.constructor.name && s(f.constructor.name), 'test');
			e.test = a;
			var u = i((f) => f.constructor.name === 'NamedNodeMap', 'isNamedNodeMap'),
				c = i((f, m, y, g, E, T) => {
					const b = f.constructor.name;
					return ++g > m.maxDepth
						? '[' + b + ']'
						: (m.min ? '' : b + r) +
								(n.indexOf(b) !== -1
									? '{' +
										(0, t.printObjectProperties)(
											u(f)
												? Array.from(f).reduce((w, P) => ((w[P.name] = P.value), w), {})
												: { ...f },
											m,
											y,
											g,
											E,
											T
										) +
										'}'
									: '[' + (0, t.printListItems)(Array.from(f), m, y, g, E, T) + ']');
				}, 'serialize');
			e.serialize = c;
			var d = { serialize: c, test: a },
				p = d;
			e.default = p;
		}
	}),
	NL = J({
		'../node_modules/pretty-format/build/plugins/lib/escapeHTML.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = t));
			function t(r) {
				return r.replace(/</g, '&lt;').replace(/>/g, '&gt;');
			}
			i(t, 'escapeHTML');
		}
	}),
	Uf = J({
		'../node_modules/pretty-format/build/plugins/lib/markup.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.printText =
					e.printProps =
					e.printElementAsLeaf =
					e.printElement =
					e.printComment =
					e.printChildren =
						void 0));
			var t = r(NL());
			function r(d) {
				return d && d.__esModule ? d : { default: d };
			}
			i(r, '_interopRequireDefault');
			var n = i((d, p, f, m, y, g, E) => {
				const T = m + f.indent,
					b = f.colors;
				return d
					.map((w) => {
						const P = p[w];
						let I = E(P, f, T, y, g);
						return (
							typeof P != 'string' &&
								(I.indexOf(`
`) !== -1 && (I = f.spacingOuter + T + I + f.spacingOuter + m),
								(I = '{' + I + '}')),
							f.spacingInner +
								m +
								b.prop.open +
								w +
								b.prop.close +
								'=' +
								b.value.open +
								I +
								b.value.close
						);
					})
					.join('');
			}, 'printProps');
			e.printProps = n;
			var o = i(
				(d, p, f, m, y, g) =>
					d
						.map((E) => p.spacingOuter + f + (typeof E == 'string' ? s(E, p) : g(E, p, f, m, y)))
						.join(''),
				'printChildren'
			);
			e.printChildren = o;
			var s = i((d, p) => {
				const f = p.colors.content;
				return f.open + (0, t.default)(d) + f.close;
			}, 'printText');
			e.printText = s;
			var a = i((d, p) => {
				const f = p.colors.comment;
				return f.open + '<!--' + (0, t.default)(d) + '-->' + f.close;
			}, 'printComment');
			e.printComment = a;
			var u = i((d, p, f, m, y) => {
				const g = m.colors.tag;
				return (
					g.open +
					'<' +
					d +
					(p && g.close + p + m.spacingOuter + y + g.open) +
					(f
						? '>' + g.close + f + m.spacingOuter + y + g.open + '</' + d
						: (p && !m.min ? '' : ' ') + '/') +
					'>' +
					g.close
				);
			}, 'printElement');
			e.printElement = u;
			var c = i((d, p) => {
				const f = p.colors.tag;
				return f.open + '<' + d + f.close + ' ' + f.open + ' />' + f.close;
			}, 'printElementAsLeaf');
			e.printElementAsLeaf = c;
		}
	}),
	ML = J({
		'../node_modules/pretty-format/build/plugins/DOMElement.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.test = e.serialize = e.default = void 0));
			var t = Uf(),
				r = 1,
				n = 3,
				o = 8,
				s = 11,
				a = /^((HTML|SVG)\w*)?Element$/,
				u = i((T) => {
					try {
						return typeof T.hasAttribute == 'function' && T.hasAttribute('is');
					} catch {
						return !1;
					}
				}, 'testHasAttribute'),
				c = i((T) => {
					const b = T.constructor.name,
						{ nodeType: w, tagName: P } = T,
						I = (typeof P == 'string' && P.includes('-')) || u(T);
					return (
						(w === r && (a.test(b) || I)) ||
						(w === n && b === 'Text') ||
						(w === o && b === 'Comment') ||
						(w === s && b === 'DocumentFragment')
					);
				}, 'testNode'),
				d = i((T) => {
					var b;
					return (
						(T == null || (b = T.constructor) === null || b === void 0 ? void 0 : b.name) && c(T)
					);
				}, 'test');
			e.test = d;
			function p(T) {
				return T.nodeType === n;
			}
			i(p, 'nodeIsText');
			function f(T) {
				return T.nodeType === o;
			}
			i(f, 'nodeIsComment');
			function m(T) {
				return T.nodeType === s;
			}
			i(m, 'nodeIsFragment');
			var y = i((T, b, w, P, I, q) => {
				if (p(T)) return (0, t.printText)(T.data, b);
				if (f(T)) return (0, t.printComment)(T.data, b);
				const C = m(T) ? 'DocumentFragment' : T.tagName.toLowerCase();
				return ++P > b.maxDepth
					? (0, t.printElementAsLeaf)(C, b)
					: (0, t.printElement)(
							C,
							(0, t.printProps)(
								m(T)
									? []
									: Array.from(T.attributes)
											.map((R) => R.name)
											.sort(),
								m(T)
									? {}
									: Array.from(T.attributes).reduce((R, _) => ((R[_.name] = _.value), R), {}),
								b,
								w + b.indent,
								P,
								I,
								q
							),
							(0, t.printChildren)(
								Array.prototype.slice.call(T.childNodes || T.children),
								b,
								w + b.indent,
								P,
								I,
								q
							),
							b,
							w
						);
			}, 'serialize');
			e.serialize = y;
			var g = { serialize: y, test: d },
				E = g;
			e.default = E;
		}
	}),
	qL = J({
		'../node_modules/pretty-format/build/plugins/Immutable.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.test = e.serialize = e.default = void 0));
			var t = du(),
				r = '@@__IMMUTABLE_ITERABLE__@@',
				n = '@@__IMMUTABLE_LIST__@@',
				o = '@@__IMMUTABLE_KEYED__@@',
				s = '@@__IMMUTABLE_MAP__@@',
				a = '@@__IMMUTABLE_ORDERED__@@',
				u = '@@__IMMUTABLE_RECORD__@@',
				c = '@@__IMMUTABLE_SEQ__@@',
				d = '@@__IMMUTABLE_SET__@@',
				p = '@@__IMMUTABLE_STACK__@@',
				f = i((_) => 'Immutable.' + _, 'getImmutableName'),
				m = i((_) => '[' + _ + ']', 'printAsLeaf'),
				y = ' ',
				g = '',
				E = i(
					(_, S, D, N, V, H, A) =>
						++N > S.maxDepth
							? m(f(A))
							: f(A) + y + '{' + (0, t.printIteratorEntries)(_.entries(), S, D, N, V, H) + '}',
					'printImmutableEntries'
				);
			function T(_) {
				let S = 0;
				return {
					next() {
						if (S < _._keys.length) {
							const D = _._keys[S++];
							return { done: !1, value: [D, _.get(D)] };
						}
						return { done: !0, value: void 0 };
					}
				};
			}
			i(T, 'getRecordEntries');
			var b = i((_, S, D, N, V, H) => {
					const A = f(_._name || 'Record');
					return ++N > S.maxDepth
						? m(A)
						: A + y + '{' + (0, t.printIteratorEntries)(T(_), S, D, N, V, H) + '}';
				}, 'printImmutableRecord'),
				w = i((_, S, D, N, V, H) => {
					const A = f('Seq');
					return ++N > S.maxDepth
						? m(A)
						: _[o]
							? A +
								y +
								'{' +
								(_._iter || _._object
									? (0, t.printIteratorEntries)(_.entries(), S, D, N, V, H)
									: g) +
								'}'
							: A +
								y +
								'[' +
								(_._iter || _._array || _._collection || _._iterable
									? (0, t.printIteratorValues)(_.values(), S, D, N, V, H)
									: g) +
								']';
				}, 'printImmutableSeq'),
				P = i(
					(_, S, D, N, V, H, A) =>
						++N > S.maxDepth
							? m(f(A))
							: f(A) + y + '[' + (0, t.printIteratorValues)(_.values(), S, D, N, V, H) + ']',
					'printImmutableValues'
				),
				I = i(
					(_, S, D, N, V, H) =>
						_[s]
							? E(_, S, D, N, V, H, _[a] ? 'OrderedMap' : 'Map')
							: _[n]
								? P(_, S, D, N, V, H, 'List')
								: _[d]
									? P(_, S, D, N, V, H, _[a] ? 'OrderedSet' : 'Set')
									: _[p]
										? P(_, S, D, N, V, H, 'Stack')
										: _[c]
											? w(_, S, D, N, V, H)
											: b(_, S, D, N, V, H),
					'serialize'
				);
			e.serialize = I;
			var q = i((_) => _ && (_[r] === !0 || _[u] === !0), 'test');
			e.test = q;
			var C = { serialize: I, test: q },
				R = C;
			e.default = R;
		}
	}),
	jL = J({
		'../node_modules/pretty-format/node_modules/react-is/cjs/react-is.production.min.js'(e) {
			var t = 60103,
				r = 60106,
				n = 60107,
				o = 60108,
				s = 60114,
				a = 60109,
				u = 60110,
				c = 60112,
				d = 60113,
				p = 60120,
				f = 60115,
				m = 60116,
				y = 60121,
				g = 60122,
				E = 60117,
				T = 60129,
				b = 60131;
			typeof Symbol == 'function' &&
				Symbol.for &&
				((w = Symbol.for),
				(t = w('react.element')),
				(r = w('react.portal')),
				(n = w('react.fragment')),
				(o = w('react.strict_mode')),
				(s = w('react.profiler')),
				(a = w('react.provider')),
				(u = w('react.context')),
				(c = w('react.forward_ref')),
				(d = w('react.suspense')),
				(p = w('react.suspense_list')),
				(f = w('react.memo')),
				(m = w('react.lazy')),
				(y = w('react.block')),
				(g = w('react.server.block')),
				(E = w('react.fundamental')),
				(T = w('react.debug_trace_mode')),
				(b = w('react.legacy_hidden')));
			var w;
			function P(A) {
				if (typeof A == 'object' && A !== null) {
					var L = A.$$typeof;
					switch (L) {
						case t:
							switch (((A = A.type), A)) {
								case n:
								case s:
								case o:
								case d:
								case p:
									return A;
								default:
									switch (((A = A && A.$$typeof), A)) {
										case u:
										case c:
										case m:
										case f:
										case a:
											return A;
										default:
											return L;
									}
							}
						case r:
							return L;
					}
				}
			}
			i(P, 'y');
			var I = a,
				q = t,
				C = c,
				R = n,
				_ = m,
				S = f,
				D = r,
				N = s,
				V = o,
				H = d;
			((e.ContextConsumer = u),
				(e.ContextProvider = I),
				(e.Element = q),
				(e.ForwardRef = C),
				(e.Fragment = R),
				(e.Lazy = _),
				(e.Memo = S),
				(e.Portal = D),
				(e.Profiler = N),
				(e.StrictMode = V),
				(e.Suspense = H),
				(e.isAsyncMode = function () {
					return !1;
				}),
				(e.isConcurrentMode = function () {
					return !1;
				}),
				(e.isContextConsumer = function (A) {
					return P(A) === u;
				}),
				(e.isContextProvider = function (A) {
					return P(A) === a;
				}),
				(e.isElement = function (A) {
					return typeof A == 'object' && A !== null && A.$$typeof === t;
				}),
				(e.isForwardRef = function (A) {
					return P(A) === c;
				}),
				(e.isFragment = function (A) {
					return P(A) === n;
				}),
				(e.isLazy = function (A) {
					return P(A) === m;
				}),
				(e.isMemo = function (A) {
					return P(A) === f;
				}),
				(e.isPortal = function (A) {
					return P(A) === r;
				}),
				(e.isProfiler = function (A) {
					return P(A) === s;
				}),
				(e.isStrictMode = function (A) {
					return P(A) === o;
				}),
				(e.isSuspense = function (A) {
					return P(A) === d;
				}),
				(e.isValidElementType = function (A) {
					return (
						typeof A == 'string' ||
						typeof A == 'function' ||
						A === n ||
						A === s ||
						A === T ||
						A === o ||
						A === d ||
						A === p ||
						A === b ||
						(typeof A == 'object' &&
							A !== null &&
							(A.$$typeof === m ||
								A.$$typeof === f ||
								A.$$typeof === a ||
								A.$$typeof === u ||
								A.$$typeof === c ||
								A.$$typeof === E ||
								A.$$typeof === y ||
								A[0] === g))
					);
				}),
				(e.typeOf = P));
		}
	}),
	DL = J({
		'../node_modules/pretty-format/node_modules/react-is/index.js'(e, t) {
			t.exports = jL();
		}
	}),
	kL = J({
		'../node_modules/pretty-format/build/plugins/ReactElement.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.test = e.serialize = e.default = void 0));
			var t = o(DL()),
				r = Uf();
			function n(m) {
				if (typeof WeakMap != 'function') return null;
				var y = new WeakMap(),
					g = new WeakMap();
				return (n = i(function (E) {
					return E ? g : y;
				}, '_getRequireWildcardCache'))(m);
			}
			i(n, '_getRequireWildcardCache');
			function o(m, y) {
				if (!y && m && m.__esModule) return m;
				if (m === null || (typeof m != 'object' && typeof m != 'function')) return { default: m };
				var g = n(y);
				if (g && g.has(m)) return g.get(m);
				var E = {},
					T = Object.defineProperty && Object.getOwnPropertyDescriptor;
				for (var b in m)
					if (b !== 'default' && Object.prototype.hasOwnProperty.call(m, b)) {
						var w = T ? Object.getOwnPropertyDescriptor(m, b) : null;
						w && (w.get || w.set) ? Object.defineProperty(E, b, w) : (E[b] = m[b]);
					}
				return ((E.default = m), g && g.set(m, E), E);
			}
			i(o, '_interopRequireWildcard');
			var s = i(
					(m, y = []) => (
						Array.isArray(m)
							? m.forEach((g) => {
									s(g, y);
								})
							: m != null && m !== !1 && y.push(m),
						y
					),
					'getChildren'
				),
				a = i((m) => {
					const y = m.type;
					if (typeof y == 'string') return y;
					if (typeof y == 'function') return y.displayName || y.name || 'Unknown';
					if (t.isFragment(m)) return 'React.Fragment';
					if (t.isSuspense(m)) return 'React.Suspense';
					if (typeof y == 'object' && y !== null) {
						if (t.isContextProvider(m)) return 'Context.Provider';
						if (t.isContextConsumer(m)) return 'Context.Consumer';
						if (t.isForwardRef(m)) {
							if (y.displayName) return y.displayName;
							const g = y.render.displayName || y.render.name || '';
							return g !== '' ? 'ForwardRef(' + g + ')' : 'ForwardRef';
						}
						if (t.isMemo(m)) {
							const g = y.displayName || y.type.displayName || y.type.name || '';
							return g !== '' ? 'Memo(' + g + ')' : 'Memo';
						}
					}
					return 'UNDEFINED';
				}, 'getType'),
				u = i((m) => {
					const { props: y } = m;
					return Object.keys(y)
						.filter((g) => g !== 'children' && y[g] !== void 0)
						.sort();
				}, 'getPropKeys'),
				c = i(
					(m, y, g, E, T, b) =>
						++E > y.maxDepth
							? (0, r.printElementAsLeaf)(a(m), y)
							: (0, r.printElement)(
									a(m),
									(0, r.printProps)(u(m), m.props, y, g + y.indent, E, T, b),
									(0, r.printChildren)(s(m.props.children), y, g + y.indent, E, T, b),
									y,
									g
								),
					'serialize'
				);
			e.serialize = c;
			var d = i((m) => m != null && t.isElement(m), 'test');
			e.test = d;
			var p = { serialize: c, test: d },
				f = p;
			e.default = f;
		}
	}),
	LL = J({
		'../node_modules/pretty-format/build/plugins/ReactTestComponent.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.test = e.serialize = e.default = void 0));
			var t = Uf(),
				r = (function () {
					return typeof globalThis < 'u'
						? globalThis
						: typeof r < 'u'
							? r
							: typeof self < 'u'
								? self
								: typeof window < 'u'
									? window
									: Function('return this')();
				})(),
				n = r['jest-symbol-do-not-touch'] || r.Symbol,
				o = typeof n == 'function' && n.for ? n.for('react.test.json') : 245830487,
				s = i((p) => {
					const { props: f } = p;
					return f
						? Object.keys(f)
								.filter((m) => f[m] !== void 0)
								.sort()
						: [];
				}, 'getPropKeys'),
				a = i(
					(p, f, m, y, g, E) =>
						++y > f.maxDepth
							? (0, t.printElementAsLeaf)(p.type, f)
							: (0, t.printElement)(
									p.type,
									p.props ? (0, t.printProps)(s(p), p.props, f, m + f.indent, y, g, E) : '',
									p.children ? (0, t.printChildren)(p.children, f, m + f.indent, y, g, E) : '',
									f,
									m
								),
					'serialize'
				);
			e.serialize = a;
			var u = i((p) => p && p.$$typeof === o, 'test');
			e.test = u;
			var c = { serialize: a, test: u },
				d = c;
			e.default = d;
		}
	}),
	FL = J({
		'../node_modules/pretty-format/build/index.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.default = e.DEFAULT_OPTIONS = void 0),
				(e.format = Ie),
				(e.plugins = void 0));
			var t = p(JE()),
				r = du(),
				n = p(OL()),
				o = p(xL()),
				s = p(IL()),
				a = p(ML()),
				u = p(qL()),
				c = p(kL()),
				d = p(LL());
			function p($) {
				return $ && $.__esModule ? $ : { default: $ };
			}
			i(p, '_interopRequireDefault');
			var f = Object.prototype.toString,
				m = Date.prototype.toISOString,
				y = Error.prototype.toString,
				g = RegExp.prototype.toString,
				E = i(
					($) => (typeof $.constructor == 'function' && $.constructor.name) || 'Object',
					'getConstructorName'
				),
				T = i(($) => typeof window < 'u' && $ === window, 'isWindow'),
				b = /^Symbol\((.*)\)(.*)$/,
				w = /\n/gi,
				P = class extends Error {
					constructor(Q, re) {
						(super(Q), (this.stack = re), (this.name = this.constructor.name));
					}
				};
			i(P, 'PrettyFormatPluginError');
			var I = P;
			function q($) {
				return (
					$ === '[object Array]' ||
					$ === '[object ArrayBuffer]' ||
					$ === '[object DataView]' ||
					$ === '[object Float32Array]' ||
					$ === '[object Float64Array]' ||
					$ === '[object Int8Array]' ||
					$ === '[object Int16Array]' ||
					$ === '[object Int32Array]' ||
					$ === '[object Uint8Array]' ||
					$ === '[object Uint8ClampedArray]' ||
					$ === '[object Uint16Array]' ||
					$ === '[object Uint32Array]'
				);
			}
			i(q, 'isToStringedArrayType');
			function C($) {
				return Object.is($, -0) ? '-0' : String($);
			}
			i(C, 'printNumber');
			function R($) {
				return `${$}n`;
			}
			i(R, 'printBigInt');
			function _($, Q) {
				return Q ? '[Function ' + ($.name || 'anonymous') + ']' : '[Function]';
			}
			i(_, 'printFunction');
			function S($) {
				return String($).replace(b, 'Symbol($1)');
			}
			i(S, 'printSymbol');
			function D($) {
				return '[' + y.call($) + ']';
			}
			i(D, 'printError');
			function N($, Q, re, oe) {
				if ($ === !0 || $ === !1) return '' + $;
				if ($ === void 0) return 'undefined';
				if ($ === null) return 'null';
				const ne = typeof $;
				if (ne === 'number') return C($);
				if (ne === 'bigint') return R($);
				if (ne === 'string') return oe ? '"' + $.replace(/"|\\/g, '\\$&') + '"' : '"' + $ + '"';
				if (ne === 'function') return _($, Q);
				if (ne === 'symbol') return S($);
				const pe = f.call($);
				return pe === '[object WeakMap]'
					? 'WeakMap {}'
					: pe === '[object WeakSet]'
						? 'WeakSet {}'
						: pe === '[object Function]' || pe === '[object GeneratorFunction]'
							? _($, Q)
							: pe === '[object Symbol]'
								? S($)
								: pe === '[object Date]'
									? isNaN(+$)
										? 'Date { NaN }'
										: m.call($)
									: pe === '[object Error]'
										? D($)
										: pe === '[object RegExp]'
											? re
												? g.call($).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
												: g.call($)
											: $ instanceof Error
												? D($)
												: null;
			}
			i(N, 'printBasicValue');
			function V($, Q, re, oe, ne, pe) {
				if (ne.indexOf($) !== -1) return '[Circular]';
				((ne = ne.slice()), ne.push($));
				const ye = ++oe > Q.maxDepth,
					fe = Q.min;
				if (Q.callToJSON && !ye && $.toJSON && typeof $.toJSON == 'function' && !pe)
					return B($.toJSON(), Q, re, oe, ne, !0);
				const ze = f.call($);
				return ze === '[object Arguments]'
					? ye
						? '[Arguments]'
						: (fe ? '' : 'Arguments ') + '[' + (0, r.printListItems)($, Q, re, oe, ne, B) + ']'
					: q(ze)
						? ye
							? '[' + $.constructor.name + ']'
							: (fe || (!Q.printBasicPrototype && $.constructor.name === 'Array')
									? ''
									: $.constructor.name + ' ') +
								'[' +
								(0, r.printListItems)($, Q, re, oe, ne, B) +
								']'
						: ze === '[object Map]'
							? ye
								? '[Map]'
								: 'Map {' + (0, r.printIteratorEntries)($.entries(), Q, re, oe, ne, B, ' => ') + '}'
							: ze === '[object Set]'
								? ye
									? '[Set]'
									: 'Set {' + (0, r.printIteratorValues)($.values(), Q, re, oe, ne, B) + '}'
								: ye || T($)
									? '[' + E($) + ']'
									: (fe || (!Q.printBasicPrototype && E($) === 'Object') ? '' : E($) + ' ') +
										'{' +
										(0, r.printObjectProperties)($, Q, re, oe, ne, B) +
										'}';
			}
			i(V, 'printComplexValue');
			function H($) {
				return $.serialize != null;
			}
			i(H, 'isNewPlugin');
			function A($, Q, re, oe, ne, pe) {
				let ye;
				try {
					ye = H($)
						? $.serialize(Q, re, oe, ne, pe, B)
						: $.print(
								Q,
								(fe) => B(fe, re, oe, ne, pe),
								(fe) => {
									const ze = oe + re.indent;
									return (
										ze +
										fe.replace(
											w,
											`
` + ze
										)
									);
								},
								{ edgeSpacing: re.spacingOuter, min: re.min, spacing: re.spacingInner },
								re.colors
							);
				} catch (fe) {
					throw new I(fe.message, fe.stack);
				}
				if (typeof ye != 'string')
					throw new Error(
						`pretty-format: Plugin must return type "string" but instead returned "${typeof ye}".`
					);
				return ye;
			}
			i(A, 'printPlugin');
			function L($, Q) {
				for (let re = 0; re < $.length; re++)
					try {
						if ($[re].test(Q)) return $[re];
					} catch (oe) {
						throw new I(oe.message, oe.stack);
					}
				return null;
			}
			i(L, 'findPlugin');
			function B($, Q, re, oe, ne, pe) {
				const ye = L(Q.plugins, $);
				if (ye !== null) return A(ye, $, Q, re, oe, ne);
				const fe = N($, Q.printFunctionName, Q.escapeRegex, Q.escapeString);
				return fe !== null ? fe : V($, Q, re, oe, ne, pe);
			}
			i(B, 'printer');
			var k = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
				K = Object.keys(k),
				X = {
					callToJSON: !0,
					compareKeys: void 0,
					escapeRegex: !1,
					escapeString: !0,
					highlight: !1,
					indent: 2,
					maxDepth: 1 / 0,
					min: !1,
					plugins: [],
					printBasicPrototype: !0,
					printFunctionName: !0,
					theme: k
				};
			e.DEFAULT_OPTIONS = X;
			function ie($) {
				if (
					(Object.keys($).forEach((Q) => {
						if (!X.hasOwnProperty(Q)) throw new Error(`pretty-format: Unknown option "${Q}".`);
					}),
					$.min && $.indent !== void 0 && $.indent !== 0)
				)
					throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
				if ($.theme !== void 0) {
					if ($.theme === null) throw new Error('pretty-format: Option "theme" must not be null.');
					if (typeof $.theme != 'object')
						throw new Error(
							`pretty-format: Option "theme" must be of type "object" but instead received "${typeof $.theme}".`
						);
				}
			}
			i(ie, 'validateOptions');
			var ae = i(
					($) =>
						K.reduce((Q, re) => {
							const oe = $.theme && $.theme[re] !== void 0 ? $.theme[re] : k[re],
								ne = oe && t.default[oe];
							if (ne && typeof ne.close == 'string' && typeof ne.open == 'string') Q[re] = ne;
							else
								throw new Error(
									`pretty-format: Option "theme" has a key "${re}" whose value "${oe}" is undefined in ansi-styles.`
								);
							return Q;
						}, Object.create(null)),
					'getColorsHighlight'
				),
				W = i(
					() => K.reduce(($, Q) => (($[Q] = { close: '', open: '' }), $), Object.create(null)),
					'getColorsEmpty'
				),
				le = i(
					($) => ($ && $.printFunctionName !== void 0 ? $.printFunctionName : X.printFunctionName),
					'getPrintFunctionName'
				),
				ve = i(
					($) => ($ && $.escapeRegex !== void 0 ? $.escapeRegex : X.escapeRegex),
					'getEscapeRegex'
				),
				de = i(
					($) => ($ && $.escapeString !== void 0 ? $.escapeString : X.escapeString),
					'getEscapeString'
				),
				ee = i(($) => {
					var Q;
					return {
						callToJSON: $ && $.callToJSON !== void 0 ? $.callToJSON : X.callToJSON,
						colors: $ && $.highlight ? ae($) : W(),
						compareKeys: $ && typeof $.compareKeys == 'function' ? $.compareKeys : X.compareKeys,
						escapeRegex: ve($),
						escapeString: de($),
						indent: $ && $.min ? '' : xe($ && $.indent !== void 0 ? $.indent : X.indent),
						maxDepth: $ && $.maxDepth !== void 0 ? $.maxDepth : X.maxDepth,
						min: $ && $.min !== void 0 ? $.min : X.min,
						plugins: $ && $.plugins !== void 0 ? $.plugins : X.plugins,
						printBasicPrototype: (Q = $?.printBasicPrototype) !== null && Q !== void 0 ? Q : !0,
						printFunctionName: le($),
						spacingInner:
							$ && $.min
								? ' '
								: `
`,
						spacingOuter:
							$ && $.min
								? ''
								: `
`
					};
				}, 'getConfig');
			function xe($) {
				return new Array($ + 1).join(' ');
			}
			i(xe, 'createIndent');
			function Ie($, Q) {
				if (Q && (ie(Q), Q.plugins)) {
					const oe = L(Q.plugins, $);
					if (oe !== null) return A(oe, $, ee(Q), '', 0, []);
				}
				const re = N($, le(Q), ve(Q), de(Q));
				return re !== null ? re : V($, ee(Q), '', 0, []);
			}
			i(Ie, 'format');
			var Xe = {
				AsymmetricMatcher: n.default,
				ConvertAnsi: o.default,
				DOMCollection: s.default,
				DOMElement: a.default,
				Immutable: u.default,
				ReactElement: c.default,
				ReactTestComponent: d.default
			};
			e.plugins = Xe;
			var rt = Ie;
			e.default = rt;
		}
	}),
	BL = J({
		'../node_modules/lz-string/libs/lz-string.js'(e, t) {
			var r = (function () {
				var n = String.fromCharCode,
					o = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
					s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$',
					a = {};
				function u(d, p) {
					if (!a[d]) {
						a[d] = {};
						for (var f = 0; f < d.length; f++) a[d][d.charAt(f)] = f;
					}
					return a[d][p];
				}
				i(u, 'getBaseValue');
				var c = {
					compressToBase64: i(function (d) {
						if (d == null) return '';
						var p = c._compress(d, 6, function (f) {
							return o.charAt(f);
						});
						switch (p.length % 4) {
							default:
							case 0:
								return p;
							case 1:
								return p + '===';
							case 2:
								return p + '==';
							case 3:
								return p + '=';
						}
					}, 'compressToBase64'),
					decompressFromBase64: i(function (d) {
						return d == null
							? ''
							: d == ''
								? null
								: c._decompress(d.length, 32, function (p) {
										return u(o, d.charAt(p));
									});
					}, 'decompressFromBase64'),
					compressToUTF16: i(function (d) {
						return d == null
							? ''
							: c._compress(d, 15, function (p) {
									return n(p + 32);
								}) + ' ';
					}, 'compressToUTF16'),
					decompressFromUTF16: i(function (d) {
						return d == null
							? ''
							: d == ''
								? null
								: c._decompress(d.length, 16384, function (p) {
										return d.charCodeAt(p) - 32;
									});
					}, 'decompressFromUTF16'),
					compressToUint8Array: i(function (d) {
						for (
							var p = c.compress(d), f = new Uint8Array(p.length * 2), m = 0, y = p.length;
							m < y;
							m++
						) {
							var g = p.charCodeAt(m);
							((f[m * 2] = g >>> 8), (f[m * 2 + 1] = g % 256));
						}
						return f;
					}, 'compressToUint8Array'),
					decompressFromUint8Array: i(function (d) {
						if (d == null) return c.decompress(d);
						for (var p = new Array(d.length / 2), f = 0, m = p.length; f < m; f++)
							p[f] = d[f * 2] * 256 + d[f * 2 + 1];
						var y = [];
						return (
							p.forEach(function (g) {
								y.push(n(g));
							}),
							c.decompress(y.join(''))
						);
					}, 'decompressFromUint8Array'),
					compressToEncodedURIComponent: i(function (d) {
						return d == null
							? ''
							: c._compress(d, 6, function (p) {
									return s.charAt(p);
								});
					}, 'compressToEncodedURIComponent'),
					decompressFromEncodedURIComponent: i(function (d) {
						return d == null
							? ''
							: d == ''
								? null
								: ((d = d.replace(/ /g, '+')),
									c._decompress(d.length, 32, function (p) {
										return u(s, d.charAt(p));
									}));
					}, 'decompressFromEncodedURIComponent'),
					compress: i(function (d) {
						return c._compress(d, 16, function (p) {
							return n(p);
						});
					}, 'compress'),
					_compress: i(function (d, p, f) {
						if (d == null) return '';
						var m,
							y,
							g = {},
							E = {},
							T = '',
							b = '',
							w = '',
							P = 2,
							I = 3,
							q = 2,
							C = [],
							R = 0,
							_ = 0,
							S;
						for (S = 0; S < d.length; S += 1)
							if (
								((T = d.charAt(S)),
								Object.prototype.hasOwnProperty.call(g, T) || ((g[T] = I++), (E[T] = !0)),
								(b = w + T),
								Object.prototype.hasOwnProperty.call(g, b))
							)
								w = b;
							else {
								if (Object.prototype.hasOwnProperty.call(E, w)) {
									if (w.charCodeAt(0) < 256) {
										for (m = 0; m < q; m++)
											((R = R << 1), _ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++);
										for (y = w.charCodeAt(0), m = 0; m < 8; m++)
											((R = (R << 1) | (y & 1)),
												_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
												(y = y >> 1));
									} else {
										for (y = 1, m = 0; m < q; m++)
											((R = (R << 1) | y),
												_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
												(y = 0));
										for (y = w.charCodeAt(0), m = 0; m < 16; m++)
											((R = (R << 1) | (y & 1)),
												_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
												(y = y >> 1));
									}
									(P--, P == 0 && ((P = Math.pow(2, q)), q++), delete E[w]);
								} else
									for (y = g[w], m = 0; m < q; m++)
										((R = (R << 1) | (y & 1)),
											_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
											(y = y >> 1));
								(P--, P == 0 && ((P = Math.pow(2, q)), q++), (g[b] = I++), (w = String(T)));
							}
						if (w !== '') {
							if (Object.prototype.hasOwnProperty.call(E, w)) {
								if (w.charCodeAt(0) < 256) {
									for (m = 0; m < q; m++)
										((R = R << 1), _ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++);
									for (y = w.charCodeAt(0), m = 0; m < 8; m++)
										((R = (R << 1) | (y & 1)),
											_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
											(y = y >> 1));
								} else {
									for (y = 1, m = 0; m < q; m++)
										((R = (R << 1) | y),
											_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
											(y = 0));
									for (y = w.charCodeAt(0), m = 0; m < 16; m++)
										((R = (R << 1) | (y & 1)),
											_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
											(y = y >> 1));
								}
								(P--, P == 0 && ((P = Math.pow(2, q)), q++), delete E[w]);
							} else
								for (y = g[w], m = 0; m < q; m++)
									((R = (R << 1) | (y & 1)),
										_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
										(y = y >> 1));
							(P--, P == 0 && ((P = Math.pow(2, q)), q++));
						}
						for (y = 2, m = 0; m < q; m++)
							((R = (R << 1) | (y & 1)),
								_ == p - 1 ? ((_ = 0), C.push(f(R)), (R = 0)) : _++,
								(y = y >> 1));
						for (;;)
							if (((R = R << 1), _ == p - 1)) {
								C.push(f(R));
								break;
							} else _++;
						return C.join('');
					}, '_compress'),
					decompress: i(function (d) {
						return d == null
							? ''
							: d == ''
								? null
								: c._decompress(d.length, 32768, function (p) {
										return d.charCodeAt(p);
									});
					}, 'decompress'),
					_decompress: i(function (d, p, f) {
						var m = [],
							y = 4,
							g = 4,
							E = 3,
							T = '',
							b = [],
							w,
							P,
							I,
							q,
							C,
							R,
							_,
							S = { val: f(0), position: p, index: 1 };
						for (w = 0; w < 3; w += 1) m[w] = w;
						for (I = 0, C = Math.pow(2, 2), R = 1; R != C; )
							((q = S.val & S.position),
								(S.position >>= 1),
								S.position == 0 && ((S.position = p), (S.val = f(S.index++))),
								(I |= (q > 0 ? 1 : 0) * R),
								(R <<= 1));
						switch (I) {
							case 0:
								for (I = 0, C = Math.pow(2, 8), R = 1; R != C; )
									((q = S.val & S.position),
										(S.position >>= 1),
										S.position == 0 && ((S.position = p), (S.val = f(S.index++))),
										(I |= (q > 0 ? 1 : 0) * R),
										(R <<= 1));
								_ = n(I);
								break;
							case 1:
								for (I = 0, C = Math.pow(2, 16), R = 1; R != C; )
									((q = S.val & S.position),
										(S.position >>= 1),
										S.position == 0 && ((S.position = p), (S.val = f(S.index++))),
										(I |= (q > 0 ? 1 : 0) * R),
										(R <<= 1));
								_ = n(I);
								break;
							case 2:
								return '';
						}
						for (m[3] = _, P = _, b.push(_); ; ) {
							if (S.index > d) return '';
							for (I = 0, C = Math.pow(2, E), R = 1; R != C; )
								((q = S.val & S.position),
									(S.position >>= 1),
									S.position == 0 && ((S.position = p), (S.val = f(S.index++))),
									(I |= (q > 0 ? 1 : 0) * R),
									(R <<= 1));
							switch ((_ = I)) {
								case 0:
									for (I = 0, C = Math.pow(2, 8), R = 1; R != C; )
										((q = S.val & S.position),
											(S.position >>= 1),
											S.position == 0 && ((S.position = p), (S.val = f(S.index++))),
											(I |= (q > 0 ? 1 : 0) * R),
											(R <<= 1));
									((m[g++] = n(I)), (_ = g - 1), y--);
									break;
								case 1:
									for (I = 0, C = Math.pow(2, 16), R = 1; R != C; )
										((q = S.val & S.position),
											(S.position >>= 1),
											S.position == 0 && ((S.position = p), (S.val = f(S.index++))),
											(I |= (q > 0 ? 1 : 0) * R),
											(R <<= 1));
									((m[g++] = n(I)), (_ = g - 1), y--);
									break;
								case 2:
									return b.join('');
							}
							if ((y == 0 && ((y = Math.pow(2, E)), E++), m[_])) T = m[_];
							else if (_ === g) T = P + P.charAt(0);
							else return null;
							(b.push(T),
								(m[g++] = P + T.charAt(0)),
								y--,
								(P = T),
								y == 0 && ((y = Math.pow(2, E)), E++));
						}
					}, '_decompress')
				};
				return c;
			})();
			typeof define == 'function' && define.amd
				? define(function () {
						return r;
					})
				: typeof t < 'u' && t != null
					? (t.exports = r)
					: typeof angular < 'u' &&
						angular != null &&
						angular.module('LZString', []).factory('LZString', function () {
							return r;
						});
		}
	}),
	$E = J({
		'../node_modules/memoizerific/memoizerific.js'(e, t) {
			(function (r) {
				if (typeof e == 'object' && typeof t < 'u') t.exports = r();
				else if (typeof define == 'function' && define.amd) define([], r);
				else {
					var n;
					(typeof window < 'u'
						? (n = window)
						: typeof global < 'u'
							? (n = global)
							: typeof self < 'u'
								? (n = self)
								: (n = this),
						(n.memoizerific = r()));
				}
			})(function () {
				return i(function r(n, o, s) {
					function a(d, p) {
						if (!o[d]) {
							if (!n[d]) {
								var f = typeof Fa == 'function' && Fa;
								if (!p && f) return f(d, !0);
								if (u) return u(d, !0);
								var m = new Error("Cannot find module '" + d + "'");
								throw ((m.code = 'MODULE_NOT_FOUND'), m);
							}
							var y = (o[d] = { exports: {} });
							n[d][0].call(
								y.exports,
								function (g) {
									var E = n[d][1][g];
									return a(E || g);
								},
								y,
								y.exports,
								r,
								n,
								o,
								s
							);
						}
						return o[d].exports;
					}
					i(a, 's');
					for (var u = typeof Fa == 'function' && Fa, c = 0; c < s.length; c++) a(s[c]);
					return a;
				}, 'e')(
					{
						1: [
							function (r, n, o) {
								n.exports = function (s) {
									if (typeof Map != 'function' || s) {
										var a = r('./similar');
										return new a();
									} else return new Map();
								};
							},
							{ './similar': 2 }
						],
						2: [
							function (r, n, o) {
								function s() {
									return ((this.list = []), (this.lastItem = void 0), (this.size = 0), this);
								}
								(i(s, 'Similar'),
									(s.prototype.get = function (a) {
										var u;
										if (this.lastItem && this.isEqual(this.lastItem.key, a))
											return this.lastItem.val;
										if (((u = this.indexOf(a)), u >= 0))
											return ((this.lastItem = this.list[u]), this.list[u].val);
									}),
									(s.prototype.set = function (a, u) {
										var c;
										return this.lastItem && this.isEqual(this.lastItem.key, a)
											? ((this.lastItem.val = u), this)
											: ((c = this.indexOf(a)),
												c >= 0
													? ((this.lastItem = this.list[c]), (this.list[c].val = u), this)
													: ((this.lastItem = { key: a, val: u }),
														this.list.push(this.lastItem),
														this.size++,
														this));
									}),
									(s.prototype.delete = function (a) {
										var u;
										if (
											(this.lastItem &&
												this.isEqual(this.lastItem.key, a) &&
												(this.lastItem = void 0),
											(u = this.indexOf(a)),
											u >= 0)
										)
											return (this.size--, this.list.splice(u, 1)[0]);
									}),
									(s.prototype.has = function (a) {
										var u;
										return this.lastItem && this.isEqual(this.lastItem.key, a)
											? !0
											: ((u = this.indexOf(a)), u >= 0 ? ((this.lastItem = this.list[u]), !0) : !1);
									}),
									(s.prototype.forEach = function (a, u) {
										var c;
										for (c = 0; c < this.size; c++)
											a.call(u || this, this.list[c].val, this.list[c].key, this);
									}),
									(s.prototype.indexOf = function (a) {
										var u;
										for (u = 0; u < this.size; u++) if (this.isEqual(this.list[u].key, a)) return u;
										return -1;
									}),
									(s.prototype.isEqual = function (a, u) {
										return a === u || (a !== a && u !== u);
									}),
									(n.exports = s));
							},
							{}
						],
						3: [
							function (r, n, o) {
								var s = r('map-or-similar');
								n.exports = function (d) {
									var p = new s(!1),
										f = [];
									return function (m) {
										var y = i(function () {
											var g = p,
												E,
												T,
												b = arguments.length - 1,
												w = Array(b + 1),
												P = !0,
												I;
											if ((y.numArgs || y.numArgs === 0) && y.numArgs !== b + 1)
												throw new Error(
													'Memoizerific functions should always be called with the same number of arguments'
												);
											for (I = 0; I < b; I++) {
												if (((w[I] = { cacheItem: g, arg: arguments[I] }), g.has(arguments[I]))) {
													g = g.get(arguments[I]);
													continue;
												}
												((P = !1), (E = new s(!1)), g.set(arguments[I], E), (g = E));
											}
											return (
												P && (g.has(arguments[b]) ? (T = g.get(arguments[b])) : (P = !1)),
												P || ((T = m.apply(null, arguments)), g.set(arguments[b], T)),
												d > 0 &&
													((w[b] = { cacheItem: g, arg: arguments[b] }),
													P ? a(f, w) : f.push(w),
													f.length > d && u(f.shift())),
												(y.wasMemoized = P),
												(y.numArgs = b + 1),
												T
											);
										}, 'memoizerific');
										return ((y.limit = d), (y.wasMemoized = !1), (y.cache = p), (y.lru = f), y);
									};
								};
								function a(d, p) {
									var f = d.length,
										m = p.length,
										y,
										g,
										E;
									for (g = 0; g < f; g++) {
										for (y = !0, E = 0; E < m; E++)
											if (!c(d[g][E].arg, p[E].arg)) {
												y = !1;
												break;
											}
										if (y) break;
									}
									d.push(d.splice(g, 1)[0]);
								}
								i(a, 'moveToMostRecentLru');
								function u(d) {
									var p = d.length,
										f = d[p - 1],
										m,
										y;
									for (
										f.cacheItem.delete(f.arg), y = p - 2;
										y >= 0 && ((f = d[y]), (m = f.cacheItem.get(f.arg)), !m || !m.size);
										y--
									)
										f.cacheItem.delete(f.arg);
								}
								i(u, 'removeCachedResult');
								function c(d, p) {
									return d === p || (d !== d && p !== p);
								}
								i(c, 'isEqual');
							},
							{ 'map-or-similar': 1 }
						]
					},
					{},
					[3]
				)(3);
			});
		}
	}),
	UE = J({
		'../node_modules/picoquery/lib/string-util.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.encodeString = n));
			var t = Array.from(
					{ length: 256 },
					(o, s) => '%' + ((s < 16 ? '0' : '') + s.toString(16)).toUpperCase()
				),
				r = new Int8Array([
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
					0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 0, 0, 0, 1, 0
				]);
			function n(o) {
				const s = o.length;
				if (s === 0) return '';
				let a = '',
					u = 0,
					c = 0;
				e: for (; c < s; c++) {
					let d = o.charCodeAt(c);
					for (; d < 128; ) {
						if (
							(r[d] !== 1 && (u < c && (a += o.slice(u, c)), (u = c + 1), (a += t[d])), ++c === s)
						)
							break e;
						d = o.charCodeAt(c);
					}
					if ((u < c && (a += o.slice(u, c)), d < 2048)) {
						((u = c + 1), (a += t[192 | (d >> 6)] + t[128 | (d & 63)]));
						continue;
					}
					if (d < 55296 || d >= 57344) {
						((u = c + 1), (a += t[224 | (d >> 12)] + t[128 | ((d >> 6) & 63)] + t[128 | (d & 63)]));
						continue;
					}
					if ((++c, c >= s)) throw new Error('URI malformed');
					const p = o.charCodeAt(c) & 1023;
					((u = c + 1),
						(d = 65536 + (((d & 1023) << 10) | p)),
						(a +=
							t[240 | (d >> 18)] +
							t[128 | ((d >> 12) & 63)] +
							t[128 | ((d >> 6) & 63)] +
							t[128 | (d & 63)]));
				}
				return u === 0 ? o : u < s ? a + o.slice(u) : a;
			}
			i(n, 'encodeString');
		}
	}),
	Vf = J({
		'../node_modules/picoquery/lib/shared.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.defaultOptions = e.defaultShouldSerializeObject = e.defaultValueSerializer = void 0));
			var t = UE(),
				r = i((s) => {
					switch (typeof s) {
						case 'string':
							return (0, t.encodeString)(s);
						case 'bigint':
						case 'boolean':
							return '' + s;
						case 'number':
							if (Number.isFinite(s)) return s < 1e21 ? '' + s : (0, t.encodeString)('' + s);
							break;
					}
					return s instanceof Date ? (0, t.encodeString)(s.toISOString()) : '';
				}, 'defaultValueSerializer');
			e.defaultValueSerializer = r;
			var n = i((s) => s instanceof Date, 'defaultShouldSerializeObject');
			e.defaultShouldSerializeObject = n;
			var o = i((s) => s, 'identityFunc');
			e.defaultOptions = {
				nesting: !0,
				nestingSyntax: 'dot',
				arrayRepeat: !1,
				arrayRepeatSyntax: 'repeat',
				delimiter: 38,
				valueDeserializer: o,
				valueSerializer: e.defaultValueSerializer,
				keyDeserializer: o,
				shouldSerializeObject: e.defaultShouldSerializeObject
			};
		}
	}),
	VE = J({
		'../node_modules/picoquery/lib/object-util.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.getDeepObject = o),
				(e.stringifyObject = p));
			var t = Vf(),
				r = UE();
			function n(f) {
				return f === '__proto__' || f === 'constructor' || f === 'prototype';
			}
			i(n, 'isPrototypeKey');
			function o(f, m, y, g, E) {
				if (n(m)) return f;
				const T = f[m];
				return typeof T == 'object' && T !== null
					? T
					: !g &&
						  (E ||
								typeof y == 'number' ||
								(typeof y == 'string' && y * 0 === 0 && y.indexOf('.') === -1))
						? (f[m] = [])
						: (f[m] = {});
			}
			i(o, 'getDeepObject');
			var s = 20,
				a = '[]',
				u = '[',
				c = ']',
				d = '.';
			function p(f, m, y = 0, g, E) {
				const {
						nestingSyntax: T = t.defaultOptions.nestingSyntax,
						arrayRepeat: b = t.defaultOptions.arrayRepeat,
						arrayRepeatSyntax: w = t.defaultOptions.arrayRepeatSyntax,
						nesting: P = t.defaultOptions.nesting,
						delimiter: I = t.defaultOptions.delimiter,
						valueSerializer: q = t.defaultOptions.valueSerializer,
						shouldSerializeObject: C = t.defaultOptions.shouldSerializeObject
					} = m,
					R = typeof I == 'number' ? String.fromCharCode(I) : I,
					_ = E === !0 && b,
					S = T === 'dot' || (T === 'js' && !E);
				if (y > s) return '';
				let D = '',
					N = !0,
					V = !1;
				for (const H in f) {
					const A = f[H];
					if (A === void 0) continue;
					let L;
					(g
						? ((L = g),
							_
								? w === 'bracket' && (L += a)
								: S
									? ((L += d), (L += H))
									: ((L += u), (L += H), (L += c)))
						: (L = H),
						N || (D += R),
						typeof A == 'object' && A !== null && !C(A)
							? ((V = A.pop !== void 0), (P || (b && V)) && (D += p(A, m, y + 1, L, V)))
							: ((D += (0, r.encodeString)(L)), (D += '='), (D += q(A, H))),
						N && (N = !1));
				}
				return D;
			}
			i(p, 'stringifyObject');
		}
	}),
	JL = J({
		'../node_modules/picoquery/lib/decode-uri-component.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.decodeURIComponent = o));
			var t = 12,
				r = 0,
				n = [
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
					2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
					3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
					5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,
					10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,
					0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0,
					0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,
					0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7
				];
			function o(u) {
				let c = u.indexOf('%');
				if (c === -1) return u;
				const d = u.length;
				let p = '',
					f = 0,
					m = 0,
					y = c,
					g = t;
				for (; c > -1 && c < d; ) {
					const E = a(u[c + 1], 4),
						T = a(u[c + 2], 0),
						b = E | T,
						w = n[b];
					if (((g = n[256 + g + w]), (m = (m << 6) | (b & n[364 + w])), g === t))
						((p += u.slice(f, y)),
							(p +=
								m <= 65535
									? String.fromCharCode(m)
									: String.fromCharCode(55232 + (m >> 10), 56320 + (m & 1023))),
							(m = 0),
							(f = c + 3),
							(c = y = u.indexOf('%', f)));
					else {
						if (g === r) return null;
						if (((c += 3), c < d && u.charCodeAt(c) === 37)) continue;
						return null;
					}
				}
				return p + u.slice(f);
			}
			i(o, 'decodeURIComponent');
			var s = {
				0: 0,
				1: 1,
				2: 2,
				3: 3,
				4: 4,
				5: 5,
				6: 6,
				7: 7,
				8: 8,
				9: 9,
				a: 10,
				A: 10,
				b: 11,
				B: 11,
				c: 12,
				C: 12,
				d: 13,
				D: 13,
				e: 14,
				E: 14,
				f: 15,
				F: 15
			};
			function a(u, c) {
				const d = s[u];
				return d === void 0 ? 255 : d << c;
			}
			i(a, 'hexCodeToInt');
		}
	}),
	$L = J({
		'../node_modules/picoquery/lib/parse.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.numberValueDeserializer = e.numberKeyDeserializer = void 0),
				(e.parse = d));
			var t = VE(),
				r = Vf(),
				n = JL(),
				o = i((p) => {
					const f = Number(p);
					return Number.isNaN(f) ? p : f;
				}, 'numberKeyDeserializer');
			e.numberKeyDeserializer = o;
			var s = i((p) => {
				const f = Number(p);
				return Number.isNaN(f) ? p : f;
			}, 'numberValueDeserializer');
			e.numberValueDeserializer = s;
			var a = /\+/g,
				u = i(function () {}, 'Empty');
			u.prototype = Object.create(null);
			function c(p, f, m, y, g) {
				let E = p.substring(f, m);
				return (y && (E = E.replace(a, ' ')), g && (E = (0, n.decodeURIComponent)(E) || E), E);
			}
			i(c, 'computeKeySlice');
			function d(p, f) {
				const {
						valueDeserializer: m = r.defaultOptions.valueDeserializer,
						keyDeserializer: y = r.defaultOptions.keyDeserializer,
						arrayRepeatSyntax: g = r.defaultOptions.arrayRepeatSyntax,
						nesting: E = r.defaultOptions.nesting,
						arrayRepeat: T = r.defaultOptions.arrayRepeat,
						nestingSyntax: b = r.defaultOptions.nestingSyntax,
						delimiter: w = r.defaultOptions.delimiter
					} = f ?? {},
					P = typeof w == 'string' ? w.charCodeAt(0) : w,
					I = b === 'js',
					q = new u();
				if (typeof p != 'string') return q;
				const C = p.length;
				let R = '',
					_ = -1,
					S = -1,
					D = -1,
					N = q,
					V,
					H = '',
					A = '',
					L = !1,
					B = !1,
					k = !1,
					K = !1,
					X = !1,
					ie = !1,
					ae = 0,
					W = -1,
					le = -1,
					ve = -1;
				for (let de = 0; de < C + 1; de++) {
					if (((ae = de !== C ? p.charCodeAt(de) : P), ae === P)) {
						if (
							((ie = S > _),
							ie || (S = de),
							D !== S - 1 &&
								((A = c(p, D + 1, W > -1 ? W : S, k, L)),
								(H = y(A)),
								V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I && X, void 0))),
							ie || H !== '')
						) {
							ie &&
								((R = p.slice(S + 1, de)),
								K && (R = R.replace(a, ' ')),
								B && (R = (0, n.decodeURIComponent)(R) || R));
							const ee = m(R, H);
							if (T) {
								const xe = N[H];
								xe === void 0
									? W > -1
										? (N[H] = [ee])
										: (N[H] = ee)
									: xe.pop
										? xe.push(ee)
										: (N[H] = [xe, ee]);
							} else N[H] = ee;
						}
						((R = ''),
							(_ = de),
							(S = de),
							(L = !1),
							(B = !1),
							(k = !1),
							(K = !1),
							(X = !1),
							(W = -1),
							(D = de),
							(N = q),
							(V = void 0),
							(H = ''));
					} else
						ae === 93
							? (T && g === 'bracket' && ve === 91 && (W = le),
								E &&
									(b === 'index' || I) &&
									S <= _ &&
									(D !== le &&
										((A = c(p, D + 1, de, k, L)),
										(H = y(A)),
										V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, void 0, void 0)),
										(V = H),
										(k = !1),
										(L = !1)),
									(D = de),
									(X = !1)))
							: ae === 46
								? E &&
									(b === 'dot' || I) &&
									S <= _ &&
									(D !== le &&
										((A = c(p, D + 1, de, k, L)),
										(H = y(A)),
										V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I)),
										(V = H),
										(k = !1),
										(L = !1)),
									(X = !0),
									(D = de))
								: ae === 91
									? E &&
										(b === 'index' || I) &&
										S <= _ &&
										(D !== le &&
											((A = c(p, D + 1, de, k, L)),
											(H = y(A)),
											I && V !== void 0 && (N = (0, t.getDeepObject)(N, V, H, I)),
											(V = H),
											(k = !1),
											(L = !1),
											(X = !1)),
										(D = de))
									: ae === 61
										? S <= _
											? (S = de)
											: (B = !0)
										: ae === 43
											? S > _
												? (K = !0)
												: (k = !0)
											: ae === 37 && (S > _ ? (B = !0) : (L = !0));
					((le = de), (ve = ae));
				}
				return q;
			}
			i(d, 'parse');
		}
	}),
	UL = J({
		'../node_modules/picoquery/lib/stringify.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = r));
			var t = VE();
			function r(n, o) {
				if (n === null || typeof n != 'object') return '';
				const s = o ?? {};
				return (0, t.stringifyObject)(n, s);
			}
			i(r, 'stringify');
		}
	}),
	Hf = J({
		'../node_modules/picoquery/lib/main.js'(e) {
			var t =
					(e && e.__createBinding) ||
					(Object.create
						? function (s, a, u, c) {
								c === void 0 && (c = u);
								var d = Object.getOwnPropertyDescriptor(a, u);
								((!d || ('get' in d ? !a.__esModule : d.writable || d.configurable)) &&
									(d = {
										enumerable: !0,
										get: i(function () {
											return a[u];
										}, 'get')
									}),
									Object.defineProperty(s, c, d));
							}
						: function (s, a, u, c) {
								(c === void 0 && (c = u), (s[c] = a[u]));
							}),
				r =
					(e && e.__exportStar) ||
					function (s, a) {
						for (var u in s)
							u !== 'default' && !Object.prototype.hasOwnProperty.call(a, u) && t(a, s, u);
					};
			(Object.defineProperty(e, '__esModule', { value: !0 }), (e.stringify = e.parse = void 0));
			var n = $L();
			Object.defineProperty(e, 'parse', {
				enumerable: !0,
				get: i(function () {
					return n.parse;
				}, 'get')
			});
			var o = UL();
			(Object.defineProperty(e, 'stringify', {
				enumerable: !0,
				get: i(function () {
					return o.stringify;
				}, 'get')
			}),
				r(Vf(), e));
		}
	}),
	HE = J({
		'../node_modules/entities/lib/maps/entities.json'(e, t) {
			t.exports = {
				Aacute: '',
				aacute: '',
				Abreve: '',
				abreve: '',
				ac: '',
				acd: '',
				acE: '',
				Acirc: '',
				acirc: '',
				acute: '',
				Acy: '',
				acy: '',
				AElig: '',
				aelig: '',
				af: '',
				Afr: '',
				afr: '',
				Agrave: '',
				agrave: '',
				alefsym: '',
				aleph: '',
				Alpha: '',
				alpha: '',
				Amacr: '',
				amacr: '',
				amalg: '',
				amp: '&',
				AMP: '&',
				andand: '',
				And: '',
				and: '',
				andd: '',
				andslope: '',
				andv: '',
				ang: '',
				ange: '',
				angle: '',
				angmsdaa: '',
				angmsdab: '',
				angmsdac: '',
				angmsdad: '',
				angmsdae: '',
				angmsdaf: '',
				angmsdag: '',
				angmsdah: '',
				angmsd: '',
				angrt: '',
				angrtvb: '',
				angrtvbd: '',
				angsph: '',
				angst: '',
				angzarr: '',
				Aogon: '',
				aogon: '',
				Aopf: '',
				aopf: '',
				apacir: '',
				ap: '',
				apE: '',
				ape: '',
				apid: '',
				apos: "'",
				ApplyFunction: '',
				approx: '',
				approxeq: '',
				Aring: '',
				aring: '',
				Ascr: '',
				ascr: '',
				Assign: '',
				ast: '*',
				asymp: '',
				asympeq: '',
				Atilde: '',
				atilde: '',
				Auml: '',
				auml: '',
				awconint: '',
				awint: '',
				backcong: '',
				backepsilon: '',
				backprime: '',
				backsim: '',
				backsimeq: '',
				Backslash: '',
				Barv: '',
				barvee: '',
				barwed: '',
				Barwed: '',
				barwedge: '',
				bbrk: '',
				bbrktbrk: '',
				bcong: '',
				Bcy: '',
				bcy: '',
				bdquo: '',
				becaus: '',
				because: '',
				Because: '',
				bemptyv: '',
				bepsi: '',
				bernou: '',
				Bernoullis: '',
				Beta: '',
				beta: '',
				beth: '',
				between: '',
				Bfr: '',
				bfr: '',
				bigcap: '',
				bigcirc: '',
				bigcup: '',
				bigodot: '',
				bigoplus: '',
				bigotimes: '',
				bigsqcup: '',
				bigstar: '',
				bigtriangledown: '',
				bigtriangleup: '',
				biguplus: '',
				bigvee: '',
				bigwedge: '',
				bkarow: '',
				blacklozenge: '',
				blacksquare: '',
				blacktriangle: '',
				blacktriangledown: '',
				blacktriangleleft: '',
				blacktriangleright: '',
				blank: '',
				blk12: '',
				blk14: '',
				blk34: '',
				block: '',
				bne: '=',
				bnequiv: '',
				bNot: '',
				bnot: '',
				Bopf: '',
				bopf: '',
				bot: '',
				bottom: '',
				bowtie: '',
				boxbox: '',
				boxdl: '',
				boxdL: '',
				boxDl: '',
				boxDL: '',
				boxdr: '',
				boxdR: '',
				boxDr: '',
				boxDR: '',
				boxh: '',
				boxH: '',
				boxhd: '',
				boxHd: '',
				boxhD: '',
				boxHD: '',
				boxhu: '',
				boxHu: '',
				boxhU: '',
				boxHU: '',
				boxminus: '',
				boxplus: '',
				boxtimes: '',
				boxul: '',
				boxuL: '',
				boxUl: '',
				boxUL: '',
				boxur: '',
				boxuR: '',
				boxUr: '',
				boxUR: '',
				boxv: '',
				boxV: '',
				boxvh: '',
				boxvH: '',
				boxVh: '',
				boxVH: '',
				boxvl: '',
				boxvL: '',
				boxVl: '',
				boxVL: '',
				boxvr: '',
				boxvR: '',
				boxVr: '',
				boxVR: '',
				bprime: '',
				breve: '',
				Breve: '',
				brvbar: '',
				bscr: '',
				Bscr: '',
				bsemi: '',
				bsim: '',
				bsime: '',
				bsolb: '',
				bsol: '\\',
				bsolhsub: '',
				bull: '',
				bullet: '',
				bump: '',
				bumpE: '',
				bumpe: '',
				Bumpeq: '',
				bumpeq: '',
				Cacute: '',
				cacute: '',
				capand: '',
				capbrcup: '',
				capcap: '',
				cap: '',
				Cap: '',
				capcup: '',
				capdot: '',
				CapitalDifferentialD: '',
				caps: '',
				caret: '',
				caron: '',
				Cayleys: '',
				ccaps: '',
				Ccaron: '',
				ccaron: '',
				Ccedil: '',
				ccedil: '',
				Ccirc: '',
				ccirc: '',
				Cconint: '',
				ccups: '',
				ccupssm: '',
				Cdot: '',
				cdot: '',
				cedil: '',
				Cedilla: '',
				cemptyv: '',
				cent: '',
				centerdot: '',
				CenterDot: '',
				cfr: '',
				Cfr: '',
				CHcy: '',
				chcy: '',
				check: '',
				checkmark: '',
				Chi: '',
				chi: '',
				circ: '',
				circeq: '',
				circlearrowleft: '',
				circlearrowright: '',
				circledast: '',
				circledcirc: '',
				circleddash: '',
				CircleDot: '',
				circledR: '',
				circledS: '',
				CircleMinus: '',
				CirclePlus: '',
				CircleTimes: '',
				cir: '',
				cirE: '',
				cire: '',
				cirfnint: '',
				cirmid: '',
				cirscir: '',
				ClockwiseContourIntegral: '',
				CloseCurlyDoubleQuote: '',
				CloseCurlyQuote: '',
				clubs: '',
				clubsuit: '',
				colon: ':',
				Colon: '',
				Colone: '',
				colone: '',
				coloneq: '',
				comma: ',',
				commat: '@',
				comp: '',
				compfn: '',
				complement: '',
				complexes: '',
				cong: '',
				congdot: '',
				Congruent: '',
				conint: '',
				Conint: '',
				ContourIntegral: '',
				copf: '',
				Copf: '',
				coprod: '',
				Coproduct: '',
				copy: '',
				COPY: '',
				copysr: '',
				CounterClockwiseContourIntegral: '',
				crarr: '',
				cross: '',
				Cross: '',
				Cscr: '',
				cscr: '',
				csub: '',
				csube: '',
				csup: '',
				csupe: '',
				ctdot: '',
				cudarrl: '',
				cudarrr: '',
				cuepr: '',
				cuesc: '',
				cularr: '',
				cularrp: '',
				cupbrcap: '',
				cupcap: '',
				CupCap: '',
				cup: '',
				Cup: '',
				cupcup: '',
				cupdot: '',
				cupor: '',
				cups: '',
				curarr: '',
				curarrm: '',
				curlyeqprec: '',
				curlyeqsucc: '',
				curlyvee: '',
				curlywedge: '',
				curren: '',
				curvearrowleft: '',
				curvearrowright: '',
				cuvee: '',
				cuwed: '',
				cwconint: '',
				cwint: '',
				cylcty: '',
				dagger: '',
				Dagger: '',
				daleth: '',
				darr: '',
				Darr: '',
				dArr: '',
				dash: '',
				Dashv: '',
				dashv: '',
				dbkarow: '',
				dblac: '',
				Dcaron: '',
				dcaron: '',
				Dcy: '',
				dcy: '',
				ddagger: '',
				ddarr: '',
				DD: '',
				dd: '',
				DDotrahd: '',
				ddotseq: '',
				deg: '',
				Del: '',
				Delta: '',
				delta: '',
				demptyv: '',
				dfisht: '',
				Dfr: '',
				dfr: '',
				dHar: '',
				dharl: '',
				dharr: '',
				DiacriticalAcute: '',
				DiacriticalDot: '',
				DiacriticalDoubleAcute: '',
				DiacriticalGrave: '`',
				DiacriticalTilde: '',
				diam: '',
				diamond: '',
				Diamond: '',
				diamondsuit: '',
				diams: '',
				die: '',
				DifferentialD: '',
				digamma: '',
				disin: '',
				div: '',
				divide: '',
				divideontimes: '',
				divonx: '',
				DJcy: '',
				djcy: '',
				dlcorn: '',
				dlcrop: '',
				dollar: '$',
				Dopf: '',
				dopf: '',
				Dot: '',
				dot: '',
				DotDot: '',
				doteq: '',
				doteqdot: '',
				DotEqual: '',
				dotminus: '',
				dotplus: '',
				dotsquare: '',
				doublebarwedge: '',
				DoubleContourIntegral: '',
				DoubleDot: '',
				DoubleDownArrow: '',
				DoubleLeftArrow: '',
				DoubleLeftRightArrow: '',
				DoubleLeftTee: '',
				DoubleLongLeftArrow: '',
				DoubleLongLeftRightArrow: '',
				DoubleLongRightArrow: '',
				DoubleRightArrow: '',
				DoubleRightTee: '',
				DoubleUpArrow: '',
				DoubleUpDownArrow: '',
				DoubleVerticalBar: '',
				DownArrowBar: '',
				downarrow: '',
				DownArrow: '',
				Downarrow: '',
				DownArrowUpArrow: '',
				DownBreve: '',
				downdownarrows: '',
				downharpoonleft: '',
				downharpoonright: '',
				DownLeftRightVector: '',
				DownLeftTeeVector: '',
				DownLeftVectorBar: '',
				DownLeftVector: '',
				DownRightTeeVector: '',
				DownRightVectorBar: '',
				DownRightVector: '',
				DownTeeArrow: '',
				DownTee: '',
				drbkarow: '',
				drcorn: '',
				drcrop: '',
				Dscr: '',
				dscr: '',
				DScy: '',
				dscy: '',
				dsol: '',
				Dstrok: '',
				dstrok: '',
				dtdot: '',
				dtri: '',
				dtrif: '',
				duarr: '',
				duhar: '',
				dwangle: '',
				DZcy: '',
				dzcy: '',
				dzigrarr: '',
				Eacute: '',
				eacute: '',
				easter: '',
				Ecaron: '',
				ecaron: '',
				Ecirc: '',
				ecirc: '',
				ecir: '',
				ecolon: '',
				Ecy: '',
				ecy: '',
				eDDot: '',
				Edot: '',
				edot: '',
				eDot: '',
				ee: '',
				efDot: '',
				Efr: '',
				efr: '',
				eg: '',
				Egrave: '',
				egrave: '',
				egs: '',
				egsdot: '',
				el: '',
				Element: '',
				elinters: '',
				ell: '',
				els: '',
				elsdot: '',
				Emacr: '',
				emacr: '',
				empty: '',
				emptyset: '',
				EmptySmallSquare: '',
				emptyv: '',
				EmptyVerySmallSquare: '',
				emsp13: '',
				emsp14: '',
				emsp: '',
				ENG: '',
				eng: '',
				ensp: '',
				Eogon: '',
				eogon: '',
				Eopf: '',
				eopf: '',
				epar: '',
				eparsl: '',
				eplus: '',
				epsi: '',
				Epsilon: '',
				epsilon: '',
				epsiv: '',
				eqcirc: '',
				eqcolon: '',
				eqsim: '',
				eqslantgtr: '',
				eqslantless: '',
				Equal: '',
				equals: '=',
				EqualTilde: '',
				equest: '',
				Equilibrium: '',
				equiv: '',
				equivDD: '',
				eqvparsl: '',
				erarr: '',
				erDot: '',
				escr: '',
				Escr: '',
				esdot: '',
				Esim: '',
				esim: '',
				Eta: '',
				eta: '',
				ETH: '',
				eth: '',
				Euml: '',
				euml: '',
				euro: '',
				excl: '!',
				exist: '',
				Exists: '',
				expectation: '',
				exponentiale: '',
				ExponentialE: '',
				fallingdotseq: '',
				Fcy: '',
				fcy: '',
				female: '',
				ffilig: '',
				fflig: '',
				ffllig: '',
				Ffr: '',
				ffr: '',
				filig: '',
				FilledSmallSquare: '',
				FilledVerySmallSquare: '',
				fjlig: 'fj',
				flat: '',
				fllig: '',
				fltns: '',
				fnof: '',
				Fopf: '',
				fopf: '',
				forall: '',
				ForAll: '',
				fork: '',
				forkv: '',
				Fouriertrf: '',
				fpartint: '',
				frac12: '',
				frac13: '',
				frac14: '',
				frac15: '',
				frac16: '',
				frac18: '',
				frac23: '',
				frac25: '',
				frac34: '',
				frac35: '',
				frac38: '',
				frac45: '',
				frac56: '',
				frac58: '',
				frac78: '',
				frasl: '',
				frown: '',
				fscr: '',
				Fscr: '',
				gacute: '',
				Gamma: '',
				gamma: '',
				Gammad: '',
				gammad: '',
				gap: '',
				Gbreve: '',
				gbreve: '',
				Gcedil: '',
				Gcirc: '',
				gcirc: '',
				Gcy: '',
				gcy: '',
				Gdot: '',
				gdot: '',
				ge: '',
				gE: '',
				gEl: '',
				gel: '',
				geq: '',
				geqq: '',
				geqslant: '',
				gescc: '',
				ges: '',
				gesdot: '',
				gesdoto: '',
				gesdotol: '',
				gesl: '',
				gesles: '',
				Gfr: '',
				gfr: '',
				gg: '',
				Gg: '',
				ggg: '',
				gimel: '',
				GJcy: '',
				gjcy: '',
				gla: '',
				gl: '',
				glE: '',
				glj: '',
				gnap: '',
				gnapprox: '',
				gne: '',
				gnE: '',
				gneq: '',
				gneqq: '',
				gnsim: '',
				Gopf: '',
				gopf: '',
				grave: '`',
				GreaterEqual: '',
				GreaterEqualLess: '',
				GreaterFullEqual: '',
				GreaterGreater: '',
				GreaterLess: '',
				GreaterSlantEqual: '',
				GreaterTilde: '',
				Gscr: '',
				gscr: '',
				gsim: '',
				gsime: '',
				gsiml: '',
				gtcc: '',
				gtcir: '',
				gt: '>',
				GT: '>',
				Gt: '',
				gtdot: '',
				gtlPar: '',
				gtquest: '',
				gtrapprox: '',
				gtrarr: '',
				gtrdot: '',
				gtreqless: '',
				gtreqqless: '',
				gtrless: '',
				gtrsim: '',
				gvertneqq: '',
				gvnE: '',
				Hacek: '',
				hairsp: '',
				half: '',
				hamilt: '',
				HARDcy: '',
				hardcy: '',
				harrcir: '',
				harr: '',
				hArr: '',
				harrw: '',
				Hat: '^',
				hbar: '',
				Hcirc: '',
				hcirc: '',
				hearts: '',
				heartsuit: '',
				hellip: '',
				hercon: '',
				hfr: '',
				Hfr: '',
				HilbertSpace: '',
				hksearow: '',
				hkswarow: '',
				hoarr: '',
				homtht: '',
				hookleftarrow: '',
				hookrightarrow: '',
				hopf: '',
				Hopf: '',
				horbar: '',
				HorizontalLine: '',
				hscr: '',
				Hscr: '',
				hslash: '',
				Hstrok: '',
				hstrok: '',
				HumpDownHump: '',
				HumpEqual: '',
				hybull: '',
				hyphen: '',
				Iacute: '',
				iacute: '',
				ic: '',
				Icirc: '',
				icirc: '',
				Icy: '',
				icy: '',
				Idot: '',
				IEcy: '',
				iecy: '',
				iexcl: '',
				iff: '',
				ifr: '',
				Ifr: '',
				Igrave: '',
				igrave: '',
				ii: '',
				iiiint: '',
				iiint: '',
				iinfin: '',
				iiota: '',
				IJlig: '',
				ijlig: '',
				Imacr: '',
				imacr: '',
				image: '',
				ImaginaryI: '',
				imagline: '',
				imagpart: '',
				imath: '',
				Im: '',
				imof: '',
				imped: '',
				Implies: '',
				incare: '',
				in: '',
				infin: '',
				infintie: '',
				inodot: '',
				intcal: '',
				int: '',
				Int: '',
				integers: '',
				Integral: '',
				intercal: '',
				Intersection: '',
				intlarhk: '',
				intprod: '',
				InvisibleComma: '',
				InvisibleTimes: '',
				IOcy: '',
				iocy: '',
				Iogon: '',
				iogon: '',
				Iopf: '',
				iopf: '',
				Iota: '',
				iota: '',
				iprod: '',
				iquest: '',
				iscr: '',
				Iscr: '',
				isin: '',
				isindot: '',
				isinE: '',
				isins: '',
				isinsv: '',
				isinv: '',
				it: '',
				Itilde: '',
				itilde: '',
				Iukcy: '',
				iukcy: '',
				Iuml: '',
				iuml: '',
				Jcirc: '',
				jcirc: '',
				Jcy: '',
				jcy: '',
				Jfr: '',
				jfr: '',
				jmath: '',
				Jopf: '',
				jopf: '',
				Jscr: '',
				jscr: '',
				Jsercy: '',
				jsercy: '',
				Jukcy: '',
				jukcy: '',
				Kappa: '',
				kappa: '',
				kappav: '',
				Kcedil: '',
				kcedil: '',
				Kcy: '',
				kcy: '',
				Kfr: '',
				kfr: '',
				kgreen: '',
				KHcy: '',
				khcy: '',
				KJcy: '',
				kjcy: '',
				Kopf: '',
				kopf: '',
				Kscr: '',
				kscr: '',
				lAarr: '',
				Lacute: '',
				lacute: '',
				laemptyv: '',
				lagran: '',
				Lambda: '',
				lambda: '',
				lang: '',
				Lang: '',
				langd: '',
				langle: '',
				lap: '',
				Laplacetrf: '',
				laquo: '',
				larrb: '',
				larrbfs: '',
				larr: '',
				Larr: '',
				lArr: '',
				larrfs: '',
				larrhk: '',
				larrlp: '',
				larrpl: '',
				larrsim: '',
				larrtl: '',
				latail: '',
				lAtail: '',
				lat: '',
				late: '',
				lates: '',
				lbarr: '',
				lBarr: '',
				lbbrk: '',
				lbrace: '{',
				lbrack: '[',
				lbrke: '',
				lbrksld: '',
				lbrkslu: '',
				Lcaron: '',
				lcaron: '',
				Lcedil: '',
				lcedil: '',
				lceil: '',
				lcub: '{',
				Lcy: '',
				lcy: '',
				ldca: '',
				ldquo: '',
				ldquor: '',
				ldrdhar: '',
				ldrushar: '',
				ldsh: '',
				le: '',
				lE: '',
				LeftAngleBracket: '',
				LeftArrowBar: '',
				leftarrow: '',
				LeftArrow: '',
				Leftarrow: '',
				LeftArrowRightArrow: '',
				leftarrowtail: '',
				LeftCeiling: '',
				LeftDoubleBracket: '',
				LeftDownTeeVector: '',
				LeftDownVectorBar: '',
				LeftDownVector: '',
				LeftFloor: '',
				leftharpoondown: '',
				leftharpoonup: '',
				leftleftarrows: '',
				leftrightarrow: '',
				LeftRightArrow: '',
				Leftrightarrow: '',
				leftrightarrows: '',
				leftrightharpoons: '',
				leftrightsquigarrow: '',
				LeftRightVector: '',
				LeftTeeArrow: '',
				LeftTee: '',
				LeftTeeVector: '',
				leftthreetimes: '',
				LeftTriangleBar: '',
				LeftTriangle: '',
				LeftTriangleEqual: '',
				LeftUpDownVector: '',
				LeftUpTeeVector: '',
				LeftUpVectorBar: '',
				LeftUpVector: '',
				LeftVectorBar: '',
				LeftVector: '',
				lEg: '',
				leg: '',
				leq: '',
				leqq: '',
				leqslant: '',
				lescc: '',
				les: '',
				lesdot: '',
				lesdoto: '',
				lesdotor: '',
				lesg: '',
				lesges: '',
				lessapprox: '',
				lessdot: '',
				lesseqgtr: '',
				lesseqqgtr: '',
				LessEqualGreater: '',
				LessFullEqual: '',
				LessGreater: '',
				lessgtr: '',
				LessLess: '',
				lesssim: '',
				LessSlantEqual: '',
				LessTilde: '',
				lfisht: '',
				lfloor: '',
				Lfr: '',
				lfr: '',
				lg: '',
				lgE: '',
				lHar: '',
				lhard: '',
				lharu: '',
				lharul: '',
				lhblk: '',
				LJcy: '',
				ljcy: '',
				llarr: '',
				ll: '',
				Ll: '',
				llcorner: '',
				Lleftarrow: '',
				llhard: '',
				lltri: '',
				Lmidot: '',
				lmidot: '',
				lmoustache: '',
				lmoust: '',
				lnap: '',
				lnapprox: '',
				lne: '',
				lnE: '',
				lneq: '',
				lneqq: '',
				lnsim: '',
				loang: '',
				loarr: '',
				lobrk: '',
				longleftarrow: '',
				LongLeftArrow: '',
				Longleftarrow: '',
				longleftrightarrow: '',
				LongLeftRightArrow: '',
				Longleftrightarrow: '',
				longmapsto: '',
				longrightarrow: '',
				LongRightArrow: '',
				Longrightarrow: '',
				looparrowleft: '',
				looparrowright: '',
				lopar: '',
				Lopf: '',
				lopf: '',
				loplus: '',
				lotimes: '',
				lowast: '',
				lowbar: '_',
				LowerLeftArrow: '',
				LowerRightArrow: '',
				loz: '',
				lozenge: '',
				lozf: '',
				lpar: '(',
				lparlt: '',
				lrarr: '',
				lrcorner: '',
				lrhar: '',
				lrhard: '',
				lrm: '',
				lrtri: '',
				lsaquo: '',
				lscr: '',
				Lscr: '',
				lsh: '',
				Lsh: '',
				lsim: '',
				lsime: '',
				lsimg: '',
				lsqb: '[',
				lsquo: '',
				lsquor: '',
				Lstrok: '',
				lstrok: '',
				ltcc: '',
				ltcir: '',
				lt: '<',
				LT: '<',
				Lt: '',
				ltdot: '',
				lthree: '',
				ltimes: '',
				ltlarr: '',
				ltquest: '',
				ltri: '',
				ltrie: '',
				ltrif: '',
				ltrPar: '',
				lurdshar: '',
				luruhar: '',
				lvertneqq: '',
				lvnE: '',
				macr: '',
				male: '',
				malt: '',
				maltese: '',
				Map: '',
				map: '',
				mapsto: '',
				mapstodown: '',
				mapstoleft: '',
				mapstoup: '',
				marker: '',
				mcomma: '',
				Mcy: '',
				mcy: '',
				mdash: '',
				mDDot: '',
				measuredangle: '',
				MediumSpace: '',
				Mellintrf: '',
				Mfr: '',
				mfr: '',
				mho: '',
				micro: '',
				midast: '*',
				midcir: '',
				mid: '',
				middot: '',
				minusb: '',
				minus: '',
				minusd: '',
				minusdu: '',
				MinusPlus: '',
				mlcp: '',
				mldr: '',
				mnplus: '',
				models: '',
				Mopf: '',
				mopf: '',
				mp: '',
				mscr: '',
				Mscr: '',
				mstpos: '',
				Mu: '',
				mu: '',
				multimap: '',
				mumap: '',
				nabla: '',
				Nacute: '',
				nacute: '',
				nang: '',
				nap: '',
				napE: '',
				napid: '',
				napos: '',
				napprox: '',
				natural: '',
				naturals: '',
				natur: '',
				nbsp: '',
				nbump: '',
				nbumpe: '',
				ncap: '',
				Ncaron: '',
				ncaron: '',
				Ncedil: '',
				ncedil: '',
				ncong: '',
				ncongdot: '',
				ncup: '',
				Ncy: '',
				ncy: '',
				ndash: '',
				nearhk: '',
				nearr: '',
				neArr: '',
				nearrow: '',
				ne: '',
				nedot: '',
				NegativeMediumSpace: '',
				NegativeThickSpace: '',
				NegativeThinSpace: '',
				NegativeVeryThinSpace: '',
				nequiv: '',
				nesear: '',
				nesim: '',
				NestedGreaterGreater: '',
				NestedLessLess: '',
				NewLine: `
`,
				nexist: '',
				nexists: '',
				Nfr: '',
				nfr: '',
				ngE: '',
				nge: '',
				ngeq: '',
				ngeqq: '',
				ngeqslant: '',
				nges: '',
				nGg: '',
				ngsim: '',
				nGt: '',
				ngt: '',
				ngtr: '',
				nGtv: '',
				nharr: '',
				nhArr: '',
				nhpar: '',
				ni: '',
				nis: '',
				nisd: '',
				niv: '',
				NJcy: '',
				njcy: '',
				nlarr: '',
				nlArr: '',
				nldr: '',
				nlE: '',
				nle: '',
				nleftarrow: '',
				nLeftarrow: '',
				nleftrightarrow: '',
				nLeftrightarrow: '',
				nleq: '',
				nleqq: '',
				nleqslant: '',
				nles: '',
				nless: '',
				nLl: '',
				nlsim: '',
				nLt: '',
				nlt: '',
				nltri: '',
				nltrie: '',
				nLtv: '',
				nmid: '',
				NoBreak: '',
				NonBreakingSpace: '',
				nopf: '',
				Nopf: '',
				Not: '',
				not: '',
				NotCongruent: '',
				NotCupCap: '',
				NotDoubleVerticalBar: '',
				NotElement: '',
				NotEqual: '',
				NotEqualTilde: '',
				NotExists: '',
				NotGreater: '',
				NotGreaterEqual: '',
				NotGreaterFullEqual: '',
				NotGreaterGreater: '',
				NotGreaterLess: '',
				NotGreaterSlantEqual: '',
				NotGreaterTilde: '',
				NotHumpDownHump: '',
				NotHumpEqual: '',
				notin: '',
				notindot: '',
				notinE: '',
				notinva: '',
				notinvb: '',
				notinvc: '',
				NotLeftTriangleBar: '',
				NotLeftTriangle: '',
				NotLeftTriangleEqual: '',
				NotLess: '',
				NotLessEqual: '',
				NotLessGreater: '',
				NotLessLess: '',
				NotLessSlantEqual: '',
				NotLessTilde: '',
				NotNestedGreaterGreater: '',
				NotNestedLessLess: '',
				notni: '',
				notniva: '',
				notnivb: '',
				notnivc: '',
				NotPrecedes: '',
				NotPrecedesEqual: '',
				NotPrecedesSlantEqual: '',
				NotReverseElement: '',
				NotRightTriangleBar: '',
				NotRightTriangle: '',
				NotRightTriangleEqual: '',
				NotSquareSubset: '',
				NotSquareSubsetEqual: '',
				NotSquareSuperset: '',
				NotSquareSupersetEqual: '',
				NotSubset: '',
				NotSubsetEqual: '',
				NotSucceeds: '',
				NotSucceedsEqual: '',
				NotSucceedsSlantEqual: '',
				NotSucceedsTilde: '',
				NotSuperset: '',
				NotSupersetEqual: '',
				NotTilde: '',
				NotTildeEqual: '',
				NotTildeFullEqual: '',
				NotTildeTilde: '',
				NotVerticalBar: '',
				nparallel: '',
				npar: '',
				nparsl: '',
				npart: '',
				npolint: '',
				npr: '',
				nprcue: '',
				nprec: '',
				npreceq: '',
				npre: '',
				nrarrc: '',
				nrarr: '',
				nrArr: '',
				nrarrw: '',
				nrightarrow: '',
				nRightarrow: '',
				nrtri: '',
				nrtrie: '',
				nsc: '',
				nsccue: '',
				nsce: '',
				Nscr: '',
				nscr: '',
				nshortmid: '',
				nshortparallel: '',
				nsim: '',
				nsime: '',
				nsimeq: '',
				nsmid: '',
				nspar: '',
				nsqsube: '',
				nsqsupe: '',
				nsub: '',
				nsubE: '',
				nsube: '',
				nsubset: '',
				nsubseteq: '',
				nsubseteqq: '',
				nsucc: '',
				nsucceq: '',
				nsup: '',
				nsupE: '',
				nsupe: '',
				nsupset: '',
				nsupseteq: '',
				nsupseteqq: '',
				ntgl: '',
				Ntilde: '',
				ntilde: '',
				ntlg: '',
				ntriangleleft: '',
				ntrianglelefteq: '',
				ntriangleright: '',
				ntrianglerighteq: '',
				Nu: '',
				nu: '',
				num: '#',
				numero: '',
				numsp: '',
				nvap: '',
				nvdash: '',
				nvDash: '',
				nVdash: '',
				nVDash: '',
				nvge: '',
				nvgt: '>',
				nvHarr: '',
				nvinfin: '',
				nvlArr: '',
				nvle: '',
				nvlt: '<',
				nvltrie: '',
				nvrArr: '',
				nvrtrie: '',
				nvsim: '',
				nwarhk: '',
				nwarr: '',
				nwArr: '',
				nwarrow: '',
				nwnear: '',
				Oacute: '',
				oacute: '',
				oast: '',
				Ocirc: '',
				ocirc: '',
				ocir: '',
				Ocy: '',
				ocy: '',
				odash: '',
				Odblac: '',
				odblac: '',
				odiv: '',
				odot: '',
				odsold: '',
				OElig: '',
				oelig: '',
				ofcir: '',
				Ofr: '',
				ofr: '',
				ogon: '',
				Ograve: '',
				ograve: '',
				ogt: '',
				ohbar: '',
				ohm: '',
				oint: '',
				olarr: '',
				olcir: '',
				olcross: '',
				oline: '',
				olt: '',
				Omacr: '',
				omacr: '',
				Omega: '',
				omega: '',
				Omicron: '',
				omicron: '',
				omid: '',
				ominus: '',
				Oopf: '',
				oopf: '',
				opar: '',
				OpenCurlyDoubleQuote: '',
				OpenCurlyQuote: '',
				operp: '',
				oplus: '',
				orarr: '',
				Or: '',
				or: '',
				ord: '',
				order: '',
				orderof: '',
				ordf: '',
				ordm: '',
				origof: '',
				oror: '',
				orslope: '',
				orv: '',
				oS: '',
				Oscr: '',
				oscr: '',
				Oslash: '',
				oslash: '',
				osol: '',
				Otilde: '',
				otilde: '',
				otimesas: '',
				Otimes: '',
				otimes: '',
				Ouml: '',
				ouml: '',
				ovbar: '',
				OverBar: '',
				OverBrace: '',
				OverBracket: '',
				OverParenthesis: '',
				para: '',
				parallel: '',
				par: '',
				parsim: '',
				parsl: '',
				part: '',
				PartialD: '',
				Pcy: '',
				pcy: '',
				percnt: '%',
				period: '.',
				permil: '',
				perp: '',
				pertenk: '',
				Pfr: '',
				pfr: '',
				Phi: '',
				phi: '',
				phiv: '',
				phmmat: '',
				phone: '',
				Pi: '',
				pi: '',
				pitchfork: '',
				piv: '',
				planck: '',
				planckh: '',
				plankv: '',
				plusacir: '',
				plusb: '',
				pluscir: '',
				plus: '+',
				plusdo: '',
				plusdu: '',
				pluse: '',
				PlusMinus: '',
				plusmn: '',
				plussim: '',
				plustwo: '',
				pm: '',
				Poincareplane: '',
				pointint: '',
				popf: '',
				Popf: '',
				pound: '',
				prap: '',
				Pr: '',
				pr: '',
				prcue: '',
				precapprox: '',
				prec: '',
				preccurlyeq: '',
				Precedes: '',
				PrecedesEqual: '',
				PrecedesSlantEqual: '',
				PrecedesTilde: '',
				preceq: '',
				precnapprox: '',
				precneqq: '',
				precnsim: '',
				pre: '',
				prE: '',
				precsim: '',
				prime: '',
				Prime: '',
				primes: '',
				prnap: '',
				prnE: '',
				prnsim: '',
				prod: '',
				Product: '',
				profalar: '',
				profline: '',
				profsurf: '',
				prop: '',
				Proportional: '',
				Proportion: '',
				propto: '',
				prsim: '',
				prurel: '',
				Pscr: '',
				pscr: '',
				Psi: '',
				psi: '',
				puncsp: '',
				Qfr: '',
				qfr: '',
				qint: '',
				qopf: '',
				Qopf: '',
				qprime: '',
				Qscr: '',
				qscr: '',
				quaternions: '',
				quatint: '',
				quest: '?',
				questeq: '',
				quot: '"',
				QUOT: '"',
				rAarr: '',
				race: '',
				Racute: '',
				racute: '',
				radic: '',
				raemptyv: '',
				rang: '',
				Rang: '',
				rangd: '',
				range: '',
				rangle: '',
				raquo: '',
				rarrap: '',
				rarrb: '',
				rarrbfs: '',
				rarrc: '',
				rarr: '',
				Rarr: '',
				rArr: '',
				rarrfs: '',
				rarrhk: '',
				rarrlp: '',
				rarrpl: '',
				rarrsim: '',
				Rarrtl: '',
				rarrtl: '',
				rarrw: '',
				ratail: '',
				rAtail: '',
				ratio: '',
				rationals: '',
				rbarr: '',
				rBarr: '',
				RBarr: '',
				rbbrk: '',
				rbrace: '}',
				rbrack: ']',
				rbrke: '',
				rbrksld: '',
				rbrkslu: '',
				Rcaron: '',
				rcaron: '',
				Rcedil: '',
				rcedil: '',
				rceil: '',
				rcub: '}',
				Rcy: '',
				rcy: '',
				rdca: '',
				rdldhar: '',
				rdquo: '',
				rdquor: '',
				rdsh: '',
				real: '',
				realine: '',
				realpart: '',
				reals: '',
				Re: '',
				rect: '',
				reg: '',
				REG: '',
				ReverseElement: '',
				ReverseEquilibrium: '',
				ReverseUpEquilibrium: '',
				rfisht: '',
				rfloor: '',
				rfr: '',
				Rfr: '',
				rHar: '',
				rhard: '',
				rharu: '',
				rharul: '',
				Rho: '',
				rho: '',
				rhov: '',
				RightAngleBracket: '',
				RightArrowBar: '',
				rightarrow: '',
				RightArrow: '',
				Rightarrow: '',
				RightArrowLeftArrow: '',
				rightarrowtail: '',
				RightCeiling: '',
				RightDoubleBracket: '',
				RightDownTeeVector: '',
				RightDownVectorBar: '',
				RightDownVector: '',
				RightFloor: '',
				rightharpoondown: '',
				rightharpoonup: '',
				rightleftarrows: '',
				rightleftharpoons: '',
				rightrightarrows: '',
				rightsquigarrow: '',
				RightTeeArrow: '',
				RightTee: '',
				RightTeeVector: '',
				rightthreetimes: '',
				RightTriangleBar: '',
				RightTriangle: '',
				RightTriangleEqual: '',
				RightUpDownVector: '',
				RightUpTeeVector: '',
				RightUpVectorBar: '',
				RightUpVector: '',
				RightVectorBar: '',
				RightVector: '',
				ring: '',
				risingdotseq: '',
				rlarr: '',
				rlhar: '',
				rlm: '',
				rmoustache: '',
				rmoust: '',
				rnmid: '',
				roang: '',
				roarr: '',
				robrk: '',
				ropar: '',
				ropf: '',
				Ropf: '',
				roplus: '',
				rotimes: '',
				RoundImplies: '',
				rpar: ')',
				rpargt: '',
				rppolint: '',
				rrarr: '',
				Rrightarrow: '',
				rsaquo: '',
				rscr: '',
				Rscr: '',
				rsh: '',
				Rsh: '',
				rsqb: ']',
				rsquo: '',
				rsquor: '',
				rthree: '',
				rtimes: '',
				rtri: '',
				rtrie: '',
				rtrif: '',
				rtriltri: '',
				RuleDelayed: '',
				ruluhar: '',
				rx: '',
				Sacute: '',
				sacute: '',
				sbquo: '',
				scap: '',
				Scaron: '',
				scaron: '',
				Sc: '',
				sc: '',
				sccue: '',
				sce: '',
				scE: '',
				Scedil: '',
				scedil: '',
				Scirc: '',
				scirc: '',
				scnap: '',
				scnE: '',
				scnsim: '',
				scpolint: '',
				scsim: '',
				Scy: '',
				scy: '',
				sdotb: '',
				sdot: '',
				sdote: '',
				searhk: '',
				searr: '',
				seArr: '',
				searrow: '',
				sect: '',
				semi: ';',
				seswar: '',
				setminus: '',
				setmn: '',
				sext: '',
				Sfr: '',
				sfr: '',
				sfrown: '',
				sharp: '',
				SHCHcy: '',
				shchcy: '',
				SHcy: '',
				shcy: '',
				ShortDownArrow: '',
				ShortLeftArrow: '',
				shortmid: '',
				shortparallel: '',
				ShortRightArrow: '',
				ShortUpArrow: '',
				shy: '',
				Sigma: '',
				sigma: '',
				sigmaf: '',
				sigmav: '',
				sim: '',
				simdot: '',
				sime: '',
				simeq: '',
				simg: '',
				simgE: '',
				siml: '',
				simlE: '',
				simne: '',
				simplus: '',
				simrarr: '',
				slarr: '',
				SmallCircle: '',
				smallsetminus: '',
				smashp: '',
				smeparsl: '',
				smid: '',
				smile: '',
				smt: '',
				smte: '',
				smtes: '',
				SOFTcy: '',
				softcy: '',
				solbar: '',
				solb: '',
				sol: '/',
				Sopf: '',
				sopf: '',
				spades: '',
				spadesuit: '',
				spar: '',
				sqcap: '',
				sqcaps: '',
				sqcup: '',
				sqcups: '',
				Sqrt: '',
				sqsub: '',
				sqsube: '',
				sqsubset: '',
				sqsubseteq: '',
				sqsup: '',
				sqsupe: '',
				sqsupset: '',
				sqsupseteq: '',
				square: '',
				Square: '',
				SquareIntersection: '',
				SquareSubset: '',
				SquareSubsetEqual: '',
				SquareSuperset: '',
				SquareSupersetEqual: '',
				SquareUnion: '',
				squarf: '',
				squ: '',
				squf: '',
				srarr: '',
				Sscr: '',
				sscr: '',
				ssetmn: '',
				ssmile: '',
				sstarf: '',
				Star: '',
				star: '',
				starf: '',
				straightepsilon: '',
				straightphi: '',
				strns: '',
				sub: '',
				Sub: '',
				subdot: '',
				subE: '',
				sube: '',
				subedot: '',
				submult: '',
				subnE: '',
				subne: '',
				subplus: '',
				subrarr: '',
				subset: '',
				Subset: '',
				subseteq: '',
				subseteqq: '',
				SubsetEqual: '',
				subsetneq: '',
				subsetneqq: '',
				subsim: '',
				subsub: '',
				subsup: '',
				succapprox: '',
				succ: '',
				succcurlyeq: '',
				Succeeds: '',
				SucceedsEqual: '',
				SucceedsSlantEqual: '',
				SucceedsTilde: '',
				succeq: '',
				succnapprox: '',
				succneqq: '',
				succnsim: '',
				succsim: '',
				SuchThat: '',
				sum: '',
				Sum: '',
				sung: '',
				sup1: '',
				sup2: '',
				sup3: '',
				sup: '',
				Sup: '',
				supdot: '',
				supdsub: '',
				supE: '',
				supe: '',
				supedot: '',
				Superset: '',
				SupersetEqual: '',
				suphsol: '',
				suphsub: '',
				suplarr: '',
				supmult: '',
				supnE: '',
				supne: '',
				supplus: '',
				supset: '',
				Supset: '',
				supseteq: '',
				supseteqq: '',
				supsetneq: '',
				supsetneqq: '',
				supsim: '',
				supsub: '',
				supsup: '',
				swarhk: '',
				swarr: '',
				swArr: '',
				swarrow: '',
				swnwar: '',
				szlig: '',
				Tab: '	',
				target: '',
				Tau: '',
				tau: '',
				tbrk: '',
				Tcaron: '',
				tcaron: '',
				Tcedil: '',
				tcedil: '',
				Tcy: '',
				tcy: '',
				tdot: '',
				telrec: '',
				Tfr: '',
				tfr: '',
				there4: '',
				therefore: '',
				Therefore: '',
				Theta: '',
				theta: '',
				thetasym: '',
				thetav: '',
				thickapprox: '',
				thicksim: '',
				ThickSpace: '',
				ThinSpace: '',
				thinsp: '',
				thkap: '',
				thksim: '',
				THORN: '',
				thorn: '',
				tilde: '',
				Tilde: '',
				TildeEqual: '',
				TildeFullEqual: '',
				TildeTilde: '',
				timesbar: '',
				timesb: '',
				times: '',
				timesd: '',
				tint: '',
				toea: '',
				topbot: '',
				topcir: '',
				top: '',
				Topf: '',
				topf: '',
				topfork: '',
				tosa: '',
				tprime: '',
				trade: '',
				TRADE: '',
				triangle: '',
				triangledown: '',
				triangleleft: '',
				trianglelefteq: '',
				triangleq: '',
				triangleright: '',
				trianglerighteq: '',
				tridot: '',
				trie: '',
				triminus: '',
				TripleDot: '',
				triplus: '',
				trisb: '',
				tritime: '',
				trpezium: '',
				Tscr: '',
				tscr: '',
				TScy: '',
				tscy: '',
				TSHcy: '',
				tshcy: '',
				Tstrok: '',
				tstrok: '',
				twixt: '',
				twoheadleftarrow: '',
				twoheadrightarrow: '',
				Uacute: '',
				uacute: '',
				uarr: '',
				Uarr: '',
				uArr: '',
				Uarrocir: '',
				Ubrcy: '',
				ubrcy: '',
				Ubreve: '',
				ubreve: '',
				Ucirc: '',
				ucirc: '',
				Ucy: '',
				ucy: '',
				udarr: '',
				Udblac: '',
				udblac: '',
				udhar: '',
				ufisht: '',
				Ufr: '',
				ufr: '',
				Ugrave: '',
				ugrave: '',
				uHar: '',
				uharl: '',
				uharr: '',
				uhblk: '',
				ulcorn: '',
				ulcorner: '',
				ulcrop: '',
				ultri: '',
				Umacr: '',
				umacr: '',
				uml: '',
				UnderBar: '_',
				UnderBrace: '',
				UnderBracket: '',
				UnderParenthesis: '',
				Union: '',
				UnionPlus: '',
				Uogon: '',
				uogon: '',
				Uopf: '',
				uopf: '',
				UpArrowBar: '',
				uparrow: '',
				UpArrow: '',
				Uparrow: '',
				UpArrowDownArrow: '',
				updownarrow: '',
				UpDownArrow: '',
				Updownarrow: '',
				UpEquilibrium: '',
				upharpoonleft: '',
				upharpoonright: '',
				uplus: '',
				UpperLeftArrow: '',
				UpperRightArrow: '',
				upsi: '',
				Upsi: '',
				upsih: '',
				Upsilon: '',
				upsilon: '',
				UpTeeArrow: '',
				UpTee: '',
				upuparrows: '',
				urcorn: '',
				urcorner: '',
				urcrop: '',
				Uring: '',
				uring: '',
				urtri: '',
				Uscr: '',
				uscr: '',
				utdot: '',
				Utilde: '',
				utilde: '',
				utri: '',
				utrif: '',
				uuarr: '',
				Uuml: '',
				uuml: '',
				uwangle: '',
				vangrt: '',
				varepsilon: '',
				varkappa: '',
				varnothing: '',
				varphi: '',
				varpi: '',
				varpropto: '',
				varr: '',
				vArr: '',
				varrho: '',
				varsigma: '',
				varsubsetneq: '',
				varsubsetneqq: '',
				varsupsetneq: '',
				varsupsetneqq: '',
				vartheta: '',
				vartriangleleft: '',
				vartriangleright: '',
				vBar: '',
				Vbar: '',
				vBarv: '',
				Vcy: '',
				vcy: '',
				vdash: '',
				vDash: '',
				Vdash: '',
				VDash: '',
				Vdashl: '',
				veebar: '',
				vee: '',
				Vee: '',
				veeeq: '',
				vellip: '',
				verbar: '|',
				Verbar: '',
				vert: '|',
				Vert: '',
				VerticalBar: '',
				VerticalLine: '|',
				VerticalSeparator: '',
				VerticalTilde: '',
				VeryThinSpace: '',
				Vfr: '',
				vfr: '',
				vltri: '',
				vnsub: '',
				vnsup: '',
				Vopf: '',
				vopf: '',
				vprop: '',
				vrtri: '',
				Vscr: '',
				vscr: '',
				vsubnE: '',
				vsubne: '',
				vsupnE: '',
				vsupne: '',
				Vvdash: '',
				vzigzag: '',
				Wcirc: '',
				wcirc: '',
				wedbar: '',
				wedge: '',
				Wedge: '',
				wedgeq: '',
				weierp: '',
				Wfr: '',
				wfr: '',
				Wopf: '',
				wopf: '',
				wp: '',
				wr: '',
				wreath: '',
				Wscr: '',
				wscr: '',
				xcap: '',
				xcirc: '',
				xcup: '',
				xdtri: '',
				Xfr: '',
				xfr: '',
				xharr: '',
				xhArr: '',
				Xi: '',
				xi: '',
				xlarr: '',
				xlArr: '',
				xmap: '',
				xnis: '',
				xodot: '',
				Xopf: '',
				xopf: '',
				xoplus: '',
				xotime: '',
				xrarr: '',
				xrArr: '',
				Xscr: '',
				xscr: '',
				xsqcup: '',
				xuplus: '',
				xutri: '',
				xvee: '',
				xwedge: '',
				Yacute: '',
				yacute: '',
				YAcy: '',
				yacy: '',
				Ycirc: '',
				ycirc: '',
				Ycy: '',
				ycy: '',
				yen: '',
				Yfr: '',
				yfr: '',
				YIcy: '',
				yicy: '',
				Yopf: '',
				yopf: '',
				Yscr: '',
				yscr: '',
				YUcy: '',
				yucy: '',
				yuml: '',
				Yuml: '',
				Zacute: '',
				zacute: '',
				Zcaron: '',
				zcaron: '',
				Zcy: '',
				zcy: '',
				Zdot: '',
				zdot: '',
				zeetrf: '',
				ZeroWidthSpace: '',
				Zeta: '',
				zeta: '',
				zfr: '',
				Zfr: '',
				ZHcy: '',
				zhcy: '',
				zigrarr: '',
				zopf: '',
				Zopf: '',
				Zscr: '',
				zscr: '',
				zwj: '',
				zwnj: ''
			};
		}
	}),
	VL = J({
		'../node_modules/entities/lib/maps/legacy.json'(e, t) {
			t.exports = {
				Aacute: '',
				aacute: '',
				Acirc: '',
				acirc: '',
				acute: '',
				AElig: '',
				aelig: '',
				Agrave: '',
				agrave: '',
				amp: '&',
				AMP: '&',
				Aring: '',
				aring: '',
				Atilde: '',
				atilde: '',
				Auml: '',
				auml: '',
				brvbar: '',
				Ccedil: '',
				ccedil: '',
				cedil: '',
				cent: '',
				copy: '',
				COPY: '',
				curren: '',
				deg: '',
				divide: '',
				Eacute: '',
				eacute: '',
				Ecirc: '',
				ecirc: '',
				Egrave: '',
				egrave: '',
				ETH: '',
				eth: '',
				Euml: '',
				euml: '',
				frac12: '',
				frac14: '',
				frac34: '',
				gt: '>',
				GT: '>',
				Iacute: '',
				iacute: '',
				Icirc: '',
				icirc: '',
				iexcl: '',
				Igrave: '',
				igrave: '',
				iquest: '',
				Iuml: '',
				iuml: '',
				laquo: '',
				lt: '<',
				LT: '<',
				macr: '',
				micro: '',
				middot: '',
				nbsp: '',
				not: '',
				Ntilde: '',
				ntilde: '',
				Oacute: '',
				oacute: '',
				Ocirc: '',
				ocirc: '',
				Ograve: '',
				ograve: '',
				ordf: '',
				ordm: '',
				Oslash: '',
				oslash: '',
				Otilde: '',
				otilde: '',
				Ouml: '',
				ouml: '',
				para: '',
				plusmn: '',
				pound: '',
				quot: '"',
				QUOT: '"',
				raquo: '',
				reg: '',
				REG: '',
				sect: '',
				shy: '',
				sup1: '',
				sup2: '',
				sup3: '',
				szlig: '',
				THORN: '',
				thorn: '',
				times: '',
				Uacute: '',
				uacute: '',
				Ucirc: '',
				ucirc: '',
				Ugrave: '',
				ugrave: '',
				uml: '',
				Uuml: '',
				uuml: '',
				Yacute: '',
				yacute: '',
				yen: '',
				yuml: ''
			};
		}
	}),
	GE = J({
		'../node_modules/entities/lib/maps/xml.json'(e, t) {
			t.exports = { amp: '&', apos: "'", gt: '>', lt: '<', quot: '"' };
		}
	}),
	HL = J({
		'../node_modules/entities/lib/maps/decode.json'(e, t) {
			t.exports = {
				0: 65533,
				128: 8364,
				130: 8218,
				131: 402,
				132: 8222,
				133: 8230,
				134: 8224,
				135: 8225,
				136: 710,
				137: 8240,
				138: 352,
				139: 8249,
				140: 338,
				142: 381,
				145: 8216,
				146: 8217,
				147: 8220,
				148: 8221,
				149: 8226,
				150: 8211,
				151: 8212,
				152: 732,
				153: 8482,
				154: 353,
				155: 8250,
				156: 339,
				158: 382,
				159: 376
			};
		}
	}),
	GL = J({
		'../node_modules/entities/lib/decode_codepoint.js'(e) {
			var t =
				(e && e.__importDefault) ||
				function (s) {
					return s && s.__esModule ? s : { default: s };
				};
			Object.defineProperty(e, '__esModule', { value: !0 });
			var r = t(HL()),
				n =
					String.fromCodePoint ||
					function (s) {
						var a = '';
						return (
							s > 65535 &&
								((s -= 65536),
								(a += String.fromCharCode(((s >>> 10) & 1023) | 55296)),
								(s = 56320 | (s & 1023))),
							(a += String.fromCharCode(s)),
							a
						);
					};
			function o(s) {
				return (s >= 55296 && s <= 57343) || s > 1114111
					? ''
					: (s in r.default && (s = r.default[s]), n(s));
			}
			(i(o, 'decodeCodePoint'), (e.default = o));
		}
	}),
	bb = J({
		'../node_modules/entities/lib/decode.js'(e) {
			var t =
				(e && e.__importDefault) ||
				function (p) {
					return p && p.__esModule ? p : { default: p };
				};
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.decodeHTML = e.decodeHTMLStrict = e.decodeXML = void 0));
			var r = t(HE()),
				n = t(VL()),
				o = t(GE()),
				s = t(GL()),
				a = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
			((e.decodeXML = u(o.default)), (e.decodeHTMLStrict = u(r.default)));
			function u(p) {
				var f = d(p);
				return function (m) {
					return String(m).replace(a, f);
				};
			}
			i(u, 'getStrictDecoder');
			var c = i(function (p, f) {
				return p < f ? 1 : -1;
			}, 'sorter');
			e.decodeHTML = (function () {
				for (
					var p = Object.keys(n.default).sort(c), f = Object.keys(r.default).sort(c), m = 0, y = 0;
					m < f.length;
					m++
				)
					p[y] === f[m] ? ((f[m] += ';?'), y++) : (f[m] += ';');
				var g = new RegExp('&(?:' + f.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)', 'g'),
					E = d(r.default);
				function T(b) {
					return (b.substr(-1) !== ';' && (b += ';'), E(b));
				}
				return (
					i(T, 'replacer'),
					function (b) {
						return String(b).replace(g, T);
					}
				);
			})();
			function d(p) {
				return i(function (m) {
					if (m.charAt(1) === '#') {
						var y = m.charAt(2);
						return y === 'X' || y === 'x'
							? s.default(parseInt(m.substr(3), 16))
							: s.default(parseInt(m.substr(2), 10));
					}
					return p[m.slice(1, -1)] || m;
				}, 'replace');
			}
			i(d, 'getReplacer');
		}
	}),
	vb = J({
		'../node_modules/entities/lib/encode.js'(e) {
			var t =
				(e && e.__importDefault) ||
				function (w) {
					return w && w.__esModule ? w : { default: w };
				};
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = void 0));
			var r = t(GE()),
				n = c(r.default),
				o = d(n);
			e.encodeXML = b(n);
			var s = t(HE()),
				a = c(s.default),
				u = d(a);
			((e.encodeHTML = y(a, u)), (e.encodeNonAsciiHTML = b(a)));
			function c(w) {
				return Object.keys(w)
					.sort()
					.reduce(function (P, I) {
						return ((P[w[I]] = '&' + I + ';'), P);
					}, {});
			}
			i(c, 'getInverseObj');
			function d(w) {
				for (var P = [], I = [], q = 0, C = Object.keys(w); q < C.length; q++) {
					var R = C[q];
					R.length === 1 ? P.push('\\' + R) : I.push(R);
				}
				P.sort();
				for (var _ = 0; _ < P.length - 1; _++) {
					for (var S = _; S < P.length - 1 && P[S].charCodeAt(1) + 1 === P[S + 1].charCodeAt(1); )
						S += 1;
					var D = 1 + S - _;
					D < 3 || P.splice(_, D, P[_] + '-' + P[S]);
				}
				return (I.unshift('[' + P.join('') + ']'), new RegExp(I.join('|'), 'g'));
			}
			i(d, 'getInverseReplacer');
			var p =
					/(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
				f =
					String.prototype.codePointAt != null
						? function (w) {
								return w.codePointAt(0);
							}
						: function (w) {
								return (w.charCodeAt(0) - 55296) * 1024 + w.charCodeAt(1) - 56320 + 65536;
							};
			function m(w) {
				return '&#x' + (w.length > 1 ? f(w) : w.charCodeAt(0)).toString(16).toUpperCase() + ';';
			}
			i(m, 'singleCharReplacer');
			function y(w, P) {
				return function (I) {
					return I.replace(P, function (q) {
						return w[q];
					}).replace(p, m);
				};
			}
			i(y, 'getInverse');
			var g = new RegExp(o.source + '|' + p.source, 'g');
			function E(w) {
				return w.replace(g, m);
			}
			(i(E, 'escape'), (e.escape = E));
			function T(w) {
				return w.replace(o, m);
			}
			(i(T, 'escapeUTF8'), (e.escapeUTF8 = T));
			function b(w) {
				return function (P) {
					return P.replace(g, function (I) {
						return w[I] || m(I);
					});
				};
			}
			i(b, 'getASCIIEncoder');
		}
	}),
	zL = J({
		'../node_modules/entities/lib/index.js'(e) {
			(Object.defineProperty(e, '__esModule', { value: !0 }),
				(e.decodeXMLStrict =
					e.decodeHTML5Strict =
					e.decodeHTML4Strict =
					e.decodeHTML5 =
					e.decodeHTML4 =
					e.decodeHTMLStrict =
					e.decodeHTML =
					e.decodeXML =
					e.encodeHTML5 =
					e.encodeHTML4 =
					e.escapeUTF8 =
					e.escape =
					e.encodeNonAsciiHTML =
					e.encodeHTML =
					e.encodeXML =
					e.encode =
					e.decodeStrict =
					e.decode =
						void 0));
			var t = bb(),
				r = vb();
			function n(c, d) {
				return (!d || d <= 0 ? t.decodeXML : t.decodeHTML)(c);
			}
			(i(n, 'decode'), (e.decode = n));
			function o(c, d) {
				return (!d || d <= 0 ? t.decodeXML : t.decodeHTMLStrict)(c);
			}
			(i(o, 'decodeStrict'), (e.decodeStrict = o));
			function s(c, d) {
				return (!d || d <= 0 ? r.encodeXML : r.encodeHTML)(c);
			}
			(i(s, 'encode'), (e.encode = s));
			var a = vb();
			(Object.defineProperty(e, 'encodeXML', {
				enumerable: !0,
				get: i(function () {
					return a.encodeXML;
				}, 'get')
			}),
				Object.defineProperty(e, 'encodeHTML', {
					enumerable: !0,
					get: i(function () {
						return a.encodeHTML;
					}, 'get')
				}),
				Object.defineProperty(e, 'encodeNonAsciiHTML', {
					enumerable: !0,
					get: i(function () {
						return a.encodeNonAsciiHTML;
					}, 'get')
				}),
				Object.defineProperty(e, 'escape', {
					enumerable: !0,
					get: i(function () {
						return a.escape;
					}, 'get')
				}),
				Object.defineProperty(e, 'escapeUTF8', {
					enumerable: !0,
					get: i(function () {
						return a.escapeUTF8;
					}, 'get')
				}),
				Object.defineProperty(e, 'encodeHTML4', {
					enumerable: !0,
					get: i(function () {
						return a.encodeHTML;
					}, 'get')
				}),
				Object.defineProperty(e, 'encodeHTML5', {
					enumerable: !0,
					get: i(function () {
						return a.encodeHTML;
					}, 'get')
				}));
			var u = bb();
			(Object.defineProperty(e, 'decodeXML', {
				enumerable: !0,
				get: i(function () {
					return u.decodeXML;
				}, 'get')
			}),
				Object.defineProperty(e, 'decodeHTML', {
					enumerable: !0,
					get: i(function () {
						return u.decodeHTML;
					}, 'get')
				}),
				Object.defineProperty(e, 'decodeHTMLStrict', {
					enumerable: !0,
					get: i(function () {
						return u.decodeHTMLStrict;
					}, 'get')
				}),
				Object.defineProperty(e, 'decodeHTML4', {
					enumerable: !0,
					get: i(function () {
						return u.decodeHTML;
					}, 'get')
				}),
				Object.defineProperty(e, 'decodeHTML5', {
					enumerable: !0,
					get: i(function () {
						return u.decodeHTML;
					}, 'get')
				}),
				Object.defineProperty(e, 'decodeHTML4Strict', {
					enumerable: !0,
					get: i(function () {
						return u.decodeHTMLStrict;
					}, 'get')
				}),
				Object.defineProperty(e, 'decodeHTML5Strict', {
					enumerable: !0,
					get: i(function () {
						return u.decodeHTMLStrict;
					}, 'get')
				}),
				Object.defineProperty(e, 'decodeXMLStrict', {
					enumerable: !0,
					get: i(function () {
						return u.decodeXML;
					}, 'get')
				}));
		}
	}),
	WL = J({
		'../node_modules/ansi-to-html/lib/ansi_to_html.js'(e, t) {
			function r(A, L) {
				if (!(A instanceof L)) throw new TypeError('Cannot call a class as a function');
			}
			i(r, '_classCallCheck');
			function n(A, L) {
				for (var B = 0; B < L.length; B++) {
					var k = L[B];
					((k.enumerable = k.enumerable || !1),
						(k.configurable = !0),
						'value' in k && (k.writable = !0),
						Object.defineProperty(A, k.key, k));
				}
			}
			i(n, '_defineProperties');
			function o(A, L, B) {
				return (L && n(A.prototype, L), B && n(A, B), A);
			}
			i(o, '_createClass');
			function s(A, L) {
				var B = (typeof Symbol < 'u' && A[Symbol.iterator]) || A['@@iterator'];
				if (!B) {
					if (Array.isArray(A) || (B = a(A)) || (L && A && typeof A.length == 'number')) {
						B && (A = B);
						var k = 0,
							K = i(function () {}, 'F');
						return {
							s: K,
							n: i(function () {
								return k >= A.length ? { done: !0 } : { done: !1, value: A[k++] };
							}, 'n'),
							e: i(function (le) {
								throw le;
							}, 'e'),
							f: K
						};
					}
					throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
				}
				var X = !0,
					ie = !1,
					ae;
				return {
					s: i(function () {
						B = B.call(A);
					}, 's'),
					n: i(function () {
						var le = B.next();
						return ((X = le.done), le);
					}, 'n'),
					e: i(function (le) {
						((ie = !0), (ae = le));
					}, 'e'),
					f: i(function () {
						try {
							!X && B.return != null && B.return();
						} finally {
							if (ie) throw ae;
						}
					}, 'f')
				};
			}
			i(s, '_createForOfIteratorHelper');
			function a(A, L) {
				if (A) {
					if (typeof A == 'string') return u(A, L);
					var B = Object.prototype.toString.call(A).slice(8, -1);
					if (
						(B === 'Object' && A.constructor && (B = A.constructor.name),
						B === 'Map' || B === 'Set')
					)
						return Array.from(A);
					if (B === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(B))
						return u(A, L);
				}
			}
			i(a, '_unsupportedIterableToArray');
			function u(A, L) {
				(L == null || L > A.length) && (L = A.length);
				for (var B = 0, k = new Array(L); B < L; B++) k[B] = A[B];
				return k;
			}
			i(u, '_arrayLikeToArray');
			var c = zL(),
				d = { fg: '#FFF', bg: '#000', newline: !1, escapeXML: !1, stream: !1, colors: p() };
			function p() {
				var A = {
					0: '#000',
					1: '#A00',
					2: '#0A0',
					3: '#A50',
					4: '#00A',
					5: '#A0A',
					6: '#0AA',
					7: '#AAA',
					8: '#555',
					9: '#F55',
					10: '#5F5',
					11: '#FF5',
					12: '#55F',
					13: '#F5F',
					14: '#5FF',
					15: '#FFF'
				};
				return (
					w(0, 5).forEach(function (L) {
						w(0, 5).forEach(function (B) {
							w(0, 5).forEach(function (k) {
								return f(L, B, k, A);
							});
						});
					}),
					w(0, 23).forEach(function (L) {
						var B = L + 232,
							k = m(L * 10 + 8);
						A[B] = '#' + k + k + k;
					}),
					A
				);
			}
			i(p, 'getDefaultColors');
			function f(A, L, B, k) {
				var K = 16 + A * 36 + L * 6 + B,
					X = A > 0 ? A * 40 + 55 : 0,
					ie = L > 0 ? L * 40 + 55 : 0,
					ae = B > 0 ? B * 40 + 55 : 0;
				k[K] = y([X, ie, ae]);
			}
			i(f, 'setStyleColor');
			function m(A) {
				for (var L = A.toString(16); L.length < 2; ) L = '0' + L;
				return L;
			}
			i(m, 'toHexString');
			function y(A) {
				var L = [],
					B = s(A),
					k;
				try {
					for (B.s(); !(k = B.n()).done; ) {
						var K = k.value;
						L.push(m(K));
					}
				} catch (X) {
					B.e(X);
				} finally {
					B.f();
				}
				return '#' + L.join('');
			}
			i(y, 'toColorHexString');
			function g(A, L, B, k) {
				var K;
				return (
					L === 'text'
						? (K = q(B, k))
						: L === 'display'
							? (K = T(A, B, k))
							: L === 'xterm256Foreground'
								? (K = _(A, k.colors[B]))
								: L === 'xterm256Background'
									? (K = S(A, k.colors[B]))
									: L === 'rgb' && (K = E(A, B)),
					K
				);
			}
			i(g, 'generateOutput');
			function E(A, L) {
				L = L.substring(2).slice(0, -1);
				var B = +L.substr(0, 2),
					k = L.substring(5).split(';'),
					K = k
						.map(function (X) {
							return ('0' + Number(X).toString(16)).substr(-2);
						})
						.join('');
				return R(A, (B === 38 ? 'color:#' : 'background-color:#') + K);
			}
			i(E, 'handleRgb');
			function T(A, L, B) {
				L = parseInt(L, 10);
				var k = {
						'-1': i(function () {
							return '<br/>';
						}, '_'),
						0: i(function () {
							return A.length && b(A);
						}, '_'),
						1: i(function () {
							return C(A, 'b');
						}, '_'),
						3: i(function () {
							return C(A, 'i');
						}, '_'),
						4: i(function () {
							return C(A, 'u');
						}, '_'),
						8: i(function () {
							return R(A, 'display:none');
						}, '_'),
						9: i(function () {
							return C(A, 'strike');
						}, '_'),
						22: i(function () {
							return R(A, 'font-weight:normal;text-decoration:none;font-style:normal');
						}, '_'),
						23: i(function () {
							return D(A, 'i');
						}, '_'),
						24: i(function () {
							return D(A, 'u');
						}, '_'),
						39: i(function () {
							return _(A, B.fg);
						}, '_'),
						49: i(function () {
							return S(A, B.bg);
						}, '_'),
						53: i(function () {
							return R(A, 'text-decoration:overline');
						}, '_')
					},
					K;
				return (
					k[L]
						? (K = k[L]())
						: 4 < L && L < 7
							? (K = C(A, 'blink'))
							: 29 < L && L < 38
								? (K = _(A, B.colors[L - 30]))
								: 39 < L && L < 48
									? (K = S(A, B.colors[L - 40]))
									: 89 < L && L < 98
										? (K = _(A, B.colors[8 + (L - 90)]))
										: 99 < L && L < 108 && (K = S(A, B.colors[8 + (L - 100)])),
					K
				);
			}
			i(T, 'handleDisplay');
			function b(A) {
				var L = A.slice(0);
				return (
					(A.length = 0),
					L.reverse()
						.map(function (B) {
							return '</' + B + '>';
						})
						.join('')
				);
			}
			i(b, 'resetStyles');
			function w(A, L) {
				for (var B = [], k = A; k <= L; k++) B.push(k);
				return B;
			}
			i(w, 'range');
			function P(A) {
				return function (L) {
					return (A === null || L.category !== A) && A !== 'all';
				};
			}
			i(P, 'notCategory');
			function I(A) {
				A = parseInt(A, 10);
				var L = null;
				return (
					A === 0
						? (L = 'all')
						: A === 1
							? (L = 'bold')
							: 2 < A && A < 5
								? (L = 'underline')
								: 4 < A && A < 7
									? (L = 'blink')
									: A === 8
										? (L = 'hide')
										: A === 9
											? (L = 'strike')
											: (29 < A && A < 38) || A === 39 || (89 < A && A < 98)
												? (L = 'foreground-color')
												: ((39 < A && A < 48) || A === 49 || (99 < A && A < 108)) &&
													(L = 'background-color'),
					L
				);
			}
			i(I, 'categoryForCode');
			function q(A, L) {
				return L.escapeXML ? c.encodeXML(A) : A;
			}
			i(q, 'pushText');
			function C(A, L, B) {
				return (
					B || (B = ''),
					A.push(L),
					'<'.concat(L).concat(B ? ' style="'.concat(B, '"') : '', '>')
				);
			}
			i(C, 'pushTag');
			function R(A, L) {
				return C(A, 'span', L);
			}
			i(R, 'pushStyle');
			function _(A, L) {
				return C(A, 'span', 'color:' + L);
			}
			i(_, 'pushForegroundColor');
			function S(A, L) {
				return C(A, 'span', 'background-color:' + L);
			}
			i(S, 'pushBackgroundColor');
			function D(A, L) {
				var B;
				if ((A.slice(-1)[0] === L && (B = A.pop()), B)) return '</' + L + '>';
			}
			i(D, 'closeTag');
			function N(A, L, B) {
				var k = !1,
					K = 3;
				function X() {
					return '';
				}
				i(X, 'remove');
				function ie(ne, pe) {
					return (B('xterm256Foreground', pe), '');
				}
				i(ie, 'removeXterm256Foreground');
				function ae(ne, pe) {
					return (B('xterm256Background', pe), '');
				}
				i(ae, 'removeXterm256Background');
				function W(ne) {
					return (L.newline ? B('display', -1) : B('text', ne), '');
				}
				i(W, 'newline');
				function le(ne, pe) {
					((k = !0), pe.trim().length === 0 && (pe = '0'), (pe = pe.trimRight(';').split(';')));
					var ye = s(pe),
						fe;
					try {
						for (ye.s(); !(fe = ye.n()).done; ) {
							var ze = fe.value;
							B('display', ze);
						}
					} catch (pt) {
						ye.e(pt);
					} finally {
						ye.f();
					}
					return '';
				}
				i(le, 'ansiMess');
				function ve(ne) {
					return (B('text', ne), '');
				}
				i(ve, 'realText');
				function de(ne) {
					return (B('rgb', ne), '');
				}
				i(de, 'rgb');
				var ee = [
					{ pattern: /^\x08+/, sub: X },
					{ pattern: /^\x1b\[[012]?K/, sub: X },
					{ pattern: /^\x1b\[\(B/, sub: X },
					{ pattern: /^\x1b\[[34]8;2;\d+;\d+;\d+m/, sub: de },
					{ pattern: /^\x1b\[38;5;(\d+)m/, sub: ie },
					{ pattern: /^\x1b\[48;5;(\d+)m/, sub: ae },
					{ pattern: /^\n/, sub: W },
					{ pattern: /^\r+\n/, sub: W },
					{ pattern: /^\r/, sub: W },
					{ pattern: /^\x1b\[((?:\d{1,3};?)+|)m/, sub: le },
					{ pattern: /^\x1b\[\d?J/, sub: X },
					{ pattern: /^\x1b\[\d{0,3};\d{0,3}f/, sub: X },
					{ pattern: /^\x1b\[?[\d;]{0,3}/, sub: X },
					{ pattern: /^(([^\x1b\x08\r\n])+)/, sub: ve }
				];
				function xe(ne, pe) {
					(pe > K && k) || ((k = !1), (A = A.replace(ne.pattern, ne.sub)));
				}
				i(xe, 'process');
				var Ie = [],
					Xe = A,
					rt = Xe.length;
				e: for (; rt > 0; ) {
					for (var $ = 0, Q = 0, re = ee.length; Q < re; $ = ++Q) {
						var oe = ee[$];
						if ((xe(oe, $), A.length !== rt)) {
							rt = A.length;
							continue e;
						}
					}
					if (A.length === rt) break;
					(Ie.push(0), (rt = A.length));
				}
				return Ie;
			}
			i(N, 'tokenize');
			function V(A, L, B) {
				return (
					L !== 'text' && ((A = A.filter(P(I(B)))), A.push({ token: L, data: B, category: I(B) })),
					A
				);
			}
			i(V, 'updateStickyStack');
			var H = (function () {
				function A(L) {
					(r(this, A),
						(L = L || {}),
						L.colors && (L.colors = Object.assign({}, d.colors, L.colors)),
						(this.options = Object.assign({}, d, L)),
						(this.stack = []),
						(this.stickyStack = []));
				}
				return (
					i(A, 'Filter'),
					o(A, [
						{
							key: 'toHtml',
							value: i(function (B) {
								var k = this;
								B = typeof B == 'string' ? [B] : B;
								var K = this.stack,
									X = this.options,
									ie = [];
								return (
									this.stickyStack.forEach(function (ae) {
										var W = g(K, ae.token, ae.data, X);
										W && ie.push(W);
									}),
									N(B.join(''), X, function (ae, W) {
										var le = g(K, ae, W, X);
										(le && ie.push(le), X.stream && (k.stickyStack = V(k.stickyStack, ae, W)));
									}),
									K.length && ie.push(b(K)),
									ie.join('')
								);
							}, 'toHtml')
						}
					]),
					A
				);
			})();
			t.exports = H;
		}
	}),
	KL = J({
		'../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
			(function (r, n) {
				typeof e == 'object' && typeof t < 'u'
					? n(e)
					: typeof define == 'function' && define.amd
						? define(['exports'], n)
						: ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
			})(e, function (r) {
				function n(l) {
					return l.text !== void 0 && l.text !== ''
						? `'${l.type}' with value '${l.text}'`
						: `'${l.type}'`;
				}
				i(n, 'tokenToString');
				const o = class zE extends Error {
					constructor(h) {
						(super(`No parslet found for token: ${n(h)}`),
							(this.token = h),
							Object.setPrototypeOf(this, zE.prototype));
					}
					getToken() {
						return this.token;
					}
				};
				i(o, 'NoParsletFoundError');
				let s = o;
				const a = class WE extends Error {
					constructor(h) {
						(super(`The parsing ended early. The next token was: ${n(h)}`),
							(this.token = h),
							Object.setPrototypeOf(this, WE.prototype));
					}
					getToken() {
						return this.token;
					}
				};
				i(a, 'EarlyEndOfParseError');
				let u = a;
				const c = class KE extends Error {
					constructor(h, v) {
						let x = `Unexpected type: '${h.type}'.`;
						(v !== void 0 && (x += ` Message: ${v}`),
							super(x),
							Object.setPrototypeOf(this, KE.prototype));
					}
				};
				i(c, 'UnexpectedTypeError');
				let d = c;
				function p(l) {
					return (h) => (h.startsWith(l) ? { type: l, text: l } : null);
				}
				i(p, 'makePunctuationRule');
				function f(l) {
					let h = 0,
						v;
					const x = l[0];
					let F = !1;
					if (x !== "'" && x !== '"') return null;
					for (; h < l.length; ) {
						if ((h++, (v = l[h]), !F && v === x)) {
							h++;
							break;
						}
						F = !F && v === '\\';
					}
					if (v !== x) throw new Error('Unterminated String');
					return l.slice(0, h);
				}
				i(f, 'getQuoted');
				const m = new RegExp(
						'[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
						'u'
					),
					y = new RegExp(
						'[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
						'u'
					);
				function g(l) {
					let h = l[0];
					if (!m.test(h)) return null;
					let v = 1;
					do {
						if (((h = l[v]), !y.test(h))) break;
						v++;
					} while (v < l.length);
					return l.slice(0, v);
				}
				i(g, 'getIdentifier');
				const E = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
				function T(l) {
					var h, v;
					return (v = (h = E.exec(l)) === null || h === void 0 ? void 0 : h[0]) !== null &&
						v !== void 0
						? v
						: null;
				}
				i(T, 'getNumber');
				const b = i((l) => {
					const h = g(l);
					return h == null ? null : { type: 'Identifier', text: h };
				}, 'identifierRule');
				function w(l) {
					return (h) => {
						if (!h.startsWith(l)) return null;
						const v = h[l.length];
						return v !== void 0 && y.test(v) ? null : { type: l, text: l };
					};
				}
				i(w, 'makeKeyWordRule');
				const P = i((l) => {
						const h = f(l);
						return h == null ? null : { type: 'StringValue', text: h };
					}, 'stringValueRule'),
					I = i((l) => (l.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
					q = i((l) => {
						const h = T(l);
						return h === null ? null : { type: 'Number', text: h };
					}, 'numberRule'),
					C = [
						I,
						p('=>'),
						p('('),
						p(')'),
						p('{'),
						p('}'),
						p('['),
						p(']'),
						p('|'),
						p('&'),
						p('<'),
						p('>'),
						p(','),
						p(';'),
						p('*'),
						p('?'),
						p('!'),
						p('='),
						p(':'),
						p('...'),
						p('.'),
						p('#'),
						p('~'),
						p('/'),
						p('@'),
						w('undefined'),
						w('null'),
						w('function'),
						w('this'),
						w('new'),
						w('module'),
						w('event'),
						w('extends'),
						w('external'),
						w('infer'),
						w('typeof'),
						w('keyof'),
						w('readonly'),
						w('import'),
						w('is'),
						w('in'),
						w('asserts'),
						q,
						b,
						P
					],
					R = /^\s*\n\s*/,
					_ = class Ka {
						static create(h) {
							const v = this.read(h);
							h = v.text;
							const x = this.read(h);
							return ((h = x.text), new Ka(h, void 0, v.token, x.token));
						}
						constructor(h, v, x, F) {
							((this.text = ''),
								(this.text = h),
								(this.previous = v),
								(this.current = x),
								(this.next = F));
						}
						static read(h, v = !1) {
							((v = v || R.test(h)), (h = h.trim()));
							for (const x of C) {
								const F = x(h);
								if (F !== null) {
									const z = Object.assign(Object.assign({}, F), { startOfLine: v });
									return ((h = h.slice(z.text.length)), { text: h, token: z });
								}
							}
							throw new Error('Unexpected Token ' + h);
						}
						advance() {
							const h = Ka.read(this.text);
							return new Ka(h.text, this.current, this.next, h.token);
						}
					};
				i(_, 'Lexer');
				let S = _;
				function D(l) {
					if (l === void 0) throw new Error('Unexpected undefined');
					if (
						l.type === 'JsdocTypeKeyValue' ||
						l.type === 'JsdocTypeParameterList' ||
						l.type === 'JsdocTypeProperty' ||
						l.type === 'JsdocTypeReadonlyProperty' ||
						l.type === 'JsdocTypeObjectField' ||
						l.type === 'JsdocTypeJsdocObjectField' ||
						l.type === 'JsdocTypeIndexSignature' ||
						l.type === 'JsdocTypeMappedType' ||
						l.type === 'JsdocTypeTypeParameter'
					)
						throw new d(l);
					return l;
				}
				i(D, 'assertRootResult');
				function N(l) {
					return l.type === 'JsdocTypeKeyValue' ? H(l) : D(l);
				}
				i(N, 'assertPlainKeyValueOrRootResult');
				function V(l) {
					return l.type === 'JsdocTypeName' ? l : H(l);
				}
				i(V, 'assertPlainKeyValueOrNameResult');
				function H(l) {
					if (l.type !== 'JsdocTypeKeyValue') throw new d(l);
					return l;
				}
				i(H, 'assertPlainKeyValueResult');
				function A(l) {
					var h;
					if (l.type === 'JsdocTypeVariadic') {
						if (((h = l.element) === null || h === void 0 ? void 0 : h.type) === 'JsdocTypeName')
							return l;
						throw new d(l);
					}
					if (l.type !== 'JsdocTypeNumber' && l.type !== 'JsdocTypeName') throw new d(l);
					return l;
				}
				i(A, 'assertNumberOrVariadicNameResult');
				function L(l) {
					if (
						l.type === 'JsdocTypeTuple' ||
						(l.type === 'JsdocTypeGeneric' && l.meta.brackets === 'square')
					)
						return l;
					throw new d(l);
				}
				i(L, 'assertArrayOrTupleResult');
				function B(l) {
					return l.type === 'JsdocTypeIndexSignature' || l.type === 'JsdocTypeMappedType';
				}
				i(B, 'isSquaredProperty');
				var k;
				(function (l) {
					((l[(l.ALL = 0)] = 'ALL'),
						(l[(l.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
						(l[(l.OBJECT = 2)] = 'OBJECT'),
						(l[(l.KEY_VALUE = 3)] = 'KEY_VALUE'),
						(l[(l.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
						(l[(l.UNION = 5)] = 'UNION'),
						(l[(l.INTERSECTION = 6)] = 'INTERSECTION'),
						(l[(l.PREFIX = 7)] = 'PREFIX'),
						(l[(l.INFIX = 8)] = 'INFIX'),
						(l[(l.TUPLE = 9)] = 'TUPLE'),
						(l[(l.SYMBOL = 10)] = 'SYMBOL'),
						(l[(l.OPTIONAL = 11)] = 'OPTIONAL'),
						(l[(l.NULLABLE = 12)] = 'NULLABLE'),
						(l[(l.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
						(l[(l.FUNCTION = 14)] = 'FUNCTION'),
						(l[(l.ARROW = 15)] = 'ARROW'),
						(l[(l.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
						(l[(l.GENERIC = 17)] = 'GENERIC'),
						(l[(l.NAME_PATH = 18)] = 'NAME_PATH'),
						(l[(l.PARENTHESIS = 19)] = 'PARENTHESIS'),
						(l[(l.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
				})(k || (k = {}));
				const K = class {
					constructor(h, v, x) {
						((this.grammar = h),
							typeof v == 'string' ? (this._lexer = S.create(v)) : (this._lexer = v),
							(this.baseParser = x));
					}
					get lexer() {
						return this._lexer;
					}
					parse() {
						const h = this.parseType(k.ALL);
						if (this.lexer.current.type !== 'EOF') throw new u(this.lexer.current);
						return h;
					}
					parseType(h) {
						return D(this.parseIntermediateType(h));
					}
					parseIntermediateType(h) {
						const v = this.tryParslets(null, h);
						if (v === null) throw new s(this.lexer.current);
						return this.parseInfixIntermediateType(v, h);
					}
					parseInfixIntermediateType(h, v) {
						let x = this.tryParslets(h, v);
						for (; x !== null; ) ((h = x), (x = this.tryParslets(h, v)));
						return h;
					}
					tryParslets(h, v) {
						for (const x of this.grammar) {
							const F = x(this, v, h);
							if (F !== null) return F;
						}
						return null;
					}
					consume(h) {
						return (
							Array.isArray(h) || (h = [h]),
							h.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
						);
					}
					acceptLexerState(h) {
						this._lexer = h.lexer;
					}
				};
				i(K, 'Parser');
				let X = K;
				function ie(l) {
					return l === '}' || l === 'EOF' || l === '|' || l === ',' || l === ')' || l === '>';
				}
				i(ie, 'isQuestionMarkUnknownType');
				const ae = i((l, h, v) => {
					const x = l.lexer.current.type,
						F = l.lexer.next.type;
					return (v == null && x === '?' && !ie(F)) || (v != null && x === '?')
						? (l.consume('?'),
							v == null
								? {
										type: 'JsdocTypeNullable',
										element: l.parseType(k.NULLABLE),
										meta: { position: 'prefix' }
									}
								: { type: 'JsdocTypeNullable', element: D(v), meta: { position: 'suffix' } })
						: null;
				}, 'nullableParslet');
				function W(l) {
					const h = i((v, x, F) => {
						const z = v.lexer.current.type,
							Z = v.lexer.next.type;
						if (F === null) {
							if ('parsePrefix' in l && l.accept(z, Z)) return l.parsePrefix(v);
						} else if ('parseInfix' in l && l.precedence > x && l.accept(z, Z))
							return l.parseInfix(v, F);
						return null;
					}, 'parslet');
					return (Object.defineProperty(h, 'name', { value: l.name }), h);
				}
				i(W, 'composeParslet');
				const le = W({
						name: 'optionalParslet',
						accept: i((l) => l === '=', 'accept'),
						precedence: k.OPTIONAL,
						parsePrefix: i(
							(l) => (
								l.consume('='),
								{
									type: 'JsdocTypeOptional',
									element: l.parseType(k.OPTIONAL),
									meta: { position: 'prefix' }
								}
							),
							'parsePrefix'
						),
						parseInfix: i(
							(l, h) => (
								l.consume('='),
								{ type: 'JsdocTypeOptional', element: D(h), meta: { position: 'suffix' } }
							),
							'parseInfix'
						)
					}),
					ve = W({
						name: 'numberParslet',
						accept: i((l) => l === 'Number', 'accept'),
						parsePrefix: i((l) => {
							const h = parseFloat(l.lexer.current.text);
							return (l.consume('Number'), { type: 'JsdocTypeNumber', value: h });
						}, 'parsePrefix')
					}),
					de = W({
						name: 'parenthesisParslet',
						accept: i((l) => l === '(', 'accept'),
						parsePrefix: i((l) => {
							if ((l.consume('('), l.consume(')')))
								return { type: 'JsdocTypeParameterList', elements: [] };
							const h = l.parseIntermediateType(k.ALL);
							if (!l.consume(')')) throw new Error('Unterminated parenthesis');
							return h.type === 'JsdocTypeParameterList'
								? h
								: h.type === 'JsdocTypeKeyValue'
									? { type: 'JsdocTypeParameterList', elements: [h] }
									: { type: 'JsdocTypeParenthesis', element: D(h) };
						}, 'parsePrefix')
					}),
					ee = W({
						name: 'specialTypesParslet',
						accept: i(
							(l, h) => (l === '?' && ie(h)) || l === 'null' || l === 'undefined' || l === '*',
							'accept'
						),
						parsePrefix: i((l) => {
							if (l.consume('null')) return { type: 'JsdocTypeNull' };
							if (l.consume('undefined')) return { type: 'JsdocTypeUndefined' };
							if (l.consume('*')) return { type: 'JsdocTypeAny' };
							if (l.consume('?')) return { type: 'JsdocTypeUnknown' };
							throw new Error('Unacceptable token: ' + l.lexer.current.text);
						}, 'parsePrefix')
					}),
					xe = W({
						name: 'notNullableParslet',
						accept: i((l) => l === '!', 'accept'),
						precedence: k.NULLABLE,
						parsePrefix: i(
							(l) => (
								l.consume('!'),
								{
									type: 'JsdocTypeNotNullable',
									element: l.parseType(k.NULLABLE),
									meta: { position: 'prefix' }
								}
							),
							'parsePrefix'
						),
						parseInfix: i(
							(l, h) => (
								l.consume('!'),
								{ type: 'JsdocTypeNotNullable', element: D(h), meta: { position: 'suffix' } }
							),
							'parseInfix'
						)
					});
				function Ie({ allowTrailingComma: l }) {
					return W({
						name: 'parameterListParslet',
						accept: i((h) => h === ',', 'accept'),
						precedence: k.PARAMETER_LIST,
						parseInfix: i((h, v) => {
							const x = [N(v)];
							h.consume(',');
							do
								try {
									const F = h.parseIntermediateType(k.PARAMETER_LIST);
									x.push(N(F));
								} catch (F) {
									if (F instanceof s) break;
									throw F;
								}
							while (h.consume(','));
							if (x.length > 0 && x.slice(0, -1).some((F) => F.type === 'JsdocTypeVariadic'))
								throw new Error('Only the last parameter may be a rest parameter');
							return { type: 'JsdocTypeParameterList', elements: x };
						}, 'parseInfix')
					});
				}
				i(Ie, 'createParameterListParslet');
				const Xe = W({
						name: 'genericParslet',
						accept: i((l, h) => l === '<' || (l === '.' && h === '<'), 'accept'),
						precedence: k.GENERIC,
						parseInfix: i((l, h) => {
							const v = l.consume('.');
							l.consume('<');
							const x = [];
							let F = !1;
							if (l.consume('infer')) {
								F = !0;
								const z = l.parseIntermediateType(k.SYMBOL);
								if (z.type !== 'JsdocTypeName')
									throw new d(
										z,
										'A typescript asserts always has to have a name on the left side.'
									);
								x.push(z);
							} else
								do x.push(l.parseType(k.PARAMETER_LIST));
								while (l.consume(','));
							if (!l.consume('>')) throw new Error('Unterminated generic parameter list');
							return Object.assign(
								Object.assign(
									{ type: 'JsdocTypeGeneric', left: D(h), elements: x },
									F ? { infer: !0 } : {}
								),
								{ meta: { brackets: 'angle', dot: v } }
							);
						}, 'parseInfix')
					}),
					rt = W({
						name: 'unionParslet',
						accept: i((l) => l === '|', 'accept'),
						precedence: k.UNION,
						parseInfix: i((l, h) => {
							l.consume('|');
							const v = [];
							do v.push(l.parseType(k.UNION));
							while (l.consume('|'));
							return { type: 'JsdocTypeUnion', elements: [D(h), ...v] };
						}, 'parseInfix')
					}),
					$ = [ae, le, ve, de, ee, xe, Ie({ allowTrailingComma: !0 }), Xe, rt, le];
				function Q({ allowSquareBracketsOnAnyType: l, allowJsdocNamePaths: h, pathGrammar: v }) {
					return i(function (F, z, Z) {
						if (Z == null || z >= k.NAME_PATH) return null;
						const ce = F.lexer.current.type,
							Re = F.lexer.next.type;
						if (
							!(
								(ce === '.' && Re !== '<') ||
								(ce === '[' && (l || Z.type === 'JsdocTypeName')) ||
								(h && (ce === '~' || ce === '#'))
							)
						)
							return null;
						let ke,
							Br = !1;
						F.consume('.')
							? (ke = 'property')
							: F.consume('[')
								? ((ke = 'property-brackets'), (Br = !0))
								: F.consume('~')
									? (ke = 'inner')
									: (F.consume('#'), (ke = 'instance'));
						const us = v !== null ? new X(v, F.lexer, F) : F,
							it = us.parseIntermediateType(k.NAME_PATH);
						F.acceptLexerState(us);
						let ur;
						switch (it.type) {
							case 'JsdocTypeName':
								ur = { type: 'JsdocTypeProperty', value: it.value, meta: { quote: void 0 } };
								break;
							case 'JsdocTypeNumber':
								ur = {
									type: 'JsdocTypeProperty',
									value: it.value.toString(10),
									meta: { quote: void 0 }
								};
								break;
							case 'JsdocTypeStringValue':
								ur = { type: 'JsdocTypeProperty', value: it.value, meta: { quote: it.meta.quote } };
								break;
							case 'JsdocTypeSpecialNamePath':
								if (it.specialType === 'event') ur = it;
								else
									throw new d(
										it,
										"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'"
									);
								break;
							default:
								throw new d(
									it,
									"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'"
								);
						}
						if (Br && !F.consume(']')) {
							const cs = F.lexer.current;
							throw new Error(
								`Unterminated square brackets. Next token is '${cs.type}' with text '${cs.text}'`
							);
						}
						return { type: 'JsdocTypeNamePath', left: D(Z), right: ur, pathType: ke };
					}, 'namePathParslet');
				}
				i(Q, 'createNamePathParslet');
				function re({ allowedAdditionalTokens: l }) {
					return W({
						name: 'nameParslet',
						accept: i(
							(h) => h === 'Identifier' || h === 'this' || h === 'new' || l.includes(h),
							'accept'
						),
						parsePrefix: i((h) => {
							const { type: v, text: x } = h.lexer.current;
							return (h.consume(v), { type: 'JsdocTypeName', value: x });
						}, 'parsePrefix')
					});
				}
				i(re, 'createNameParslet');
				const oe = W({
					name: 'stringValueParslet',
					accept: i((l) => l === 'StringValue', 'accept'),
					parsePrefix: i((l) => {
						const h = l.lexer.current.text;
						return (
							l.consume('StringValue'),
							{
								type: 'JsdocTypeStringValue',
								value: h.slice(1, -1),
								meta: { quote: h[0] === "'" ? 'single' : 'double' }
							}
						);
					}, 'parsePrefix')
				});
				function ne({ pathGrammar: l, allowedTypes: h }) {
					return W({
						name: 'specialNamePathParslet',
						accept: i((v) => h.includes(v), 'accept'),
						parsePrefix: i((v) => {
							const x = v.lexer.current.type;
							if ((v.consume(x), !v.consume(':'))) return { type: 'JsdocTypeName', value: x };
							let F,
								z = v.lexer.current;
							if (v.consume('StringValue'))
								F = {
									type: 'JsdocTypeSpecialNamePath',
									value: z.text.slice(1, -1),
									specialType: x,
									meta: { quote: z.text[0] === "'" ? 'single' : 'double' }
								};
							else {
								let Re = '';
								const Te = ['Identifier', '@', '/'];
								for (; Te.some((ke) => v.consume(ke)); ) ((Re += z.text), (z = v.lexer.current));
								F = {
									type: 'JsdocTypeSpecialNamePath',
									value: Re,
									specialType: x,
									meta: { quote: void 0 }
								};
							}
							const Z = new X(l, v.lexer, v),
								ce = Z.parseInfixIntermediateType(F, k.ALL);
							return (v.acceptLexerState(Z), D(ce));
						}, 'parsePrefix')
					});
				}
				i(ne, 'createSpecialNamePathParslet');
				const pe = [
						re({ allowedAdditionalTokens: ['external', 'module'] }),
						oe,
						ve,
						Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null })
					],
					ye = [...pe, ne({ allowedTypes: ['event'], pathGrammar: pe })];
				function fe(l) {
					let h;
					if (l.type === 'JsdocTypeParameterList') h = l.elements;
					else if (l.type === 'JsdocTypeParenthesis') h = [l.element];
					else throw new d(l);
					return h.map((v) => N(v));
				}
				i(fe, 'getParameters');
				function ze(l) {
					const h = fe(l);
					if (h.some((v) => v.type === 'JsdocTypeKeyValue'))
						throw new Error('No parameter should be named');
					return h;
				}
				i(ze, 'getUnnamedParameters');
				function pt({
					allowNamedParameters: l,
					allowNoReturnType: h,
					allowWithoutParenthesis: v,
					allowNewAsFunctionKeyword: x
				}) {
					return W({
						name: 'functionParslet',
						accept: i((F, z) => F === 'function' || (x && F === 'new' && z === '('), 'accept'),
						parsePrefix: i((F) => {
							const z = F.consume('new');
							F.consume('function');
							const Z = F.lexer.current.type === '(';
							if (!Z) {
								if (!v) throw new Error('function is missing parameter list');
								return { type: 'JsdocTypeName', value: 'function' };
							}
							let ce = {
								type: 'JsdocTypeFunction',
								parameters: [],
								arrow: !1,
								constructor: z,
								parenthesis: Z
							};
							const Re = F.parseIntermediateType(k.FUNCTION);
							if (l === void 0) ce.parameters = ze(Re);
							else {
								if (z && Re.type === 'JsdocTypeFunction' && Re.arrow)
									return ((ce = Re), (ce.constructor = !0), ce);
								ce.parameters = fe(Re);
								for (const Te of ce.parameters)
									if (Te.type === 'JsdocTypeKeyValue' && !l.includes(Te.key))
										throw new Error(
											`only allowed named parameters are ${l.join(', ')} but got ${Te.type}`
										);
							}
							if (F.consume(':')) ce.returnType = F.parseType(k.PREFIX);
							else if (!h) throw new Error('function is missing return type');
							return ce;
						}, 'parsePrefix')
					});
				}
				i(pt, 'createFunctionParslet');
				function vt({ allowPostfix: l, allowEnclosingBrackets: h }) {
					return W({
						name: 'variadicParslet',
						accept: i((v) => v === '...', 'accept'),
						precedence: k.PREFIX,
						parsePrefix: i((v) => {
							v.consume('...');
							const x = h && v.consume('[');
							try {
								const F = v.parseType(k.PREFIX);
								if (x && !v.consume(']'))
									throw new Error("Unterminated variadic type. Missing ']'");
								return {
									type: 'JsdocTypeVariadic',
									element: D(F),
									meta: { position: 'prefix', squareBrackets: x }
								};
							} catch (F) {
								if (F instanceof s) {
									if (x) throw new Error('Empty square brackets for variadic are not allowed.');
									return {
										type: 'JsdocTypeVariadic',
										meta: { position: void 0, squareBrackets: !1 }
									};
								} else throw F;
							}
						}, 'parsePrefix'),
						parseInfix: l
							? (v, x) => (
									v.consume('...'),
									{
										type: 'JsdocTypeVariadic',
										element: D(x),
										meta: { position: 'suffix', squareBrackets: !1 }
									}
								)
							: void 0
					});
				}
				i(vt, 'createVariadicParslet');
				const Ft = W({
						name: 'symbolParslet',
						accept: i((l) => l === '(', 'accept'),
						precedence: k.SYMBOL,
						parseInfix: i((l, h) => {
							if (h.type !== 'JsdocTypeName')
								throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
							l.consume('(');
							const v = { type: 'JsdocTypeSymbol', value: h.value };
							if (!l.consume(')')) {
								const x = l.parseIntermediateType(k.SYMBOL);
								if (((v.element = A(x)), !l.consume(')')))
									throw new Error('Symbol does not end after value');
							}
							return v;
						}, 'parseInfix')
					}),
					ft = W({
						name: 'arrayBracketsParslet',
						precedence: k.ARRAY_BRACKETS,
						accept: i((l, h) => l === '[' && h === ']', 'accept'),
						parseInfix: i(
							(l, h) => (
								l.consume('['),
								l.consume(']'),
								{
									type: 'JsdocTypeGeneric',
									left: { type: 'JsdocTypeName', value: 'Array' },
									elements: [D(h)],
									meta: { brackets: 'square', dot: !1 }
								}
							),
							'parseInfix'
						)
					});
				function Et({ objectFieldGrammar: l, allowKeyTypes: h }) {
					return W({
						name: 'objectParslet',
						accept: i((v) => v === '{', 'accept'),
						parsePrefix: i((v) => {
							v.consume('{');
							const x = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
							if (!v.consume('}')) {
								let F;
								const z = new X(l, v.lexer, v);
								for (;;) {
									z.acceptLexerState(v);
									let Z = z.parseIntermediateType(k.OBJECT);
									(v.acceptLexerState(z),
										Z === void 0 && h && (Z = v.parseIntermediateType(k.OBJECT)));
									let ce = !1;
									if (
										(Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
										Z.type === 'JsdocTypeNumber' ||
											Z.type === 'JsdocTypeName' ||
											Z.type === 'JsdocTypeStringValue')
									) {
										let Te;
										(Z.type === 'JsdocTypeStringValue' && (Te = Z.meta.quote),
											x.elements.push({
												type: 'JsdocTypeObjectField',
												key: Z.value.toString(),
												right: void 0,
												optional: ce,
												readonly: !1,
												meta: { quote: Te }
											}));
									} else if (
										Z.type === 'JsdocTypeObjectField' ||
										Z.type === 'JsdocTypeJsdocObjectField'
									)
										x.elements.push(Z);
									else throw new d(Z);
									if (v.lexer.current.startOfLine)
										((F = 'linebreak'), v.consume(',') || v.consume(';'));
									else if (v.consume(',')) F = 'comma';
									else if (v.consume(';')) F = 'semicolon';
									else break;
									if (v.lexer.current.type === '}') break;
								}
								if (
									((x.meta.separator = F ?? 'comma'),
									F === 'linebreak' && (x.meta.propertyIndent = '  '),
									!v.consume('}'))
								)
									throw new Error("Unterminated record type. Missing '}'");
							}
							return x;
						}, 'parsePrefix')
					});
				}
				i(Et, 'createObjectParslet');
				function Tt({
					allowSquaredProperties: l,
					allowKeyTypes: h,
					allowReadonly: v,
					allowOptional: x
				}) {
					return W({
						name: 'objectFieldParslet',
						precedence: k.KEY_VALUE,
						accept: i((F) => F === ':', 'accept'),
						parseInfix: i((F, z) => {
							var Z;
							let ce = !1,
								Re = !1;
							(x && z.type === 'JsdocTypeNullable' && ((ce = !0), (z = z.element)),
								v && z.type === 'JsdocTypeReadonlyProperty' && ((Re = !0), (z = z.element)));
							const Te = (Z = F.baseParser) !== null && Z !== void 0 ? Z : F;
							if (
								(Te.acceptLexerState(F),
								z.type === 'JsdocTypeNumber' ||
									z.type === 'JsdocTypeName' ||
									z.type === 'JsdocTypeStringValue' ||
									B(z))
							) {
								if (B(z) && !l) throw new d(z);
								Te.consume(':');
								let ke;
								z.type === 'JsdocTypeStringValue' && (ke = z.meta.quote);
								const Br = Te.parseType(k.KEY_VALUE);
								return (
									F.acceptLexerState(Te),
									{
										type: 'JsdocTypeObjectField',
										key: B(z) ? z : z.value.toString(),
										right: Br,
										optional: ce,
										readonly: Re,
										meta: { quote: ke }
									}
								);
							} else {
								if (!h) throw new d(z);
								Te.consume(':');
								const ke = Te.parseType(k.KEY_VALUE);
								return (
									F.acceptLexerState(Te),
									{ type: 'JsdocTypeJsdocObjectField', left: D(z), right: ke }
								);
							}
						}, 'parseInfix')
					});
				}
				i(Tt, 'createObjectFieldParslet');
				function _t({ allowOptional: l, allowVariadic: h }) {
					return W({
						name: 'keyValueParslet',
						precedence: k.KEY_VALUE,
						accept: i((v) => v === ':', 'accept'),
						parseInfix: i((v, x) => {
							let F = !1,
								z = !1;
							if (
								(l && x.type === 'JsdocTypeNullable' && ((F = !0), (x = x.element)),
								h &&
									x.type === 'JsdocTypeVariadic' &&
									x.element !== void 0 &&
									((z = !0), (x = x.element)),
								x.type !== 'JsdocTypeName')
							)
								throw new d(x);
							v.consume(':');
							const Z = v.parseType(k.KEY_VALUE);
							return {
								type: 'JsdocTypeKeyValue',
								key: x.value,
								right: Z,
								optional: F,
								variadic: z
							};
						}, 'parseInfix')
					});
				}
				i(_t, 'createKeyValueParslet');
				const Un = [
						...$,
						pt({
							allowWithoutParenthesis: !0,
							allowNamedParameters: ['this', 'new'],
							allowNoReturnType: !0,
							allowNewAsFunctionKeyword: !1
						}),
						oe,
						ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
						vt({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
						re({ allowedAdditionalTokens: ['keyof'] }),
						Ft,
						ft,
						Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye })
					],
					Bi = [
						...Un,
						Et({
							objectFieldGrammar: [
								re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
								Tt({
									allowSquaredProperties: !1,
									allowKeyTypes: !0,
									allowOptional: !1,
									allowReadonly: !1
								}),
								...Un
							],
							allowKeyTypes: !0
						}),
						_t({ allowOptional: !0, allowVariadic: !0 })
					],
					Vn = W({
						name: 'typeOfParslet',
						accept: i((l) => l === 'typeof', 'accept'),
						parsePrefix: i(
							(l) => (
								l.consume('typeof'),
								{ type: 'JsdocTypeTypeof', element: l.parseType(k.KEY_OF_TYPE_OF) }
							),
							'parsePrefix'
						)
					}),
					Ji = [
						re({
							allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']
						}),
						ae,
						le,
						oe,
						ve,
						Tt({
							allowSquaredProperties: !1,
							allowKeyTypes: !1,
							allowOptional: !1,
							allowReadonly: !1
						})
					],
					$i = [
						...$,
						Et({ allowKeyTypes: !1, objectFieldGrammar: Ji }),
						re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
						Vn,
						pt({
							allowWithoutParenthesis: !1,
							allowNamedParameters: ['this', 'new'],
							allowNoReturnType: !0,
							allowNewAsFunctionKeyword: !1
						}),
						vt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
						re({ allowedAdditionalTokens: ['keyof'] }),
						ne({ allowedTypes: ['module'], pathGrammar: ye }),
						Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
						_t({ allowOptional: !1, allowVariadic: !1 }),
						Ft
					],
					Ui = W({
						name: 'assertsParslet',
						accept: i((l) => l === 'asserts', 'accept'),
						parsePrefix: i((l) => {
							l.consume('asserts');
							const h = l.parseIntermediateType(k.SYMBOL);
							if (h.type !== 'JsdocTypeName')
								throw new d(h, 'A typescript asserts always has to have a name on the left side.');
							return l.consume('is')
								? { type: 'JsdocTypeAsserts', left: h, right: D(l.parseIntermediateType(k.INFIX)) }
								: { type: 'JsdocTypeAssertsPlain', element: h };
						}, 'parsePrefix')
					});
				function Hn({ allowQuestionMark: l }) {
					return W({
						name: 'tupleParslet',
						accept: i((h) => h === '[', 'accept'),
						parsePrefix: i((h) => {
							h.consume('[');
							const v = { type: 'JsdocTypeTuple', elements: [] };
							if (h.consume(']')) return v;
							const x = h.parseIntermediateType(k.ALL);
							if (
								(x.type === 'JsdocTypeParameterList'
									? x.elements[0].type === 'JsdocTypeKeyValue'
										? (v.elements = x.elements.map(H))
										: (v.elements = x.elements.map(D))
									: x.type === 'JsdocTypeKeyValue'
										? (v.elements = [H(x)])
										: (v.elements = [D(x)]),
								!h.consume(']'))
							)
								throw new Error("Unterminated '['");
							if (v.elements.some((F) => F.type === 'JsdocTypeUnknown'))
								throw new Error('Question mark in tuple not allowed');
							return v;
						}, 'parsePrefix')
					});
				}
				i(Hn, 'createTupleParslet');
				const Vi = W({
						name: 'keyOfParslet',
						accept: i((l) => l === 'keyof', 'accept'),
						parsePrefix: i(
							(l) => (
								l.consume('keyof'),
								{ type: 'JsdocTypeKeyof', element: D(l.parseType(k.KEY_OF_TYPE_OF)) }
							),
							'parsePrefix'
						)
					}),
					Hi = W({
						name: 'importParslet',
						accept: i((l) => l === 'import', 'accept'),
						parsePrefix: i((l) => {
							if ((l.consume('import'), !l.consume('(')))
								throw new Error('Missing parenthesis after import keyword');
							const h = l.parseType(k.PREFIX);
							if (h.type !== 'JsdocTypeStringValue')
								throw new Error('Only string values are allowed as paths for imports');
							if (!l.consume(')'))
								throw new Error('Missing closing parenthesis after import keyword');
							return { type: 'JsdocTypeImport', element: h };
						}, 'parsePrefix')
					}),
					Gi = W({
						name: 'readonlyPropertyParslet',
						accept: i((l) => l === 'readonly', 'accept'),
						parsePrefix: i(
							(l) => (
								l.consume('readonly'),
								{ type: 'JsdocTypeReadonlyProperty', element: l.parseIntermediateType(k.KEY_VALUE) }
							),
							'parsePrefix'
						)
					}),
					zi = W({
						name: 'arrowFunctionParslet',
						precedence: k.ARROW,
						accept: i((l) => l === '=>', 'accept'),
						parseInfix: i(
							(l, h) => (
								l.consume('=>'),
								{
									type: 'JsdocTypeFunction',
									parameters: fe(h).map(V),
									arrow: !0,
									constructor: !1,
									parenthesis: !0,
									returnType: l.parseType(k.OBJECT)
								}
							),
							'parseInfix'
						)
					}),
					Wi = W({
						name: 'genericArrowFunctionParslet',
						accept: i((l) => l === '<', 'accept'),
						parsePrefix: i((l) => {
							const h = [];
							l.consume('<');
							do {
								let x,
									F = l.parseIntermediateType(k.SYMBOL);
								if (
									(F.type === 'JsdocTypeOptional' && ((F = F.element), (x = l.parseType(k.SYMBOL))),
									F.type !== 'JsdocTypeName')
								)
									throw new d(F);
								let z;
								l.consume('extends') &&
									((z = l.parseType(k.SYMBOL)),
									z.type === 'JsdocTypeOptional' && ((z = z.element), (x = l.parseType(k.SYMBOL))));
								const Z = { type: 'JsdocTypeTypeParameter', name: F };
								if (
									(z !== void 0 && (Z.constraint = z),
									x !== void 0 && (Z.defaultValue = x),
									h.push(Z),
									l.consume('>'))
								)
									break;
							} while (l.consume(','));
							const v = l.parseIntermediateType(k.SYMBOL);
							return ((v.typeParameters = h), v);
						}, 'parsePrefix')
					}),
					Ki = W({
						name: 'intersectionParslet',
						accept: i((l) => l === '&', 'accept'),
						precedence: k.INTERSECTION,
						parseInfix: i((l, h) => {
							l.consume('&');
							const v = [];
							do v.push(l.parseType(k.INTERSECTION));
							while (l.consume('&'));
							return { type: 'JsdocTypeIntersection', elements: [D(h), ...v] };
						}, 'parseInfix')
					}),
					Yi = W({
						name: 'predicateParslet',
						precedence: k.INFIX,
						accept: i((l) => l === 'is', 'accept'),
						parseInfix: i((l, h) => {
							if (h.type !== 'JsdocTypeName')
								throw new d(
									h,
									'A typescript predicate always has to have a name on the left side.'
								);
							return (
								l.consume('is'),
								{ type: 'JsdocTypePredicate', left: h, right: D(l.parseIntermediateType(k.INFIX)) }
							);
						}, 'parseInfix')
					}),
					Xi = W({
						name: 'objectSquareBracketPropertyParslet',
						accept: i((l) => l === '[', 'accept'),
						parsePrefix: i((l) => {
							if (l.baseParser === void 0) throw new Error('Only allowed inside object grammar');
							l.consume('[');
							const h = l.lexer.current.text;
							l.consume('Identifier');
							let v;
							if (l.consume(':')) {
								const x = l.baseParser;
								(x.acceptLexerState(l),
									(v = {
										type: 'JsdocTypeIndexSignature',
										key: h,
										right: x.parseType(k.INDEX_BRACKETS)
									}),
									l.acceptLexerState(x));
							} else if (l.consume('in')) {
								const x = l.baseParser;
								(x.acceptLexerState(l),
									(v = {
										type: 'JsdocTypeMappedType',
										key: h,
										right: x.parseType(k.ARRAY_BRACKETS)
									}),
									l.acceptLexerState(x));
							} else throw new Error("Missing ':' or 'in' inside square bracketed property.");
							if (!l.consume(']')) throw new Error('Unterminated square brackets');
							return v;
						}, 'parsePrefix')
					}),
					Qi = W({
						name: 'readonlyArrayParslet',
						accept: i((l) => l === 'readonly', 'accept'),
						parsePrefix: i(
							(l) => (
								l.consume('readonly'),
								{ type: 'JsdocTypeReadonlyArray', element: L(l.parseIntermediateType(k.ALL)) }
							),
							'parsePrefix'
						)
					}),
					Zi = W({
						name: 'conditionalParslet',
						precedence: k.INFIX,
						accept: i((l) => l === 'extends', 'accept'),
						parseInfix: i((l, h) => {
							l.consume('extends');
							const v = l.parseType(k.KEY_OF_TYPE_OF).element,
								x = l.parseType(k.INFIX);
							return (
								l.consume(':'),
								{
									type: 'JsdocTypeConditional',
									checksType: D(h),
									extendsType: v,
									trueType: x,
									falseType: l.parseType(k.INFIX)
								}
							);
						}, 'parseInfix')
					}),
					es = [
						Gi,
						re({
							allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']
						}),
						ae,
						le,
						oe,
						ve,
						Tt({
							allowSquaredProperties: !0,
							allowKeyTypes: !1,
							allowOptional: !0,
							allowReadonly: !0
						}),
						Xi
					],
					ts = [
						...$,
						Et({ allowKeyTypes: !1, objectFieldGrammar: es }),
						Qi,
						Vn,
						Vi,
						Hi,
						oe,
						pt({
							allowWithoutParenthesis: !0,
							allowNoReturnType: !1,
							allowNamedParameters: ['this', 'new', 'args'],
							allowNewAsFunctionKeyword: !0
						}),
						Hn({ allowQuestionMark: !1 }),
						vt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
						Ui,
						Zi,
						re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
						ne({ allowedTypes: ['module'], pathGrammar: ye }),
						ft,
						zi,
						Wi,
						Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
						Ki,
						Yi,
						_t({ allowVariadic: !0, allowOptional: !0 })
					];
				function kr(l, h) {
					switch (h) {
						case 'closure':
							return new X($i, l).parse();
						case 'jsdoc':
							return new X(Bi, l).parse();
						case 'typescript':
							return new X(ts, l).parse();
					}
				}
				i(kr, 'parse');
				function Gn(l, h = ['typescript', 'closure', 'jsdoc']) {
					let v;
					for (const x of h)
						try {
							return kr(l, x);
						} catch (F) {
							v = F;
						}
					throw v;
				}
				i(Gn, 'tryParse');
				function Y(l, h) {
					const v = l[h.type];
					if (v === void 0)
						throw new Error(`In this set of transform rules exists no rule for type ${h.type}.`);
					return v(h, (x) => Y(l, x));
				}
				i(Y, 'transform');
				function ue(l) {
					throw new Error(
						'This transform is not available. Are you trying the correct parsing mode?'
					);
				}
				i(ue, 'notAvailableTransform');
				function Xt(l) {
					const h = { params: [] };
					for (const v of l.parameters)
						v.type === 'JsdocTypeKeyValue'
							? v.key === 'this'
								? (h.this = v.right)
								: v.key === 'new'
									? (h.new = v.right)
									: h.params.push(v)
							: h.params.push(v);
					return h;
				}
				i(Xt, 'extractSpecialParams');
				function lr(l, h, v) {
					return l === 'prefix' ? v + h : h + v;
				}
				i(lr, 'applyPosition');
				function nt(l, h) {
					switch (h) {
						case 'double':
							return `"${l}"`;
						case 'single':
							return `'${l}'`;
						case void 0:
							return l;
					}
				}
				i(nt, 'quote');
				function zn() {
					return {
						JsdocTypeParenthesis: i(
							(l, h) => `(${l.element !== void 0 ? h(l.element) : ''})`,
							'JsdocTypeParenthesis'
						),
						JsdocTypeKeyof: i((l, h) => `keyof ${h(l.element)}`, 'JsdocTypeKeyof'),
						JsdocTypeFunction: i((l, h) => {
							var v;
							if (l.arrow) {
								if (l.returnType === void 0) throw new Error('Arrow function needs a return type.');
								let x = `${l.typeParameters !== void 0 ? `<${(v = l.typeParameters.map(h).join(', ')) !== null && v !== void 0 ? v : ''}>` : ''}(${l.parameters.map(h).join(', ')}) => ${h(l.returnType)}`;
								return (l.constructor && (x = 'new ' + x), x);
							} else {
								let x = l.constructor ? 'new' : 'function';
								return (
									l.parenthesis &&
										((x += `(${l.parameters.map(h).join(', ')})`),
										l.returnType !== void 0 && (x += `: ${h(l.returnType)}`)),
									x
								);
							}
						}, 'JsdocTypeFunction'),
						JsdocTypeName: i((l) => l.value, 'JsdocTypeName'),
						JsdocTypeTuple: i((l, h) => `[${l.elements.map(h).join(', ')}]`, 'JsdocTypeTuple'),
						JsdocTypeVariadic: i(
							(l, h) =>
								l.meta.position === void 0 ? '...' : lr(l.meta.position, h(l.element), '...'),
							'JsdocTypeVariadic'
						),
						JsdocTypeNamePath: i((l, h) => {
							const v = h(l.left),
								x = h(l.right);
							switch (l.pathType) {
								case 'inner':
									return `${v}~${x}`;
								case 'instance':
									return `${v}#${x}`;
								case 'property':
									return `${v}.${x}`;
								case 'property-brackets':
									return `${v}[${x}]`;
							}
						}, 'JsdocTypeNamePath'),
						JsdocTypeStringValue: i((l) => nt(l.value, l.meta.quote), 'JsdocTypeStringValue'),
						JsdocTypeAny: i(() => '*', 'JsdocTypeAny'),
						JsdocTypeGeneric: i((l, h) => {
							if (l.meta.brackets === 'square') {
								const v = l.elements[0],
									x = h(v);
								return v.type === 'JsdocTypeUnion' || v.type === 'JsdocTypeIntersection'
									? `(${x})[]`
									: `${x}[]`;
							} else
								return `${h(l.left)}${l.meta.dot ? '.' : ''}<${l.infer === !0 ? 'infer ' : ''}${l.elements.map(h).join(', ')}>`;
						}, 'JsdocTypeGeneric'),
						JsdocTypeImport: i((l, h) => `import(${h(l.element)})`, 'JsdocTypeImport'),
						JsdocTypeObjectField: i((l, h) => {
							let v = '';
							return (
								l.readonly && (v += 'readonly '),
								typeof l.key == 'string' ? (v += nt(l.key, l.meta.quote)) : (v += h(l.key)),
								l.optional && (v += '?'),
								l.right === void 0 ? v : v + `: ${h(l.right)}`
							);
						}, 'JsdocTypeObjectField'),
						JsdocTypeJsdocObjectField: i(
							(l, h) => `${h(l.left)}: ${h(l.right)}`,
							'JsdocTypeJsdocObjectField'
						),
						JsdocTypeKeyValue: i((l, h) => {
							let v = l.key;
							return (
								l.optional && (v += '?'),
								l.variadic && (v = '...' + v),
								l.right === void 0 ? v : v + `: ${h(l.right)}`
							);
						}, 'JsdocTypeKeyValue'),
						JsdocTypeSpecialNamePath: i(
							(l) => `${l.specialType}:${nt(l.value, l.meta.quote)}`,
							'JsdocTypeSpecialNamePath'
						),
						JsdocTypeNotNullable: i(
							(l, h) => lr(l.meta.position, h(l.element), '!'),
							'JsdocTypeNotNullable'
						),
						JsdocTypeNull: i(() => 'null', 'JsdocTypeNull'),
						JsdocTypeNullable: i(
							(l, h) => lr(l.meta.position, h(l.element), '?'),
							'JsdocTypeNullable'
						),
						JsdocTypeNumber: i((l) => l.value.toString(), 'JsdocTypeNumber'),
						JsdocTypeObject: i((l, h) => {
							var v, x;
							return `{${
								(l.meta.separator === 'linebreak' && l.elements.length > 1
									? `
` + ((v = l.meta.propertyIndent) !== null && v !== void 0 ? v : '')
									: '') +
								l.elements.map(h).join(
									l.meta.separator === 'comma'
										? ', '
										: l.meta.separator === 'linebreak'
											? `
` + ((x = l.meta.propertyIndent) !== null && x !== void 0 ? x : '')
											: '; '
								) +
								(l.meta.separator === 'linebreak' && l.elements.length > 1
									? `
`
									: '')
							}}`;
						}, 'JsdocTypeObject'),
						JsdocTypeOptional: i(
							(l, h) => lr(l.meta.position, h(l.element), '='),
							'JsdocTypeOptional'
						),
						JsdocTypeSymbol: i(
							(l, h) => `${l.value}(${l.element !== void 0 ? h(l.element) : ''})`,
							'JsdocTypeSymbol'
						),
						JsdocTypeTypeof: i((l, h) => `typeof ${h(l.element)}`, 'JsdocTypeTypeof'),
						JsdocTypeUndefined: i(() => 'undefined', 'JsdocTypeUndefined'),
						JsdocTypeUnion: i((l, h) => l.elements.map(h).join(' | '), 'JsdocTypeUnion'),
						JsdocTypeUnknown: i(() => '?', 'JsdocTypeUnknown'),
						JsdocTypeIntersection: i(
							(l, h) => l.elements.map(h).join(' & '),
							'JsdocTypeIntersection'
						),
						JsdocTypeProperty: i((l) => nt(l.value, l.meta.quote), 'JsdocTypeProperty'),
						JsdocTypePredicate: i((l, h) => `${h(l.left)} is ${h(l.right)}`, 'JsdocTypePredicate'),
						JsdocTypeIndexSignature: i(
							(l, h) => `[${l.key}: ${h(l.right)}]`,
							'JsdocTypeIndexSignature'
						),
						JsdocTypeMappedType: i((l, h) => `[${l.key} in ${h(l.right)}]`, 'JsdocTypeMappedType'),
						JsdocTypeAsserts: i(
							(l, h) => `asserts ${h(l.left)} is ${h(l.right)}`,
							'JsdocTypeAsserts'
						),
						JsdocTypeReadonlyArray: i(
							(l, h) => `readonly ${h(l.element)}`,
							'JsdocTypeReadonlyArray'
						),
						JsdocTypeAssertsPlain: i((l, h) => `asserts ${h(l.element)}`, 'JsdocTypeAssertsPlain'),
						JsdocTypeConditional: i(
							(l, h) =>
								`${h(l.checksType)} extends ${h(l.extendsType)} ? ${h(l.trueType)} : ${h(l.falseType)}`,
							'JsdocTypeConditional'
						),
						JsdocTypeTypeParameter: i(
							(l, h) =>
								`${h(l.name)}${l.constraint !== void 0 ? ` extends ${h(l.constraint)}` : ''}${l.defaultValue !== void 0 ? ` = ${h(l.defaultValue)}` : ''}`,
							'JsdocTypeTypeParameter'
						)
					};
				}
				i(zn, 'stringifyRules');
				const Xc = zn();
				function rs(l) {
					return Y(Xc, l);
				}
				i(rs, 'stringify');
				const Qc = [
					'null',
					'true',
					'false',
					'break',
					'case',
					'catch',
					'class',
					'const',
					'continue',
					'debugger',
					'default',
					'delete',
					'do',
					'else',
					'export',
					'extends',
					'finally',
					'for',
					'function',
					'if',
					'import',
					'in',
					'instanceof',
					'new',
					'return',
					'super',
					'switch',
					'this',
					'throw',
					'try',
					'typeof',
					'var',
					'void',
					'while',
					'with',
					'yield'
				];
				function ot(l) {
					const h = { type: 'NameExpression', name: l };
					return (Qc.includes(l) && (h.reservedWord = !0), h);
				}
				i(ot, 'makeName');
				const Zc = {
					JsdocTypeOptional: i((l, h) => {
						const v = h(l.element);
						return ((v.optional = !0), v);
					}, 'JsdocTypeOptional'),
					JsdocTypeNullable: i((l, h) => {
						const v = h(l.element);
						return ((v.nullable = !0), v);
					}, 'JsdocTypeNullable'),
					JsdocTypeNotNullable: i((l, h) => {
						const v = h(l.element);
						return ((v.nullable = !1), v);
					}, 'JsdocTypeNotNullable'),
					JsdocTypeVariadic: i((l, h) => {
						if (l.element === void 0)
							throw new Error('dots without value are not allowed in catharsis mode');
						const v = h(l.element);
						return ((v.repeatable = !0), v);
					}, 'JsdocTypeVariadic'),
					JsdocTypeAny: i(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
					JsdocTypeNull: i(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
					JsdocTypeStringValue: i((l) => ot(nt(l.value, l.meta.quote)), 'JsdocTypeStringValue'),
					JsdocTypeUndefined: i(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
					JsdocTypeUnknown: i(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
					JsdocTypeFunction: i((l, h) => {
						const v = Xt(l),
							x = { type: 'FunctionType', params: v.params.map(h) };
						return (
							v.this !== void 0 && (x.this = h(v.this)),
							v.new !== void 0 && (x.new = h(v.new)),
							l.returnType !== void 0 && (x.result = h(l.returnType)),
							x
						);
					}, 'JsdocTypeFunction'),
					JsdocTypeGeneric: i(
						(l, h) => ({
							type: 'TypeApplication',
							applications: l.elements.map((v) => h(v)),
							expression: h(l.left)
						}),
						'JsdocTypeGeneric'
					),
					JsdocTypeSpecialNamePath: i(
						(l) => ot(l.specialType + ':' + nt(l.value, l.meta.quote)),
						'JsdocTypeSpecialNamePath'
					),
					JsdocTypeName: i(
						(l) => (l.value !== 'function' ? ot(l.value) : { type: 'FunctionType', params: [] }),
						'JsdocTypeName'
					),
					JsdocTypeNumber: i((l) => ot(l.value.toString()), 'JsdocTypeNumber'),
					JsdocTypeObject: i((l, h) => {
						const v = { type: 'RecordType', fields: [] };
						for (const x of l.elements)
							x.type !== 'JsdocTypeObjectField' && x.type !== 'JsdocTypeJsdocObjectField'
								? v.fields.push({ type: 'FieldType', key: h(x), value: void 0 })
								: v.fields.push(h(x));
						return v;
					}, 'JsdocTypeObject'),
					JsdocTypeObjectField: i((l, h) => {
						if (typeof l.key != 'string')
							throw new Error('Index signatures and mapped types are not supported');
						return {
							type: 'FieldType',
							key: ot(nt(l.key, l.meta.quote)),
							value: l.right === void 0 ? void 0 : h(l.right)
						};
					}, 'JsdocTypeObjectField'),
					JsdocTypeJsdocObjectField: i(
						(l, h) => ({ type: 'FieldType', key: h(l.left), value: h(l.right) }),
						'JsdocTypeJsdocObjectField'
					),
					JsdocTypeUnion: i(
						(l, h) => ({ type: 'TypeUnion', elements: l.elements.map((v) => h(v)) }),
						'JsdocTypeUnion'
					),
					JsdocTypeKeyValue: i(
						(l, h) => ({
							type: 'FieldType',
							key: ot(l.key),
							value: l.right === void 0 ? void 0 : h(l.right)
						}),
						'JsdocTypeKeyValue'
					),
					JsdocTypeNamePath: i((l, h) => {
						const v = h(l.left);
						let x;
						l.right.type === 'JsdocTypeSpecialNamePath'
							? (x = h(l.right).name)
							: (x = nt(l.right.value, l.right.meta.quote));
						const F = l.pathType === 'inner' ? '~' : l.pathType === 'instance' ? '#' : '.';
						return ot(`${v.name}${F}${x}`);
					}, 'JsdocTypeNamePath'),
					JsdocTypeSymbol: i((l) => {
						let h = '',
							v = l.element,
							x = !1;
						return (
							v?.type === 'JsdocTypeVariadic' &&
								(v.meta.position === 'prefix' ? (h = '...') : (x = !0), (v = v.element)),
							v?.type === 'JsdocTypeName'
								? (h += v.value)
								: v?.type === 'JsdocTypeNumber' && (h += v.value.toString()),
							x && (h += '...'),
							ot(`${l.value}(${h})`)
						);
					}, 'JsdocTypeSymbol'),
					JsdocTypeParenthesis: i((l, h) => h(D(l.element)), 'JsdocTypeParenthesis'),
					JsdocTypeMappedType: ue,
					JsdocTypeIndexSignature: ue,
					JsdocTypeImport: ue,
					JsdocTypeKeyof: ue,
					JsdocTypeTuple: ue,
					JsdocTypeTypeof: ue,
					JsdocTypeIntersection: ue,
					JsdocTypeProperty: ue,
					JsdocTypePredicate: ue,
					JsdocTypeAsserts: ue,
					JsdocTypeReadonlyArray: ue,
					JsdocTypeAssertsPlain: ue,
					JsdocTypeConditional: ue,
					JsdocTypeTypeParameter: ue
				};
				function ns(l) {
					return Y(Zc, l);
				}
				i(ns, 'catharsisTransform');
				function mt(l) {
					switch (l) {
						case void 0:
							return 'none';
						case 'single':
							return 'single';
						case 'double':
							return 'double';
					}
				}
				i(mt, 'getQuoteStyle');
				function os(l) {
					switch (l) {
						case 'inner':
							return 'INNER_MEMBER';
						case 'instance':
							return 'INSTANCE_MEMBER';
						case 'property':
							return 'MEMBER';
						case 'property-brackets':
							return 'MEMBER';
					}
				}
				i(os, 'getMemberType');
				function Lr(l, h) {
					return h.length === 2
						? { type: l, left: h[0], right: h[1] }
						: { type: l, left: h[0], right: Lr(l, h.slice(1)) };
				}
				i(Lr, 'nestResults');
				const ed = {
					JsdocTypeOptional: i(
						(l, h) => ({
							type: 'OPTIONAL',
							value: h(l.element),
							meta: {
								syntax: l.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'
							}
						}),
						'JsdocTypeOptional'
					),
					JsdocTypeNullable: i(
						(l, h) => ({
							type: 'NULLABLE',
							value: h(l.element),
							meta: {
								syntax:
									l.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'
							}
						}),
						'JsdocTypeNullable'
					),
					JsdocTypeNotNullable: i(
						(l, h) => ({
							type: 'NOT_NULLABLE',
							value: h(l.element),
							meta: { syntax: l.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' }
						}),
						'JsdocTypeNotNullable'
					),
					JsdocTypeVariadic: i((l, h) => {
						const v = {
							type: 'VARIADIC',
							meta: {
								syntax:
									l.meta.position === 'prefix'
										? 'PREFIX_DOTS'
										: l.meta.position === 'suffix'
											? 'SUFFIX_DOTS'
											: 'ONLY_DOTS'
							}
						};
						return (l.element !== void 0 && (v.value = h(l.element)), v);
					}, 'JsdocTypeVariadic'),
					JsdocTypeName: i((l) => ({ type: 'NAME', name: l.value }), 'JsdocTypeName'),
					JsdocTypeTypeof: i(
						(l, h) => ({ type: 'TYPE_QUERY', name: h(l.element) }),
						'JsdocTypeTypeof'
					),
					JsdocTypeTuple: i(
						(l, h) => ({ type: 'TUPLE', entries: l.elements.map(h) }),
						'JsdocTypeTuple'
					),
					JsdocTypeKeyof: i(
						(l, h) => ({ type: 'KEY_QUERY', value: h(l.element) }),
						'JsdocTypeKeyof'
					),
					JsdocTypeImport: i(
						(l) => ({
							type: 'IMPORT',
							path: {
								type: 'STRING_VALUE',
								quoteStyle: mt(l.element.meta.quote),
								string: l.element.value
							}
						}),
						'JsdocTypeImport'
					),
					JsdocTypeUndefined: i(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
					JsdocTypeAny: i(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
					JsdocTypeFunction: i((l, h) => {
						const v = Xt(l),
							x = {
								type: l.arrow ? 'ARROW' : 'FUNCTION',
								params: v.params.map((F) => {
									if (F.type === 'JsdocTypeKeyValue') {
										if (F.right === void 0)
											throw new Error(
												"Function parameter without ':' is not expected to be 'KEY_VALUE'"
											);
										return { type: 'NAMED_PARAMETER', name: F.key, typeName: h(F.right) };
									} else return h(F);
								}),
								new: null,
								returns: null
							};
						return (
							v.this !== void 0 ? (x.this = h(v.this)) : l.arrow || (x.this = null),
							v.new !== void 0 && (x.new = h(v.new)),
							l.returnType !== void 0 && (x.returns = h(l.returnType)),
							x
						);
					}, 'JsdocTypeFunction'),
					JsdocTypeGeneric: i((l, h) => {
						const v = {
							type: 'GENERIC',
							subject: h(l.left),
							objects: l.elements.map(h),
							meta: {
								syntax:
									l.meta.brackets === 'square'
										? 'SQUARE_BRACKET'
										: l.meta.dot
											? 'ANGLE_BRACKET_WITH_DOT'
											: 'ANGLE_BRACKET'
							}
						};
						return (
							l.meta.brackets === 'square' &&
								l.elements[0].type === 'JsdocTypeFunction' &&
								!l.elements[0].parenthesis &&
								(v.objects[0] = { type: 'NAME', name: 'function' }),
							v
						);
					}, 'JsdocTypeGeneric'),
					JsdocTypeObjectField: i((l, h) => {
						if (typeof l.key != 'string')
							throw new Error('Index signatures and mapped types are not supported');
						if (l.right === void 0)
							return {
								type: 'RECORD_ENTRY',
								key: l.key,
								quoteStyle: mt(l.meta.quote),
								value: null,
								readonly: !1
							};
						let v = h(l.right);
						return (
							l.optional &&
								(v = { type: 'OPTIONAL', value: v, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
							{
								type: 'RECORD_ENTRY',
								key: l.key.toString(),
								quoteStyle: mt(l.meta.quote),
								value: v,
								readonly: !1
							}
						);
					}, 'JsdocTypeObjectField'),
					JsdocTypeJsdocObjectField: i(() => {
						throw new Error('Keys may not be typed in jsdoctypeparser.');
					}, 'JsdocTypeJsdocObjectField'),
					JsdocTypeKeyValue: i((l, h) => {
						if (l.right === void 0)
							return {
								type: 'RECORD_ENTRY',
								key: l.key,
								quoteStyle: 'none',
								value: null,
								readonly: !1
							};
						let v = h(l.right);
						return (
							l.optional &&
								(v = { type: 'OPTIONAL', value: v, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
							{ type: 'RECORD_ENTRY', key: l.key, quoteStyle: 'none', value: v, readonly: !1 }
						);
					}, 'JsdocTypeKeyValue'),
					JsdocTypeObject: i((l, h) => {
						const v = [];
						for (const x of l.elements)
							(x.type === 'JsdocTypeObjectField' || x.type === 'JsdocTypeJsdocObjectField') &&
								v.push(h(x));
						return { type: 'RECORD', entries: v };
					}, 'JsdocTypeObject'),
					JsdocTypeSpecialNamePath: i((l) => {
						if (l.specialType !== 'module')
							throw new Error(
								`jsdoctypeparser does not support type ${l.specialType} at this point.`
							);
						return {
							type: 'MODULE',
							value: { type: 'FILE_PATH', quoteStyle: mt(l.meta.quote), path: l.value }
						};
					}, 'JsdocTypeSpecialNamePath'),
					JsdocTypeNamePath: i((l, h) => {
						let v = !1,
							x,
							F;
						l.right.type === 'JsdocTypeSpecialNamePath' && l.right.specialType === 'event'
							? ((v = !0), (x = l.right.value), (F = mt(l.right.meta.quote)))
							: ((x = l.right.value), (F = mt(l.right.meta.quote)));
						const z = {
							type: os(l.pathType),
							owner: h(l.left),
							name: x,
							quoteStyle: F,
							hasEventPrefix: v
						};
						if (z.owner.type === 'MODULE') {
							const Z = z.owner;
							return ((z.owner = z.owner.value), (Z.value = z), Z);
						} else return z;
					}, 'JsdocTypeNamePath'),
					JsdocTypeUnion: i((l, h) => Lr('UNION', l.elements.map(h)), 'JsdocTypeUnion'),
					JsdocTypeParenthesis: i(
						(l, h) => ({ type: 'PARENTHESIS', value: h(D(l.element)) }),
						'JsdocTypeParenthesis'
					),
					JsdocTypeNull: i(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
					JsdocTypeUnknown: i(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
					JsdocTypeStringValue: i(
						(l) => ({ type: 'STRING_VALUE', quoteStyle: mt(l.meta.quote), string: l.value }),
						'JsdocTypeStringValue'
					),
					JsdocTypeIntersection: i(
						(l, h) => Lr('INTERSECTION', l.elements.map(h)),
						'JsdocTypeIntersection'
					),
					JsdocTypeNumber: i(
						(l) => ({ type: 'NUMBER_VALUE', number: l.value.toString() }),
						'JsdocTypeNumber'
					),
					JsdocTypeSymbol: ue,
					JsdocTypeProperty: ue,
					JsdocTypePredicate: ue,
					JsdocTypeMappedType: ue,
					JsdocTypeIndexSignature: ue,
					JsdocTypeAsserts: ue,
					JsdocTypeReadonlyArray: ue,
					JsdocTypeAssertsPlain: ue,
					JsdocTypeConditional: ue,
					JsdocTypeTypeParameter: ue
				};
				function is(l) {
					return Y(ed, l);
				}
				i(is, 'jtpTransform');
				function ss() {
					return {
						JsdocTypeIntersection: i(
							(l, h) => ({ type: 'JsdocTypeIntersection', elements: l.elements.map(h) }),
							'JsdocTypeIntersection'
						),
						JsdocTypeGeneric: i(
							(l, h) => ({
								type: 'JsdocTypeGeneric',
								left: h(l.left),
								elements: l.elements.map(h),
								meta: { dot: l.meta.dot, brackets: l.meta.brackets }
							}),
							'JsdocTypeGeneric'
						),
						JsdocTypeNullable: i((l) => l, 'JsdocTypeNullable'),
						JsdocTypeUnion: i(
							(l, h) => ({ type: 'JsdocTypeUnion', elements: l.elements.map(h) }),
							'JsdocTypeUnion'
						),
						JsdocTypeUnknown: i((l) => l, 'JsdocTypeUnknown'),
						JsdocTypeUndefined: i((l) => l, 'JsdocTypeUndefined'),
						JsdocTypeTypeof: i(
							(l, h) => ({ type: 'JsdocTypeTypeof', element: h(l.element) }),
							'JsdocTypeTypeof'
						),
						JsdocTypeSymbol: i((l, h) => {
							const v = { type: 'JsdocTypeSymbol', value: l.value };
							return (l.element !== void 0 && (v.element = h(l.element)), v);
						}, 'JsdocTypeSymbol'),
						JsdocTypeOptional: i(
							(l, h) => ({
								type: 'JsdocTypeOptional',
								element: h(l.element),
								meta: { position: l.meta.position }
							}),
							'JsdocTypeOptional'
						),
						JsdocTypeObject: i(
							(l, h) => ({
								type: 'JsdocTypeObject',
								meta: { separator: 'comma' },
								elements: l.elements.map(h)
							}),
							'JsdocTypeObject'
						),
						JsdocTypeNumber: i((l) => l, 'JsdocTypeNumber'),
						JsdocTypeNull: i((l) => l, 'JsdocTypeNull'),
						JsdocTypeNotNullable: i(
							(l, h) => ({
								type: 'JsdocTypeNotNullable',
								element: h(l.element),
								meta: { position: l.meta.position }
							}),
							'JsdocTypeNotNullable'
						),
						JsdocTypeSpecialNamePath: i((l) => l, 'JsdocTypeSpecialNamePath'),
						JsdocTypeObjectField: i(
							(l, h) => ({
								type: 'JsdocTypeObjectField',
								key: l.key,
								right: l.right === void 0 ? void 0 : h(l.right),
								optional: l.optional,
								readonly: l.readonly,
								meta: l.meta
							}),
							'JsdocTypeObjectField'
						),
						JsdocTypeJsdocObjectField: i(
							(l, h) => ({ type: 'JsdocTypeJsdocObjectField', left: h(l.left), right: h(l.right) }),
							'JsdocTypeJsdocObjectField'
						),
						JsdocTypeKeyValue: i(
							(l, h) => ({
								type: 'JsdocTypeKeyValue',
								key: l.key,
								right: l.right === void 0 ? void 0 : h(l.right),
								optional: l.optional,
								variadic: l.variadic
							}),
							'JsdocTypeKeyValue'
						),
						JsdocTypeImport: i(
							(l, h) => ({ type: 'JsdocTypeImport', element: h(l.element) }),
							'JsdocTypeImport'
						),
						JsdocTypeAny: i((l) => l, 'JsdocTypeAny'),
						JsdocTypeStringValue: i((l) => l, 'JsdocTypeStringValue'),
						JsdocTypeNamePath: i((l) => l, 'JsdocTypeNamePath'),
						JsdocTypeVariadic: i((l, h) => {
							const v = {
								type: 'JsdocTypeVariadic',
								meta: { position: l.meta.position, squareBrackets: l.meta.squareBrackets }
							};
							return (l.element !== void 0 && (v.element = h(l.element)), v);
						}, 'JsdocTypeVariadic'),
						JsdocTypeTuple: i(
							(l, h) => ({ type: 'JsdocTypeTuple', elements: l.elements.map(h) }),
							'JsdocTypeTuple'
						),
						JsdocTypeName: i((l) => l, 'JsdocTypeName'),
						JsdocTypeFunction: i((l, h) => {
							const v = {
								type: 'JsdocTypeFunction',
								arrow: l.arrow,
								parameters: l.parameters.map(h),
								constructor: l.constructor,
								parenthesis: l.parenthesis
							};
							return (l.returnType !== void 0 && (v.returnType = h(l.returnType)), v);
						}, 'JsdocTypeFunction'),
						JsdocTypeKeyof: i(
							(l, h) => ({ type: 'JsdocTypeKeyof', element: h(l.element) }),
							'JsdocTypeKeyof'
						),
						JsdocTypeParenthesis: i(
							(l, h) => ({ type: 'JsdocTypeParenthesis', element: h(l.element) }),
							'JsdocTypeParenthesis'
						),
						JsdocTypeProperty: i((l) => l, 'JsdocTypeProperty'),
						JsdocTypePredicate: i(
							(l, h) => ({ type: 'JsdocTypePredicate', left: h(l.left), right: h(l.right) }),
							'JsdocTypePredicate'
						),
						JsdocTypeIndexSignature: i(
							(l, h) => ({ type: 'JsdocTypeIndexSignature', key: l.key, right: h(l.right) }),
							'JsdocTypeIndexSignature'
						),
						JsdocTypeMappedType: i(
							(l, h) => ({ type: 'JsdocTypeMappedType', key: l.key, right: h(l.right) }),
							'JsdocTypeMappedType'
						),
						JsdocTypeAsserts: i(
							(l, h) => ({ type: 'JsdocTypeAsserts', left: h(l.left), right: h(l.right) }),
							'JsdocTypeAsserts'
						),
						JsdocTypeReadonlyArray: i(
							(l, h) => ({ type: 'JsdocTypeReadonlyArray', element: h(l.element) }),
							'JsdocTypeReadonlyArray'
						),
						JsdocTypeAssertsPlain: i(
							(l, h) => ({ type: 'JsdocTypeAssertsPlain', element: h(l.element) }),
							'JsdocTypeAssertsPlain'
						),
						JsdocTypeConditional: i(
							(l, h) => ({
								type: 'JsdocTypeConditional',
								checksType: h(l.checksType),
								extendsType: h(l.extendsType),
								trueType: h(l.trueType),
								falseType: h(l.falseType)
							}),
							'JsdocTypeConditional'
						),
						JsdocTypeTypeParameter: i(
							(l, h) => ({
								type: 'JsdocTypeTypeParameter',
								name: h(l.name),
								constraint: l.constraint !== void 0 ? h(l.constraint) : void 0,
								defaultValue: l.defaultValue !== void 0 ? h(l.defaultValue) : void 0
							}),
							'JsdocTypeTypeParameter'
						)
					};
				}
				i(ss, 'identityTransformRules');
				const as = {
					JsdocTypeAny: [],
					JsdocTypeFunction: ['parameters', 'returnType'],
					JsdocTypeGeneric: ['left', 'elements'],
					JsdocTypeImport: [],
					JsdocTypeIndexSignature: ['right'],
					JsdocTypeIntersection: ['elements'],
					JsdocTypeKeyof: ['element'],
					JsdocTypeKeyValue: ['right'],
					JsdocTypeMappedType: ['right'],
					JsdocTypeName: [],
					JsdocTypeNamePath: ['left', 'right'],
					JsdocTypeNotNullable: ['element'],
					JsdocTypeNull: [],
					JsdocTypeNullable: ['element'],
					JsdocTypeNumber: [],
					JsdocTypeObject: ['elements'],
					JsdocTypeObjectField: ['right'],
					JsdocTypeJsdocObjectField: ['left', 'right'],
					JsdocTypeOptional: ['element'],
					JsdocTypeParenthesis: ['element'],
					JsdocTypeSpecialNamePath: [],
					JsdocTypeStringValue: [],
					JsdocTypeSymbol: ['element'],
					JsdocTypeTuple: ['elements'],
					JsdocTypeTypeof: ['element'],
					JsdocTypeUndefined: [],
					JsdocTypeUnion: ['elements'],
					JsdocTypeUnknown: [],
					JsdocTypeVariadic: ['element'],
					JsdocTypeProperty: [],
					JsdocTypePredicate: ['left', 'right'],
					JsdocTypeAsserts: ['left', 'right'],
					JsdocTypeReadonlyArray: ['element'],
					JsdocTypeAssertsPlain: ['element'],
					JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
					JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue']
				};
				function Fr(l, h, v, x, F) {
					x?.(l, h, v);
					const z = as[l.type];
					for (const Z of z) {
						const ce = l[Z];
						if (ce !== void 0)
							if (Array.isArray(ce)) for (const Re of ce) Fr(Re, l, Z, x, F);
							else Fr(ce, l, Z, x, F);
					}
					F?.(l, h, v);
				}
				i(Fr, '_traverse');
				function ls(l, h, v) {
					Fr(l, void 0, void 0, h, v);
				}
				(i(ls, 'traverse'),
					(r.catharsisTransform = ns),
					(r.identityTransformRules = ss),
					(r.jtpTransform = is),
					(r.parse = kr),
					(r.stringify = rs),
					(r.stringifyRules = zn),
					(r.transform = Y),
					(r.traverse = ls),
					(r.tryParse = Gn),
					(r.visitorKeys = as));
			});
		}
	}),
	YL = J({
		'../node_modules/browser-dtector/browser-dtector.umd.min.js'(e, t) {
			(function (r, n) {
				typeof e == 'object' && typeof t < 'u'
					? (t.exports = n())
					: typeof define == 'function' && define.amd
						? define(n)
						: ((r = typeof globalThis < 'u' ? globalThis : r || self).BrowserDetector = n());
			})(e, function () {
				function r(c, d) {
					for (var p = 0; p < d.length; p++) {
						var f = d[p];
						((f.enumerable = f.enumerable || !1),
							(f.configurable = !0),
							'value' in f && (f.writable = !0),
							Object.defineProperty(
								c,
								((m = f.key),
								(y = void 0),
								typeof (y = (function (g, E) {
									if (typeof g != 'object' || g === null) return g;
									var T = g[Symbol.toPrimitive];
									if (T !== void 0) {
										var b = T.call(g, E);
										if (typeof b != 'object') return b;
										throw new TypeError('@@toPrimitive must return a primitive value.');
									}
									return (E === 'string' ? String : Number)(g);
								})(m, 'string')) == 'symbol'
									? y
									: String(y)),
								f
							));
					}
					var m, y;
				}
				i(r, 'e');
				var n = {
						chrome: 'Google Chrome',
						brave: 'Brave',
						crios: 'Google Chrome',
						edge: 'Microsoft Edge',
						edg: 'Microsoft Edge',
						edgios: 'Microsoft Edge',
						fennec: 'Mozilla Firefox',
						jsdom: 'JsDOM',
						mozilla: 'Mozilla Firefox',
						fxios: 'Mozilla Firefox',
						msie: 'Microsoft Internet Explorer',
						opera: 'Opera',
						opios: 'Opera',
						opr: 'Opera',
						opt: 'Opera',
						rv: 'Microsoft Internet Explorer',
						safari: 'Safari',
						samsungbrowser: 'Samsung Browser',
						electron: 'Electron'
					},
					o = {
						android: 'Android',
						androidTablet: 'Android Tablet',
						cros: 'Chrome OS',
						fennec: 'Android Tablet',
						ipad: 'IPad',
						iphone: 'IPhone',
						jsdom: 'JsDOM',
						linux: 'Linux',
						mac: 'Macintosh',
						tablet: 'Android Tablet',
						win: 'Windows',
						'windows phone': 'Windows Phone',
						xbox: 'Microsoft Xbox'
					},
					s = i(function (c) {
						var d = new RegExp(
								'^-?\\d+(?:.\\d{0,'.concat(
									arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1,
									'})?'
								)
							),
							p = Number(c).toString().match(d);
						return p ? p[0] : null;
					}, 'n'),
					a = i(function () {
						return typeof window < 'u' ? window.navigator : null;
					}, 'i'),
					u = (function () {
						function c(m) {
							var y;
							((function (g, E) {
								if (!(g instanceof E)) throw new TypeError('Cannot call a class as a function');
							})(this, c),
								(this.userAgent =
									m || ((y = a()) === null || y === void 0 ? void 0 : y.userAgent) || null));
						}
						i(c, 't');
						var d, p, f;
						return (
							(d = c),
							(p = [
								{
									key: 'parseUserAgent',
									value: i(function (m) {
										var y,
											g,
											E,
											T = {},
											b = m || this.userAgent || '',
											w = b.toLowerCase().replace(/\s\s+/g, ' '),
											P =
												/(edge)\/([\w.]+)/.exec(w) ||
												/(edg)[/]([\w.]+)/.exec(w) ||
												/(opr)[/]([\w.]+)/.exec(w) ||
												/(opt)[/]([\w.]+)/.exec(w) ||
												/(fxios)[/]([\w.]+)/.exec(w) ||
												/(edgios)[/]([\w.]+)/.exec(w) ||
												/(jsdom)[/]([\w.]+)/.exec(w) ||
												/(samsungbrowser)[/]([\w.]+)/.exec(w) ||
												/(electron)[/]([\w.]+)/.exec(w) ||
												/(chrome)[/]([\w.]+)/.exec(w) ||
												/(crios)[/]([\w.]+)/.exec(w) ||
												/(opios)[/]([\w.]+)/.exec(w) ||
												/(version)(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(w) ||
												/(webkit)[/]([\w.]+).*(version)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(w) ||
												/(applewebkit)[/]([\w.]+).*(safari)[/]([\w.]+)/.exec(w) ||
												/(webkit)[/]([\w.]+)/.exec(w) ||
												/(opera)(?:.*version|)[/]([\w.]+)/.exec(w) ||
												/(msie) ([\w.]+)/.exec(w) ||
												/(fennec)[/]([\w.]+)/.exec(w) ||
												(w.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(w)) ||
												(w.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(w)) ||
												[],
											I =
												/(ipad)/.exec(w) ||
												/(ipod)/.exec(w) ||
												/(iphone)/.exec(w) ||
												/(jsdom)/.exec(w) ||
												/(windows phone)/.exec(w) ||
												/(xbox)/.exec(w) ||
												/(win)/.exec(w) ||
												/(tablet)/.exec(w) ||
												(/(android)/.test(w) && /(mobile)/.test(w) === !1 && ['androidTablet']) ||
												/(android)/.exec(w) ||
												/(mac)/.exec(w) ||
												/(linux)/.exec(w) ||
												/(cros)/.exec(w) ||
												[],
											q = P[5] || P[3] || P[1] || null,
											C = I[0] || null,
											R = P[4] || P[2] || null,
											_ = a();
										(q === 'chrome' &&
											typeof (_ == null || (y = _.brave) === null || y === void 0
												? void 0
												: y.isBrave) == 'function' &&
											(q = 'brave'),
											q && (T[q] = !0),
											C && (T[C] = !0));
										var S = !!(T.tablet || T.android || T.androidTablet),
											D = !!(T.ipad || T.tablet || T.androidTablet),
											N = !!(
												T.android ||
												T.androidTablet ||
												T.tablet ||
												T.ipad ||
												T.ipod ||
												T.iphone ||
												T['windows phone']
											),
											V = !!(T.cros || T.mac || T.linux || T.win),
											H = !!(
												T.brave ||
												T.chrome ||
												T.crios ||
												T.opr ||
												T.safari ||
												T.edg ||
												T.electron
											),
											A = !!(T.msie || T.rv);
										return {
											name: (g = n[q]) !== null && g !== void 0 ? g : null,
											platform: (E = o[C]) !== null && E !== void 0 ? E : null,
											userAgent: b,
											version: R,
											shortVersion: R ? s(parseFloat(R), 2) : null,
											isAndroid: S,
											isTablet: D,
											isMobile: N,
											isDesktop: V,
											isWebkit: H,
											isIE: A
										};
									}, 'value')
								},
								{
									key: 'getBrowserInfo',
									value: i(function () {
										var m = this.parseUserAgent();
										return {
											name: m.name,
											platform: m.platform,
											userAgent: m.userAgent,
											version: m.version,
											shortVersion: m.shortVersion
										};
									}, 'value')
								}
							]),
							(f = [
								{
									key: 'VERSION',
									get: i(function () {
										return '3.4.0';
									}, 'get')
								}
							]),
							p && r(d.prototype, p),
							f && r(d, f),
							Object.defineProperty(d, 'prototype', { writable: !1 }),
							c
						);
					})();
				return u;
			});
		}
	}),
	Gf = {};
Lt(Gf, {
	ARGTYPES_INFO_REQUEST: () => yT,
	ARGTYPES_INFO_RESPONSE: () => jd,
	CHANNEL_CREATED: () => QL,
	CHANNEL_WS_DISCONNECT: () => YE,
	CONFIG_ERROR: () => XE,
	CREATE_NEW_STORYFILE_REQUEST: () => ZL,
	CREATE_NEW_STORYFILE_RESPONSE: () => e1,
	CURRENT_STORY_WAS_SET: () => Nd,
	DOCS_PREPARED: () => QE,
	DOCS_RENDERED: () => Wf,
	FILE_COMPONENT_SEARCH_REQUEST: () => t1,
	FILE_COMPONENT_SEARCH_RESPONSE: () => r1,
	FORCE_REMOUNT: () => fl,
	FORCE_RE_RENDER: () => Kf,
	GLOBALS_UPDATED: () => $s,
	NAVIGATE_URL: () => n1,
	OPEN_IN_EDITOR_REQUEST: () => T1,
	OPEN_IN_EDITOR_RESPONSE: () => _1,
	PLAY_FUNCTION_THREW_EXCEPTION: () => ZE,
	PRELOAD_ENTRIES: () => tT,
	PREVIEW_BUILDER_PROGRESS: () => o1,
	PREVIEW_INITIALIZED: () => rT,
	PREVIEW_KEYDOWN: () => nT,
	REGISTER_SUBSCRIPTION: () => i1,
	REQUEST_WHATS_NEW_DATA: () => h1,
	RESET_STORY_ARGS: () => Yf,
	RESULT_WHATS_NEW_DATA: () => y1,
	SAVE_STORY_REQUEST: () => v1,
	SAVE_STORY_RESPONSE: () => E1,
	SELECT_STORY: () => s1,
	SET_CONFIG: () => a1,
	SET_CURRENT_STORY: () => Xf,
	SET_FILTER: () => l1,
	SET_GLOBALS: () => oT,
	SET_INDEX: () => u1,
	SET_STORIES: () => c1,
	SET_WHATS_NEW_CACHE: () => g1,
	SHARED_STATE_CHANGED: () => d1,
	SHARED_STATE_SET: () => p1,
	STORIES_COLLAPSE_ALL: () => f1,
	STORIES_EXPAND_ALL: () => m1,
	STORY_ARGS_UPDATED: () => iT,
	STORY_CHANGED: () => sT,
	STORY_ERRORED: () => aT,
	STORY_FINISHED: () => qd,
	STORY_HOT_UPDATED: () => fT,
	STORY_INDEX_INVALIDATED: () => lT,
	STORY_MISSING: () => Md,
	STORY_PREPARED: () => uT,
	STORY_RENDERED: () => ml,
	STORY_RENDER_PHASE_CHANGED: () => fo,
	STORY_SPECIFIED: () => cT,
	STORY_THREW_EXCEPTION: () => dT,
	STORY_UNCHANGED: () => pT,
	TELEMETRY_ERROR: () => hT,
	TOGGLE_WHATS_NEW_NOTIFICATIONS: () => b1,
	UNHANDLED_ERRORS_WHILE_PLAYING: () => eT,
	UPDATE_GLOBALS: () => Qf,
	UPDATE_QUERY_PARAMS: () => mT,
	UPDATE_STORY_ARGS: () => Zf,
	default: () => XL
});
var zf = ((e) => (
		(e.CHANNEL_WS_DISCONNECT = 'channelWSDisconnect'),
		(e.CHANNEL_CREATED = 'channelCreated'),
		(e.CONFIG_ERROR = 'configError'),
		(e.STORY_INDEX_INVALIDATED = 'storyIndexInvalidated'),
		(e.STORY_SPECIFIED = 'storySpecified'),
		(e.SET_CONFIG = 'setConfig'),
		(e.SET_STORIES = 'setStories'),
		(e.SET_INDEX = 'setIndex'),
		(e.SET_CURRENT_STORY = 'setCurrentStory'),
		(e.CURRENT_STORY_WAS_SET = 'currentStoryWasSet'),
		(e.FORCE_RE_RENDER = 'forceReRender'),
		(e.FORCE_REMOUNT = 'forceRemount'),
		(e.PRELOAD_ENTRIES = 'preloadStories'),
		(e.STORY_PREPARED = 'storyPrepared'),
		(e.DOCS_PREPARED = 'docsPrepared'),
		(e.STORY_CHANGED = 'storyChanged'),
		(e.STORY_UNCHANGED = 'storyUnchanged'),
		(e.STORY_RENDERED = 'storyRendered'),
		(e.STORY_FINISHED = 'storyFinished'),
		(e.STORY_MISSING = 'storyMissing'),
		(e.STORY_ERRORED = 'storyErrored'),
		(e.STORY_THREW_EXCEPTION = 'storyThrewException'),
		(e.STORY_RENDER_PHASE_CHANGED = 'storyRenderPhaseChanged'),
		(e.STORY_HOT_UPDATED = 'storyHotUpdated'),
		(e.PLAY_FUNCTION_THREW_EXCEPTION = 'playFunctionThrewException'),
		(e.UNHANDLED_ERRORS_WHILE_PLAYING = 'unhandledErrorsWhilePlaying'),
		(e.UPDATE_STORY_ARGS = 'updateStoryArgs'),
		(e.STORY_ARGS_UPDATED = 'storyArgsUpdated'),
		(e.RESET_STORY_ARGS = 'resetStoryArgs'),
		(e.SET_FILTER = 'setFilter'),
		(e.SET_GLOBALS = 'setGlobals'),
		(e.UPDATE_GLOBALS = 'updateGlobals'),
		(e.GLOBALS_UPDATED = 'globalsUpdated'),
		(e.REGISTER_SUBSCRIPTION = 'registerSubscription'),
		(e.PREVIEW_INITIALIZED = 'previewInitialized'),
		(e.PREVIEW_KEYDOWN = 'previewKeydown'),
		(e.PREVIEW_BUILDER_PROGRESS = 'preview_builder_progress'),
		(e.SELECT_STORY = 'selectStory'),
		(e.STORIES_COLLAPSE_ALL = 'storiesCollapseAll'),
		(e.STORIES_EXPAND_ALL = 'storiesExpandAll'),
		(e.DOCS_RENDERED = 'docsRendered'),
		(e.SHARED_STATE_CHANGED = 'sharedStateChanged'),
		(e.SHARED_STATE_SET = 'sharedStateSet'),
		(e.NAVIGATE_URL = 'navigateUrl'),
		(e.UPDATE_QUERY_PARAMS = 'updateQueryParams'),
		(e.REQUEST_WHATS_NEW_DATA = 'requestWhatsNewData'),
		(e.RESULT_WHATS_NEW_DATA = 'resultWhatsNewData'),
		(e.SET_WHATS_NEW_CACHE = 'setWhatsNewCache'),
		(e.TOGGLE_WHATS_NEW_NOTIFICATIONS = 'toggleWhatsNewNotifications'),
		(e.TELEMETRY_ERROR = 'telemetryError'),
		(e.FILE_COMPONENT_SEARCH_REQUEST = 'fileComponentSearchRequest'),
		(e.FILE_COMPONENT_SEARCH_RESPONSE = 'fileComponentSearchResponse'),
		(e.SAVE_STORY_REQUEST = 'saveStoryRequest'),
		(e.SAVE_STORY_RESPONSE = 'saveStoryResponse'),
		(e.ARGTYPES_INFO_REQUEST = 'argtypesInfoRequest'),
		(e.ARGTYPES_INFO_RESPONSE = 'argtypesInfoResponse'),
		(e.CREATE_NEW_STORYFILE_REQUEST = 'createNewStoryfileRequest'),
		(e.CREATE_NEW_STORYFILE_RESPONSE = 'createNewStoryfileResponse'),
		(e.OPEN_IN_EDITOR_REQUEST = 'openInEditorRequest'),
		(e.OPEN_IN_EDITOR_RESPONSE = 'openInEditorResponse'),
		e
	))(zf || {}),
	XL = zf,
	{
		CHANNEL_WS_DISCONNECT: YE,
		CHANNEL_CREATED: QL,
		CONFIG_ERROR: XE,
		CREATE_NEW_STORYFILE_REQUEST: ZL,
		CREATE_NEW_STORYFILE_RESPONSE: e1,
		CURRENT_STORY_WAS_SET: Nd,
		DOCS_PREPARED: QE,
		DOCS_RENDERED: Wf,
		FILE_COMPONENT_SEARCH_REQUEST: t1,
		FILE_COMPONENT_SEARCH_RESPONSE: r1,
		FORCE_RE_RENDER: Kf,
		FORCE_REMOUNT: fl,
		GLOBALS_UPDATED: $s,
		NAVIGATE_URL: n1,
		PLAY_FUNCTION_THREW_EXCEPTION: ZE,
		UNHANDLED_ERRORS_WHILE_PLAYING: eT,
		PRELOAD_ENTRIES: tT,
		PREVIEW_INITIALIZED: rT,
		PREVIEW_BUILDER_PROGRESS: o1,
		PREVIEW_KEYDOWN: nT,
		REGISTER_SUBSCRIPTION: i1,
		RESET_STORY_ARGS: Yf,
		SELECT_STORY: s1,
		SET_CONFIG: a1,
		SET_CURRENT_STORY: Xf,
		SET_FILTER: l1,
		SET_GLOBALS: oT,
		SET_INDEX: u1,
		SET_STORIES: c1,
		SHARED_STATE_CHANGED: d1,
		SHARED_STATE_SET: p1,
		STORIES_COLLAPSE_ALL: f1,
		STORIES_EXPAND_ALL: m1,
		STORY_ARGS_UPDATED: iT,
		STORY_CHANGED: sT,
		STORY_ERRORED: aT,
		STORY_INDEX_INVALIDATED: lT,
		STORY_MISSING: Md,
		STORY_PREPARED: uT,
		STORY_RENDER_PHASE_CHANGED: fo,
		STORY_RENDERED: ml,
		STORY_FINISHED: qd,
		STORY_SPECIFIED: cT,
		STORY_THREW_EXCEPTION: dT,
		STORY_UNCHANGED: pT,
		STORY_HOT_UPDATED: fT,
		UPDATE_GLOBALS: Qf,
		UPDATE_QUERY_PARAMS: mT,
		UPDATE_STORY_ARGS: Zf,
		REQUEST_WHATS_NEW_DATA: h1,
		RESULT_WHATS_NEW_DATA: y1,
		SET_WHATS_NEW_CACHE: g1,
		TOGGLE_WHATS_NEW_NOTIFICATIONS: b1,
		TELEMETRY_ERROR: hT,
		SAVE_STORY_REQUEST: v1,
		SAVE_STORY_RESPONSE: E1,
		ARGTYPES_INFO_REQUEST: yT,
		ARGTYPES_INFO_RESPONSE: jd,
		OPEN_IN_EDITOR_REQUEST: T1,
		OPEN_IN_EDITOR_RESPONSE: _1
	} = zf,
	gT = {};
Lt(gT, { global: () => te });
var te = (() => {
		let e;
		return (
			typeof window < 'u'
				? (e = window)
				: typeof globalThis < 'u'
					? (e = globalThis)
					: typeof global < 'u'
						? (e = global)
						: typeof self < 'u'
							? (e = self)
							: (e = {}),
			e
		);
	})(),
	bT = {
		'@storybook/global': '__STORYBOOK_MODULE_GLOBAL__',
		'storybook/test': '__STORYBOOK_MODULE_TEST__',
		'storybook/actions': '__STORYBOOK_MODULE_ACTIONS__',
		'storybook/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__',
		'storybook/internal/channels': '__STORYBOOK_MODULE_CHANNELS__',
		'storybook/internal/client-logger': '__STORYBOOK_MODULE_CLIENT_LOGGER__',
		'storybook/internal/core-events': '__STORYBOOK_MODULE_CORE_EVENTS__',
		'storybook/internal/preview-errors': '__STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__',
		'storybook/internal/types': '__STORYBOOK_MODULE_TYPES__',
		'storybook/internal/preview-api': '__STORYBOOK_MODULE_PREVIEW_API__'
	},
	w1 = Object.keys(bT),
	vT = {};
Lt(vT, {
	Channel: () => pu,
	HEARTBEAT_INTERVAL: () => x_,
	HEARTBEAT_MAX_LATENCY: () => I_,
	PostMessageTransport: () => C_,
	WebsocketTransport: () => M_,
	createBrowserChannel: () => q_,
	default: () => WB
});
function Ee(e) {
	for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
	var n = Array.from(typeof e == 'string' ? [e] : e);
	n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '');
	var o = n.reduce(function (u, c) {
		var d = c.match(/\n([\t ]+|(?!\s).)/g);
		return d
			? u.concat(
					d.map(function (p) {
						var f, m;
						return (m = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !==
							null && m !== void 0
							? m
							: 0;
					})
				)
			: u;
	}, []);
	if (o.length) {
		var s = new RegExp(
			`
[	 ]{` +
				Math.min.apply(Math, o) +
				'}',
			'g'
		);
		n = n.map(function (u) {
			return u.replace(
				s,
				`
`
			);
		});
	}
	n[0] = n[0].replace(/^\r?\n/, '');
	var a = n[0];
	return (
		t.forEach(function (u, c) {
			var d = a.match(/(?:^|\n)( *)$/),
				p = d ? d[1] : '',
				f = u;
			(typeof u == 'string' &&
				u.includes(`
`) &&
				(f = String(u)
					.split(
						`
`
					)
					.map(function (m, y) {
						return y === 0 ? m : '' + p + m;
					}).join(`
`)),
				(a += f + n[c + 1]));
		}),
		a
	);
}
i(Ee, 'dedent');
var Eb = new Map(),
	S1 = 'UNIVERSAL_STORE:',
	Qt = { PENDING: 'PENDING', RESOLVED: 'RESOLVED', REJECTED: 'REJECTED' },
	kn = class me {
		constructor(t, r) {
			if (
				((this.debugging = !1),
				(this.listeners = new Map([['*', new Set()]])),
				(this.getState = i(
					() => (this.debug('getState', { state: this.state }), this.state),
					'getState'
				)),
				(this.subscribe = i((n, o) => {
					const s = typeof n == 'function',
						a = s ? '*' : n,
						u = s ? n : o;
					if ((this.debug('subscribe', { eventType: a, listener: u }), !u))
						throw new TypeError(
							`Missing first subscribe argument, or second if first is the event type, when subscribing to a UniversalStore with id '${this.id}'`
						);
					return (
						this.listeners.has(a) || this.listeners.set(a, new Set()),
						this.listeners.get(a).add(u),
						() => {
							(this.debug('unsubscribe', { eventType: a, listener: u }),
								this.listeners.has(a) &&
									(this.listeners.get(a).delete(u),
									this.listeners.get(a)?.size === 0 && this.listeners.delete(a)));
						}
					);
				}, 'subscribe')),
				(this.send = i((n) => {
					if ((this.debug('send', { event: n }), this.status !== me.Status.READY))
						throw new TypeError(Ee`Cannot send event before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ event: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
					(this.emitToListeners(n, { actor: this.actor }),
						this.emitToChannel(n, { actor: this.actor }));
				}, 'send')),
				(this.debugging = t.debug ?? !1),
				!me.isInternalConstructing)
			)
				throw new TypeError(
					'UniversalStore is not constructable - use UniversalStore.create() instead'
				);
			if (
				((me.isInternalConstructing = !1),
				(this.id = t.id),
				(this.actorId = Date.now().toString(36) + Math.random().toString(36).substring(2)),
				(this.actorType = t.leader ? me.ActorType.LEADER : me.ActorType.FOLLOWER),
				(this.state = t.initialState),
				(this.channelEventName = `${S1}${this.id}`),
				this.debug('constructor', {
					options: t,
					environmentOverrides: r,
					channelEventName: this.channelEventName
				}),
				this.actor.type === me.ActorType.LEADER)
			)
				this.syncing = { state: Qt.RESOLVED, promise: Promise.resolve() };
			else {
				let n, o;
				const s = new Promise((a, u) => {
					((n = i(() => {
						this.syncing.state === Qt.PENDING && ((this.syncing.state = Qt.RESOLVED), a());
					}, 'syncingResolve')),
						(o = i((c) => {
							this.syncing.state === Qt.PENDING && ((this.syncing.state = Qt.REJECTED), u(c));
						}, 'syncingReject')));
				});
				this.syncing = { state: Qt.PENDING, promise: s, resolve: n, reject: o };
			}
			((this.getState = this.getState.bind(this)),
				(this.setState = this.setState.bind(this)),
				(this.subscribe = this.subscribe.bind(this)),
				(this.onStateChange = this.onStateChange.bind(this)),
				(this.send = this.send.bind(this)),
				(this.emitToChannel = this.emitToChannel.bind(this)),
				(this.prepareThis = this.prepareThis.bind(this)),
				(this.emitToListeners = this.emitToListeners.bind(this)),
				(this.handleChannelEvents = this.handleChannelEvents.bind(this)),
				(this.debug = this.debug.bind(this)),
				(this.channel = r?.channel ?? me.preparation.channel),
				(this.environment = r?.environment ?? me.preparation.environment),
				this.channel && this.environment
					? (me.preparation.resolve({ channel: this.channel, environment: this.environment }),
						this.prepareThis({ channel: this.channel, environment: this.environment }))
					: me.preparation.promise.then(this.prepareThis));
		}
		static setupPreparationPromise() {
			let t, r;
			const n = new Promise((o, s) => {
				((t = i((a) => {
					o(a);
				}, 'resolveRef')),
					(r = i((...a) => {
						s(a);
					}, 'rejectRef')));
			});
			me.preparation = { resolve: t, reject: r, promise: n };
		}
		get actor() {
			return Object.freeze({
				id: this.actorId,
				type: this.actorType,
				environment: this.environment ?? me.Environment.UNKNOWN
			});
		}
		get status() {
			if (!this.channel || !this.environment) return me.Status.UNPREPARED;
			switch (this.syncing?.state) {
				case Qt.PENDING:
				case void 0:
					return me.Status.SYNCING;
				case Qt.REJECTED:
					return me.Status.ERROR;
				case Qt.RESOLVED:
				default:
					return me.Status.READY;
			}
		}
		untilReady() {
			return Promise.all([me.preparation.promise, this.syncing?.promise]);
		}
		static create(t) {
			if (!t || typeof t?.id != 'string')
				throw new TypeError('id is required and must be a string, when creating a UniversalStore');
			t.debug &&
				console.debug(
					Ee`[UniversalStore]
        create`,
					{ options: t }
				);
			const r = Eb.get(t.id);
			if (r)
				return (
					console.warn(Ee`UniversalStore with id "${t.id}" already exists in this environment, re-using existing.
        You should reuse the existing instance instead of trying to create a new one.`),
					r
				);
			me.isInternalConstructing = !0;
			const n = new me(t);
			return (Eb.set(t.id, n), n);
		}
		static __prepare(t, r) {
			((me.preparation.channel = t),
				(me.preparation.environment = r),
				me.preparation.resolve({ channel: t, environment: r }));
		}
		setState(t) {
			const r = this.state,
				n = typeof t == 'function' ? t(r) : t;
			if (
				(this.debug('setState', { newState: n, previousState: r, updater: t }),
				this.status !== me.Status.READY)
			)
				throw new TypeError(Ee`Cannot set state before store is ready. You can get the current status with store.status,
        or await store.readyPromise to wait for the store to be ready before sending events.
        ${JSON.stringify({ newState: n, id: this.id, actor: this.actor, environment: this.environment }, null, 2)}`);
			this.state = n;
			const o = { type: me.InternalEventType.SET_STATE, payload: { state: n, previousState: r } };
			(this.emitToChannel(o, { actor: this.actor }),
				this.emitToListeners(o, { actor: this.actor }));
		}
		onStateChange(t) {
			return (
				this.debug('onStateChange', { listener: t }),
				this.subscribe(me.InternalEventType.SET_STATE, ({ payload: r }, n) => {
					t(r.state, r.previousState, n);
				})
			);
		}
		emitToChannel(t, r) {
			(this.debug('emitToChannel', { event: t, eventInfo: r, channel: !!this.channel }),
				this.channel?.emit(this.channelEventName, { event: t, eventInfo: r }));
		}
		prepareThis({ channel: t, environment: r }) {
			((this.channel = t),
				(this.environment = r),
				this.debug('prepared', { channel: !!t, environment: r }),
				this.channel.on(this.channelEventName, this.handleChannelEvents),
				this.actor.type === me.ActorType.LEADER
					? this.emitToChannel({ type: me.InternalEventType.LEADER_CREATED }, { actor: this.actor })
					: (this.emitToChannel(
							{ type: me.InternalEventType.FOLLOWER_CREATED },
							{ actor: this.actor }
						),
						this.emitToChannel(
							{ type: me.InternalEventType.EXISTING_STATE_REQUEST },
							{ actor: this.actor }
						),
						setTimeout(() => {
							this.syncing.reject(
								new TypeError(
									`No existing state found for follower with id: '${this.id}'. Make sure a leader with the same id exists before creating a follower.`
								)
							);
						}, 1e3)));
		}
		emitToListeners(t, r) {
			const n = this.listeners.get(t.type),
				o = this.listeners.get('*');
			(this.debug('emitToListeners', {
				event: t,
				eventInfo: r,
				eventTypeListeners: n,
				everythingListeners: o
			}),
				[...(n ?? []), ...(o ?? [])].forEach((s) => s(t, r)));
		}
		handleChannelEvents(t) {
			const { event: r, eventInfo: n } = t;
			if ([n.actor.id, n.forwardingActor?.id].includes(this.actor.id)) {
				this.debug('handleChannelEvents: Ignoring event from self', { channelEvent: t });
				return;
			} else if (
				this.syncing?.state === Qt.PENDING &&
				r.type !== me.InternalEventType.EXISTING_STATE_RESPONSE
			) {
				this.debug('handleChannelEvents: Ignoring event while syncing', { channelEvent: t });
				return;
			}
			if (
				(this.debug('handleChannelEvents', { channelEvent: t }),
				this.actor.type === me.ActorType.LEADER)
			) {
				let o = !0;
				switch (r.type) {
					case me.InternalEventType.EXISTING_STATE_REQUEST:
						o = !1;
						const s = { type: me.InternalEventType.EXISTING_STATE_RESPONSE, payload: this.state };
						(this.debug('handleChannelEvents: responding to existing state request', {
							responseEvent: s
						}),
							this.emitToChannel(s, { actor: this.actor }),
							this.emitToListeners(s, { actor: this.actor }));
						break;
					case me.InternalEventType.LEADER_CREATED:
						((o = !1),
							(this.syncing.state = Qt.REJECTED),
							this.debug('handleChannelEvents: erroring due to second leader being created', {
								event: r
							}),
							console.error(Ee`Detected multiple UniversalStore leaders created with the same id "${this.id}".
            Only one leader can exists at a time, your stores are now in an invalid state.
            Leaders detected:
            this: ${JSON.stringify(this.actor, null, 2)}
            other: ${JSON.stringify(n.actor, null, 2)}`));
						break;
				}
				o &&
					(this.debug('handleChannelEvents: forwarding event', { channelEvent: t }),
					this.emitToChannel(r, { actor: n.actor, forwardingActor: this.actor }));
			}
			if (this.actor.type === me.ActorType.FOLLOWER)
				switch (r.type) {
					case me.InternalEventType.EXISTING_STATE_RESPONSE:
						if (
							(this.debug(
								"handleChannelEvents: Setting state from leader's existing state response",
								{ event: r }
							),
							this.syncing?.state !== Qt.PENDING)
						)
							break;
						this.syncing.resolve?.();
						const o = {
							type: me.InternalEventType.SET_STATE,
							payload: { state: r.payload, previousState: this.state }
						};
						((this.state = r.payload), this.emitToListeners(o, n));
						break;
				}
			switch (r.type) {
				case me.InternalEventType.SET_STATE:
					(this.debug('handleChannelEvents: Setting state', { event: r }),
						(this.state = r.payload.state));
					break;
			}
			this.emitToListeners(r, { actor: n.actor });
		}
		debug(t, r) {
			this.debugging &&
				console.debug(
					Ee`[UniversalStore::${this.id}::${this.environment ?? me.Environment.UNKNOWN}]
        ${t}`,
					JSON.stringify(
						{ data: r, actor: this.actor, state: this.state, status: this.status },
						null,
						2
					)
				);
		}
		static __reset() {
			(me.preparation.reject(new Error('reset')),
				me.setupPreparationPromise(),
				(me.isInternalConstructing = !1));
		}
	};
i(kn, 'UniversalStore');
kn.ActorType = { LEADER: 'LEADER', FOLLOWER: 'FOLLOWER' };
kn.Environment = {
	SERVER: 'SERVER',
	MANAGER: 'MANAGER',
	PREVIEW: 'PREVIEW',
	UNKNOWN: 'UNKNOWN',
	MOCK: 'MOCK'
};
kn.InternalEventType = {
	EXISTING_STATE_REQUEST: '__EXISTING_STATE_REQUEST',
	EXISTING_STATE_RESPONSE: '__EXISTING_STATE_RESPONSE',
	SET_STATE: '__SET_STATE',
	LEADER_CREATED: '__LEADER_CREATED',
	FOLLOWER_CREATED: '__FOLLOWER_CREATED'
};
kn.Status = { UNPREPARED: 'UNPREPARED', SYNCING: 'SYNCING', READY: 'READY', ERROR: 'ERROR' };
kn.isInternalConstructing = !1;
kn.setupPreparationPromise();
var td = kn,
	R1 = i((e) => e.transports !== void 0, 'isMulti'),
	P1 = i(() => Math.random().toString(16).slice(2), 'generateRandomId'),
	ET = class {
		constructor(t = {}) {
			((this.sender = P1()),
				(this.events = {}),
				(this.data = {}),
				(this.transports = []),
				(this.isAsync = t.async || !1),
				R1(t)
					? ((this.transports = t.transports || []),
						this.transports.forEach((r) => {
							r.setHandler((n) => this.handleEvent(n));
						}))
					: (this.transports = t.transport ? [t.transport] : []),
				this.transports.forEach((r) => {
					r.setHandler((n) => this.handleEvent(n));
				}));
		}
		get hasTransport() {
			return this.transports.length > 0;
		}
		addListener(t, r) {
			((this.events[t] = this.events[t] || []), this.events[t].push(r));
		}
		emit(t, ...r) {
			const n = { type: t, args: r, from: this.sender };
			let o = {};
			r.length >= 1 && r[0] && r[0].options && (o = r[0].options);
			const s = i(() => {
				(this.transports.forEach((a) => {
					a.send(n, o);
				}),
					this.handleEvent(n));
			}, 'handler');
			this.isAsync ? setImmediate(s) : s();
		}
		last(t) {
			return this.data[t];
		}
		eventNames() {
			return Object.keys(this.events);
		}
		listenerCount(t) {
			const r = this.listeners(t);
			return r ? r.length : 0;
		}
		listeners(t) {
			return this.events[t] || void 0;
		}
		once(t, r) {
			const n = this.onceListener(t, r);
			this.addListener(t, n);
		}
		removeAllListeners(t) {
			t ? this.events[t] && delete this.events[t] : (this.events = {});
		}
		removeListener(t, r) {
			const n = this.listeners(t);
			n && (this.events[t] = n.filter((o) => o !== r));
		}
		on(t, r) {
			this.addListener(t, r);
		}
		off(t, r) {
			this.removeListener(t, r);
		}
		handleEvent(t) {
			const r = this.listeners(t.type);
			(r &&
				r.length &&
				r.forEach((n) => {
					n.apply(t, t.args);
				}),
				(this.data[t.type] = t.args));
		}
		onceListener(t, r) {
			const n = i((...o) => (this.removeListener(t, n), r(...o)), 'onceListener');
			return n;
		}
	};
i(ET, 'Channel');
var pu = ET,
	TT = {};
Lt(TT, { deprecate: () => em, logger: () => Je, once: () => Ye, pretty: () => Wt });
var { LOGLEVEL: A1 } = te,
	gn = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 },
	O1 = A1,
	jo = gn[O1] || gn.info,
	Je = {
		trace: i((e, ...t) => {
			jo <= gn.trace && console.trace(e, ...t);
		}, 'trace'),
		debug: i((e, ...t) => {
			jo <= gn.debug && console.debug(e, ...t);
		}, 'debug'),
		info: i((e, ...t) => {
			jo <= gn.info && console.info(e, ...t);
		}, 'info'),
		warn: i((e, ...t) => {
			jo <= gn.warn && console.warn(e, ...t);
		}, 'warn'),
		error: i((e, ...t) => {
			jo <= gn.error && console.error(e, ...t);
		}, 'error'),
		log: i((e, ...t) => {
			jo < gn.silent && console.log(e, ...t);
		}, 'log')
	},
	Dd = new Set(),
	Ye = i(
		(e) =>
			(t, ...r) => {
				if (!Dd.has(t)) return (Dd.add(t), Je[e](t, ...r));
			},
		'once'
	);
Ye.clear = () => Dd.clear();
Ye.trace = Ye('trace');
Ye.debug = Ye('debug');
Ye.info = Ye('info');
Ye.warn = Ye('warn');
Ye.error = Ye('error');
Ye.log = Ye('log');
var em = Ye('warn'),
	Wt = i(
		(e) =>
			(...t) => {
				const r = [];
				if (t.length) {
					const n = /<span\s+style=(['"])([^'"]*)\1\s*>/gi,
						o = /<\/span>/gi;
					let s;
					for (r.push(t[0].replace(n, '%c').replace(o, '%c')); (s = n.exec(t[0])); )
						(r.push(s[2]), r.push(''));
					for (let a = 1; a < t.length; a++) r.push(t[a]);
				}
				Je[e].apply(Je, r);
			},
		'pretty'
	);
Wt.trace = Wt('trace');
Wt.debug = Wt('debug');
Wt.info = Wt('info');
Wt.warn = Wt('warn');
Wt.error = Wt('error');
var C1 = Object.create,
	_T = Object.defineProperty,
	x1 = Object.getOwnPropertyDescriptor,
	wT = Object.getOwnPropertyNames,
	I1 = Object.getPrototypeOf,
	N1 = Object.prototype.hasOwnProperty,
	be = i(
		(e, t) =>
			i(function () {
				return (t || (0, e[wT(e)[0]])((t = { exports: {} }).exports, t), t.exports);
			}, '__require'),
		'__commonJS'
	),
	M1 = i((e, t, r, n) => {
		if ((t && typeof t == 'object') || typeof t == 'function')
			for (let o of wT(t))
				!N1.call(e, o) &&
					o !== r &&
					_T(e, o, { get: i(() => t[o], 'get'), enumerable: !(n = x1(t, o)) || n.enumerable });
		return e;
	}, '__copyProps'),
	tm = i(
		(e, t, r) => (
			(r = e != null ? C1(I1(e)) : {}),
			M1(t || !e || !e.__esModule ? _T(r, 'default', { value: e, enumerable: !0 }) : r, e)
		),
		'__toESM'
	),
	q1 = [
		'bubbles',
		'cancelBubble',
		'cancelable',
		'composed',
		'currentTarget',
		'defaultPrevented',
		'eventPhase',
		'isTrusted',
		'returnValue',
		'srcElement',
		'target',
		'timeStamp',
		'type'
	],
	j1 = ['detail'];
function ST(e) {
	const t = q1.filter((r) => e[r] !== void 0).reduce((r, n) => ((r[n] = e[n]), r), {});
	if (e instanceof CustomEvent) for (const r of j1.filter((n) => e[n] !== void 0)) t[r] = e[r];
	return t;
}
i(ST, 'extractEventHiddenProperties');
var RT = be({
		'node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js'(e, t) {
			t.exports = Object;
		}
	}),
	D1 = be({
		'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js'(e, t) {
			t.exports = Error;
		}
	}),
	k1 = be({
		'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js'(e, t) {
			t.exports = EvalError;
		}
	}),
	L1 = be({
		'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js'(e, t) {
			t.exports = RangeError;
		}
	}),
	F1 = be({
		'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js'(e, t) {
			t.exports = ReferenceError;
		}
	}),
	B1 = be({
		'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js'(e, t) {
			t.exports = SyntaxError;
		}
	}),
	rm = be({
		'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js'(e, t) {
			t.exports = TypeError;
		}
	}),
	J1 = be({
		'node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js'(e, t) {
			t.exports = URIError;
		}
	}),
	$1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js'(e, t) {
			t.exports = Math.abs;
		}
	}),
	U1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js'(e, t) {
			t.exports = Math.floor;
		}
	}),
	V1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js'(e, t) {
			t.exports = Math.max;
		}
	}),
	H1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js'(e, t) {
			t.exports = Math.min;
		}
	}),
	G1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js'(e, t) {
			t.exports = Math.pow;
		}
	}),
	z1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js'(e, t) {
			t.exports = Math.round;
		}
	}),
	W1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js'(e, t) {
			t.exports =
				Number.isNaN ||
				i(function (n) {
					return n !== n;
				}, 'isNaN2');
		}
	}),
	K1 = be({
		'node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js'(e, t) {
			var r = W1();
			t.exports = i(function (o) {
				return r(o) || o === 0 ? o : o < 0 ? -1 : 1;
			}, 'sign');
		}
	}),
	Y1 = be({
		'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js'(e, t) {
			t.exports = Object.getOwnPropertyDescriptor;
		}
	}),
	nm = be({
		'node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js'(e, t) {
			var r = Y1();
			if (r)
				try {
					r([], 'length');
				} catch {
					r = null;
				}
			t.exports = r;
		}
	}),
	X1 = be({
		'node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js'(e, t) {
			var r = Object.defineProperty || !1;
			if (r)
				try {
					r({}, 'a', { value: 1 });
				} catch {
					r = !1;
				}
			t.exports = r;
		}
	}),
	PT = be({
		'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js'(e, t) {
			t.exports = i(function () {
				if (typeof Symbol != 'function' || typeof Object.getOwnPropertySymbols != 'function')
					return !1;
				if (typeof Symbol.iterator == 'symbol') return !0;
				var n = {},
					o = Symbol('test'),
					s = Object(o);
				if (
					typeof o == 'string' ||
					Object.prototype.toString.call(o) !== '[object Symbol]' ||
					Object.prototype.toString.call(s) !== '[object Symbol]'
				)
					return !1;
				var a = 42;
				n[o] = a;
				for (var u in n) return !1;
				if (
					(typeof Object.keys == 'function' && Object.keys(n).length !== 0) ||
					(typeof Object.getOwnPropertyNames == 'function' &&
						Object.getOwnPropertyNames(n).length !== 0)
				)
					return !1;
				var c = Object.getOwnPropertySymbols(n);
				if (c.length !== 1 || c[0] !== o || !Object.prototype.propertyIsEnumerable.call(n, o))
					return !1;
				if (typeof Object.getOwnPropertyDescriptor == 'function') {
					var d = Object.getOwnPropertyDescriptor(n, o);
					if (d.value !== a || d.enumerable !== !0) return !1;
				}
				return !0;
			}, 'hasSymbols');
		}
	}),
	AT = be({
		'node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js'(e, t) {
			var r = typeof Symbol < 'u' && Symbol,
				n = PT();
			t.exports = i(function () {
				return typeof r != 'function' ||
					typeof Symbol != 'function' ||
					typeof r('foo') != 'symbol' ||
					typeof Symbol('bar') != 'symbol'
					? !1
					: n();
			}, 'hasNativeSymbols');
		}
	}),
	OT = be({
		'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js'(e, t) {
			t.exports = (typeof Reflect < 'u' && Reflect.getPrototypeOf) || null;
		}
	}),
	CT = be({
		'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js'(e, t) {
			var r = RT();
			t.exports = r.getPrototypeOf || null;
		}
	}),
	Q1 = be({
		'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js'(e, t) {
			var r = 'Function.prototype.bind called on incompatible ',
				n = Object.prototype.toString,
				o = Math.max,
				s = '[object Function]',
				a = i(function (p, f) {
					for (var m = [], y = 0; y < p.length; y += 1) m[y] = p[y];
					for (var g = 0; g < f.length; g += 1) m[g + p.length] = f[g];
					return m;
				}, 'concatty2'),
				u = i(function (p, f) {
					for (var m = [], y = f || 0, g = 0; y < p.length; y += 1, g += 1) m[g] = p[y];
					return m;
				}, 'slicy2'),
				c = i(function (d, p) {
					for (var f = '', m = 0; m < d.length; m += 1) ((f += d[m]), m + 1 < d.length && (f += p));
					return f;
				}, 'joiny');
			t.exports = i(function (p) {
				var f = this;
				if (typeof f != 'function' || n.apply(f) !== s) throw new TypeError(r + f);
				for (
					var m = u(arguments, 1),
						y,
						g = i(function () {
							if (this instanceof y) {
								var P = f.apply(this, a(m, arguments));
								return Object(P) === P ? P : this;
							}
							return f.apply(p, a(m, arguments));
						}, 'binder'),
						E = o(0, f.length - m.length),
						T = [],
						b = 0;
					b < E;
					b++
				)
					T[b] = '$' + b;
				if (
					((y = Function(
						'binder',
						'return function (' + c(T, ',') + '){ return binder.apply(this,arguments); }'
					)(g)),
					f.prototype)
				) {
					var w = i(function () {}, 'Empty2');
					((w.prototype = f.prototype), (y.prototype = new w()), (w.prototype = null));
				}
				return y;
			}, 'bind');
		}
	}),
	fu = be({
		'node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js'(e, t) {
			var r = Q1();
			t.exports = Function.prototype.bind || r;
		}
	}),
	om = be({
		'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js'(
			e,
			t
		) {
			t.exports = Function.prototype.call;
		}
	}),
	xT = be({
		'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js'(
			e,
			t
		) {
			t.exports = Function.prototype.apply;
		}
	}),
	Z1 = be({
		'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js'(
			e,
			t
		) {
			t.exports = typeof Reflect < 'u' && Reflect && Reflect.apply;
		}
	}),
	eF = be({
		'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js'(
			e,
			t
		) {
			var r = fu(),
				n = xT(),
				o = om(),
				s = Z1();
			t.exports = s || r.call(o, n);
		}
	}),
	IT = be({
		'node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js'(
			e,
			t
		) {
			var r = fu(),
				n = rm(),
				o = om(),
				s = eF();
			t.exports = i(function (u) {
				if (u.length < 1 || typeof u[0] != 'function') throw new n('a function is required');
				return s(r, o, u);
			}, 'callBindBasic');
		}
	}),
	tF = be({
		'node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js'(e, t) {
			var r = IT(),
				n = nm(),
				o;
			try {
				o = [].__proto__ === Array.prototype;
			} catch (c) {
				if (!c || typeof c != 'object' || !('code' in c) || c.code !== 'ERR_PROTO_ACCESS') throw c;
			}
			var s = !!o && n && n(Object.prototype, '__proto__'),
				a = Object,
				u = a.getPrototypeOf;
			t.exports =
				s && typeof s.get == 'function'
					? r([s.get])
					: typeof u == 'function'
						? i(function (d) {
								return u(d == null ? d : a(d));
							}, 'getDunder')
						: !1;
		}
	}),
	rF = be({
		'node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js'(e, t) {
			var r = OT(),
				n = CT(),
				o = tF();
			t.exports = r
				? i(function (a) {
						return r(a);
					}, 'getProto')
				: n
					? i(function (a) {
							if (!a || (typeof a != 'object' && typeof a != 'function'))
								throw new TypeError('getProto: not an object');
							return n(a);
						}, 'getProto')
					: o
						? i(function (a) {
								return o(a);
							}, 'getProto')
						: null;
		}
	}),
	NT = be({
		'node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js'(e, t) {
			var r = Function.prototype.call,
				n = Object.prototype.hasOwnProperty,
				o = fu();
			t.exports = o.call(r, n);
		}
	}),
	nF = be({
		'node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js'(e, t) {
			var r,
				n = RT(),
				o = D1(),
				s = k1(),
				a = L1(),
				u = F1(),
				c = B1(),
				d = rm(),
				p = J1(),
				f = $1(),
				m = U1(),
				y = V1(),
				g = H1(),
				E = G1(),
				T = z1(),
				b = K1(),
				w = Function,
				P = i(function ($) {
					try {
						return w('"use strict"; return (' + $ + ').constructor;')();
					} catch {}
				}, 'getEvalledConstructor'),
				I = nm(),
				q = X1(),
				C = i(function () {
					throw new d();
				}, 'throwTypeError'),
				R = I
					? (function () {
							try {
								return (arguments.callee, C);
							} catch {
								try {
									return I(arguments, 'callee').get;
								} catch {
									return C;
								}
							}
						})()
					: C,
				_ = AT()(),
				S = rF(),
				D = CT(),
				N = OT(),
				V = xT(),
				H = om(),
				A = {},
				L = typeof Uint8Array > 'u' || !S ? r : S(Uint8Array),
				B = {
					__proto__: null,
					'%AggregateError%': typeof AggregateError > 'u' ? r : AggregateError,
					'%Array%': Array,
					'%ArrayBuffer%': typeof ArrayBuffer > 'u' ? r : ArrayBuffer,
					'%ArrayIteratorPrototype%': _ && S ? S([][Symbol.iterator]()) : r,
					'%AsyncFromSyncIteratorPrototype%': r,
					'%AsyncFunction%': A,
					'%AsyncGenerator%': A,
					'%AsyncGeneratorFunction%': A,
					'%AsyncIteratorPrototype%': A,
					'%Atomics%': typeof Atomics > 'u' ? r : Atomics,
					'%BigInt%': typeof BigInt > 'u' ? r : BigInt,
					'%BigInt64Array%': typeof BigInt64Array > 'u' ? r : BigInt64Array,
					'%BigUint64Array%': typeof BigUint64Array > 'u' ? r : BigUint64Array,
					'%Boolean%': Boolean,
					'%DataView%': typeof DataView > 'u' ? r : DataView,
					'%Date%': Date,
					'%decodeURI%': decodeURI,
					'%decodeURIComponent%': decodeURIComponent,
					'%encodeURI%': encodeURI,
					'%encodeURIComponent%': encodeURIComponent,
					'%Error%': o,
					'%eval%': eval,
					'%EvalError%': s,
					'%Float16Array%': typeof Float16Array > 'u' ? r : Float16Array,
					'%Float32Array%': typeof Float32Array > 'u' ? r : Float32Array,
					'%Float64Array%': typeof Float64Array > 'u' ? r : Float64Array,
					'%FinalizationRegistry%': typeof FinalizationRegistry > 'u' ? r : FinalizationRegistry,
					'%Function%': w,
					'%GeneratorFunction%': A,
					'%Int8Array%': typeof Int8Array > 'u' ? r : Int8Array,
					'%Int16Array%': typeof Int16Array > 'u' ? r : Int16Array,
					'%Int32Array%': typeof Int32Array > 'u' ? r : Int32Array,
					'%isFinite%': isFinite,
					'%isNaN%': isNaN,
					'%IteratorPrototype%': _ && S ? S(S([][Symbol.iterator]())) : r,
					'%JSON%': typeof JSON == 'object' ? JSON : r,
					'%Map%': typeof Map > 'u' ? r : Map,
					'%MapIteratorPrototype%':
						typeof Map > 'u' || !_ || !S ? r : S(new Map()[Symbol.iterator]()),
					'%Math%': Math,
					'%Number%': Number,
					'%Object%': n,
					'%Object.getOwnPropertyDescriptor%': I,
					'%parseFloat%': parseFloat,
					'%parseInt%': parseInt,
					'%Promise%': typeof Promise > 'u' ? r : Promise,
					'%Proxy%': typeof Proxy > 'u' ? r : Proxy,
					'%RangeError%': a,
					'%ReferenceError%': u,
					'%Reflect%': typeof Reflect > 'u' ? r : Reflect,
					'%RegExp%': RegExp,
					'%Set%': typeof Set > 'u' ? r : Set,
					'%SetIteratorPrototype%':
						typeof Set > 'u' || !_ || !S ? r : S(new Set()[Symbol.iterator]()),
					'%SharedArrayBuffer%': typeof SharedArrayBuffer > 'u' ? r : SharedArrayBuffer,
					'%String%': String,
					'%StringIteratorPrototype%': _ && S ? S(''[Symbol.iterator]()) : r,
					'%Symbol%': _ ? Symbol : r,
					'%SyntaxError%': c,
					'%ThrowTypeError%': R,
					'%TypedArray%': L,
					'%TypeError%': d,
					'%Uint8Array%': typeof Uint8Array > 'u' ? r : Uint8Array,
					'%Uint8ClampedArray%': typeof Uint8ClampedArray > 'u' ? r : Uint8ClampedArray,
					'%Uint16Array%': typeof Uint16Array > 'u' ? r : Uint16Array,
					'%Uint32Array%': typeof Uint32Array > 'u' ? r : Uint32Array,
					'%URIError%': p,
					'%WeakMap%': typeof WeakMap > 'u' ? r : WeakMap,
					'%WeakRef%': typeof WeakRef > 'u' ? r : WeakRef,
					'%WeakSet%': typeof WeakSet > 'u' ? r : WeakSet,
					'%Function.prototype.call%': H,
					'%Function.prototype.apply%': V,
					'%Object.defineProperty%': q,
					'%Object.getPrototypeOf%': D,
					'%Math.abs%': f,
					'%Math.floor%': m,
					'%Math.max%': y,
					'%Math.min%': g,
					'%Math.pow%': E,
					'%Math.round%': T,
					'%Math.sign%': b,
					'%Reflect.getPrototypeOf%': N
				};
			if (S)
				try {
					null.error;
				} catch ($) {
					((k = S(S($))), (B['%Error.prototype%'] = k));
				}
			var k,
				K = i(function $(Q) {
					var re;
					if (Q === '%AsyncFunction%') re = P('async function () {}');
					else if (Q === '%GeneratorFunction%') re = P('function* () {}');
					else if (Q === '%AsyncGeneratorFunction%') re = P('async function* () {}');
					else if (Q === '%AsyncGenerator%') {
						var oe = $('%AsyncGeneratorFunction%');
						oe && (re = oe.prototype);
					} else if (Q === '%AsyncIteratorPrototype%') {
						var ne = $('%AsyncGenerator%');
						ne && S && (re = S(ne.prototype));
					}
					return ((B[Q] = re), re);
				}, 'doEval2'),
				X = {
					__proto__: null,
					'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
					'%ArrayPrototype%': ['Array', 'prototype'],
					'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
					'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
					'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
					'%ArrayProto_values%': ['Array', 'prototype', 'values'],
					'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
					'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
					'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
					'%BooleanPrototype%': ['Boolean', 'prototype'],
					'%DataViewPrototype%': ['DataView', 'prototype'],
					'%DatePrototype%': ['Date', 'prototype'],
					'%ErrorPrototype%': ['Error', 'prototype'],
					'%EvalErrorPrototype%': ['EvalError', 'prototype'],
					'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
					'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
					'%FunctionPrototype%': ['Function', 'prototype'],
					'%Generator%': ['GeneratorFunction', 'prototype'],
					'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
					'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
					'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
					'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
					'%JSONParse%': ['JSON', 'parse'],
					'%JSONStringify%': ['JSON', 'stringify'],
					'%MapPrototype%': ['Map', 'prototype'],
					'%NumberPrototype%': ['Number', 'prototype'],
					'%ObjectPrototype%': ['Object', 'prototype'],
					'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
					'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
					'%PromisePrototype%': ['Promise', 'prototype'],
					'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
					'%Promise_all%': ['Promise', 'all'],
					'%Promise_reject%': ['Promise', 'reject'],
					'%Promise_resolve%': ['Promise', 'resolve'],
					'%RangeErrorPrototype%': ['RangeError', 'prototype'],
					'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
					'%RegExpPrototype%': ['RegExp', 'prototype'],
					'%SetPrototype%': ['Set', 'prototype'],
					'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
					'%StringPrototype%': ['String', 'prototype'],
					'%SymbolPrototype%': ['Symbol', 'prototype'],
					'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
					'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
					'%TypeErrorPrototype%': ['TypeError', 'prototype'],
					'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
					'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
					'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
					'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
					'%URIErrorPrototype%': ['URIError', 'prototype'],
					'%WeakMapPrototype%': ['WeakMap', 'prototype'],
					'%WeakSetPrototype%': ['WeakSet', 'prototype']
				},
				ie = fu(),
				ae = NT(),
				W = ie.call(H, Array.prototype.concat),
				le = ie.call(V, Array.prototype.splice),
				ve = ie.call(H, String.prototype.replace),
				de = ie.call(H, String.prototype.slice),
				ee = ie.call(H, RegExp.prototype.exec),
				xe =
					/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
				Ie = /\\(\\)?/g,
				Xe = i(function (Q) {
					var re = de(Q, 0, 1),
						oe = de(Q, -1);
					if (re === '%' && oe !== '%')
						throw new c('invalid intrinsic syntax, expected closing `%`');
					if (oe === '%' && re !== '%')
						throw new c('invalid intrinsic syntax, expected opening `%`');
					var ne = [];
					return (
						ve(Q, xe, function (pe, ye, fe, ze) {
							ne[ne.length] = fe ? ve(ze, Ie, '$1') : ye || pe;
						}),
						ne
					);
				}, 'stringToPath3'),
				rt = i(function (Q, re) {
					var oe = Q,
						ne;
					if ((ae(X, oe) && ((ne = X[oe]), (oe = '%' + ne[0] + '%')), ae(B, oe))) {
						var pe = B[oe];
						if ((pe === A && (pe = K(oe)), typeof pe > 'u' && !re))
							throw new d(
								'intrinsic ' + Q + ' exists, but is not available. Please file an issue!'
							);
						return { alias: ne, name: oe, value: pe };
					}
					throw new c('intrinsic ' + Q + ' does not exist!');
				}, 'getBaseIntrinsic2');
			t.exports = i(function (Q, re) {
				if (typeof Q != 'string' || Q.length === 0)
					throw new d('intrinsic name must be a non-empty string');
				if (arguments.length > 1 && typeof re != 'boolean')
					throw new d('"allowMissing" argument must be a boolean');
				if (ee(/^%?[^%]*%?$/, Q) === null)
					throw new c(
						'`%` may not be present anywhere but at the beginning and end of the intrinsic name'
					);
				var oe = Xe(Q),
					ne = oe.length > 0 ? oe[0] : '',
					pe = rt('%' + ne + '%', re),
					ye = pe.name,
					fe = pe.value,
					ze = !1,
					pt = pe.alias;
				pt && ((ne = pt[0]), le(oe, W([0, 1], pt)));
				for (var vt = 1, Ft = !0; vt < oe.length; vt += 1) {
					var ft = oe[vt],
						Et = de(ft, 0, 1),
						Tt = de(ft, -1);
					if (
						(Et === '"' || Et === "'" || Et === '`' || Tt === '"' || Tt === "'" || Tt === '`') &&
						Et !== Tt
					)
						throw new c('property names with quotes must have matching quotes');
					if (
						((ft === 'constructor' || !Ft) && (ze = !0),
						(ne += '.' + ft),
						(ye = '%' + ne + '%'),
						ae(B, ye))
					)
						fe = B[ye];
					else if (fe != null) {
						if (!(ft in fe)) {
							if (!re)
								throw new d(
									'base intrinsic for ' + Q + ' exists, but the property is not available.'
								);
							return;
						}
						if (I && vt + 1 >= oe.length) {
							var _t = I(fe, ft);
							((Ft = !!_t),
								Ft && 'get' in _t && !('originalValue' in _t.get) ? (fe = _t.get) : (fe = fe[ft]));
						} else ((Ft = ae(fe, ft)), (fe = fe[ft]));
						Ft && !ze && (B[ye] = fe);
					}
				}
				return fe;
			}, 'GetIntrinsic');
		}
	}),
	im = be({
		'node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js'(e, t) {
			var r = nF(),
				n = IT(),
				o = n([r('%String.prototype.indexOf%')]);
			t.exports = i(function (a, u) {
				var c = r(a, !!u);
				return typeof c == 'function' && o(a, '.prototype.') > -1 ? n([c]) : c;
			}, 'callBoundIntrinsic');
		}
	}),
	oF = be({
		'node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js'(e, t) {
			var r = PT();
			t.exports = i(function () {
				return r() && !!Symbol.toStringTag;
			}, 'hasToStringTagShams');
		}
	}),
	MT = be({
		'node_modules/.pnpm/is-regex@1.2.1/node_modules/is-regex/index.js'(e, t) {
			var r = im(),
				n = oF()(),
				o = NT(),
				s = nm(),
				a;
			n
				? ((u = r('RegExp.prototype.exec')),
					(c = {}),
					(d = i(function () {
						throw c;
					}, 'throwRegexMarker')),
					(p = { toString: d, valueOf: d }),
					typeof Symbol.toPrimitive == 'symbol' && (p[Symbol.toPrimitive] = d),
					(a = i(function (g) {
						if (!g || typeof g != 'object') return !1;
						var E = s(g, 'lastIndex'),
							T = E && o(E, 'value');
						if (!T) return !1;
						try {
							u(g, p);
						} catch (b) {
							return b === c;
						}
					}, 'isRegex')))
				: ((f = r('Object.prototype.toString')),
					(m = '[object RegExp]'),
					(a = i(function (g) {
						return !g || (typeof g != 'object' && typeof g != 'function') ? !1 : f(g) === m;
					}, 'isRegex')));
			var u, c, d, p, f, m;
			t.exports = a;
		}
	}),
	iF = be({
		'node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js'(e, t) {
			t.exports = n;
			var r = Object.prototype.toString;
			function n(o) {
				if (!o) return !1;
				var s = r.call(o);
				return (
					s === '[object Function]' ||
					(typeof o == 'function' && s !== '[object RegExp]') ||
					(typeof window < 'u' &&
						(o === window.setTimeout ||
							o === window.alert ||
							o === window.confirm ||
							o === window.prompt))
				);
			}
			i(n, 'isFunction3');
		}
	}),
	sF = be({
		'node_modules/.pnpm/safe-regex-test@1.1.0/node_modules/safe-regex-test/index.js'(e, t) {
			var r = im(),
				n = MT(),
				o = r('RegExp.prototype.exec'),
				s = rm();
			t.exports = i(function (u) {
				if (!n(u)) throw new s('`regex` must be a RegExp');
				return i(function (d) {
					return o(u, d) !== null;
				}, 'test');
			}, 'regexTester');
		}
	}),
	aF = be({
		'node_modules/.pnpm/is-symbol@1.1.1/node_modules/is-symbol/index.js'(e, t) {
			var r = im(),
				n = r('Object.prototype.toString'),
				o = AT()(),
				s = sF();
			o
				? ((a = r('Symbol.prototype.toString')),
					(u = s(/^Symbol\(.*\)$/)),
					(c = i(function (p) {
						return typeof p.valueOf() != 'symbol' ? !1 : u(a(p));
					}, 'isRealSymbolObject')),
					(t.exports = i(function (p) {
						if (typeof p == 'symbol') return !0;
						if (!p || typeof p != 'object' || n(p) !== '[object Symbol]') return !1;
						try {
							return c(p);
						} catch {
							return !1;
						}
					}, 'isSymbol3')))
				: (t.exports = i(function (p) {
						return !1;
					}, 'isSymbol3'));
			var a, u, c;
		}
	}),
	lF = tm(MT()),
	uF = tm(iF()),
	cF = tm(aF());
function qT(e) {
	return e != null && typeof e == 'object' && Array.isArray(e) === !1;
}
i(qT, 'isObject');
var dF = typeof global == 'object' && global && global.Object === Object && global,
	pF = dF,
	fF = typeof self == 'object' && self && self.Object === Object && self,
	mF = pF || fF || Function('return this')(),
	sm = mF,
	hF = sm.Symbol,
	oi = hF,
	jT = Object.prototype,
	yF = jT.hasOwnProperty,
	gF = jT.toString,
	ds = oi ? oi.toStringTag : void 0;
function DT(e) {
	var t = yF.call(e, ds),
		r = e[ds];
	try {
		e[ds] = void 0;
		var n = !0;
	} catch {}
	var o = gF.call(e);
	return (n && (t ? (e[ds] = r) : delete e[ds]), o);
}
i(DT, 'getRawTag');
var bF = DT,
	vF = Object.prototype,
	EF = vF.toString;
function kT(e) {
	return EF.call(e);
}
i(kT, 'objectToString');
var TF = kT,
	_F = '[object Null]',
	wF = '[object Undefined]',
	Tb = oi ? oi.toStringTag : void 0;
function LT(e) {
	return e == null ? (e === void 0 ? wF : _F) : Tb && Tb in Object(e) ? bF(e) : TF(e);
}
i(LT, 'baseGetTag');
var FT = LT;
function BT(e) {
	return e != null && typeof e == 'object';
}
i(BT, 'isObjectLike');
var SF = BT,
	RF = '[object Symbol]';
function JT(e) {
	return typeof e == 'symbol' || (SF(e) && FT(e) == RF);
}
i(JT, 'isSymbol');
var am = JT;
function $T(e, t) {
	for (var r = -1, n = e == null ? 0 : e.length, o = Array(n); ++r < n; ) o[r] = t(e[r], r, e);
	return o;
}
i($T, 'arrayMap');
var PF = $T,
	AF = Array.isArray,
	lm = AF,
	_b = oi ? oi.prototype : void 0,
	wb = _b ? _b.toString : void 0;
function um(e) {
	if (typeof e == 'string') return e;
	if (lm(e)) return PF(e, um) + '';
	if (am(e)) return wb ? wb.call(e) : '';
	var t = e + '';
	return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
i(um, 'baseToString');
var OF = um;
function UT(e) {
	var t = typeof e;
	return e != null && (t == 'object' || t == 'function');
}
i(UT, 'isObject2');
var VT = UT,
	CF = '[object AsyncFunction]',
	xF = '[object Function]',
	IF = '[object GeneratorFunction]',
	NF = '[object Proxy]';
function HT(e) {
	if (!VT(e)) return !1;
	var t = FT(e);
	return t == xF || t == IF || t == CF || t == NF;
}
i(HT, 'isFunction');
var MF = HT,
	qF = sm['__core-js_shared__'],
	rd = qF,
	Sb = (function () {
		var e = /[^.]+$/.exec((rd && rd.keys && rd.keys.IE_PROTO) || '');
		return e ? 'Symbol(src)_1.' + e : '';
	})();
function GT(e) {
	return !!Sb && Sb in e;
}
i(GT, 'isMasked');
var jF = GT,
	DF = Function.prototype,
	kF = DF.toString;
function zT(e) {
	if (e != null) {
		try {
			return kF.call(e);
		} catch {}
		try {
			return e + '';
		} catch {}
	}
	return '';
}
i(zT, 'toSource');
var LF = zT,
	FF = /[\\^$.*+?()[\]{}|]/g,
	BF = /^\[object .+?Constructor\]$/,
	JF = Function.prototype,
	$F = Object.prototype,
	UF = JF.toString,
	VF = $F.hasOwnProperty,
	HF = RegExp(
		'^' +
			UF.call(VF)
				.replace(FF, '\\$&')
				.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
			'$'
	);
function WT(e) {
	if (!VT(e) || jF(e)) return !1;
	var t = MF(e) ? HF : BF;
	return t.test(LF(e));
}
i(WT, 'baseIsNative');
var GF = WT;
function KT(e, t) {
	return e?.[t];
}
i(KT, 'getValue');
var zF = KT;
function YT(e, t) {
	var r = zF(e, t);
	return GF(r) ? r : void 0;
}
i(YT, 'getNative');
var XT = YT;
function QT(e, t) {
	return e === t || (e !== e && t !== t);
}
i(QT, 'eq');
var WF = QT,
	KF = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	YF = /^\w*$/;
function ZT(e, t) {
	if (lm(e)) return !1;
	var r = typeof e;
	return r == 'number' || r == 'symbol' || r == 'boolean' || e == null || am(e)
		? !0
		: YF.test(e) || !KF.test(e) || (t != null && e in Object(t));
}
i(ZT, 'isKey');
var XF = ZT,
	QF = XT(Object, 'create'),
	Us = QF;
function e_() {
	((this.__data__ = Us ? Us(null) : {}), (this.size = 0));
}
i(e_, 'hashClear');
var ZF = e_;
function t_(e) {
	var t = this.has(e) && delete this.__data__[e];
	return ((this.size -= t ? 1 : 0), t);
}
i(t_, 'hashDelete');
var eB = t_,
	tB = '__lodash_hash_undefined__',
	rB = Object.prototype,
	nB = rB.hasOwnProperty;
function r_(e) {
	var t = this.__data__;
	if (Us) {
		var r = t[e];
		return r === tB ? void 0 : r;
	}
	return nB.call(t, e) ? t[e] : void 0;
}
i(r_, 'hashGet');
var oB = r_,
	iB = Object.prototype,
	sB = iB.hasOwnProperty;
function n_(e) {
	var t = this.__data__;
	return Us ? t[e] !== void 0 : sB.call(t, e);
}
i(n_, 'hashHas');
var aB = n_,
	lB = '__lodash_hash_undefined__';
function o_(e, t) {
	var r = this.__data__;
	return ((this.size += this.has(e) ? 0 : 1), (r[e] = Us && t === void 0 ? lB : t), this);
}
i(o_, 'hashSet');
var uB = o_;
function Ro(e) {
	var t = -1,
		r = e == null ? 0 : e.length;
	for (this.clear(); ++t < r; ) {
		var n = e[t];
		this.set(n[0], n[1]);
	}
}
i(Ro, 'Hash');
Ro.prototype.clear = ZF;
Ro.prototype.delete = eB;
Ro.prototype.get = oB;
Ro.prototype.has = aB;
Ro.prototype.set = uB;
var Rb = Ro;
function i_() {
	((this.__data__ = []), (this.size = 0));
}
i(i_, 'listCacheClear');
var cB = i_;
function s_(e, t) {
	for (var r = e.length; r--; ) if (WF(e[r][0], t)) return r;
	return -1;
}
i(s_, 'assocIndexOf');
var mu = s_,
	dB = Array.prototype,
	pB = dB.splice;
function a_(e) {
	var t = this.__data__,
		r = mu(t, e);
	if (r < 0) return !1;
	var n = t.length - 1;
	return (r == n ? t.pop() : pB.call(t, r, 1), --this.size, !0);
}
i(a_, 'listCacheDelete');
var fB = a_;
function l_(e) {
	var t = this.__data__,
		r = mu(t, e);
	return r < 0 ? void 0 : t[r][1];
}
i(l_, 'listCacheGet');
var mB = l_;
function u_(e) {
	return mu(this.__data__, e) > -1;
}
i(u_, 'listCacheHas');
var hB = u_;
function c_(e, t) {
	var r = this.__data__,
		n = mu(r, e);
	return (n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this);
}
i(c_, 'listCacheSet');
var yB = c_;
function Po(e) {
	var t = -1,
		r = e == null ? 0 : e.length;
	for (this.clear(); ++t < r; ) {
		var n = e[t];
		this.set(n[0], n[1]);
	}
}
i(Po, 'ListCache');
Po.prototype.clear = cB;
Po.prototype.delete = fB;
Po.prototype.get = mB;
Po.prototype.has = hB;
Po.prototype.set = yB;
var gB = Po,
	bB = XT(sm, 'Map'),
	vB = bB;
function d_() {
	((this.size = 0), (this.__data__ = { hash: new Rb(), map: new (vB || gB)(), string: new Rb() }));
}
i(d_, 'mapCacheClear');
var EB = d_;
function p_(e) {
	var t = typeof e;
	return t == 'string' || t == 'number' || t == 'symbol' || t == 'boolean'
		? e !== '__proto__'
		: e === null;
}
i(p_, 'isKeyable');
var TB = p_;
function f_(e, t) {
	var r = e.__data__;
	return TB(t) ? r[typeof t == 'string' ? 'string' : 'hash'] : r.map;
}
i(f_, 'getMapData');
var hu = f_;
function m_(e) {
	var t = hu(this, e).delete(e);
	return ((this.size -= t ? 1 : 0), t);
}
i(m_, 'mapCacheDelete');
var _B = m_;
function h_(e) {
	return hu(this, e).get(e);
}
i(h_, 'mapCacheGet');
var wB = h_;
function y_(e) {
	return hu(this, e).has(e);
}
i(y_, 'mapCacheHas');
var SB = y_;
function g_(e, t) {
	var r = hu(this, e),
		n = r.size;
	return (r.set(e, t), (this.size += r.size == n ? 0 : 1), this);
}
i(g_, 'mapCacheSet');
var RB = g_;
function Ao(e) {
	var t = -1,
		r = e == null ? 0 : e.length;
	for (this.clear(); ++t < r; ) {
		var n = e[t];
		this.set(n[0], n[1]);
	}
}
i(Ao, 'MapCache');
Ao.prototype.clear = EB;
Ao.prototype.delete = _B;
Ao.prototype.get = wB;
Ao.prototype.has = SB;
Ao.prototype.set = RB;
var b_ = Ao,
	PB = 'Expected a function';
function yu(e, t) {
	if (typeof e != 'function' || (t != null && typeof t != 'function')) throw new TypeError(PB);
	var r = i(function () {
		var n = arguments,
			o = t ? t.apply(this, n) : n[0],
			s = r.cache;
		if (s.has(o)) return s.get(o);
		var a = e.apply(this, n);
		return ((r.cache = s.set(o, a) || s), a);
	}, 'memoized');
	return ((r.cache = new (yu.Cache || b_)()), r);
}
i(yu, 'memoize');
yu.Cache = b_;
var AB = yu,
	OB = 500;
function v_(e) {
	var t = AB(e, function (n) {
			return (r.size === OB && r.clear(), n);
		}),
		r = t.cache;
	return t;
}
i(v_, 'memoizeCapped');
var CB = v_,
	xB =
		/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
	IB = /\\(\\)?/g,
	NB = CB(function (e) {
		var t = [];
		return (
			e.charCodeAt(0) === 46 && t.push(''),
			e.replace(xB, function (r, n, o, s) {
				t.push(o ? s.replace(IB, '$1') : n || r);
			}),
			t
		);
	}),
	MB = NB;
function E_(e) {
	return e == null ? '' : OF(e);
}
i(E_, 'toString');
var qB = E_;
function T_(e, t) {
	return lm(e) ? e : XF(e, t) ? [e] : MB(qB(e));
}
i(T_, 'castPath');
var jB = T_;
function __(e) {
	if (typeof e == 'string' || am(e)) return e;
	var t = e + '';
	return t == '0' && 1 / e == -1 / 0 ? '-0' : t;
}
i(__, 'toKey');
var DB = __;
function w_(e, t) {
	t = jB(t, e);
	for (var r = 0, n = t.length; e != null && r < n; ) e = e[DB(t[r++])];
	return r && r == n ? e : void 0;
}
i(w_, 'baseGet');
var kB = w_;
function S_(e, t, r) {
	var n = e == null ? void 0 : kB(e, t);
	return n === void 0 ? r : n;
}
i(S_, 'get');
var LB = S_,
	cm = qT,
	FB = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/,
	dm = i((e) => e.match(/^[\[\{\"\}].*[\]\}\"]$/), 'isJSON');
function pm(e) {
	if (!cm(e)) return e;
	let t = e,
		r = !1;
	return (
		typeof Event < 'u' && e instanceof Event && ((t = ST(t)), (r = !0)),
		(t = Object.keys(t).reduce((n, o) => {
			try {
				(t[o] && t[o].toJSON, (n[o] = t[o]));
			} catch {
				r = !0;
			}
			return n;
		}, {})),
		r ? t : e
	);
}
i(pm, 'convertUnconventionalData');
var BB = i(function (t) {
		let r, n, o, s;
		return i(function (u, c) {
			try {
				if (u === '') return ((s = []), (r = new Map([[c, '[]']])), (n = new Map()), (o = []), c);
				const d = n.get(this) || this;
				for (; o.length && d !== o[0]; ) (o.shift(), s.pop());
				if (typeof c == 'boolean') return c;
				if (c === void 0) return t.allowUndefined ? '_undefined_' : void 0;
				if (c === null) return null;
				if (typeof c == 'number')
					return c === Number.NEGATIVE_INFINITY
						? '_-Infinity_'
						: c === Number.POSITIVE_INFINITY
							? '_Infinity_'
							: Number.isNaN(c)
								? '_NaN_'
								: c;
				if (typeof c == 'bigint') return `_bigint_${c.toString()}`;
				if (typeof c == 'string') return FB.test(c) ? (t.allowDate ? `_date_${c}` : void 0) : c;
				if ((0, lF.default)(c)) return t.allowRegExp ? `_regexp_${c.flags}|${c.source}` : void 0;
				if ((0, uF.default)(c)) return;
				if ((0, cF.default)(c)) {
					if (!t.allowSymbol) return;
					const f = Symbol.keyFor(c);
					return f !== void 0 ? `_gsymbol_${f}` : `_symbol_${c.toString().slice(7, -1)}`;
				}
				if (o.length >= t.maxDepth) return Array.isArray(c) ? `[Array(${c.length})]` : '[Object]';
				if (c === this) return `_duplicate_${JSON.stringify(s)}`;
				if (c instanceof Error && t.allowError)
					return {
						__isConvertedError__: !0,
						errorProperties: {
							...(c.cause ? { cause: c.cause } : {}),
							...c,
							name: c.name,
							message: c.message,
							stack: c.stack,
							'_constructor-name_': c.constructor.name
						}
					};
				if (c?.constructor?.name && c.constructor.name !== 'Object' && !Array.isArray(c)) {
					const f = r.get(c);
					if (!f) {
						const m = {
							__isClassInstance__: !0,
							__className__: c.constructor.name,
							...Object.getOwnPropertyNames(c).reduce((y, g) => {
								try {
									y[g] = c[g];
								} catch {}
								return y;
							}, {})
						};
						return (
							s.push(u),
							o.unshift(m),
							r.set(c, JSON.stringify(s)),
							c !== m && n.set(c, m),
							m
						);
					}
					return `_duplicate_${f}`;
				}
				const p = r.get(c);
				if (!p) {
					const f = Array.isArray(c) ? c : pm(c);
					return (s.push(u), o.unshift(f), r.set(c, JSON.stringify(s)), c !== f && n.set(c, f), f);
				}
				return `_duplicate_${p}`;
			} catch {
				return;
			}
		}, 'replace');
	}, 'replacer2'),
	JB = i(function (t) {
		const r = [];
		let n;
		return i(function (s, a) {
			if (
				(s === '' &&
					((n = a),
					r.forEach(({ target: u, container: c, replacement: d }) => {
						const p = dm(d) ? JSON.parse(d) : d.split('.');
						p.length === 0 ? (c[u] = n) : (c[u] = LB(n, p));
					})),
				s === '_constructor-name_')
			)
				return a;
			if (cm(a) && a.__isConvertedError__) {
				const { message: u, ...c } = a.errorProperties,
					d = new Error(u);
				return (Object.assign(d, c), d);
			}
			if (typeof a == 'string' && a.startsWith('_regexp_') && t.allowRegExp) {
				const [, u, c] = a.match(/_regexp_([^|]*)\|(.*)/) || [];
				return new RegExp(c, u);
			}
			return typeof a == 'string' && a.startsWith('_date_') && t.allowDate
				? new Date(a.replace('_date_', ''))
				: typeof a == 'string' && a.startsWith('_duplicate_')
					? (r.push({ target: s, container: this, replacement: a.replace(/^_duplicate_/, '') }),
						null)
					: typeof a == 'string' && a.startsWith('_symbol_') && t.allowSymbol
						? Symbol(a.replace('_symbol_', ''))
						: typeof a == 'string' && a.startsWith('_gsymbol_') && t.allowSymbol
							? Symbol.for(a.replace('_gsymbol_', ''))
							: typeof a == 'string' && a === '_-Infinity_'
								? Number.NEGATIVE_INFINITY
								: typeof a == 'string' && a === '_Infinity_'
									? Number.POSITIVE_INFINITY
									: typeof a == 'string' && a === '_NaN_'
										? Number.NaN
										: typeof a == 'string' &&
											  a.startsWith('_bigint_') &&
											  typeof BigInt == 'function'
											? BigInt(a.replace('_bigint_', ''))
											: a;
		}, 'revive');
	}, 'reviver2'),
	R_ = {
		maxDepth: 10,
		space: void 0,
		allowRegExp: !0,
		allowDate: !0,
		allowError: !0,
		allowUndefined: !0,
		allowSymbol: !0
	},
	P_ = i((e, t = {}) => {
		const r = { ...R_, ...t };
		return JSON.stringify(pm(e), BB(r), t.space);
	}, 'stringify'),
	$B = i(() => {
		const e = new Map();
		return i(function t(r) {
			(cm(r) &&
				Object.entries(r).forEach(([n, o]) => {
					o === '_undefined_' ? (r[n] = void 0) : e.get(o) || (e.set(o, !0), t(o));
				}),
				Array.isArray(r) &&
					r.forEach((n, o) => {
						n === '_undefined_'
							? (e.set(n, !0), (r[o] = void 0))
							: e.get(n) || (e.set(n, !0), t(n));
					}));
		}, 'mutateUndefined');
	}, 'mutator'),
	A_ = i((e, t = {}) => {
		const r = { ...R_, ...t },
			n = JSON.parse(e, JB(r));
		return ($B()(n), n);
	}, 'parse'),
	UB = 'Invariant failed';
function Cr(e, t) {
	if (!e) throw new Error(UB);
}
i(Cr, 'invariant');
var VB = i((e) => {
		const t = Array.from(document.querySelectorAll('iframe[data-is-storybook]')),
			[r, ...n] = t.filter((s) => {
				try {
					return (
						s.contentWindow?.location.origin === e.source.location.origin &&
						s.contentWindow?.location.pathname === e.source.location.pathname
					);
				} catch {}
				try {
					return s.contentWindow === e.source;
				} catch {}
				const a = s.getAttribute('src');
				let u;
				try {
					if (!a) return !1;
					({ origin: u } = new URL(a, document.location.toString()));
				} catch {
					return !1;
				}
				return u === e.origin;
			}),
			o = r?.getAttribute('src');
		if (o && n.length === 0) {
			const { protocol: s, host: a, pathname: u } = new URL(o, document.location.toString());
			return `${s}//${a}${u}`;
		}
		return (n.length > 0 && Je.error('found multiple candidates for event source'), null);
	}, 'getEventSourceUrl'),
	{ document: nd, location: od } = te,
	Pb = 'storybook-channel',
	HB = { maxDepth: 25 },
	O_ = class {
		constructor(t) {
			if (
				((this.config = t),
				(this.connected = !1),
				(this.buffer = []),
				typeof te?.addEventListener == 'function' &&
					te.addEventListener('message', this.handleEvent.bind(this), !1),
				t.page !== 'manager' && t.page !== 'preview')
			)
				throw new Error(`postmsg-channel: "config.page" cannot be "${t.page}"`);
		}
		setHandler(t) {
			this.handler = (...r) => {
				(t.apply(this, r),
					!this.connected && this.getLocalFrame().length && (this.flush(), (this.connected = !0)));
			};
		}
		send(t, r) {
			const {
					target: n,
					allowRegExp: o,
					allowSymbol: s,
					allowDate: a,
					allowError: u,
					allowUndefined: c,
					maxDepth: d,
					space: p
				} = r || {},
				f = Object.fromEntries(
					Object.entries({
						allowRegExp: o,
						allowSymbol: s,
						allowDate: a,
						allowError: u,
						allowUndefined: c,
						maxDepth: d,
						space: p
					}).filter(([T, b]) => typeof b < 'u')
				),
				m = { ...HB, ...(te.CHANNEL_OPTIONS || {}), ...f },
				y = this.getFrames(n),
				g = new URLSearchParams(od?.search || ''),
				E = P_({ key: Pb, event: t, refId: g.get('refId') }, m);
			return y.length
				? (this.buffer.length && this.flush(),
					y.forEach((T) => {
						try {
							T.postMessage(E, '*');
						} catch {
							Je.error('sending over postmessage fail');
						}
					}),
					Promise.resolve(null))
				: new Promise((T, b) => {
						this.buffer.push({ event: t, resolve: T, reject: b });
					});
		}
		flush() {
			const { buffer: t } = this;
			((this.buffer = []),
				t.forEach((r) => {
					this.send(r.event).then(r.resolve).catch(r.reject);
				}));
		}
		getFrames(t) {
			if (this.config.page === 'manager') {
				const n = Array.from(
					nd.querySelectorAll('iframe[data-is-storybook][data-is-loaded]')
				).flatMap((o) => {
					try {
						return o.contentWindow && o.dataset.isStorybook !== void 0 && o.id === t
							? [o.contentWindow]
							: [];
					} catch {
						return [];
					}
				});
				return n?.length ? n : this.getCurrentFrames();
			}
			return te && te.parent && te.parent !== te.self ? [te.parent] : [];
		}
		getCurrentFrames() {
			return this.config.page === 'manager'
				? Array.from(nd.querySelectorAll('[data-is-storybook="true"]')).flatMap((r) =>
						r.contentWindow ? [r.contentWindow] : []
					)
				: te && te.parent
					? [te.parent]
					: [];
		}
		getLocalFrame() {
			return this.config.page === 'manager'
				? Array.from(nd.querySelectorAll('#storybook-preview-iframe')).flatMap((r) =>
						r.contentWindow ? [r.contentWindow] : []
					)
				: te && te.parent
					? [te.parent]
					: [];
		}
		handleEvent(t) {
			try {
				const { data: r } = t,
					{
						key: n,
						event: o,
						refId: s
					} = typeof r == 'string' && dm(r) ? A_(r, te.CHANNEL_OPTIONS || {}) : r;
				if (n === Pb) {
					const a =
							this.config.page === 'manager'
								? '<span style="color: #37D5D3; background: black"> manager </span>'
								: '<span style="color: #1EA7FD; background: black"> preview </span>',
						u = Object.values(Gf).includes(o.type)
							? `<span style="color: #FF4785">${o.type}</span>`
							: `<span style="color: #FFAE00">${o.type}</span>`;
					if (
						(s && (o.refId = s),
						(o.source = this.config.page === 'preview' ? t.origin : VB(t)),
						!o.source)
					) {
						Wt.error(`${a} received ${u} but was unable to determine the source of the event`);
						return;
					}
					const c = `${a} received ${u} (${r.length})`;
					(Wt.debug(
						od.origin !== o.source
							? c
							: `${c} <span style="color: gray">(on ${od.origin} from ${o.source})</span>`,
						...o.args
					),
						Cr(this.handler, 'ChannelHandler should be set'),
						this.handler(o));
				}
			} catch (r) {
				Je.error(r);
			}
		}
	};
i(O_, 'PostMessageTransport');
var C_ = O_,
	{ WebSocket: GB } = te,
	x_ = 15e3,
	I_ = 5e3,
	N_ = class {
		constructor({ url: t, onError: r, page: n }) {
			((this.buffer = []),
				(this.isReady = !1),
				(this.isClosed = !1),
				(this.pingTimeout = 0),
				(this.socket = new GB(t)),
				(this.socket.onopen = () => {
					((this.isReady = !0), this.heartbeat(), this.flush());
				}),
				(this.socket.onmessage = ({ data: o }) => {
					const s = typeof o == 'string' && dm(o) ? A_(o) : o;
					(Cr(this.handler),
						this.handler(s),
						s.type === 'ping' && (this.heartbeat(), this.send({ type: 'pong' })));
				}),
				(this.socket.onerror = (o) => {
					r && r(o);
				}),
				(this.socket.onclose = (o) => {
					(Cr(this.handler),
						this.handler({
							type: YE,
							args: [{ reason: o.reason, code: o.code }],
							from: n || 'preview'
						}),
						(this.isClosed = !0),
						clearTimeout(this.pingTimeout));
				}));
		}
		heartbeat() {
			(clearTimeout(this.pingTimeout),
				(this.pingTimeout = setTimeout(() => {
					this.socket.close(3008, 'timeout');
				}, x_ + I_)));
		}
		setHandler(t) {
			this.handler = t;
		}
		send(t) {
			this.isClosed || (this.isReady ? this.sendNow(t) : this.sendLater(t));
		}
		sendLater(t) {
			this.buffer.push(t);
		}
		sendNow(t) {
			const r = P_(t, { maxDepth: 15, ...te.CHANNEL_OPTIONS });
			this.socket.send(r);
		}
		flush() {
			const { buffer: t } = this;
			((this.buffer = []), t.forEach((r) => this.send(r)));
		}
	};
i(N_, 'WebsocketTransport');
var M_ = N_,
	{ CONFIG_TYPE: zB } = te,
	WB = pu;
function q_({ page: e, extraTransports: t = [] }) {
	const r = [new C_({ page: e }), ...t];
	if (zB === 'DEVELOPMENT') {
		const o = window.location.protocol === 'http:' ? 'ws' : 'wss',
			{ hostname: s, port: a } = window.location,
			u = `${o}://${s}:${a}/storybook-server-channel`;
		r.push(new M_({ url: u, onError: i(() => {}, 'onError'), page: e }));
	}
	const n = new pu({ transports: r });
	return (td.__prepare(n, e === 'manager' ? td.Environment.MANAGER : td.Environment.PREVIEW), n);
}
i(q_, 'createBrowserChannel');
var j_ = {};
Lt(j_, {
	CalledExtractOnStoreError: () => V_,
	CalledPreviewMethodBeforeInitializationError: () => Vt,
	Category: () => L_,
	ElementA11yParameterError: () => eJ,
	EmptyIndexError: () => Z_,
	ImplicitActionsDuringRendering: () => $_,
	MdxFileWithNoCsfReferencesError: () => X_,
	MissingRenderToCanvasError: () => G_,
	MissingStoryAfterHmrError: () => B_,
	MissingStoryFromCsfFileError: () => nw,
	MountMustBeDestructuredError: () => fm,
	NextJsSharpError: () => YB,
	NextjsRouterMocksNotAvailable: () => XB,
	NoRenderFunctionError: () => lw,
	NoStoryMatchError: () => tw,
	NoStoryMountedError: () => cw,
	StatusTypeIdMismatchError: () => KB,
	StoryIndexFetchError: () => K_,
	StoryStoreAccessedBeforeInitializationError: () => iw,
	UnknownArgTypesError: () => QB,
	UnsupportedViewportDimensionError: () => ZB
});
function kd({ code: e, category: t }) {
	const r = String(e).padStart(4, '0');
	return `SB_${t}_${r}`;
}
i(kd, 'parseErrorCode');
function Ld(e) {
	if (/^(?!.*storybook\.js\.org)|[?&]ref=error\b/.test(e)) return e;
	try {
		const t = new URL(e);
		return (t.searchParams.set('ref', 'error'), t.toString());
	} catch {
		return e;
	}
}
i(Ld, 'appendErrorRef');
var D_ = class k_ extends Error {
	constructor(t) {
		(super(k_.getFullMessage(t)),
			(this.data = {}),
			(this.fromStorybook = !0),
			(this.category = t.category),
			(this.documentation = t.documentation ?? !1),
			(this.code = t.code));
	}
	get fullErrorCode() {
		return kd({ code: this.code, category: this.category });
	}
	get name() {
		const t = this.constructor.name;
		return `${this.fullErrorCode} (${t})`;
	}
	static getFullMessage({ documentation: t, code: r, category: n, message: o }) {
		let s;
		return (
			t === !0
				? (s = `https://storybook.js.org/error/${kd({ code: r, category: n })}?ref=error`)
				: typeof t == 'string'
					? (s = Ld(t))
					: Array.isArray(t) &&
						(s = `
${t.map((a) => `	- ${Ld(a)}`).join(`
`)}`),
			`${o}${
				s != null
					? `

More info: ${s}
`
					: ''
			}`
		);
	}
};
i(D_, 'StorybookError');
var tt = D_,
	L_ = ((e) => (
		(e.BLOCKS = 'BLOCKS'),
		(e.DOCS_TOOLS = 'DOCS-TOOLS'),
		(e.PREVIEW_CLIENT_LOGGER = 'PREVIEW_CLIENT-LOGGER'),
		(e.PREVIEW_CHANNELS = 'PREVIEW_CHANNELS'),
		(e.PREVIEW_CORE_EVENTS = 'PREVIEW_CORE-EVENTS'),
		(e.PREVIEW_INSTRUMENTER = 'PREVIEW_INSTRUMENTER'),
		(e.PREVIEW_API = 'PREVIEW_API'),
		(e.PREVIEW_REACT_DOM_SHIM = 'PREVIEW_REACT-DOM-SHIM'),
		(e.PREVIEW_ROUTER = 'PREVIEW_ROUTER'),
		(e.PREVIEW_THEMING = 'PREVIEW_THEMING'),
		(e.RENDERER_HTML = 'RENDERER_HTML'),
		(e.RENDERER_PREACT = 'RENDERER_PREACT'),
		(e.RENDERER_REACT = 'RENDERER_REACT'),
		(e.RENDERER_SERVER = 'RENDERER_SERVER'),
		(e.RENDERER_SVELTE = 'RENDERER_SVELTE'),
		(e.RENDERER_VUE = 'RENDERER_VUE'),
		(e.RENDERER_VUE3 = 'RENDERER_VUE3'),
		(e.RENDERER_WEB_COMPONENTS = 'RENDERER_WEB-COMPONENTS'),
		(e.FRAMEWORK_NEXTJS = 'FRAMEWORK_NEXTJS'),
		(e.ADDON_VITEST = 'ADDON_VITEST'),
		(e.ADDON_A11Y = 'ADDON_A11Y'),
		e
	))(L_ || {}),
	F_ = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 1,
				message: Ee`
        Couldn't find story matching id '${t.storyId}' after HMR.
        - Did you just rename a story?
        - Did you remove it from your CSF file?
        - Are you sure a story with the id '${t.storyId}' exists?
        - Please check the values in the stories field of your main.js config and see if they would match your CSF File.
        - Also check the browser console and terminal for potential error messages.`
			}),
				(this.data = t));
		}
	};
i(F_, 'MissingStoryAfterHmrError');
var B_ = F_,
	J_ = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 2,
				documentation:
					'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#using-implicit-actions-during-rendering-is-deprecated-for-example-in-the-play-function',
				message: Ee`
        We detected that you use an implicit action arg while ${t.phase} of your story.  
        ${
					t.deprecated
						? `
This is deprecated and won't work in Storybook 8 anymore.
`
						: ''
				}
        Please provide an explicit spy to your args like this:
          import { fn } from 'storybook/test';
          ... 
          args: {
           ${t.name}: fn()
          }`
			}),
				(this.data = t));
		}
	};
i(J_, 'ImplicitActionsDuringRendering');
var $_ = J_,
	U_ = class extends tt {
		constructor() {
			super({
				category: 'PREVIEW_API',
				code: 3,
				message: Ee`
        Cannot call \`storyStore.extract()\` without calling \`storyStore.cacheAllCsfFiles()\` first.

        You probably meant to call \`await preview.extract()\` which does the above for you.`
			});
		}
	};
i(U_, 'CalledExtractOnStoreError');
var V_ = U_,
	H_ = class extends tt {
		constructor() {
			super({
				category: 'PREVIEW_API',
				code: 4,
				message: Ee`
        Expected your framework's preset to export a \`renderToCanvas\` field.

        Perhaps it needs to be upgraded for Storybook 7.0?`,
				documentation:
					'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field'
			});
		}
	};
i(H_, 'MissingRenderToCanvasError');
var G_ = H_,
	z_ = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 5,
				message: Ee`
        Called \`Preview.${t.methodName}()\` before initialization.
        
        The preview needs to load the story index before most methods can be called. If you want
        to call \`${t.methodName}\`, try \`await preview.initializationPromise;\` first.
        
        If you didn't call the above code, then likely it was called by an addon that needs to
        do the above.`
			}),
				(this.data = t));
		}
	};
i(z_, 'CalledPreviewMethodBeforeInitializationError');
var Vt = z_,
	W_ = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 6,
				message: Ee`
        Error fetching \`/index.json\`:
        
        ${t.text}

        If you are in development, this likely indicates a problem with your Storybook process,
        check the terminal for errors.

        If you are in a deployed Storybook, there may have been an issue deploying the full Storybook
        build.`
			}),
				(this.data = t));
		}
	};
i(W_, 'StoryIndexFetchError');
var K_ = W_,
	Y_ = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 7,
				message: Ee`
        Tried to render docs entry ${t.storyId} but it is a MDX file that has no CSF
        references, or autodocs for a CSF file that some doesn't refer to itself.
        
        This likely is an internal error in Storybook's indexing, or you've attached the
        \`attached-mdx\` tag to an MDX file that is not attached.`
			}),
				(this.data = t));
		}
	};
i(Y_, 'MdxFileWithNoCsfReferencesError');
var X_ = Y_,
	Q_ = class extends tt {
		constructor() {
			super({
				category: 'PREVIEW_API',
				code: 8,
				message: Ee`
        Couldn't find any stories in your Storybook.

        - Please check your stories field of your main.js config: does it match correctly?
        - Also check the browser console and terminal for error messages.`
			});
		}
	};
i(Q_, 'EmptyIndexError');
var Z_ = Q_,
	ew = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 9,
				message: Ee`
        Couldn't find story matching '${t.storySpecifier}'.

        - Are you sure a story with that id exists?
        - Please check your stories field of your main.js config.
        - Also check the browser console and terminal for error messages.`
			}),
				(this.data = t));
		}
	};
i(ew, 'NoStoryMatchError');
var tw = ew,
	rw = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 10,
				message: Ee`
        Couldn't find story matching id '${t.storyId}' after importing a CSF file.

        The file was indexed as if the story was there, but then after importing the file in the browser
        we didn't find the story. Possible reasons:
        - You are using a custom story indexer that is misbehaving.
        - You have a custom file loader that is removing or renaming exports.

        Please check your browser console and terminal for errors that may explain the issue.`
			}),
				(this.data = t));
		}
	};
i(rw, 'MissingStoryFromCsfFileError');
var nw = rw,
	ow = class extends tt {
		constructor() {
			super({
				category: 'PREVIEW_API',
				code: 11,
				message: Ee`
        Cannot access the Story Store until the index is ready.

        It is not recommended to use methods directly on the Story Store anyway, in Storybook 9 we will
        remove access to the store entirely`
			});
		}
	};
i(ow, 'StoryStoreAccessedBeforeInitializationError');
var iw = ow,
	sw = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 12,
				message: Ee`
      Incorrect use of mount in the play function.
      
      To use mount in the play function, you must satisfy the following two requirements: 
      
      1. You *must* destructure the mount property from the \`context\` (the argument passed to your play function). 
         This makes sure that Storybook does not start rendering the story before the play function begins.
      
      2. Your Storybook framework or builder must be configured to transpile to ES2017 or newer. 
         This is because destructuring statements and async/await usages are otherwise transpiled away, 
         which prevents Storybook from recognizing your usage of \`mount\`.
      
      Note that Angular is not supported. As async/await is transpiled to support the zone.js polyfill. 
      
      More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#run-code-before-the-component-gets-rendered
      
      Received the following play function:
      ${t.playFunction}`
			}),
				(this.data = t));
		}
	};
i(sw, 'MountMustBeDestructuredError');
var fm = sw,
	aw = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 14,
				message: Ee`
        No render function available for storyId '${t.id}'
      `
			}),
				(this.data = t));
		}
	};
i(aw, 'NoRenderFunctionError');
var lw = aw,
	uw = class extends tt {
		constructor() {
			super({
				category: 'PREVIEW_API',
				code: 15,
				message: Ee`
        No component is mounted in your story.
        
        This usually occurs when you destructure mount in the play function, but forget to call it.
        
        For example:

        async play({ mount, canvasElement }) {
          //  mount should be called: await mount(); 
          const canvas = within(canvasElement);
          const button = await canvas.findByRole('button');
          await userEvent.click(button);
        };

        Make sure to either remove it or call mount in your play function.
      `
			});
		}
	};
i(uw, 'NoStoryMountedError');
var cw = uw,
	dw = class extends tt {
		constructor(t) {
			(super({
				category: 'PREVIEW_API',
				code: 16,
				message: `Status has typeId "${t.status.typeId}" but was added to store with typeId "${t.typeId}". Full status: ${JSON.stringify(t.status, null, 2)}`
			}),
				(this.data = t));
		}
	};
i(dw, 'StatusTypeIdMismatchError');
var KB = dw,
	pw = class extends tt {
		constructor() {
			super({
				category: 'FRAMEWORK_NEXTJS',
				code: 1,
				documentation: 'https://storybook.js.org/docs/get-started/nextjs#faq',
				message: Ee`
      You are importing avif images, but you don't have sharp installed.

      You have to install sharp in order to use image optimization features in Next.js.
      `
			});
		}
	};
i(pw, 'NextJsSharpError');
var YB = pw,
	fw = class extends tt {
		constructor(t) {
			(super({
				category: 'FRAMEWORK_NEXTJS',
				code: 2,
				message: Ee`
        Tried to access router mocks from "${t.importType}" but they were not created yet. You might be running code in an unsupported environment.
      `
			}),
				(this.data = t));
		}
	};
i(fw, 'NextjsRouterMocksNotAvailable');
var XB = fw,
	mw = class extends tt {
		constructor(t) {
			(super({
				category: 'DOCS-TOOLS',
				code: 1,
				documentation: 'https://github.com/storybookjs/storybook/issues/26606',
				message: Ee`
        There was a failure when generating detailed ArgTypes in ${t.language} for:
        ${JSON.stringify(t.type, null, 2)} 
        
        Storybook will fall back to use a generic type description instead.

        This type is either not supported or it is a bug in the docgen generation in Storybook.
        If you think this is a bug, please detail it as much as possible in the Github issue.
      `
			}),
				(this.data = t));
		}
	};
i(mw, 'UnknownArgTypesError');
var QB = mw,
	hw = class extends tt {
		constructor(t) {
			(super({
				category: 'ADDON_VITEST',
				code: 1,
				message: Ee`
        Encountered an unsupported value "${t.value}" when setting the viewport ${t.dimension} dimension.
        
        The Storybook plugin only supports values in the following units:
        - px, vh, vw, em, rem and %.
        
        You can either change the viewport for this story to use one of the supported units or skip the test by adding '!test' to the story's tags per https://storybook.js.org/docs/writing-stories/tags
      `
			}),
				(this.data = t));
		}
	};
i(hw, 'UnsupportedViewportDimensionError');
var ZB = hw,
	yw = class extends tt {
		constructor() {
			super({
				category: 'ADDON_A11Y',
				code: 1,
				documentation:
					'https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter',
				message:
					'The "element" parameter in parameters.a11y has been removed. Use "context" instead.'
			});
		}
	};
i(yw, 'ElementA11yParameterError');
var eJ = yw,
	gw = {};
Lt(gw, { Addon_TypesEnum: () => bw });
var bw = ((e) => (
		(e.TAB = 'tab'),
		(e.PANEL = 'panel'),
		(e.TOOL = 'tool'),
		(e.TOOLEXTRA = 'toolextra'),
		(e.PREVIEW = 'preview'),
		(e.experimental_PAGE = 'page'),
		(e.experimental_TEST_PROVIDER = 'test-provider'),
		e
	))(bw || {}),
	vw = {};
Lt(vw, {
	ADDON_ID: () => gu,
	CLEAR_ID: () => nJ,
	CYCLIC_KEY: () => oJ,
	EVENT_ID: () => Ew,
	PANEL_ID: () => rJ,
	PARAM_KEY: () => tJ,
	action: () => Li,
	actions: () => kz,
	config: () => ua,
	configureActions: () => qz
});
var tJ = 'actions',
	gu = 'storybook/actions',
	rJ = `${gu}/panel`,
	Ew = `${gu}/action-event`,
	nJ = `${gu}/action-clear`,
	oJ = '$___storybook.isCyclic',
	Fd = {};
Lt(Fd, {
	DocsContext: () => Qg,
	HooksContext: () => hm,
	Preview: () => tM,
	PreviewWeb: () => Pz,
	PreviewWithSelection: () => dM,
	ReporterAPI: () => Kg,
	StoryStore: () => YN,
	UrlStore: () => bM,
	WebView: () => TM,
	addons: () => ir,
	applyHooks: () => Sw,
	combineArgs: () => ru,
	combineParameters: () => _o,
	composeConfigs: () => wo,
	composeStepRunners: () => Gg,
	composeStories: () => GN,
	composeStory: () => Xg,
	createPlaywrightTest: () => zN,
	decorateStory: () => Fg,
	defaultDecorateStory: () => Jg,
	emitTransformCode: () => PM,
	filterArgTypes: () => BN,
	getCsfFactoryAnnotations: () => Yg,
	inferControls: () => Hg,
	makeDecorator: () => lJ,
	mockChannel: () => mm,
	normalizeArrays: () => De,
	normalizeProjectAnnotations: () => la,
	normalizeStory: () => ni,
	pauseAnimations: () => Nc,
	prepareMeta: () => $g,
	prepareStory: () => Ic,
	sanitizeStoryContextUpdate: () => Bg,
	setDefaultProjectAnnotations: () => UN,
	setProjectAnnotations: () => HN,
	simulateDOMContentLoaded: () => su,
	simulatePageLoad: () => SM,
	sortStoriesV7: () => fz,
	useArgs: () => Nw,
	useCallback: () => ii,
	useChannel: () => xw,
	useEffect: () => In,
	useGlobals: () => Mw,
	useMemo: () => bm,
	useParameter: () => Iw,
	useReducer: () => Cw,
	useRef: () => Pw,
	useState: () => Ow,
	useStoryContext: () => ha,
	userOrAutoTitle: () => cz,
	userOrAutoTitleFromSpecifier: () => QN,
	waitForAnimations: () => Mc
});
function mm() {
	const e = { setHandler: i(() => {}, 'setHandler'), send: i(() => {}, 'send') };
	return new pu({ transport: e });
}
i(mm, 'mockChannel');
var Tw = class {
	constructor() {
		((this.getChannel = i(() => {
			if (!this.channel) {
				const t = mm();
				return (this.setChannel(t), t);
			}
			return this.channel;
		}, 'getChannel')),
			(this.ready = i(() => this.promise, 'ready')),
			(this.hasChannel = i(() => !!this.channel, 'hasChannel')),
			(this.setChannel = i((t) => {
				((this.channel = t), this.resolve());
			}, 'setChannel')),
			(this.promise = new Promise((t) => {
				this.resolve = () => t(this.getChannel());
			})));
	}
};
i(Tw, 'AddonStore');
var iJ = Tw,
	id = '__STORYBOOK_ADDONS_PREVIEW';
function _w() {
	return (te[id] || (te[id] = new iJ()), te[id]);
}
i(_w, 'getAddonsStore');
var ir = _w(),
	ww = class {
		constructor() {
			((this.hookListsMap = void 0),
				(this.mountedDecorators = void 0),
				(this.prevMountedDecorators = void 0),
				(this.currentHooks = void 0),
				(this.nextHookIndex = void 0),
				(this.currentPhase = void 0),
				(this.currentEffects = void 0),
				(this.prevEffects = void 0),
				(this.currentDecoratorName = void 0),
				(this.hasUpdates = void 0),
				(this.currentContext = void 0),
				(this.renderListener = i((t) => {
					t === this.currentContext?.id &&
						(this.triggerEffects(), (this.currentContext = null), this.removeRenderListeners());
				}, 'renderListener')),
				this.init());
		}
		init() {
			((this.hookListsMap = new WeakMap()),
				(this.mountedDecorators = new Set()),
				(this.prevMountedDecorators = new Set()),
				(this.currentHooks = []),
				(this.nextHookIndex = 0),
				(this.currentPhase = 'NONE'),
				(this.currentEffects = []),
				(this.prevEffects = []),
				(this.currentDecoratorName = null),
				(this.hasUpdates = !1),
				(this.currentContext = null));
		}
		clean() {
			(this.prevEffects.forEach((t) => {
				t.destroy && t.destroy();
			}),
				this.init(),
				this.removeRenderListeners());
		}
		getNextHook() {
			const t = this.currentHooks[this.nextHookIndex];
			return ((this.nextHookIndex += 1), t);
		}
		triggerEffects() {
			(this.prevEffects.forEach((t) => {
				!this.currentEffects.includes(t) && t.destroy && t.destroy();
			}),
				this.currentEffects.forEach((t) => {
					this.prevEffects.includes(t) || (t.destroy = t.create());
				}),
				(this.prevEffects = this.currentEffects),
				(this.currentEffects = []));
		}
		addRenderListeners() {
			(this.removeRenderListeners(), ir.getChannel().on(ml, this.renderListener));
		}
		removeRenderListeners() {
			ir.getChannel().removeListener(ml, this.renderListener);
		}
	};
i(ww, 'HooksContext');
var hm = ww;
function Bd(e) {
	const t = i((...r) => {
		const { hooks: n } = typeof r[0] == 'function' ? r[1] : r[0],
			o = n.currentPhase,
			s = n.currentHooks,
			a = n.nextHookIndex,
			u = n.currentDecoratorName;
		((n.currentDecoratorName = e.name),
			n.prevMountedDecorators.has(e)
				? ((n.currentPhase = 'UPDATE'), (n.currentHooks = n.hookListsMap.get(e) || []))
				: ((n.currentPhase = 'MOUNT'),
					(n.currentHooks = []),
					n.hookListsMap.set(e, n.currentHooks),
					n.prevMountedDecorators.add(e)),
			(n.nextHookIndex = 0));
		const c = te.STORYBOOK_HOOKS_CONTEXT;
		te.STORYBOOK_HOOKS_CONTEXT = n;
		const d = e(...r);
		if (((te.STORYBOOK_HOOKS_CONTEXT = c), n.currentPhase === 'UPDATE' && n.getNextHook() != null))
			throw new Error(
				'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'
			);
		return (
			(n.currentPhase = o),
			(n.currentHooks = s),
			(n.nextHookIndex = a),
			(n.currentDecoratorName = u),
			d
		);
	}, 'hookified');
	return ((t.originalFn = e), t);
}
i(Bd, 'hookify');
var sd = 0,
	sJ = 25,
	Sw = i(
		(e) => (t, r) => {
			const n = e(
				Bd(t),
				r.map((o) => Bd(o))
			);
			return (o) => {
				const { hooks: s } = o;
				((s.prevMountedDecorators ??= new Set()),
					(s.mountedDecorators = new Set([t, ...r])),
					(s.currentContext = o),
					(s.hasUpdates = !1));
				let a = n(o);
				for (sd = 1; s.hasUpdates; )
					if (((s.hasUpdates = !1), (s.currentEffects = []), (a = n(o)), (sd += 1), sd > sJ))
						throw new Error(
							'Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.'
						);
				return (s.addRenderListeners(), a);
			};
		},
		'applyHooks'
	),
	aJ = i((e, t) => e.length === t.length && e.every((r, n) => r === t[n]), 'areDepsEqual'),
	ym = i(
		() =>
			new Error(
				'Storybook preview hooks can only be called inside decorators and story functions.'
			),
		'invalidHooksError'
	);
function gm() {
	return te.STORYBOOK_HOOKS_CONTEXT || null;
}
i(gm, 'getHooksContextOrNull');
function bu() {
	const e = gm();
	if (e == null) throw ym();
	return e;
}
i(bu, 'getHooksContextOrThrow');
function Rw(e, t, r) {
	const n = bu();
	if (n.currentPhase === 'MOUNT') {
		r != null &&
			!Array.isArray(r) &&
			Je.warn(
				`${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`
			);
		const o = { name: e, deps: r };
		return (n.currentHooks.push(o), t(o), o);
	}
	if (n.currentPhase === 'UPDATE') {
		const o = n.getNextHook();
		if (o == null) throw new Error('Rendered more hooks than during the previous render.');
		return (
			o.name !== e &&
				Je.warn(
					`Storybook has detected a change in the order of Hooks${n.currentDecoratorName ? ` called by ${n.currentDecoratorName}` : ''}. This will lead to bugs and errors if not fixed.`
				),
			r != null &&
				o.deps == null &&
				Je.warn(
					`${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`
				),
			r != null &&
				o.deps != null &&
				r.length !== o.deps.length &&
				Je.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${o.deps}
Incoming: ${r}`),
			(r == null || o.deps == null || !aJ(r, o.deps)) && (t(o), (o.deps = r)),
			o
		);
	}
	throw ym();
}
i(Rw, 'useHook');
function ma(e, t, r) {
	const { memoizedState: n } = Rw(
		e,
		(o) => {
			o.memoizedState = t();
		},
		r
	);
	return n;
}
i(ma, 'useMemoLike');
function bm(e, t) {
	return ma('useMemo', e, t);
}
i(bm, 'useMemo');
function ii(e, t) {
	return ma('useCallback', () => e, t);
}
i(ii, 'useCallback');
function vm(e, t) {
	return ma(e, () => ({ current: t }), []);
}
i(vm, 'useRefLike');
function Pw(e) {
	return vm('useRef', e);
}
i(Pw, 'useRef');
function Aw() {
	const e = gm();
	if (e != null && e.currentPhase !== 'NONE') e.hasUpdates = !0;
	else
		try {
			ir.getChannel().emit(Kf);
		} catch {
			Je.warn('State updates of Storybook preview hooks work only in browser');
		}
}
i(Aw, 'triggerUpdate');
function Em(e, t) {
	const r = vm(e, typeof t == 'function' ? t() : t),
		n = i((o) => {
			((r.current = typeof o == 'function' ? o(r.current) : o), Aw());
		}, 'setState');
	return [r.current, n];
}
i(Em, 'useStateLike');
function Ow(e) {
	return Em('useState', e);
}
i(Ow, 'useState');
function Cw(e, t, r) {
	const n = r != null ? () => r(t) : t,
		[o, s] = Em('useReducer', n);
	return [o, i((u) => s((c) => e(c, u)), 'dispatch')];
}
i(Cw, 'useReducer');
function In(e, t) {
	const r = bu(),
		n = ma('useEffect', () => ({ create: e }), t);
	r.currentEffects.includes(n) || r.currentEffects.push(n);
}
i(In, 'useEffect');
function xw(e, t = []) {
	const r = ir.getChannel();
	return (
		In(
			() => (
				Object.entries(e).forEach(([n, o]) => r.on(n, o)),
				() => {
					Object.entries(e).forEach(([n, o]) => r.removeListener(n, o));
				}
			),
			[...Object.keys(e), ...t]
		),
		ii(r.emit.bind(r), [r])
	);
}
i(xw, 'useChannel');
function ha() {
	const { currentContext: e } = bu();
	if (e == null) throw ym();
	return e;
}
i(ha, 'useStoryContext');
function Iw(e, t) {
	const { parameters: r } = ha();
	if (e) return r[e] ?? t;
}
i(Iw, 'useParameter');
function Nw() {
	const e = ir.getChannel(),
		{ id: t, args: r } = ha(),
		n = ii((s) => e.emit(Zf, { storyId: t, updatedArgs: s }), [e, t]),
		o = ii((s) => e.emit(Yf, { storyId: t, argNames: s }), [e, t]);
	return [r, n, o];
}
i(Nw, 'useArgs');
function Mw() {
	const e = ir.getChannel(),
		{ globals: t } = ha(),
		r = ii((n) => e.emit(Qf, { globals: n }), [e]);
	return [t, r];
}
i(Mw, 'useGlobals');
var lJ = i(({ name: e, parameterName: t, wrapper: r, skipIfNoParametersOrOptions: n = !1 }) => {
	const o = i(
		(s) => (a, u) => {
			const c = u.parameters && u.parameters[t];
			return (c && c.disable) || (n && !s && !c) ? a(u) : r(a, u, { options: s, parameters: c });
		},
		'decorator'
	);
	return (...s) =>
		typeof s[0] == 'function'
			? o()(...s)
			: (...a) => {
					if (a.length > 1) return s.length > 1 ? o(s)(...a) : o(...s)(...a);
					throw new Error(`Passing stories directly into ${e}() is not allowed,
        instead use addDecorator(${e}) and pass options with the '${t}' parameter`);
				};
}, 'makeDecorator');
function qw(e) {
	return e
		.replace(/_/g, ' ')
		.replace(/-/g, ' ')
		.replace(/\./g, ' ')
		.replace(/([^\n])([A-Z])([a-z])/g, (t, r, n, o) => `${r} ${n}${o}`)
		.replace(/([a-z])([A-Z])/g, (t, r, n) => `${r} ${n}`)
		.replace(/([a-z])([0-9])/gi, (t, r, n) => `${r} ${n}`)
		.replace(/([0-9])([a-z])/gi, (t, r, n) => `${r} ${n}`)
		.replace(/(\s|^)(\w)/g, (t, r, n) => `${r}${n.toUpperCase()}`)
		.replace(/ +/g, ' ')
		.trim();
}
i(qw, 'toStartCaseStr');
var Ab = et(Lj(), 1),
	jw = i((e) => e.map((t) => typeof t < 'u').filter(Boolean).length, 'count'),
	uJ = i((e, t) => {
		const { exists: r, eq: n, neq: o, truthy: s } = e;
		if (jw([r, n, o, s]) > 1)
			throw new Error(`Invalid conditional test ${JSON.stringify({ exists: r, eq: n, neq: o })}`);
		if (typeof n < 'u') return (0, Ab.isEqual)(t, n);
		if (typeof o < 'u') return !(0, Ab.isEqual)(t, o);
		if (typeof r < 'u') {
			const u = typeof t < 'u';
			return r ? u : !u;
		}
		return (typeof s > 'u' ? !0 : s) ? !!t : !t;
	}, 'testValue'),
	cJ = i((e, t, r) => {
		if (!e.if) return !0;
		const { arg: n, global: o } = e.if;
		if (jw([n, o]) !== 1)
			throw new Error(`Invalid conditional value ${JSON.stringify({ arg: n, global: o })}`);
		const s = n ? t[n] : r[o];
		return uJ(e.if, s);
	}, 'includeConditionalArg');
function Dw(e) {
	return e != null && kw(e).includes('mount');
}
i(Dw, 'mountDestructured');
function kw(e) {
	const t = e.toString().match(/[^(]*\(([^)]*)/);
	if (!t) return [];
	const r = Jd(t[1]);
	if (!r.length) return [];
	const n = r[0];
	return n.startsWith('{') && n.endsWith('}')
		? Jd(n.slice(1, -1).replace(/\s/g, '')).map((s) => s.replace(/:.*|=.*/g, ''))
		: [];
}
i(kw, 'getUsedProps');
function Jd(e) {
	const t = [],
		r = [];
	let n = 0;
	for (let s = 0; s < e.length; s++)
		if (e[s] === '{' || e[s] === '[') r.push(e[s] === '{' ? '}' : ']');
		else if (e[s] === r[r.length - 1]) r.pop();
		else if (!r.length && e[s] === ',') {
			const a = e.substring(n, s).trim();
			(a && t.push(a), (n = s + 1));
		}
	const o = e.substring(n).trim();
	return (o && t.push(o), t);
}
i(Jd, 'splitByComma');
var Lw = {};
Lt(Lw, { argsEnhancers: () => fJ });
var Fw = i((e, t) => typeof t[e] > 'u' && !(e in t), 'isInInitialArgs'),
	dJ = i((e) => {
		const {
			initialArgs: t,
			argTypes: r,
			id: n,
			parameters: { actions: o }
		} = e;
		if (!o || o.disable || !o.argTypesRegex || !r) return {};
		const s = new RegExp(o.argTypesRegex);
		return Object.entries(r)
			.filter(([u]) => !!s.test(u))
			.reduce((u, [c, d]) => (Fw(c, t) && (u[c] = Li(c, { implicit: !0, id: n })), u), {});
	}, 'inferActionsFromArgTypesRegex'),
	pJ = i((e) => {
		const {
			initialArgs: t,
			argTypes: r,
			parameters: { actions: n }
		} = e;
		return n?.disable || !r
			? {}
			: Object.entries(r)
					.filter(([s, a]) => !!a.action)
					.reduce(
						(s, [a, u]) => (Fw(a, t) && (s[a] = Li(typeof u.action == 'string' ? u.action : a)), s),
						{}
					);
	}, 'addActionsFromArgTypes'),
	fJ = [pJ, dJ],
	Bw = {};
Lt(Bw, { loaders: () => A3 });
var Jw = {};
Lt(Jw, {
	buildQueries: () => sH,
	clearAllMocks: () => My,
	configure: () => aH,
	createEvent: () => lH,
	expect: () => S3,
	findAllByAltText: () => cH,
	findAllByDisplayValue: () => dH,
	findAllByLabelText: () => pH,
	findAllByPlaceholderText: () => fH,
	findAllByRole: () => mH,
	findAllByTestId: () => hH,
	findAllByText: () => yH,
	findAllByTitle: () => gH,
	findByAltText: () => bH,
	findByDisplayValue: () => vH,
	findByLabelText: () => EH,
	findByPlaceholderText: () => TH,
	findByRole: () => _H,
	findByTestId: () => wH,
	findByText: () => SH,
	findByTitle: () => RH,
	fireEvent: () => uH,
	fn: () => Iy,
	getAllByAltText: () => PH,
	getAllByDisplayValue: () => AH,
	getAllByLabelText: () => OH,
	getAllByPlaceholderText: () => CH,
	getAllByRole: () => xH,
	getAllByTestId: () => IH,
	getAllByText: () => NH,
	getAllByTitle: () => MH,
	getByAltText: () => qH,
	getByDisplayValue: () => jH,
	getByLabelText: () => DH,
	getByPlaceholderText: () => kH,
	getByRole: () => LH,
	getByTestId: () => FH,
	getByText: () => BH,
	getByTitle: () => JH,
	getConfig: () => $H,
	getDefaultNormalizer: () => UH,
	getElementError: () => VH,
	getNodeText: () => HH,
	getQueriesForElement: () => GH,
	getRoles: () => zH,
	getSuggestedQuery: () => WH,
	isInaccessible: () => KH,
	isMockFunction: () => so,
	logDOM: () => YH,
	logRoles: () => XH,
	mocked: () => aA,
	mocks: () => xa,
	onMockCall: () => xy,
	prettyDOM: () => QH,
	prettyFormat: () => _3,
	queries: () => ZH,
	queryAllByAltText: () => e3,
	queryAllByAttribute: () => t3,
	queryAllByDisplayValue: () => r3,
	queryAllByLabelText: () => n3,
	queryAllByPlaceholderText: () => o3,
	queryAllByRole: () => i3,
	queryAllByTestId: () => s3,
	queryAllByText: () => a3,
	queryAllByTitle: () => l3,
	queryByAltText: () => u3,
	queryByAttribute: () => c3,
	queryByDisplayValue: () => d3,
	queryByLabelText: () => p3,
	queryByPlaceholderText: () => f3,
	queryByRole: () => m3,
	queryByTestId: () => h3,
	queryByText: () => y3,
	queryByTitle: () => g3,
	queryHelpers: () => b3,
	resetAllMocks: () => qy,
	restoreAllMocks: () => jy,
	sb: () => R3,
	screen: () => v3,
	spyOn: () => ZU,
	uninstrumentedUserEvent: () => ZI,
	userEvent: () => w3,
	waitFor: () => E3,
	waitForElementToBeRemoved: () => T3,
	within: () => QI
});
var mJ = {
		reset: [0, 0],
		bold: [1, 22, '\x1B[22m\x1B[1m'],
		dim: [2, 22, '\x1B[22m\x1B[2m'],
		italic: [3, 23],
		underline: [4, 24],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		gray: [90, 39],
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		blackBright: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
		bgBlackBright: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	},
	$w = Object.entries(mJ);
function ya(e) {
	return String(e);
}
i(ya, 'a');
ya.open = '';
ya.close = '';
$w.reduce((e, [t]) => ((e[t] = ya), e), { isColorSupported: !1 });
function Uw(e = !1) {
	let t = typeof process < 'u' ? process : void 0,
		r = t?.env || {},
		n = t?.argv || [];
	return (
		(!('NO_COLOR' in r || n.includes('--no-color')) &&
			('FORCE_COLOR' in r ||
				n.includes('--color') ||
				t?.platform === 'win32' ||
				(e && r.TERM !== 'dumb') ||
				'CI' in r)) ||
		(typeof window < 'u' && !!window.chrome)
	);
}
i(Uw, 'C');
function Vw(e = !1) {
	let t = Uw(e),
		r = i((a, u, c, d) => {
			let p = '',
				f = 0;
			do ((p += a.substring(f, d) + c), (f = d + u.length), (d = a.indexOf(u, f)));
			while (~d);
			return p + a.substring(f);
		}, 'i'),
		n = i((a, u, c = a) => {
			let d = i((p) => {
				let f = String(p),
					m = f.indexOf(u, a.length);
				return ~m ? a + r(f, u, c, m) + u : a + f + u;
			}, 'o');
			return ((d.open = a), (d.close = u), d);
		}, 'g'),
		o = { isColorSupported: t },
		s = i((a) => `\x1B[${a}m`, 'd');
	for (let [a, u] of $w) o[a] = t ? n(s(u[0]), s(u[1]), u[2]) : ya;
	return o;
}
i(Vw, 'p');
var Ke = Vw();
function Tm(e, t) {
	return (
		t.forEach(function (r) {
			r &&
				typeof r != 'string' &&
				!Array.isArray(r) &&
				Object.keys(r).forEach(function (n) {
					if (n !== 'default' && !(n in e)) {
						var o = Object.getOwnPropertyDescriptor(r, n);
						Object.defineProperty(
							e,
							n,
							o.get
								? o
								: {
										enumerable: !0,
										get: i(function () {
											return r[n];
										}, 'get')
									}
						);
					}
				});
		}),
		Object.freeze(e)
	);
}
i(Tm, '_mergeNamespaces');
function Hw(e, t) {
	const r = Object.keys(e),
		n = t === null ? r : r.sort(t);
	if (Object.getOwnPropertySymbols)
		for (const o of Object.getOwnPropertySymbols(e))
			Object.getOwnPropertyDescriptor(e, o).enumerable && n.push(o);
	return n;
}
i(Hw, 'getKeysOfEnumerableProperties');
function Ai(e, t, r, n, o, s, a = ': ') {
	let u = '',
		c = 0,
		d = e.next();
	if (!d.done) {
		u += t.spacingOuter;
		const p = r + t.indent;
		for (; !d.done; ) {
			if (((u += p), c++ === t.maxWidth)) {
				u += '';
				break;
			}
			const f = s(d.value[0], t, p, n, o),
				m = s(d.value[1], t, p, n, o);
			((u += f + a + m),
				(d = e.next()),
				d.done ? t.min || (u += ',') : (u += `,${t.spacingInner}`));
		}
		u += t.spacingOuter + r;
	}
	return u;
}
i(Ai, 'printIteratorEntries');
function vu(e, t, r, n, o, s) {
	let a = '',
		u = 0,
		c = e.next();
	if (!c.done) {
		a += t.spacingOuter;
		const d = r + t.indent;
		for (; !c.done; ) {
			if (((a += d), u++ === t.maxWidth)) {
				a += '';
				break;
			}
			((a += s(c.value, t, d, n, o)),
				(c = e.next()),
				c.done ? t.min || (a += ',') : (a += `,${t.spacingInner}`));
		}
		a += t.spacingOuter + r;
	}
	return a;
}
i(vu, 'printIteratorValues');
function Vs(e, t, r, n, o, s) {
	let a = '';
	e = e instanceof ArrayBuffer ? new DataView(e) : e;
	const u = i((d) => d instanceof DataView, 'isDataView'),
		c = u(e) ? e.byteLength : e.length;
	if (c > 0) {
		a += t.spacingOuter;
		const d = r + t.indent;
		for (let p = 0; p < c; p++) {
			if (((a += d), p === t.maxWidth)) {
				a += '';
				break;
			}
			((u(e) || p in e) && (a += s(u(e) ? e.getInt8(p) : e[p], t, d, n, o)),
				p < c - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
		}
		a += t.spacingOuter + r;
	}
	return a;
}
i(Vs, 'printListItems');
function Eu(e, t, r, n, o, s) {
	let a = '';
	const u = Hw(e, t.compareKeys);
	if (u.length > 0) {
		a += t.spacingOuter;
		const c = r + t.indent;
		for (let d = 0; d < u.length; d++) {
			const p = u[d],
				f = s(p, t, c, n, o),
				m = s(e[p], t, c, n, o);
			((a += `${c + f}: ${m}`),
				d < u.length - 1 ? (a += `,${t.spacingInner}`) : t.min || (a += ','));
		}
		a += t.spacingOuter + r;
	}
	return a;
}
i(Eu, 'printObjectProperties');
var hJ = typeof Symbol == 'function' && Symbol.for ? Symbol.for('jest.asymmetricMatcher') : 1267621,
	Ba = ' ',
	yJ = i((e, t, r, n, o, s) => {
		const a = e.toString();
		if (a === 'ArrayContaining' || a === 'ArrayNotContaining')
			return ++n > t.maxDepth ? `[${a}]` : `${a + Ba}[${Vs(e.sample, t, r, n, o, s)}]`;
		if (a === 'ObjectContaining' || a === 'ObjectNotContaining')
			return ++n > t.maxDepth ? `[${a}]` : `${a + Ba}{${Eu(e.sample, t, r, n, o, s)}}`;
		if (
			a === 'StringMatching' ||
			a === 'StringNotMatching' ||
			a === 'StringContaining' ||
			a === 'StringNotContaining'
		)
			return a + Ba + s(e.sample, t, r, n, o);
		if (typeof e.toAsymmetricMatcher != 'function')
			throw new TypeError(
				`Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`
			);
		return e.toAsymmetricMatcher();
	}, 'serialize$5'),
	gJ = i((e) => e && e.$$typeof === hJ, 'test$5'),
	bJ = { serialize: yJ, test: gJ },
	vJ = ' ',
	Gw = new Set(['DOMStringMap', 'NamedNodeMap']),
	EJ = /^(?:HTML\w*Collection|NodeList)$/;
function zw(e) {
	return Gw.has(e) || EJ.test(e);
}
i(zw, 'testName');
var TJ = i((e) => e && e.constructor && !!e.constructor.name && zw(e.constructor.name), 'test$4');
function Ww(e) {
	return e.constructor.name === 'NamedNodeMap';
}
i(Ww, 'isNamedNodeMap');
var _J = i((e, t, r, n, o, s) => {
		const a = e.constructor.name;
		return ++n > t.maxDepth
			? `[${a}]`
			: (t.min ? '' : a + vJ) +
					(Gw.has(a)
						? `{${Eu(Ww(e) ? [...e].reduce((u, c) => ((u[c.name] = c.value), u), {}) : { ...e }, t, r, n, o, s)}}`
						: `[${Vs([...e], t, r, n, o, s)}]`);
	}, 'serialize$4'),
	wJ = { serialize: _J, test: TJ };
function _m(e) {
	return e.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
}
i(_m, 'escapeHTML');
function Tu(e, t, r, n, o, s, a) {
	const u = n + r.indent,
		c = r.colors;
	return e
		.map((d) => {
			const p = t[d];
			let f = a(p, r, u, o, s);
			return (
				typeof p != 'string' &&
					(f.includes(`
`) && (f = r.spacingOuter + u + f + r.spacingOuter + n),
					(f = `{${f}}`)),
				`${r.spacingInner + n + c.prop.open + d + c.prop.close}=${c.value.open}${f}${c.value.close}`
			);
		})
		.join('');
}
i(Tu, 'printProps');
function _u(e, t, r, n, o, s) {
	return e
		.map((a) => t.spacingOuter + r + (typeof a == 'string' ? wm(a, t) : s(a, t, r, n, o)))
		.join('');
}
i(_u, 'printChildren');
function wm(e, t) {
	const r = t.colors.content;
	return r.open + _m(e) + r.close;
}
i(wm, 'printText');
function Kw(e, t) {
	const r = t.colors.comment;
	return `${r.open}<!--${_m(e)}-->${r.close}`;
}
i(Kw, 'printComment');
function wu(e, t, r, n, o) {
	const s = n.colors.tag;
	return `${s.open}<${e}${t && s.close + t + n.spacingOuter + o + s.open}${r ? `>${s.close}${r}${n.spacingOuter}${o}${s.open}</${e}` : `${t && !n.min ? '' : ' '}/`}>${s.close}`;
}
i(wu, 'printElement');
function Su(e, t) {
	const r = t.colors.tag;
	return `${r.open}<${e}${r.close} ${r.open} />${r.close}`;
}
i(Su, 'printElementAsLeaf');
var SJ = 1,
	Yw = 3,
	Xw = 8,
	Qw = 11,
	RJ = /^(?:(?:HTML|SVG)\w*)?Element$/;
function Zw(e) {
	try {
		return typeof e.hasAttribute == 'function' && e.hasAttribute('is');
	} catch {
		return !1;
	}
}
i(Zw, 'testHasAttribute');
function eS(e) {
	const t = e.constructor.name,
		{ nodeType: r, tagName: n } = e,
		o = (typeof n == 'string' && n.includes('-')) || Zw(e);
	return (
		(r === SJ && (RJ.test(t) || o)) ||
		(r === Yw && t === 'Text') ||
		(r === Xw && t === 'Comment') ||
		(r === Qw && t === 'DocumentFragment')
	);
}
i(eS, 'testNode');
var PJ = i((e) => {
	var t;
	return (e == null || (t = e.constructor) === null || t === void 0 ? void 0 : t.name) && eS(e);
}, 'test$3');
function tS(e) {
	return e.nodeType === Yw;
}
i(tS, 'nodeIsText');
function rS(e) {
	return e.nodeType === Xw;
}
i(rS, 'nodeIsComment');
function Ya(e) {
	return e.nodeType === Qw;
}
i(Ya, 'nodeIsFragment');
var AJ = i((e, t, r, n, o, s) => {
		if (tS(e)) return wm(e.data, t);
		if (rS(e)) return Kw(e.data, t);
		const a = Ya(e) ? 'DocumentFragment' : e.tagName.toLowerCase();
		return ++n > t.maxDepth
			? Su(a, t)
			: wu(
					a,
					Tu(
						Ya(e) ? [] : Array.from(e.attributes, (u) => u.name).sort(),
						Ya(e) ? {} : [...e.attributes].reduce((u, c) => ((u[c.name] = c.value), u), {}),
						t,
						r + t.indent,
						n,
						o,
						s
					),
					_u(Array.prototype.slice.call(e.childNodes || e.children), t, r + t.indent, n, o, s),
					t,
					r
				);
	}, 'serialize$3'),
	OJ = { serialize: AJ, test: PJ },
	CJ = '@@__IMMUTABLE_ITERABLE__@@',
	xJ = '@@__IMMUTABLE_LIST__@@',
	IJ = '@@__IMMUTABLE_KEYED__@@',
	NJ = '@@__IMMUTABLE_MAP__@@',
	Ob = '@@__IMMUTABLE_ORDERED__@@',
	MJ = '@@__IMMUTABLE_RECORD__@@',
	qJ = '@@__IMMUTABLE_SEQ__@@',
	jJ = '@@__IMMUTABLE_SET__@@',
	DJ = '@@__IMMUTABLE_STACK__@@',
	si = i((e) => `Immutable.${e}`, 'getImmutableName'),
	Ru = i((e) => `[${e}]`, 'printAsLeaf'),
	Hs = ' ',
	Cb = '';
function nS(e, t, r, n, o, s, a) {
	return ++n > t.maxDepth ? Ru(si(a)) : `${si(a) + Hs}{${Ai(e.entries(), t, r, n, o, s)}}`;
}
i(nS, 'printImmutableEntries');
function oS(e) {
	let t = 0;
	return {
		next() {
			if (t < e._keys.length) {
				const r = e._keys[t++];
				return { done: !1, value: [r, e.get(r)] };
			}
			return { done: !0, value: void 0 };
		}
	};
}
i(oS, 'getRecordEntries');
function iS(e, t, r, n, o, s) {
	const a = si(e._name || 'Record');
	return ++n > t.maxDepth ? Ru(a) : `${a + Hs}{${Ai(oS(e), t, r, n, o, s)}}`;
}
i(iS, 'printImmutableRecord');
function sS(e, t, r, n, o, s) {
	const a = si('Seq');
	return ++n > t.maxDepth
		? Ru(a)
		: e[IJ]
			? `${a + Hs}{${e._iter || e._object ? Ai(e.entries(), t, r, n, o, s) : Cb}}`
			: `${a + Hs}[${e._iter || e._array || e._collection || e._iterable ? vu(e.values(), t, r, n, o, s) : Cb}]`;
}
i(sS, 'printImmutableSeq');
function Xa(e, t, r, n, o, s, a) {
	return ++n > t.maxDepth ? Ru(si(a)) : `${si(a) + Hs}[${vu(e.values(), t, r, n, o, s)}]`;
}
i(Xa, 'printImmutableValues');
var kJ = i(
		(e, t, r, n, o, s) =>
			e[NJ]
				? nS(e, t, r, n, o, s, e[Ob] ? 'OrderedMap' : 'Map')
				: e[xJ]
					? Xa(e, t, r, n, o, s, 'List')
					: e[jJ]
						? Xa(e, t, r, n, o, s, e[Ob] ? 'OrderedSet' : 'Set')
						: e[DJ]
							? Xa(e, t, r, n, o, s, 'Stack')
							: e[qJ]
								? sS(e, t, r, n, o, s)
								: iS(e, t, r, n, o, s),
		'serialize$2'
	),
	LJ = i((e) => e && (e[CJ] === !0 || e[MJ] === !0), 'test$2'),
	FJ = { serialize: kJ, test: LJ };
function Sm(e) {
	return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
i(Sm, 'getDefaultExportFromCjs');
var ad = { exports: {} },
	je = {},
	xb;
function aS() {
	if (xb) return je;
	xb = 1;
	var e = Symbol.for('react.transitional.element'),
		t = Symbol.for('react.portal'),
		r = Symbol.for('react.fragment'),
		n = Symbol.for('react.strict_mode'),
		o = Symbol.for('react.profiler'),
		s = Symbol.for('react.consumer'),
		a = Symbol.for('react.context'),
		u = Symbol.for('react.forward_ref'),
		c = Symbol.for('react.suspense'),
		d = Symbol.for('react.suspense_list'),
		p = Symbol.for('react.memo'),
		f = Symbol.for('react.lazy'),
		m = Symbol.for('react.view_transition'),
		y = Symbol.for('react.client.reference');
	function g(E) {
		if (typeof E == 'object' && E !== null) {
			var T = E.$$typeof;
			switch (T) {
				case e:
					switch (((E = E.type), E)) {
						case r:
						case o:
						case n:
						case c:
						case d:
						case m:
							return E;
						default:
							switch (((E = E && E.$$typeof), E)) {
								case a:
								case u:
								case f:
								case p:
									return E;
								case s:
									return E;
								default:
									return T;
							}
					}
				case t:
					return T;
			}
		}
	}
	return (
		i(g, 'typeOf'),
		(je.ContextConsumer = s),
		(je.ContextProvider = a),
		(je.Element = e),
		(je.ForwardRef = u),
		(je.Fragment = r),
		(je.Lazy = f),
		(je.Memo = p),
		(je.Portal = t),
		(je.Profiler = o),
		(je.StrictMode = n),
		(je.Suspense = c),
		(je.SuspenseList = d),
		(je.isContextConsumer = function (E) {
			return g(E) === s;
		}),
		(je.isContextProvider = function (E) {
			return g(E) === a;
		}),
		(je.isElement = function (E) {
			return typeof E == 'object' && E !== null && E.$$typeof === e;
		}),
		(je.isForwardRef = function (E) {
			return g(E) === u;
		}),
		(je.isFragment = function (E) {
			return g(E) === r;
		}),
		(je.isLazy = function (E) {
			return g(E) === f;
		}),
		(je.isMemo = function (E) {
			return g(E) === p;
		}),
		(je.isPortal = function (E) {
			return g(E) === t;
		}),
		(je.isProfiler = function (E) {
			return g(E) === o;
		}),
		(je.isStrictMode = function (E) {
			return g(E) === n;
		}),
		(je.isSuspense = function (E) {
			return g(E) === c;
		}),
		(je.isSuspenseList = function (E) {
			return g(E) === d;
		}),
		(je.isValidElementType = function (E) {
			return (
				typeof E == 'string' ||
				typeof E == 'function' ||
				E === r ||
				E === o ||
				E === n ||
				E === c ||
				E === d ||
				(typeof E == 'object' &&
					E !== null &&
					(E.$$typeof === f ||
						E.$$typeof === p ||
						E.$$typeof === a ||
						E.$$typeof === s ||
						E.$$typeof === u ||
						E.$$typeof === y ||
						E.getModuleId !== void 0))
			);
		}),
		(je.typeOf = g),
		je
	);
}
i(aS, 'requireReactIs_production');
var Ib;
function lS() {
	return (Ib || ((Ib = 1), (ad.exports = aS())), ad.exports);
}
i(lS, 'requireReactIs$1');
var uS = lS(),
	BJ = Sm(uS),
	JJ = Tm({ __proto__: null, default: BJ }, [uS]),
	ld = { exports: {} },
	Ne = {},
	Nb;
function cS() {
	if (Nb) return Ne;
	Nb = 1;
	var e = Symbol.for('react.element'),
		t = Symbol.for('react.portal'),
		r = Symbol.for('react.fragment'),
		n = Symbol.for('react.strict_mode'),
		o = Symbol.for('react.profiler'),
		s = Symbol.for('react.provider'),
		a = Symbol.for('react.context'),
		u = Symbol.for('react.server_context'),
		c = Symbol.for('react.forward_ref'),
		d = Symbol.for('react.suspense'),
		p = Symbol.for('react.suspense_list'),
		f = Symbol.for('react.memo'),
		m = Symbol.for('react.lazy'),
		y = Symbol.for('react.offscreen'),
		g;
	g = Symbol.for('react.module.reference');
	function E(T) {
		if (typeof T == 'object' && T !== null) {
			var b = T.$$typeof;
			switch (b) {
				case e:
					switch (((T = T.type), T)) {
						case r:
						case o:
						case n:
						case d:
						case p:
							return T;
						default:
							switch (((T = T && T.$$typeof), T)) {
								case u:
								case a:
								case c:
								case m:
								case f:
								case s:
									return T;
								default:
									return b;
							}
					}
				case t:
					return b;
			}
		}
	}
	return (
		i(E, 'v'),
		(Ne.ContextConsumer = a),
		(Ne.ContextProvider = s),
		(Ne.Element = e),
		(Ne.ForwardRef = c),
		(Ne.Fragment = r),
		(Ne.Lazy = m),
		(Ne.Memo = f),
		(Ne.Portal = t),
		(Ne.Profiler = o),
		(Ne.StrictMode = n),
		(Ne.Suspense = d),
		(Ne.SuspenseList = p),
		(Ne.isAsyncMode = function () {
			return !1;
		}),
		(Ne.isConcurrentMode = function () {
			return !1;
		}),
		(Ne.isContextConsumer = function (T) {
			return E(T) === a;
		}),
		(Ne.isContextProvider = function (T) {
			return E(T) === s;
		}),
		(Ne.isElement = function (T) {
			return typeof T == 'object' && T !== null && T.$$typeof === e;
		}),
		(Ne.isForwardRef = function (T) {
			return E(T) === c;
		}),
		(Ne.isFragment = function (T) {
			return E(T) === r;
		}),
		(Ne.isLazy = function (T) {
			return E(T) === m;
		}),
		(Ne.isMemo = function (T) {
			return E(T) === f;
		}),
		(Ne.isPortal = function (T) {
			return E(T) === t;
		}),
		(Ne.isProfiler = function (T) {
			return E(T) === o;
		}),
		(Ne.isStrictMode = function (T) {
			return E(T) === n;
		}),
		(Ne.isSuspense = function (T) {
			return E(T) === d;
		}),
		(Ne.isSuspenseList = function (T) {
			return E(T) === p;
		}),
		(Ne.isValidElementType = function (T) {
			return (
				typeof T == 'string' ||
				typeof T == 'function' ||
				T === r ||
				T === o ||
				T === n ||
				T === d ||
				T === p ||
				T === y ||
				(typeof T == 'object' &&
					T !== null &&
					(T.$$typeof === m ||
						T.$$typeof === f ||
						T.$$typeof === s ||
						T.$$typeof === a ||
						T.$$typeof === c ||
						T.$$typeof === g ||
						T.getModuleId !== void 0))
			);
		}),
		(Ne.typeOf = E),
		Ne
	);
}
i(cS, 'requireReactIs_production_min');
var Mb;
function dS() {
	return (Mb || ((Mb = 1), (ld.exports = cS())), ld.exports);
}
i(dS, 'requireReactIs');
var pS = dS(),
	$J = Sm(pS),
	UJ = Tm({ __proto__: null, default: $J }, [pS]),
	VJ = [
		'isAsyncMode',
		'isConcurrentMode',
		'isContextConsumer',
		'isContextProvider',
		'isElement',
		'isForwardRef',
		'isFragment',
		'isLazy',
		'isMemo',
		'isPortal',
		'isProfiler',
		'isStrictMode',
		'isSuspense',
		'isSuspenseList',
		'isValidElementType'
	],
	Kn = Object.fromEntries(VJ.map((e) => [e, (t) => UJ[e](t) || JJ[e](t)]));
function Rm(e, t = []) {
	if (Array.isArray(e)) for (const r of e) Rm(r, t);
	else e != null && e !== !1 && e !== '' && t.push(e);
	return t;
}
i(Rm, 'getChildren');
function $d(e) {
	const t = e.type;
	if (typeof t == 'string') return t;
	if (typeof t == 'function') return t.displayName || t.name || 'Unknown';
	if (Kn.isFragment(e)) return 'React.Fragment';
	if (Kn.isSuspense(e)) return 'React.Suspense';
	if (typeof t == 'object' && t !== null) {
		if (Kn.isContextProvider(e)) return 'Context.Provider';
		if (Kn.isContextConsumer(e)) return 'Context.Consumer';
		if (Kn.isForwardRef(e)) {
			if (t.displayName) return t.displayName;
			const r = t.render.displayName || t.render.name || '';
			return r === '' ? 'ForwardRef' : `ForwardRef(${r})`;
		}
		if (Kn.isMemo(e)) {
			const r = t.displayName || t.type.displayName || t.type.name || '';
			return r === '' ? 'Memo' : `Memo(${r})`;
		}
	}
	return 'UNDEFINED';
}
i($d, 'getType');
function fS(e) {
	const { props: t } = e;
	return Object.keys(t)
		.filter((r) => r !== 'children' && t[r] !== void 0)
		.sort();
}
i(fS, 'getPropKeys$1');
var HJ = i(
		(e, t, r, n, o, s) =>
			++n > t.maxDepth
				? Su($d(e), t)
				: wu(
						$d(e),
						Tu(fS(e), e.props, t, r + t.indent, n, o, s),
						_u(Rm(e.props.children), t, r + t.indent, n, o, s),
						t,
						r
					),
		'serialize$1'
	),
	GJ = i((e) => e != null && Kn.isElement(e), 'test$1'),
	zJ = { serialize: HJ, test: GJ },
	WJ = typeof Symbol == 'function' && Symbol.for ? Symbol.for('react.test.json') : 245830487;
function mS(e) {
	const { props: t } = e;
	return t
		? Object.keys(t)
				.filter((r) => t[r] !== void 0)
				.sort()
		: [];
}
i(mS, 'getPropKeys');
var KJ = i(
		(e, t, r, n, o, s) =>
			++n > t.maxDepth
				? Su(e.type, t)
				: wu(
						e.type,
						e.props ? Tu(mS(e), e.props, t, r + t.indent, n, o, s) : '',
						e.children ? _u(e.children, t, r + t.indent, n, o, s) : '',
						t,
						r
					),
		'serialize'
	),
	YJ = i((e) => e && e.$$typeof === WJ, 'test'),
	XJ = { serialize: KJ, test: YJ },
	hS = Object.prototype.toString,
	QJ = Date.prototype.toISOString,
	ZJ = Error.prototype.toString,
	qb = RegExp.prototype.toString;
function As(e) {
	return (typeof e.constructor == 'function' && e.constructor.name) || 'Object';
}
i(As, 'getConstructorName');
function yS(e) {
	return typeof window < 'u' && e === window;
}
i(yS, 'isWindow');
var e$ = /^Symbol\((.*)\)(.*)$/,
	t$ = /\n/g,
	gS = class extends Error {
		constructor(t, r) {
			(super(t), (this.stack = r), (this.name = this.constructor.name));
		}
	};
i(gS, 'PrettyFormatPluginError');
var bS = gS;
function vS(e) {
	return (
		e === '[object Array]' ||
		e === '[object ArrayBuffer]' ||
		e === '[object DataView]' ||
		e === '[object Float32Array]' ||
		e === '[object Float64Array]' ||
		e === '[object Int8Array]' ||
		e === '[object Int16Array]' ||
		e === '[object Int32Array]' ||
		e === '[object Uint8Array]' ||
		e === '[object Uint8ClampedArray]' ||
		e === '[object Uint16Array]' ||
		e === '[object Uint32Array]'
	);
}
i(vS, 'isToStringedArrayType');
function ES(e) {
	return Object.is(e, -0) ? '-0' : String(e);
}
i(ES, 'printNumber');
function TS(e) {
	return `${e}n`;
}
i(TS, 'printBigInt');
function Ud(e, t) {
	return t ? `[Function ${e.name || 'anonymous'}]` : '[Function]';
}
i(Ud, 'printFunction');
function Vd(e) {
	return String(e).replace(e$, 'Symbol($1)');
}
i(Vd, 'printSymbol');
function Hd(e) {
	return `[${ZJ.call(e)}]`;
}
i(Hd, 'printError');
function Pm(e, t, r, n) {
	if (e === !0 || e === !1) return `${e}`;
	if (e === void 0) return 'undefined';
	if (e === null) return 'null';
	const o = typeof e;
	if (o === 'number') return ES(e);
	if (o === 'bigint') return TS(e);
	if (o === 'string') return n ? `"${e.replaceAll(/"|\\/g, '\\$&')}"` : `"${e}"`;
	if (o === 'function') return Ud(e, t);
	if (o === 'symbol') return Vd(e);
	const s = hS.call(e);
	return s === '[object WeakMap]'
		? 'WeakMap {}'
		: s === '[object WeakSet]'
			? 'WeakSet {}'
			: s === '[object Function]' || s === '[object GeneratorFunction]'
				? Ud(e, t)
				: s === '[object Symbol]'
					? Vd(e)
					: s === '[object Date]'
						? Number.isNaN(+e)
							? 'Date { NaN }'
							: QJ.call(e)
						: s === '[object Error]'
							? Hd(e)
							: s === '[object RegExp]'
								? r
									? qb.call(e).replaceAll(/[$()*+.?[\\\]^{|}]/g, '\\$&')
									: qb.call(e)
								: e instanceof Error
									? Hd(e)
									: null;
}
i(Pm, 'printBasicValue');
function Am(e, t, r, n, o, s) {
	if (o.includes(e)) return '[Circular]';
	((o = [...o]), o.push(e));
	const a = ++n > t.maxDepth,
		u = t.min;
	if (t.callToJSON && !a && e.toJSON && typeof e.toJSON == 'function' && !s)
		return Kr(e.toJSON(), t, r, n, o, !0);
	const c = hS.call(e);
	return c === '[object Arguments]'
		? a
			? '[Arguments]'
			: `${u ? '' : 'Arguments '}[${Vs(e, t, r, n, o, Kr)}]`
		: vS(c)
			? a
				? `[${e.constructor.name}]`
				: `${u || (!t.printBasicPrototype && e.constructor.name === 'Array') ? '' : `${e.constructor.name} `}[${Vs(e, t, r, n, o, Kr)}]`
			: c === '[object Map]'
				? a
					? '[Map]'
					: `Map {${Ai(e.entries(), t, r, n, o, Kr, ' => ')}}`
				: c === '[object Set]'
					? a
						? '[Set]'
						: `Set {${vu(e.values(), t, r, n, o, Kr)}}`
					: a || yS(e)
						? `[${As(e)}]`
						: `${u || (!t.printBasicPrototype && As(e) === 'Object') ? '' : `${As(e)} `}{${Eu(e, t, r, n, o, Kr)}}`;
}
i(Am, 'printComplexValue');
var r$ = {
	test: i((e) => e && e instanceof Error, 'test'),
	serialize(e, t, r, n, o, s) {
		if (o.includes(e)) return '[Circular]';
		o = [...o, e];
		const a = ++n > t.maxDepth,
			{ message: u, cause: c, ...d } = e,
			p = {
				message: u,
				...(typeof c < 'u' ? { cause: c } : {}),
				...(e instanceof AggregateError ? { errors: e.errors } : {}),
				...d
			},
			f = e.name !== 'Error' ? e.name : As(e);
		return a ? `[${f}]` : `${f} {${Ai(Object.entries(p).values(), t, r, n, o, s)}}`;
	}
};
function _S(e) {
	return e.serialize != null;
}
i(_S, 'isNewPlugin');
function Om(e, t, r, n, o, s) {
	let a;
	try {
		a = _S(e)
			? e.serialize(t, r, n, o, s, Kr)
			: e.print(
					t,
					(u) => Kr(u, r, n, o, s),
					(u) => {
						const c = n + r.indent;
						return (
							c +
							u.replaceAll(
								t$,
								`
${c}`
							)
						);
					},
					{ edgeSpacing: r.spacingOuter, min: r.min, spacing: r.spacingInner },
					r.colors
				);
	} catch (u) {
		throw new bS(u.message, u.stack);
	}
	if (typeof a != 'string')
		throw new TypeError(
			`pretty-format: Plugin must return type "string" but instead returned "${typeof a}".`
		);
	return a;
}
i(Om, 'printPlugin');
function Cm(e, t) {
	for (const r of e)
		try {
			if (r.test(t)) return r;
		} catch (n) {
			throw new bS(n.message, n.stack);
		}
	return null;
}
i(Cm, 'findPlugin');
function Kr(e, t, r, n, o, s) {
	const a = Cm(t.plugins, e);
	if (a !== null) return Om(a, e, t, r, n, o);
	const u = Pm(e, t.printFunctionName, t.escapeRegex, t.escapeString);
	return u !== null ? u : Am(e, t, r, n, o, s);
}
i(Kr, 'printer');
var xm = { comment: 'gray', content: 'reset', prop: 'yellow', tag: 'cyan', value: 'green' },
	wS = Object.keys(xm),
	dr = {
		callToJSON: !0,
		compareKeys: void 0,
		escapeRegex: !1,
		escapeString: !0,
		highlight: !1,
		indent: 2,
		maxDepth: Number.POSITIVE_INFINITY,
		maxWidth: Number.POSITIVE_INFINITY,
		min: !1,
		plugins: [],
		printBasicPrototype: !0,
		printFunctionName: !0,
		theme: xm
	};
function SS(e) {
	for (const t of Object.keys(e))
		if (!Object.prototype.hasOwnProperty.call(dr, t))
			throw new Error(`pretty-format: Unknown option "${t}".`);
	if (e.min && e.indent !== void 0 && e.indent !== 0)
		throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
i(SS, 'validateOptions');
function RS() {
	return wS.reduce((e, t) => {
		const r = xm[t],
			n = r && Ke[r];
		if (n && typeof n.close == 'string' && typeof n.open == 'string') e[t] = n;
		else
			throw new Error(
				`pretty-format: Option "theme" has a key "${t}" whose value "${r}" is undefined in ansi-styles.`
			);
		return e;
	}, Object.create(null));
}
i(RS, 'getColorsHighlight');
function PS() {
	return wS.reduce((e, t) => ((e[t] = { close: '', open: '' }), e), Object.create(null));
}
i(PS, 'getColorsEmpty');
function Im(e) {
	return e?.printFunctionName ?? dr.printFunctionName;
}
i(Im, 'getPrintFunctionName');
function Nm(e) {
	return e?.escapeRegex ?? dr.escapeRegex;
}
i(Nm, 'getEscapeRegex');
function Mm(e) {
	return e?.escapeString ?? dr.escapeString;
}
i(Mm, 'getEscapeString');
function Gd(e) {
	return {
		callToJSON: e?.callToJSON ?? dr.callToJSON,
		colors: e?.highlight ? RS() : PS(),
		compareKeys:
			typeof e?.compareKeys == 'function' || e?.compareKeys === null
				? e.compareKeys
				: dr.compareKeys,
		escapeRegex: Nm(e),
		escapeString: Mm(e),
		indent: e?.min ? '' : AS(e?.indent ?? dr.indent),
		maxDepth: e?.maxDepth ?? dr.maxDepth,
		maxWidth: e?.maxWidth ?? dr.maxWidth,
		min: e?.min ?? dr.min,
		plugins: e?.plugins ?? dr.plugins,
		printBasicPrototype: e?.printBasicPrototype ?? !0,
		printFunctionName: Im(e),
		spacingInner: e?.min
			? ' '
			: `
`,
		spacingOuter: e?.min
			? ''
			: `
`
	};
}
i(Gd, 'getConfig');
function AS(e) {
	return Array.from({ length: e + 1 }).join(' ');
}
i(AS, 'createIndent');
function fr(e, t) {
	if (t && (SS(t), t.plugins)) {
		const n = Cm(t.plugins, e);
		if (n !== null) return Om(n, e, Gd(t), '', 0, []);
	}
	const r = Pm(e, Im(t), Nm(t), Mm(t));
	return r !== null ? r : Am(e, Gd(t), '', 0, []);
}
i(fr, 'format');
var qm = {
		AsymmetricMatcher: bJ,
		DOMCollection: wJ,
		DOMElement: OJ,
		Immutable: FJ,
		ReactElement: zJ,
		ReactTestComponent: XJ,
		Error: r$
	},
	jb = {
		bold: ['1', '22'],
		dim: ['2', '22'],
		italic: ['3', '23'],
		underline: ['4', '24'],
		inverse: ['7', '27'],
		hidden: ['8', '28'],
		strike: ['9', '29'],
		black: ['30', '39'],
		red: ['31', '39'],
		green: ['32', '39'],
		yellow: ['33', '39'],
		blue: ['34', '39'],
		magenta: ['35', '39'],
		cyan: ['36', '39'],
		white: ['37', '39'],
		brightblack: ['30;1', '39'],
		brightred: ['31;1', '39'],
		brightgreen: ['32;1', '39'],
		brightyellow: ['33;1', '39'],
		brightblue: ['34;1', '39'],
		brightmagenta: ['35;1', '39'],
		brightcyan: ['36;1', '39'],
		brightwhite: ['37;1', '39'],
		grey: ['90', '39']
	},
	n$ = {
		special: 'cyan',
		number: 'yellow',
		bigint: 'yellow',
		boolean: 'yellow',
		undefined: 'grey',
		null: 'bold',
		string: 'green',
		symbol: 'green',
		date: 'magenta',
		regexp: 'red'
	},
	ai = '';
function OS(e, t) {
	const r = jb[n$[t]] || jb[t] || '';
	return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
i(OS, 'colorise');
function CS(
	{
		showHidden: e = !1,
		depth: t = 2,
		colors: r = !1,
		customInspect: n = !0,
		showProxy: o = !1,
		maxArrayLength: s = 1 / 0,
		breakLength: a = 1 / 0,
		seen: u = [],
		truncate: c = 1 / 0,
		stylize: d = String
	} = {},
	p
) {
	const f = {
		showHidden: !!e,
		depth: Number(t),
		colors: !!r,
		customInspect: !!n,
		showProxy: !!o,
		maxArrayLength: Number(s),
		breakLength: Number(a),
		truncate: Number(c),
		seen: u,
		inspect: p,
		stylize: d
	};
	return (f.colors && (f.stylize = OS), f);
}
i(CS, 'normaliseOptions');
function xS(e) {
	return e >= '\uD800' && e <= '\uDBFF';
}
i(xS, 'isHighSurrogate');
function an(e, t, r = ai) {
	e = String(e);
	const n = r.length,
		o = e.length;
	if (n > t && o > n) return r;
	if (o > t && o > n) {
		let s = t - n;
		return (s > 0 && xS(e[s - 1]) && (s = s - 1), `${e.slice(0, s)}${r}`);
	}
	return e;
}
i(an, 'truncate');
function sr(e, t, r, n = ', ') {
	r = r || t.inspect;
	const o = e.length;
	if (o === 0) return '';
	const s = t.truncate;
	let a = '',
		u = '',
		c = '';
	for (let d = 0; d < o; d += 1) {
		const p = d + 1 === e.length,
			f = d + 2 === e.length;
		c = `${ai}(${e.length - d})`;
		const m = e[d];
		t.truncate = s - a.length - (p ? 0 : n.length);
		const y = u || r(m, t) + (p ? '' : n),
			g = a.length + y.length,
			E = g + c.length;
		if (
			(p && g > s && a.length + c.length <= s) ||
			(!p && !f && E > s) ||
			((u = p ? '' : r(e[d + 1], t) + (f ? '' : n)), !p && f && E > s && g + u.length > s)
		)
			break;
		if (((a += y), !p && !f && g + u.length >= s)) {
			c = `${ai}(${e.length - d - 1})`;
			break;
		}
		c = '';
	}
	return `${a}${c}`;
}
i(sr, 'inspectList');
function IS(e) {
	return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
		? e
		: JSON.stringify(e)
				.replace(/'/g, "\\'")
				.replace(/\\"/g, '"')
				.replace(/(^"|"$)/g, "'");
}
i(IS, 'quoteComplexKey');
function li([e, t], r) {
	return (
		(r.truncate -= 2),
		typeof e == 'string' ? (e = IS(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
		(r.truncate -= e.length),
		(t = r.inspect(t, r)),
		`${e}: ${t}`
	);
}
i(li, 'inspectProperty');
function NS(e, t) {
	const r = Object.keys(e).slice(e.length);
	if (!e.length && !r.length) return '[]';
	t.truncate -= 4;
	const n = sr(e, t);
	t.truncate -= n.length;
	let o = '';
	return (
		r.length &&
			(o = sr(
				r.map((s) => [s, e[s]]),
				t,
				li
			)),
		`[ ${n}${o ? `, ${o}` : ''} ]`
	);
}
i(NS, 'inspectArray');
var o$ = i(
	(e) =>
		typeof Buffer == 'function' && e instanceof Buffer
			? 'Buffer'
			: e[Symbol.toStringTag]
				? e[Symbol.toStringTag]
				: e.constructor.name,
	'getArrayName'
);
function Tr(e, t) {
	const r = o$(e);
	t.truncate -= r.length + 4;
	const n = Object.keys(e).slice(e.length);
	if (!e.length && !n.length) return `${r}[]`;
	let o = '';
	for (let a = 0; a < e.length; a++) {
		const u = `${t.stylize(an(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
		if (((t.truncate -= u.length), e[a] !== e.length && t.truncate <= 3)) {
			o += `${ai}(${e.length - e[a] + 1})`;
			break;
		}
		o += u;
	}
	let s = '';
	return (
		n.length &&
			(s = sr(
				n.map((a) => [a, e[a]]),
				t,
				li
			)),
		`${r}[ ${o}${s ? `, ${s}` : ''} ]`
	);
}
i(Tr, 'inspectTypedArray');
function MS(e, t) {
	const r = e.toJSON();
	if (r === null) return 'Invalid Date';
	const n = r.split('T'),
		o = n[0];
	return t.stylize(`${o}T${an(n[1], t.truncate - o.length - 1)}`, 'date');
}
i(MS, 'inspectDate');
function zd(e, t) {
	const r = e[Symbol.toStringTag] || 'Function',
		n = e.name;
	return n
		? t.stylize(`[${r} ${an(n, t.truncate - 11)}]`, 'special')
		: t.stylize(`[${r}]`, 'special');
}
i(zd, 'inspectFunction');
function qS([e, t], r) {
	return (
		(r.truncate -= 4),
		(e = r.inspect(e, r)),
		(r.truncate -= e.length),
		(t = r.inspect(t, r)),
		`${e} => ${t}`
	);
}
i(qS, 'inspectMapEntry');
function jS(e) {
	const t = [];
	return (
		e.forEach((r, n) => {
			t.push([n, r]);
		}),
		t
	);
}
i(jS, 'mapToEntries');
function DS(e, t) {
	return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${sr(jS(e), t, qS)} }`);
}
i(DS, 'inspectMap');
var i$ = Number.isNaN || ((e) => e !== e);
function Wd(e, t) {
	return i$(e)
		? t.stylize('NaN', 'number')
		: e === 1 / 0
			? t.stylize('Infinity', 'number')
			: e === -1 / 0
				? t.stylize('-Infinity', 'number')
				: e === 0
					? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
					: t.stylize(an(String(e), t.truncate), 'number');
}
i(Wd, 'inspectNumber');
function Kd(e, t) {
	let r = an(e.toString(), t.truncate - 1);
	return (r !== ai && (r += 'n'), t.stylize(r, 'bigint'));
}
i(Kd, 'inspectBigInt');
function kS(e, t) {
	const r = e.toString().split('/')[2],
		n = t.truncate - (2 + r.length),
		o = e.source;
	return t.stylize(`/${an(o, n)}/${r}`, 'regexp');
}
i(kS, 'inspectRegExp');
function LS(e) {
	const t = [];
	return (
		e.forEach((r) => {
			t.push(r);
		}),
		t
	);
}
i(LS, 'arrayFromSet');
function FS(e, t) {
	return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${sr(LS(e), t)} }`);
}
i(FS, 'inspectSet');
var Db = new RegExp(
		"['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
		'g'
	),
	s$ = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
	a$ = 16;
function BS(e) {
	return s$[e] || `\\u${`0000${e.charCodeAt(0).toString(a$)}`.slice(-4)}`;
}
i(BS, 'escape');
function Yd(e, t) {
	return (Db.test(e) && (e = e.replace(Db, BS)), t.stylize(`'${an(e, t.truncate - 2)}'`, 'string'));
}
i(Yd, 'inspectString');
function Xd(e) {
	return 'description' in Symbol.prototype
		? e.description
			? `Symbol(${e.description})`
			: 'Symbol()'
		: e.toString();
}
i(Xd, 'inspectSymbol');
var l$ = i(() => 'Promise{}', 'getPromiseValue'),
	u$ = l$;
function Os(e, t) {
	const r = Object.getOwnPropertyNames(e),
		n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
	if (r.length === 0 && n.length === 0) return '{}';
	if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
	t.seen.push(e);
	const o = sr(
			r.map((u) => [u, e[u]]),
			t,
			li
		),
		s = sr(
			n.map((u) => [u, e[u]]),
			t,
			li
		);
	t.seen.pop();
	let a = '';
	return (o && s && (a = ', '), `{ ${o}${a}${s} }`);
}
i(Os, 'inspectObject');
var ud = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function JS(e, t) {
	let r = '';
	return (
		ud && ud in e && (r = e[ud]),
		(r = r || e.constructor.name),
		(!r || r === '_class') && (r = '<Anonymous Class>'),
		(t.truncate -= r.length),
		`${r}${Os(e, t)}`
	);
}
i(JS, 'inspectClass');
function $S(e, t) {
	return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${sr(e, t)} ]`);
}
i($S, 'inspectArguments');
var c$ = [
	'stack',
	'line',
	'column',
	'name',
	'message',
	'fileName',
	'lineNumber',
	'columnNumber',
	'number',
	'description',
	'cause'
];
function US(e, t) {
	const r = Object.getOwnPropertyNames(e).filter((a) => c$.indexOf(a) === -1),
		n = e.name;
	t.truncate -= n.length;
	let o = '';
	if (
		(typeof e.message == 'string' ? (o = an(e.message, t.truncate)) : r.unshift('message'),
		(o = o ? `: ${o}` : ''),
		(t.truncate -= o.length + 5),
		(t.seen = t.seen || []),
		t.seen.includes(e))
	)
		return '[Circular]';
	t.seen.push(e);
	const s = sr(
		r.map((a) => [a, e[a]]),
		t,
		li
	);
	return `${n}${o}${s ? ` { ${s} }` : ''}`;
}
i(US, 'inspectObject');
function VS([e, t], r) {
	return (
		(r.truncate -= 3),
		t
			? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
			: `${r.stylize(String(e), 'yellow')}`
	);
}
i(VS, 'inspectAttribute');
function hl(e, t) {
	return sr(
		e,
		t,
		HS,
		`
`
	);
}
i(hl, 'inspectNodeCollection');
function HS(e, t) {
	switch (e.nodeType) {
		case 1:
			return jm(e, t);
		case 3:
			return t.inspect(e.data, t);
		default:
			return t.inspect(e, t);
	}
}
i(HS, 'inspectNode');
function jm(e, t) {
	const r = e.getAttributeNames(),
		n = e.tagName.toLowerCase(),
		o = t.stylize(`<${n}`, 'special'),
		s = t.stylize('>', 'special'),
		a = t.stylize(`</${n}>`, 'special');
	t.truncate -= n.length * 2 + 5;
	let u = '';
	(r.length > 0 &&
		((u += ' '),
		(u += sr(
			r.map((p) => [p, e.getAttribute(p)]),
			t,
			VS,
			' '
		))),
		(t.truncate -= u.length));
	const c = t.truncate;
	let d = hl(e.children, t);
	return (d && d.length > c && (d = `${ai}(${e.children.length})`), `${o}${u}${s}${d}${a}`);
}
i(jm, 'inspectHTML');
var d$ = typeof Symbol == 'function' && typeof Symbol.for == 'function',
	cd = d$ ? Symbol.for('chai/inspect') : '@@chai/inspect',
	dd = Symbol.for('nodejs.util.inspect.custom'),
	kb = new WeakMap(),
	Lb = {},
	Fb = {
		undefined: i((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
		null: i((e, t) => t.stylize('null', 'null'), 'null'),
		boolean: i((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
		Boolean: i((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
		number: Wd,
		Number: Wd,
		bigint: Kd,
		BigInt: Kd,
		string: Yd,
		String: Yd,
		function: zd,
		Function: zd,
		symbol: Xd,
		Symbol: Xd,
		Array: NS,
		Date: MS,
		Map: DS,
		Set: FS,
		RegExp: kS,
		Promise: u$,
		WeakSet: i((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
		WeakMap: i((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
		Arguments: $S,
		Int8Array: Tr,
		Uint8Array: Tr,
		Uint8ClampedArray: Tr,
		Int16Array: Tr,
		Uint16Array: Tr,
		Int32Array: Tr,
		Uint32Array: Tr,
		Float32Array: Tr,
		Float64Array: Tr,
		Generator: i(() => '', 'Generator'),
		DataView: i(() => '', 'DataView'),
		ArrayBuffer: i(() => '', 'ArrayBuffer'),
		Error: US,
		HTMLCollection: hl,
		NodeList: hl
	},
	p$ = i(
		(e, t, r, n) =>
			cd in e && typeof e[cd] == 'function'
				? e[cd](t)
				: dd in e && typeof e[dd] == 'function'
					? e[dd](t.depth, t, n)
					: 'inspect' in e && typeof e.inspect == 'function'
						? e.inspect(t.depth, t)
						: 'constructor' in e && kb.has(e.constructor)
							? kb.get(e.constructor)(e, t)
							: Lb[r]
								? Lb[r](e, t)
								: '',
		'inspectCustom'
	),
	f$ = Object.prototype.toString;
function Cs(e, t = {}) {
	const r = CS(t, Cs),
		{ customInspect: n } = r;
	let o = e === null ? 'null' : typeof e;
	if ((o === 'object' && (o = f$.call(e).slice(8, -1)), o in Fb)) return Fb[o](e, r);
	if (n && e) {
		const a = p$(e, r, o, Cs);
		if (a) return typeof a == 'string' ? a : Cs(a, r);
	}
	const s = e ? Object.getPrototypeOf(e) : !1;
	return s === Object.prototype || s === null
		? Os(e, r)
		: e && typeof HTMLElement == 'function' && e instanceof HTMLElement
			? jm(e, r)
			: 'constructor' in e
				? e.constructor !== Object
					? JS(e, r)
					: Os(e, r)
				: e === Object(e)
					? Os(e, r)
					: r.stylize(String(e), o);
}
i(Cs, 'inspect');
var {
		AsymmetricMatcher: m$,
		DOMCollection: h$,
		DOMElement: y$,
		Immutable: g$,
		ReactElement: b$,
		ReactTestComponent: v$
	} = qm,
	Bb = [v$, b$, y$, h$, g$, m$];
function jt(e, t = 10, { maxLength: r, ...n } = {}) {
	const o = r ?? 1e4;
	let s;
	try {
		s = fr(e, { maxDepth: t, escapeString: !1, plugins: Bb, ...n });
	} catch {
		s = fr(e, { callToJSON: !1, maxDepth: t, escapeString: !1, plugins: Bb, ...n });
	}
	return s.length >= o && t > 1
		? jt(e, Math.floor(Math.min(t, Number.MAX_SAFE_INTEGER) / 2), { maxLength: r, ...n })
		: s;
}
i(jt, 'stringify');
var E$ = /%[sdjifoOc%]/g;
function GS(...e) {
	if (typeof e[0] != 'string') {
		const s = [];
		for (let a = 0; a < e.length; a++) s.push(Fo(e[a], { depth: 0, colors: !1 }));
		return s.join(' ');
	}
	const t = e.length;
	let r = 1;
	const n = e[0];
	let o = String(n).replace(E$, (s) => {
		if (s === '%%') return '%';
		if (r >= t) return s;
		switch (s) {
			case '%s': {
				const a = e[r++];
				return typeof a == 'bigint'
					? `${a.toString()}n`
					: typeof a == 'number' && a === 0 && 1 / a < 0
						? '-0'
						: typeof a == 'object' && a !== null
							? typeof a.toString == 'function' && a.toString !== Object.prototype.toString
								? a.toString()
								: Fo(a, { depth: 0, colors: !1 })
							: String(a);
			}
			case '%d': {
				const a = e[r++];
				return typeof a == 'bigint' ? `${a.toString()}n` : Number(a).toString();
			}
			case '%i': {
				const a = e[r++];
				return typeof a == 'bigint' ? `${a.toString()}n` : Number.parseInt(String(a)).toString();
			}
			case '%f':
				return Number.parseFloat(String(e[r++])).toString();
			case '%o':
				return Fo(e[r++], { showHidden: !0, showProxy: !0 });
			case '%O':
				return Fo(e[r++]);
			case '%c':
				return (r++, '');
			case '%j':
				try {
					return JSON.stringify(e[r++]);
				} catch (a) {
					const u = a.message;
					if (
						u.includes('circular structure') ||
						u.includes('cyclic structures') ||
						u.includes('cyclic object')
					)
						return '[Circular]';
					throw a;
				}
			default:
				return s;
		}
	});
	for (let s = e[r]; r < t; s = e[++r])
		s === null || typeof s != 'object' ? (o += ` ${s}`) : (o += ` ${Fo(s)}`);
	return o;
}
i(GS, 'format');
function Fo(e, t = {}) {
	return (t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), Cs(e, t));
}
i(Fo, 'inspect');
function Dm(e) {
	return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
i(Dm, 'getDefaultExportFromCjs');
function _r(e, t, r) {
	const n = typeof e;
	if (!r.includes(n)) throw new TypeError(`${t} value must be ${r.join(' or ')}, received "${n}"`);
}
i(_r, 'assertTypes');
function xs(e) {
	return e != null && typeof e == 'object' && !Array.isArray(e);
}
i(xs, 'isObject');
function zS(e) {
	return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
i(zS, 'isFinalObj');
function Gs(e) {
	return Object.prototype.toString.apply(e).slice(8, -1);
}
i(Gs, 'getType');
function WS(e, t) {
	const r = typeof t == 'function' ? t : (n) => t.add(n);
	(Object.getOwnPropertyNames(e).forEach(r), Object.getOwnPropertySymbols(e).forEach(r));
}
i(WS, 'collectOwnProperties');
function km(e) {
	const t = new Set();
	return zS(e) ? [] : (WS(e, t), Array.from(t));
}
i(km, 'getOwnProperties');
var KS = { forceWritable: !1 };
function Qd(e, t = KS) {
	return yl(e, new WeakMap(), t);
}
i(Qd, 'deepClone');
function yl(e, t, r = KS) {
	let n, o;
	if (t.has(e)) return t.get(e);
	if (Array.isArray(e)) {
		for (o = Array.from({ length: (n = e.length) }), t.set(e, o); n--; ) o[n] = yl(e[n], t, r);
		return o;
	}
	if (Object.prototype.toString.call(e) === '[object Object]') {
		((o = Object.create(Object.getPrototypeOf(e))), t.set(e, o));
		const s = km(e);
		for (const a of s) {
			const u = Object.getOwnPropertyDescriptor(e, a);
			if (!u) continue;
			const c = yl(e[a], t, r);
			r.forceWritable
				? Object.defineProperty(o, a, {
						enumerable: u.enumerable,
						configurable: !0,
						writable: !0,
						value: c
					})
				: 'get' in u
					? Object.defineProperty(o, a, {
							...u,
							get() {
								return c;
							}
						})
					: Object.defineProperty(o, a, { ...u, value: c });
		}
		return o;
	}
	return e;
}
i(yl, 'clone');
function YS() {}
i(YS, 'noop');
var At = -1,
	ht = 1,
	We = 0,
	XS = class {
		0;
		1;
		constructor(t, r) {
			((this[0] = t), (this[1] = r));
		}
	};
i(XS, 'Diff');
var He = XS;
function QS(e, t) {
	if (!e || !t || e.charAt(0) !== t.charAt(0)) return 0;
	let r = 0,
		n = Math.min(e.length, t.length),
		o = n,
		s = 0;
	for (; r < o; )
		(e.substring(s, o) === t.substring(s, o) ? ((r = o), (s = r)) : (n = o),
			(o = Math.floor((n - r) / 2 + r)));
	return o;
}
i(QS, 'diff_commonPrefix');
function Lm(e, t) {
	if (!e || !t || e.charAt(e.length - 1) !== t.charAt(t.length - 1)) return 0;
	let r = 0,
		n = Math.min(e.length, t.length),
		o = n,
		s = 0;
	for (; r < o; )
		(e.substring(e.length - o, e.length - s) === t.substring(t.length - o, t.length - s)
			? ((r = o), (s = r))
			: (n = o),
			(o = Math.floor((n - r) / 2 + r)));
	return o;
}
i(Lm, 'diff_commonSuffix');
function Zd(e, t) {
	const r = e.length,
		n = t.length;
	if (r === 0 || n === 0) return 0;
	r > n ? (e = e.substring(r - n)) : r < n && (t = t.substring(0, r));
	const o = Math.min(r, n);
	if (e === t) return o;
	let s = 0,
		a = 1;
	for (;;) {
		const u = e.substring(o - a),
			c = t.indexOf(u);
		if (c === -1) return s;
		((a += c), (c === 0 || e.substring(o - a) === t.substring(0, a)) && ((s = a), a++));
	}
}
i(Zd, 'diff_commonOverlap_');
function ZS(e) {
	let t = !1;
	const r = [];
	let n = 0,
		o = null,
		s = 0,
		a = 0,
		u = 0,
		c = 0,
		d = 0;
	for (; s < e.length; )
		(e[s][0] === We
			? ((r[n++] = s), (a = c), (u = d), (c = 0), (d = 0), (o = e[s][1]))
			: (e[s][0] === ht ? (c += e[s][1].length) : (d += e[s][1].length),
				o &&
					o.length <= Math.max(a, u) &&
					o.length <= Math.max(c, d) &&
					(e.splice(r[n - 1], 0, new He(At, o)),
					(e[r[n - 1] + 1][0] = ht),
					n--,
					n--,
					(s = n > 0 ? r[n - 1] : -1),
					(a = 0),
					(u = 0),
					(c = 0),
					(d = 0),
					(o = null),
					(t = !0))),
			s++);
	for (t && Fm(e), e0(e), s = 1; s < e.length; ) {
		if (e[s - 1][0] === At && e[s][0] === ht) {
			const p = e[s - 1][1],
				f = e[s][1],
				m = Zd(p, f),
				y = Zd(f, p);
			(m >= y
				? (m >= p.length / 2 || m >= f.length / 2) &&
					(e.splice(s, 0, new He(We, f.substring(0, m))),
					(e[s - 1][1] = p.substring(0, p.length - m)),
					(e[s + 1][1] = f.substring(m)),
					s++)
				: (y >= p.length / 2 || y >= f.length / 2) &&
					(e.splice(s, 0, new He(We, p.substring(0, y))),
					(e[s - 1][0] = ht),
					(e[s - 1][1] = f.substring(0, f.length - y)),
					(e[s + 1][0] = At),
					(e[s + 1][1] = p.substring(y)),
					s++),
				s++);
		}
		s++;
	}
}
i(ZS, 'diff_cleanupSemantic');
var Jb = /[^a-z0-9]/i,
	$b = /\s/,
	Ub = /[\r\n]/,
	T$ = /\n\r?\n$/,
	_$ = /^\r?\n\r?\n/;
function e0(e) {
	let t = 1;
	for (; t < e.length - 1; ) {
		if (e[t - 1][0] === We && e[t + 1][0] === We) {
			let r = e[t - 1][1],
				n = e[t][1],
				o = e[t + 1][1];
			const s = Lm(r, n);
			if (s) {
				const p = n.substring(n.length - s);
				((r = r.substring(0, r.length - s)), (n = p + n.substring(0, n.length - s)), (o = p + o));
			}
			let a = r,
				u = n,
				c = o,
				d = gs(r, n) + gs(n, o);
			for (; n.charAt(0) === o.charAt(0); ) {
				((r += n.charAt(0)), (n = n.substring(1) + o.charAt(0)), (o = o.substring(1)));
				const p = gs(r, n) + gs(n, o);
				p >= d && ((d = p), (a = r), (u = n), (c = o));
			}
			e[t - 1][1] !== a &&
				(a ? (e[t - 1][1] = a) : (e.splice(t - 1, 1), t--),
				(e[t][1] = u),
				c ? (e[t + 1][1] = c) : (e.splice(t + 1, 1), t--));
		}
		t++;
	}
}
i(e0, 'diff_cleanupSemanticLossless');
function Fm(e) {
	e.push(new He(We, ''));
	let t = 0,
		r = 0,
		n = 0,
		o = '',
		s = '',
		a;
	for (; t < e.length; )
		switch (e[t][0]) {
			case ht:
				(n++, (s += e[t][1]), t++);
				break;
			case At:
				(r++, (o += e[t][1]), t++);
				break;
			case We:
				(r + n > 1
					? (r !== 0 &&
							n !== 0 &&
							((a = QS(s, o)),
							a !== 0 &&
								(t - r - n > 0 && e[t - r - n - 1][0] === We
									? (e[t - r - n - 1][1] += s.substring(0, a))
									: (e.splice(0, 0, new He(We, s.substring(0, a))), t++),
								(s = s.substring(a)),
								(o = o.substring(a))),
							(a = Lm(s, o)),
							a !== 0 &&
								((e[t][1] = s.substring(s.length - a) + e[t][1]),
								(s = s.substring(0, s.length - a)),
								(o = o.substring(0, o.length - a)))),
						(t -= r + n),
						e.splice(t, r + n),
						o.length && (e.splice(t, 0, new He(At, o)), t++),
						s.length && (e.splice(t, 0, new He(ht, s)), t++),
						t++)
					: t !== 0 && e[t - 1][0] === We
						? ((e[t - 1][1] += e[t][1]), e.splice(t, 1))
						: t++,
					(n = 0),
					(r = 0),
					(o = ''),
					(s = ''));
				break;
		}
	e[e.length - 1][1] === '' && e.pop();
	let u = !1;
	for (t = 1; t < e.length - 1; )
		(e[t - 1][0] === We &&
			e[t + 1][0] === We &&
			(e[t][1].substring(e[t][1].length - e[t - 1][1].length) === e[t - 1][1]
				? ((e[t][1] = e[t - 1][1] + e[t][1].substring(0, e[t][1].length - e[t - 1][1].length)),
					(e[t + 1][1] = e[t - 1][1] + e[t + 1][1]),
					e.splice(t - 1, 1),
					(u = !0))
				: e[t][1].substring(0, e[t + 1][1].length) === e[t + 1][1] &&
					((e[t - 1][1] += e[t + 1][1]),
					(e[t][1] = e[t][1].substring(e[t + 1][1].length) + e[t + 1][1]),
					e.splice(t + 1, 1),
					(u = !0))),
			t++);
	u && Fm(e);
}
i(Fm, 'diff_cleanupMerge');
function gs(e, t) {
	if (!e || !t) return 6;
	const r = e.charAt(e.length - 1),
		n = t.charAt(0),
		o = r.match(Jb),
		s = n.match(Jb),
		a = o && r.match($b),
		u = s && n.match($b),
		c = a && r.match(Ub),
		d = u && n.match(Ub),
		p = c && e.match(T$),
		f = d && t.match(_$);
	return p || f ? 5 : c || d ? 4 : o && !a && u ? 3 : a || u ? 2 : o || s ? 1 : 0;
}
i(gs, 'diff_cleanupSemanticScore_');
var t0 = 'Compared values have no visual difference.',
	w$ =
		'Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.',
	Ja = {},
	Vb;
function r0() {
	if (Vb) return Ja;
	((Vb = 1), Object.defineProperty(Ja, '__esModule', { value: !0 }), (Ja.default = m));
	const e = 'diff-sequences',
		t = 0,
		r = i((y, g, E, T, b) => {
			let w = 0;
			for (; y < g && E < T && b(y, E); ) ((y += 1), (E += 1), (w += 1));
			return w;
		}, 'countCommonItemsF'),
		n = i((y, g, E, T, b) => {
			let w = 0;
			for (; y <= g && E <= T && b(g, T); ) ((g -= 1), (T -= 1), (w += 1));
			return w;
		}, 'countCommonItemsR'),
		o = i((y, g, E, T, b, w, P) => {
			let I = 0,
				q = -y,
				C = w[I],
				R = C;
			w[I] += r(C + 1, g, T + C - q + 1, E, b);
			const _ = y < P ? y : P;
			for (I += 1, q += 2; I <= _; I += 1, q += 2) {
				if (I !== y && R < w[I]) C = w[I];
				else if (((C = R + 1), g <= C)) return I - 1;
				((R = w[I]), (w[I] = C + r(C + 1, g, T + C - q + 1, E, b)));
			}
			return P;
		}, 'extendPathsF'),
		s = i((y, g, E, T, b, w, P) => {
			let I = 0,
				q = y,
				C = w[I],
				R = C;
			w[I] -= n(g, C - 1, E, T + C - q - 1, b);
			const _ = y < P ? y : P;
			for (I += 1, q -= 2; I <= _; I += 1, q -= 2) {
				if (I !== y && w[I] < R) C = w[I];
				else if (((C = R - 1), C < g)) return I - 1;
				((R = w[I]), (w[I] = C - n(g, C - 1, E, T + C - q - 1, b)));
			}
			return P;
		}, 'extendPathsR'),
		a = i((y, g, E, T, b, w, P, I, q, C, R) => {
			const _ = T - g,
				S = E - g,
				N = b - T - S,
				V = -N - (y - 1),
				H = -N + (y - 1);
			let A = t;
			const L = y < I ? y : I;
			for (let B = 0, k = -y; B <= L; B += 1, k += 2) {
				const K = B === 0 || (B !== y && A < P[B]),
					X = K ? P[B] : A,
					ie = K ? X : X + 1,
					ae = _ + ie - k,
					W = r(ie + 1, E, ae + 1, b, w),
					le = ie + W;
				if (((A = P[B]), (P[B] = le), V <= k && k <= H)) {
					const ve = (y - 1 - (k + N)) / 2;
					if (ve <= C && q[ve] - 1 <= le) {
						const de = _ + X - (K ? k + 1 : k - 1),
							ee = n(g, X, T, de, w),
							xe = X - ee,
							Ie = de - ee,
							Xe = xe + 1,
							rt = Ie + 1;
						((R.nChangePreceding = y - 1),
							y - 1 === Xe + rt - g - T
								? ((R.aEndPreceding = g), (R.bEndPreceding = T))
								: ((R.aEndPreceding = Xe), (R.bEndPreceding = rt)),
							(R.nCommonPreceding = ee),
							ee !== 0 && ((R.aCommonPreceding = Xe), (R.bCommonPreceding = rt)),
							(R.nCommonFollowing = W),
							W !== 0 && ((R.aCommonFollowing = ie + 1), (R.bCommonFollowing = ae + 1)));
						const $ = le + 1,
							Q = ae + W + 1;
						return (
							(R.nChangeFollowing = y - 1),
							y - 1 === E + b - $ - Q
								? ((R.aStartFollowing = E), (R.bStartFollowing = b))
								: ((R.aStartFollowing = $), (R.bStartFollowing = Q)),
							!0
						);
					}
				}
			}
			return !1;
		}, 'extendOverlappablePathsF'),
		u = i((y, g, E, T, b, w, P, I, q, C, R) => {
			const _ = b - E,
				S = E - g,
				N = b - T - S,
				V = N - y,
				H = N + y;
			let A = t;
			const L = y < C ? y : C;
			for (let B = 0, k = y; B <= L; B += 1, k -= 2) {
				const K = B === 0 || (B !== y && q[B] < A),
					X = K ? q[B] : A,
					ie = K ? X : X - 1,
					ae = _ + ie - k,
					W = n(g, ie - 1, T, ae - 1, w),
					le = ie - W;
				if (((A = q[B]), (q[B] = le), V <= k && k <= H)) {
					const ve = (y + (k - N)) / 2;
					if (ve <= I && le - 1 <= P[ve]) {
						const de = ae - W;
						if (
							((R.nChangePreceding = y),
							y === le + de - g - T
								? ((R.aEndPreceding = g), (R.bEndPreceding = T))
								: ((R.aEndPreceding = le), (R.bEndPreceding = de)),
							(R.nCommonPreceding = W),
							W !== 0 && ((R.aCommonPreceding = le), (R.bCommonPreceding = de)),
							(R.nChangeFollowing = y - 1),
							y === 1)
						)
							((R.nCommonFollowing = 0), (R.aStartFollowing = E), (R.bStartFollowing = b));
						else {
							const ee = _ + X - (K ? k - 1 : k + 1),
								xe = r(X, E, ee, b, w);
							((R.nCommonFollowing = xe),
								xe !== 0 && ((R.aCommonFollowing = X), (R.bCommonFollowing = ee)));
							const Ie = X + xe,
								Xe = ee + xe;
							y - 1 === E + b - Ie - Xe
								? ((R.aStartFollowing = E), (R.bStartFollowing = b))
								: ((R.aStartFollowing = Ie), (R.bStartFollowing = Xe));
						}
						return !0;
					}
				}
			}
			return !1;
		}, 'extendOverlappablePathsR'),
		c = i((y, g, E, T, b, w, P, I, q) => {
			const C = T - g,
				R = b - E,
				_ = E - g,
				S = b - T,
				D = S - _;
			let N = _,
				V = _;
			if (((P[0] = g - 1), (I[0] = E), D % 2 === 0)) {
				const H = (y || D) / 2,
					A = (_ + S) / 2;
				for (let L = 1; L <= A; L += 1)
					if (((N = o(L, E, b, C, w, P, N)), L < H)) V = s(L, g, T, R, w, I, V);
					else if (u(L, g, E, T, b, w, P, N, I, V, q)) return;
			} else {
				const H = ((y || D) + 1) / 2,
					A = (_ + S + 1) / 2;
				let L = 1;
				for (N = o(L, E, b, C, w, P, N), L += 1; L <= A; L += 1)
					if (((V = s(L - 1, g, T, R, w, I, V)), L < H)) N = o(L, E, b, C, w, P, N);
					else if (a(L, g, E, T, b, w, P, N, I, V, q)) return;
			}
			throw new Error(`${e}: no overlap aStart=${g} aEnd=${E} bStart=${T} bEnd=${b}`);
		}, 'divide'),
		d = i((y, g, E, T, b, w, P, I, q, C) => {
			if (b - T < E - g) {
				if (((w = !w), w && P.length === 1)) {
					const { foundSubsequence: le, isCommon: ve } = P[0];
					P[1] = {
						foundSubsequence: i((de, ee, xe) => {
							le(de, xe, ee);
						}, 'foundSubsequence'),
						isCommon: i((de, ee) => ve(ee, de), 'isCommon')
					};
				}
				const ae = g,
					W = E;
				((g = T), (E = b), (T = ae), (b = W));
			}
			const { foundSubsequence: R, isCommon: _ } = P[w ? 1 : 0];
			c(y, g, E, T, b, _, I, q, C);
			const {
				nChangePreceding: S,
				aEndPreceding: D,
				bEndPreceding: N,
				nCommonPreceding: V,
				aCommonPreceding: H,
				bCommonPreceding: A,
				nCommonFollowing: L,
				aCommonFollowing: B,
				bCommonFollowing: k,
				nChangeFollowing: K,
				aStartFollowing: X,
				bStartFollowing: ie
			} = C;
			(g < D && T < N && d(S, g, D, T, N, w, P, I, q, C),
				V !== 0 && R(V, H, A),
				L !== 0 && R(L, B, k),
				X < E && ie < b && d(K, X, E, ie, b, w, P, I, q, C));
		}, 'findSubsequences'),
		p = i((y, g) => {
			if (typeof g != 'number')
				throw new TypeError(`${e}: ${y} typeof ${typeof g} is not a number`);
			if (!Number.isSafeInteger(g))
				throw new RangeError(`${e}: ${y} value ${g} is not a safe integer`);
			if (g < 0) throw new RangeError(`${e}: ${y} value ${g} is a negative integer`);
		}, 'validateLength'),
		f = i((y, g) => {
			const E = typeof g;
			if (E !== 'function') throw new TypeError(`${e}: ${y} typeof ${E} is not a function`);
		}, 'validateCallback');
	function m(y, g, E, T) {
		(p('aLength', y), p('bLength', g), f('isCommon', E), f('foundSubsequence', T));
		const b = r(0, y, 0, g, E);
		if ((b !== 0 && T(b, 0, 0), y !== b || g !== b)) {
			const w = b,
				P = b,
				I = n(w, y - 1, P, g - 1, E),
				q = y - I,
				C = g - I,
				R = b + I;
			(y !== R &&
				g !== R &&
				d(0, w, q, P, C, !1, [{ foundSubsequence: T, isCommon: E }], [t], [t], {
					aCommonFollowing: t,
					aCommonPreceding: t,
					aEndPreceding: t,
					aStartFollowing: t,
					bCommonFollowing: t,
					bCommonPreceding: t,
					bEndPreceding: t,
					bStartFollowing: t,
					nChangeFollowing: t,
					nChangePreceding: t,
					nCommonFollowing: t,
					nCommonPreceding: t
				}),
				I !== 0 && T(I, q, C));
		}
	}
	return (i(m, 'diffSequence'), Ja);
}
i(r0, 'requireBuild');
var S$ = r0(),
	n0 = Dm(S$);
function o0(e, t) {
	return e.replace(/\s+$/, (r) => t(r));
}
i(o0, 'formatTrailingSpaces');
function Pu(e, t, r, n, o, s) {
	return e.length !== 0
		? r(`${n} ${o0(e, o)}`)
		: n !== ' '
			? r(n)
			: t && s.length !== 0
				? r(`${n} ${s}`)
				: '';
}
i(Pu, 'printDiffLine');
function Bm(
	e,
	t,
	{ aColor: r, aIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: s }
) {
	return Pu(e, t, r, n, o, s);
}
i(Bm, 'printDeleteLine');
function Jm(
	e,
	t,
	{ bColor: r, bIndicator: n, changeLineTrailingSpaceColor: o, emptyFirstOrLastLinePlaceholder: s }
) {
	return Pu(e, t, r, n, o, s);
}
i(Jm, 'printInsertLine');
function $m(
	e,
	t,
	{
		commonColor: r,
		commonIndicator: n,
		commonLineTrailingSpaceColor: o,
		emptyFirstOrLastLinePlaceholder: s
	}
) {
	return Pu(e, t, r, n, o, s);
}
i($m, 'printCommonLine');
function ep(e, t, r, n, { patchColor: o }) {
	return o(`@@ -${e + 1},${t - e} +${r + 1},${n - r} @@`);
}
i(ep, 'createPatchMark');
function i0(e, t) {
	const r = e.length,
		n = t.contextLines,
		o = n + n;
	let s = r,
		a = !1,
		u = 0,
		c = 0;
	for (; c !== r; ) {
		const I = c;
		for (; c !== r && e[c][0] === We; ) c += 1;
		if (I !== c)
			if (I === 0) c > n && ((s -= c - n), (a = !0));
			else if (c === r) {
				const q = c - I;
				q > n && ((s -= q - n), (a = !0));
			} else {
				const q = c - I;
				q > o && ((s -= q - o), (u += 1));
			}
		for (; c !== r && e[c][0] !== We; ) c += 1;
	}
	const d = u !== 0 || a;
	u !== 0 ? (s += u + 1) : a && (s += 1);
	const p = s - 1,
		f = [];
	let m = 0;
	d && f.push('');
	let y = 0,
		g = 0,
		E = 0,
		T = 0;
	const b = i((I) => {
			const q = f.length;
			(f.push($m(I, q === 0 || q === p, t)), (E += 1), (T += 1));
		}, 'pushCommonLine'),
		w = i((I) => {
			const q = f.length;
			(f.push(Bm(I, q === 0 || q === p, t)), (E += 1));
		}, 'pushDeleteLine'),
		P = i((I) => {
			const q = f.length;
			(f.push(Jm(I, q === 0 || q === p, t)), (T += 1));
		}, 'pushInsertLine');
	for (c = 0; c !== r; ) {
		let I = c;
		for (; c !== r && e[c][0] === We; ) c += 1;
		if (I !== c)
			if (I === 0) {
				c > n && ((I = c - n), (y = I), (g = I), (E = y), (T = g));
				for (let q = I; q !== c; q += 1) b(e[q][1]);
			} else if (c === r) {
				const q = c - I > n ? I + n : c;
				for (let C = I; C !== q; C += 1) b(e[C][1]);
			} else {
				const q = c - I;
				if (q > o) {
					const C = I + n;
					for (let _ = I; _ !== C; _ += 1) b(e[_][1]);
					((f[m] = ep(y, E, g, T, t)), (m = f.length), f.push(''));
					const R = q - o;
					((y = E + R), (g = T + R), (E = y), (T = g));
					for (let _ = c - n; _ !== c; _ += 1) b(e[_][1]);
				} else for (let C = I; C !== c; C += 1) b(e[C][1]);
			}
		for (; c !== r && e[c][0] === At; ) (w(e[c][1]), (c += 1));
		for (; c !== r && e[c][0] === ht; ) (P(e[c][1]), (c += 1));
	}
	return (
		d && (f[m] = ep(y, E, g, T, t)),
		f.join(`
`)
	);
}
i(i0, 'joinAlignedDiffsNoExpand');
function s0(e, t) {
	return e.map((r, n, o) => {
		const s = r[1],
			a = n === 0 || n === o.length - 1;
		switch (r[0]) {
			case At:
				return Bm(s, a, t);
			case ht:
				return Jm(s, a, t);
			default:
				return $m(s, a, t);
		}
	}).join(`
`);
}
i(s0, 'joinAlignedDiffsExpand');
var pd = i((e) => e, 'noColor'),
	a0 = 5,
	R$ = 0;
function l0() {
	return {
		aAnnotation: 'Expected',
		aColor: Ke.green,
		aIndicator: '-',
		bAnnotation: 'Received',
		bColor: Ke.red,
		bIndicator: '+',
		changeColor: Ke.inverse,
		changeLineTrailingSpaceColor: pd,
		commonColor: Ke.dim,
		commonIndicator: ' ',
		commonLineTrailingSpaceColor: pd,
		compareKeys: void 0,
		contextLines: a0,
		emptyFirstOrLastLinePlaceholder: '',
		expand: !1,
		includeChangeCounts: !1,
		omitAnnotationLines: !1,
		patchColor: Ke.yellow,
		printBasicPrototype: !1,
		truncateThreshold: R$,
		truncateAnnotation: '... Diff result is truncated',
		truncateAnnotationColor: pd
	};
}
i(l0, 'getDefaultOptions');
function u0(e) {
	return e && typeof e == 'function' ? e : void 0;
}
i(u0, 'getCompareKeys');
function c0(e) {
	return typeof e == 'number' && Number.isSafeInteger(e) && e >= 0 ? e : a0;
}
i(c0, 'getContextLines');
function Ln(e = {}) {
	return { ...l0(), ...e, compareKeys: u0(e.compareKeys), contextLines: c0(e.contextLines) };
}
i(Ln, 'normalizeDiffOptions');
function Xn(e) {
	return e.length === 1 && e[0].length === 0;
}
i(Xn, 'isEmptyString');
function d0(e) {
	let t = 0,
		r = 0;
	return (
		e.forEach((n) => {
			switch (n[0]) {
				case At:
					t += 1;
					break;
				case ht:
					r += 1;
					break;
			}
		}),
		{ a: t, b: r }
	);
}
i(d0, 'countChanges');
function p0(
	{
		aAnnotation: e,
		aColor: t,
		aIndicator: r,
		bAnnotation: n,
		bColor: o,
		bIndicator: s,
		includeChangeCounts: a,
		omitAnnotationLines: u
	},
	c
) {
	if (u) return '';
	let d = '',
		p = '';
	if (a) {
		const y = String(c.a),
			g = String(c.b),
			E = n.length - e.length,
			T = ' '.repeat(Math.max(0, E)),
			b = ' '.repeat(Math.max(0, -E)),
			w = g.length - y.length,
			P = ' '.repeat(Math.max(0, w)),
			I = ' '.repeat(Math.max(0, -w));
		((d = `${T}  ${r} ${P}${y}`), (p = `${b}  ${s} ${I}${g}`));
	}
	const f = `${r} ${e}${d}`,
		m = `${s} ${n}${p}`;
	return `${t(f)}
${o(m)}

`;
}
i(p0, 'printAnnotation');
function Au(e, t, r) {
	return (
		p0(r, d0(e)) +
		(r.expand ? s0(e, r) : i0(e, r)) +
		(t
			? r.truncateAnnotationColor(`
${r.truncateAnnotation}`)
			: '')
	);
}
i(Au, 'printDiffLines');
function ga(e, t, r) {
	const n = Ln(r),
		[o, s] = Um(Xn(e) ? [] : e, Xn(t) ? [] : t, n);
	return Au(o, s, n);
}
i(ga, 'diffLinesUnified');
function f0(e, t, r, n, o) {
	if (
		(Xn(e) && Xn(r) && ((e = []), (r = [])),
		Xn(t) && Xn(n) && ((t = []), (n = [])),
		e.length !== r.length || t.length !== n.length)
	)
		return ga(e, t, o);
	const [s, a] = Um(r, n, o);
	let u = 0,
		c = 0;
	return (
		s.forEach((d) => {
			switch (d[0]) {
				case At:
					((d[1] = e[u]), (u += 1));
					break;
				case ht:
					((d[1] = t[c]), (c += 1));
					break;
				default:
					((d[1] = t[c]), (u += 1), (c += 1));
			}
		}),
		Au(s, a, Ln(o))
	);
}
i(f0, 'diffLinesUnified2');
function Um(e, t, r) {
	const n = r?.truncateThreshold ?? !1,
		o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0),
		s = n ? Math.min(e.length, o) : e.length,
		a = n ? Math.min(t.length, o) : t.length,
		u = s !== e.length || a !== t.length,
		c = i((y, g) => e[y] === t[g], 'isCommon'),
		d = [];
	let p = 0,
		f = 0;
	for (
		n0(
			s,
			a,
			c,
			i((y, g, E) => {
				for (; p !== g; p += 1) d.push(new He(At, e[p]));
				for (; f !== E; f += 1) d.push(new He(ht, t[f]));
				for (; y !== 0; y -= 1, p += 1, f += 1) d.push(new He(We, t[f]));
			}, 'foundSubsequence')
		);
		p !== s;
		p += 1
	)
		d.push(new He(At, e[p]));
	for (; f !== a; f += 1) d.push(new He(ht, t[f]));
	return [d, u];
}
i(Um, 'diffLinesRaw');
function tp(e) {
	if (e === void 0) return 'undefined';
	if (e === null) return 'null';
	if (Array.isArray(e)) return 'array';
	if (typeof e == 'boolean') return 'boolean';
	if (typeof e == 'function') return 'function';
	if (typeof e == 'number') return 'number';
	if (typeof e == 'string') return 'string';
	if (typeof e == 'bigint') return 'bigint';
	if (typeof e == 'object') {
		if (e != null) {
			if (e.constructor === RegExp) return 'regexp';
			if (e.constructor === Map) return 'map';
			if (e.constructor === Set) return 'set';
			if (e.constructor === Date) return 'date';
		}
		return 'object';
	} else if (typeof e == 'symbol') return 'symbol';
	throw new Error(`value of unknown type: ${e}`);
}
i(tp, 'getType');
function rp(e) {
	return e.includes(`\r
`)
		? `\r
`
		: `
`;
}
i(rp, 'getNewLineSymbol');
function m0(e, t, r) {
	const n = r?.truncateThreshold ?? !1,
		o = Math.max(Math.floor(r?.truncateThreshold ?? 0), 0);
	let s = e.length,
		a = t.length;
	if (n) {
		const y = e.includes(`
`),
			g = t.includes(`
`),
			E = rp(e),
			T = rp(t),
			b = y
				? `${e.split(E, o).join(E)}
`
				: e,
			w = g
				? `${t.split(T, o).join(T)}
`
				: t;
		((s = b.length), (a = w.length));
	}
	const u = s !== e.length || a !== t.length,
		c = i((y, g) => e[y] === t[g], 'isCommon');
	let d = 0,
		p = 0;
	const f = [];
	return (
		n0(
			s,
			a,
			c,
			i((y, g, E) => {
				(d !== g && f.push(new He(At, e.slice(d, g))),
					p !== E && f.push(new He(ht, t.slice(p, E))),
					(d = g + y),
					(p = E + y),
					f.push(new He(We, t.slice(E, p))));
			}, 'foundSubsequence')
		),
		d !== s && f.push(new He(At, e.slice(d))),
		p !== a && f.push(new He(ht, t.slice(p))),
		[f, u]
	);
}
i(m0, 'diffStrings');
function h0(e, t, r) {
	return t.reduce(
		(n, o) => n + (o[0] === We ? o[1] : o[0] === e && o[1].length !== 0 ? r(o[1]) : ''),
		''
	);
}
i(h0, 'concatenateRelevantDiffs');
var y0 = class {
	op;
	line;
	lines;
	changeColor;
	constructor(t, r) {
		((this.op = t), (this.line = []), (this.lines = []), (this.changeColor = r));
	}
	pushSubstring(t) {
		this.pushDiff(new He(this.op, t));
	}
	pushLine() {
		(this.lines.push(
			this.line.length !== 1
				? new He(this.op, h0(this.op, this.line, this.changeColor))
				: this.line[0][0] === this.op
					? this.line[0]
					: new He(this.op, this.line[0][1])
		),
			(this.line.length = 0));
	}
	isLineEmpty() {
		return this.line.length === 0;
	}
	pushDiff(t) {
		this.line.push(t);
	}
	align(t) {
		const r = t[1];
		if (
			r.includes(`
`)
		) {
			const n = r.split(`
`),
				o = n.length - 1;
			n.forEach((s, a) => {
				a < o ? (this.pushSubstring(s), this.pushLine()) : s.length !== 0 && this.pushSubstring(s);
			});
		} else this.pushDiff(t);
	}
	moveLinesTo(t) {
		(this.isLineEmpty() || this.pushLine(), t.push(...this.lines), (this.lines.length = 0));
	}
};
i(y0, 'ChangeBuffer');
var Hb = y0,
	g0 = class {
		deleteBuffer;
		insertBuffer;
		lines;
		constructor(t, r) {
			((this.deleteBuffer = t), (this.insertBuffer = r), (this.lines = []));
		}
		pushDiffCommonLine(t) {
			this.lines.push(t);
		}
		pushDiffChangeLines(t) {
			const r = t[1].length === 0;
			((!r || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(t),
				(!r || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(t));
		}
		flushChangeLines() {
			(this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines));
		}
		align(t) {
			const r = t[0],
				n = t[1];
			if (
				n.includes(`
`)
			) {
				const o = n.split(`
`),
					s = o.length - 1;
				o.forEach((a, u) => {
					if (u === 0) {
						const c = new He(r, a);
						this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()
							? (this.flushChangeLines(), this.pushDiffCommonLine(c))
							: (this.pushDiffChangeLines(c), this.flushChangeLines());
					} else
						u < s
							? this.pushDiffCommonLine(new He(r, a))
							: a.length !== 0 && this.pushDiffChangeLines(new He(r, a));
				});
			} else this.pushDiffChangeLines(t);
		}
		getLines() {
			return (this.flushChangeLines(), this.lines);
		}
	};
i(g0, 'CommonBuffer');
var P$ = g0;
function b0(e, t) {
	const r = new Hb(At, t),
		n = new Hb(ht, t),
		o = new P$(r, n);
	return (
		e.forEach((s) => {
			switch (s[0]) {
				case At:
					r.align(s);
					break;
				case ht:
					n.align(s);
					break;
				default:
					o.align(s);
			}
		}),
		o.getLines()
	);
}
i(b0, 'getAlignedDiffs');
function v0(e, t) {
	if (t) {
		const r = e.length - 1;
		return e.some(
			(n, o) =>
				n[0] === We &&
				(o !== r ||
					n[1] !==
						`
`)
		);
	}
	return e.some((r) => r[0] === We);
}
i(v0, 'hasCommonDiff');
function E0(e, t, r) {
	if (e !== t && e.length !== 0 && t.length !== 0) {
		const n =
				e.includes(`
`) ||
				t.includes(`
`),
			[o, s] = Vm(
				n
					? `${e}
`
					: e,
				n
					? `${t}
`
					: t,
				!0,
				r
			);
		if (v0(o, n)) {
			const a = Ln(r),
				u = b0(o, a.changeColor);
			return Au(u, s, a);
		}
	}
	return ga(
		e.split(`
`),
		t.split(`
`),
		r
	);
}
i(E0, 'diffStringsUnified');
function Vm(e, t, r, n) {
	const [o, s] = m0(e, t, n);
	return (r && ZS(o), [o, s]);
}
i(Vm, 'diffStringsRaw');
function gl(e, t) {
	const { commonColor: r } = Ln(t);
	return r(e);
}
i(gl, 'getCommonMessage');
var {
		AsymmetricMatcher: A$,
		DOMCollection: O$,
		DOMElement: C$,
		Immutable: x$,
		ReactElement: I$,
		ReactTestComponent: N$
	} = qm,
	T0 = [N$, I$, C$, O$, x$, A$, qm.Error],
	np = { maxDepth: 20, plugins: T0 },
	_0 = { callToJSON: !1, maxDepth: 8, plugins: T0 };
function Oo(e, t, r) {
	if (Object.is(e, t)) return '';
	const n = tp(e);
	let o = n,
		s = !1;
	if (n === 'object' && typeof e.asymmetricMatch == 'function') {
		if (
			e.$$typeof !== Symbol.for('jest.asymmetricMatcher') ||
			typeof e.getExpectedType != 'function'
		)
			return;
		((o = e.getExpectedType()), (s = o === 'string'));
	}
	if (o !== tp(t)) {
		let a = function (P) {
			return P.length <= T ? P : `${P.slice(0, T)}...`;
		};
		i(a, 'truncate');
		const {
				aAnnotation: u,
				aColor: c,
				aIndicator: d,
				bAnnotation: p,
				bColor: f,
				bIndicator: m
			} = Ln(r),
			y = bl(_0, r);
		let g = fr(e, y),
			E = fr(t, y);
		const T = 1e5;
		((g = a(g)), (E = a(E)));
		const b = `${c(`${d} ${u}:`)} 
${g}`,
			w = `${f(`${m} ${p}:`)} 
${E}`;
		return `${b}

${w}`;
	}
	if (!s)
		switch (n) {
			case 'string':
				return ga(
					e.split(`
`),
					t.split(`
`),
					r
				);
			case 'boolean':
			case 'number':
				return w0(e, t, r);
			case 'map':
				return Qa(op(e), op(t), r);
			case 'set':
				return Qa(ip(e), ip(t), r);
			default:
				return Qa(e, t, r);
		}
}
i(Oo, 'diff');
function w0(e, t, r) {
	const n = fr(e, np),
		o = fr(t, np);
	return n === o
		? ''
		: ga(
				n.split(`
`),
				o.split(`
`),
				r
			);
}
i(w0, 'comparePrimitive');
function op(e) {
	return new Map(Array.from(e.entries()).sort());
}
i(op, 'sortMap');
function ip(e) {
	return new Set(Array.from(e.values()).sort());
}
i(ip, 'sortSet');
function Qa(e, t, r) {
	let n,
		o = !1;
	try {
		const a = bl(np, r);
		n = sp(e, t, a, r);
	} catch {
		o = !0;
	}
	const s = gl(t0, r);
	if (n === void 0 || n === s) {
		const a = bl(_0, r);
		((n = sp(e, t, a, r)),
			n !== s &&
				!o &&
				(n = `${gl(w$, r)}

${n}`));
	}
	return n;
}
i(Qa, 'compareObjects');
function bl(e, t) {
	const { compareKeys: r, printBasicPrototype: n, maxDepth: o } = Ln(t);
	return { ...e, compareKeys: r, printBasicPrototype: n, maxDepth: o ?? e.maxDepth };
}
i(bl, 'getFormatOptions');
function sp(e, t, r, n) {
	const o = { ...r, indent: 0 },
		s = fr(e, o),
		a = fr(t, o);
	if (s === a) return gl(t0, n);
	{
		const u = fr(e, r),
			c = fr(t, r);
		return f0(
			u.split(`
`),
			c.split(`
`),
			s.split(`
`),
			a.split(`
`),
			n
		);
	}
}
i(sp, 'getObjectsDifference');
var Gb = 2e4;
function ap(e) {
	return Gs(e) === 'Object' && typeof e.asymmetricMatch == 'function';
}
i(ap, 'isAsymmetricMatcher');
function lp(e, t) {
	const r = Gs(e),
		n = Gs(t);
	return r === n && (r === 'Object' || r === 'Array');
}
i(lp, 'isReplaceable');
function Hm(e, t, r) {
	const { aAnnotation: n, bAnnotation: o } = Ln(r);
	if (
		typeof t == 'string' &&
		typeof e == 'string' &&
		t.length > 0 &&
		e.length > 0 &&
		t.length <= Gb &&
		e.length <= Gb &&
		t !== e
	) {
		if (
			t.includes(`
`) ||
			e.includes(`
`)
		)
			return E0(t, e, r);
		const [p] = Vm(t, e, !0),
			f = p.some((E) => E[0] === We),
			m = S0(n, o),
			y = m(n) + P0(up(p, At, f)),
			g = m(o) + R0(up(p, ht, f));
		return `${y}
${g}`;
	}
	const s = Qd(t, { forceWritable: !0 }),
		a = Qd(e, { forceWritable: !0 }),
		{ replacedExpected: u, replacedActual: c } = Gm(a, s);
	return Oo(u, c, r);
}
i(Hm, 'printDiffOrStringify');
function Gm(e, t, r = new WeakSet(), n = new WeakSet()) {
	return e instanceof Error && t instanceof Error && typeof e.cause < 'u' && typeof t.cause > 'u'
		? (delete e.cause, { replacedActual: e, replacedExpected: t })
		: lp(e, t)
			? r.has(e) || n.has(t)
				? { replacedActual: e, replacedExpected: t }
				: (r.add(e),
					n.add(t),
					km(t).forEach((o) => {
						const s = t[o],
							a = e[o];
						if (ap(s)) s.asymmetricMatch(a) && (e[o] = s);
						else if (ap(a)) a.asymmetricMatch(s) && (t[o] = a);
						else if (lp(a, s)) {
							const u = Gm(a, s, r, n);
							((e[o] = u.replacedActual), (t[o] = u.replacedExpected));
						}
					}),
					{ replacedActual: e, replacedExpected: t })
			: { replacedActual: e, replacedExpected: t };
}
i(Gm, 'replaceAsymmetricMatcher');
function S0(...e) {
	const t = e.reduce((r, n) => (n.length > r ? n.length : r), 0);
	return (r) => `${r}: ${' '.repeat(t - r.length)}`;
}
i(S0, 'getLabelPrinter');
var M$ = '';
function zm(e) {
	return e.replace(/\s+$/gm, (t) => M$.repeat(t.length));
}
i(zm, 'replaceTrailingSpaces');
function R0(e) {
	return Ke.red(zm(jt(e)));
}
i(R0, 'printReceived');
function P0(e) {
	return Ke.green(zm(jt(e)));
}
i(P0, 'printExpected');
function up(e, t, r) {
	return e.reduce(
		(n, o) => n + (o[0] === We ? o[1] : o[0] === t ? (r ? Ke.inverse(o[1]) : o[1]) : ''),
		''
	);
}
i(up, 'getCommonAndChangedSubstrings');
var q$ = '@@__IMMUTABLE_RECORD__@@',
	j$ = '@@__IMMUTABLE_ITERABLE__@@';
function A0(e) {
	return e && (e[j$] || e[q$]);
}
i(A0, 'isImmutable');
var D$ = Object.getPrototypeOf({});
function cp(e) {
	return e instanceof Error
		? `<unserializable>: ${e.message}`
		: typeof e == 'string'
			? `<unserializable>: ${e}`
			: '<unserializable>';
}
i(cp, 'getUnserializableMessage');
function Yr(e, t = new WeakMap()) {
	if (!e || typeof e == 'string') return e;
	if (e instanceof Error && 'toJSON' in e && typeof e.toJSON == 'function') {
		const r = e.toJSON();
		return (
			r &&
				r !== e &&
				typeof r == 'object' &&
				(typeof e.message == 'string' && bs(() => r.message ?? (r.message = e.message)),
				typeof e.stack == 'string' && bs(() => r.stack ?? (r.stack = e.stack)),
				typeof e.name == 'string' && bs(() => r.name ?? (r.name = e.name)),
				e.cause != null && bs(() => r.cause ?? (r.cause = Yr(e.cause, t)))),
			Yr(r, t)
		);
	}
	if (typeof e == 'function') return `Function<${e.name || 'anonymous'}>`;
	if (typeof e == 'symbol') return e.toString();
	if (typeof e != 'object') return e;
	if (typeof Buffer < 'u' && e instanceof Buffer) return `<Buffer(${e.length}) ...>`;
	if (typeof Uint8Array < 'u' && e instanceof Uint8Array) return `<Uint8Array(${e.length}) ...>`;
	if (A0(e)) return Yr(e.toJSON(), t);
	if (e instanceof Promise || (e.constructor && e.constructor.prototype === 'AsyncFunction'))
		return 'Promise';
	if (typeof Element < 'u' && e instanceof Element) return e.tagName;
	if (typeof e.asymmetricMatch == 'function') return `${e.toString()} ${GS(e.sample)}`;
	if (typeof e.toJSON == 'function') return Yr(e.toJSON(), t);
	if (t.has(e)) return t.get(e);
	if (Array.isArray(e)) {
		const r = new Array(e.length);
		return (
			t.set(e, r),
			e.forEach((n, o) => {
				try {
					r[o] = Yr(n, t);
				} catch (s) {
					r[o] = cp(s);
				}
			}),
			r
		);
	} else {
		const r = Object.create(null);
		t.set(e, r);
		let n = e;
		for (; n && n !== D$; )
			(Object.getOwnPropertyNames(n).forEach((o) => {
				if (!(o in r))
					try {
						r[o] = Yr(e[o], t);
					} catch (s) {
						(delete r[o], (r[o] = cp(s)));
					}
			}),
				(n = Object.getPrototypeOf(n)));
		return r;
	}
}
i(Yr, 'serializeValue');
function bs(e) {
	try {
		return e();
	} catch {}
}
i(bs, 'safe');
function O0(e) {
	return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, '');
}
i(O0, 'normalizeErrorMessage');
function Ou(e, t, r = new WeakSet()) {
	if (!e || typeof e != 'object') return { message: String(e) };
	const n = e;
	((n.showDiff || (n.showDiff === void 0 && n.expected !== void 0 && n.actual !== void 0)) &&
		(n.diff = Hm(n.actual, n.expected, { ...t, ...n.diffOptions })),
		'expected' in n && typeof n.expected != 'string' && (n.expected = jt(n.expected, 10)),
		'actual' in n && typeof n.actual != 'string' && (n.actual = jt(n.actual, 10)));
	try {
		typeof n.message == 'string' && (n.message = O0(n.message));
	} catch {}
	try {
		!r.has(n) && typeof n.cause == 'object' && (r.add(n), (n.cause = Ou(n.cause, t, r)));
	} catch {}
	try {
		return Yr(n);
	} catch (o) {
		return Yr(
			new Error(`Failed to fully serialize error: ${o?.message}
Inner error message: ${n?.message}`)
		);
	}
}
i(Ou, 'processError');
var Jr = {
		CALL: 'storybook/instrumenter/call',
		SYNC: 'storybook/instrumenter/sync',
		START: 'storybook/instrumenter/start',
		BACK: 'storybook/instrumenter/back',
		GOTO: 'storybook/instrumenter/goto',
		NEXT: 'storybook/instrumenter/next',
		END: 'storybook/instrumenter/end'
	},
	fd = globalThis.__STORYBOOK_ADDONS_PREVIEW,
	k$ = new Error(
		'This function ran after the play function completed. Did you forget to `await` it?'
	),
	zb = i((e) => Object.prototype.toString.call(e) === '[object Object]', 'isObject'),
	L$ = i((e) => Object.prototype.toString.call(e) === '[object Module]', 'isModule'),
	F$ = i((e) => {
		if (!zb(e) && !L$(e)) return !1;
		if (e.constructor === void 0) return !0;
		const t = e.constructor.prototype;
		return !!zb(t);
	}, 'isInstrumentable'),
	B$ = i((e) => {
		try {
			return new e.constructor();
		} catch {
			return {};
		}
	}, 'construct'),
	md = i(
		() => ({
			renderPhase: 'preparing',
			isDebugging: !1,
			isPlaying: !1,
			isLocked: !1,
			cursor: 0,
			calls: [],
			shadowCalls: [],
			callRefsByResult: new Map(),
			chainedCallIds: new Set(),
			ancestors: [],
			playUntil: void 0,
			resolvers: {},
			syncTimeout: void 0
		}),
		'getInitialState'
	),
	Wb = i((e, t = !1) => {
		const r = (t ? e.shadowCalls : e.calls).filter((o) => o.retain);
		if (!r.length) return;
		const n = new Map(Array.from(e.callRefsByResult.entries()).filter(([, o]) => o.retain));
		return { cursor: r.length, calls: r, callRefsByResult: n };
	}, 'getRetainedState'),
	C0 = class {
		constructor() {
			((this.detached = !1),
				(this.initialized = !1),
				(this.state = {}),
				(this.loadParentWindowState = i(() => {
					try {
						this.state =
							te.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};
					} catch {
						this.detached = !0;
					}
				}, 'loadParentWindowState')),
				(this.updateParentWindowState = i(() => {
					try {
						te.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;
					} catch {
						this.detached = !0;
					}
				}, 'updateParentWindowState')),
				this.loadParentWindowState());
			const t = i(({ storyId: c, renderPhase: d, isPlaying: p = !0, isDebugging: f = !1 }) => {
					const m = this.getState(c);
					(this.setState(c, {
						...md(),
						...Wb(m, f),
						renderPhase: d || m.renderPhase,
						shadowCalls: f ? m.shadowCalls : [],
						chainedCallIds: f ? m.chainedCallIds : new Set(),
						playUntil: f ? m.playUntil : void 0,
						isPlaying: p,
						isDebugging: f
					}),
						this.sync(c));
				}, 'resetState'),
				r = i(
					(c) =>
						({ storyId: d, playUntil: p }) => {
							this.getState(d).isDebugging ||
								this.setState(d, ({ calls: m }) => ({
									calls: [],
									shadowCalls: m.map((y) => ({ ...y, status: 'waiting' })),
									isDebugging: !0
								}));
							const f = this.getLog(d);
							(this.setState(d, ({ shadowCalls: m }) => {
								if (p || !f.length) return { playUntil: p };
								const y = m.findIndex((g) => g.id === f[0].callId);
								return {
									playUntil: m
										.slice(0, y)
										.filter((g) => g.interceptable && !g.ancestors?.length)
										.slice(-1)[0]?.id
								};
							}),
								c.emit(fl, { storyId: d, isDebugging: !0 }));
						},
					'start'
				),
				n = i(
					(c) =>
						({ storyId: d }) => {
							const p = this.getLog(d).filter((m) => !m.ancestors?.length),
								f = p.reduceRight((m, y, g) => (m >= 0 || y.status === 'waiting' ? m : g), -1);
							r(c)({ storyId: d, playUntil: p[f - 1]?.callId });
						},
					'back'
				),
				o = i(
					(c) =>
						({ storyId: d, callId: p }) => {
							const { calls: f, shadowCalls: m, resolvers: y } = this.getState(d),
								g = f.find(({ id: T }) => T === p),
								E = m.find(({ id: T }) => T === p);
							if (!g && E && Object.values(y).length > 0) {
								const T = this.getLog(d).find((b) => b.status === 'waiting')?.callId;
								(E.id !== T && this.setState(d, { playUntil: E.id }),
									Object.values(y).forEach((b) => b()));
							} else r(c)({ storyId: d, playUntil: p });
						},
					'goto'
				),
				s = i(
					(c) =>
						({ storyId: d }) => {
							const { resolvers: p } = this.getState(d);
							if (Object.values(p).length > 0) Object.values(p).forEach((f) => f());
							else {
								const f = this.getLog(d).find((m) => m.status === 'waiting')?.callId;
								f ? r(c)({ storyId: d, playUntil: f }) : a({ storyId: d });
							}
						},
					'next'
				),
				a = i(({ storyId: c }) => {
					(this.setState(c, { playUntil: void 0, isDebugging: !1 }),
						Object.values(this.getState(c).resolvers).forEach((d) => d()));
				}, 'end'),
				u = i(({ storyId: c, newPhase: d }) => {
					const { isDebugging: p } = this.getState(c);
					if (d === 'preparing' && p) return t({ storyId: c, renderPhase: d, isDebugging: p });
					if (d === 'playing') return t({ storyId: c, renderPhase: d, isDebugging: p });
					(d === 'played'
						? this.setState(c, { renderPhase: d, isLocked: !1, isPlaying: !1, isDebugging: !1 })
						: d === 'errored'
							? this.setState(c, { renderPhase: d, isLocked: !1, isPlaying: !1 })
							: d === 'aborted'
								? this.setState(c, { renderPhase: d, isLocked: !0, isPlaying: !1 })
								: this.setState(c, { renderPhase: d }),
						this.sync(c));
				}, 'renderPhaseChanged');
			fd &&
				fd.ready().then(() => {
					((this.channel = fd.getChannel()),
						this.channel.on(fl, t),
						this.channel.on(fo, u),
						this.channel.on(Xf, () => {
							this.initialized ? this.cleanup() : (this.initialized = !0);
						}),
						this.channel.on(Jr.START, r(this.channel)),
						this.channel.on(Jr.BACK, n(this.channel)),
						this.channel.on(Jr.GOTO, o(this.channel)),
						this.channel.on(Jr.NEXT, s(this.channel)),
						this.channel.on(Jr.END, a));
				});
		}
		getState(t) {
			return this.state[t] || md();
		}
		setState(t, r) {
			if (t) {
				const n = this.getState(t),
					o = typeof r == 'function' ? r(n) : r;
				((this.state = { ...this.state, [t]: { ...n, ...o } }), this.updateParentWindowState());
			}
		}
		cleanup() {
			this.state = Object.entries(this.state).reduce((n, [o, s]) => {
				const a = Wb(s);
				return (a && (n[o] = Object.assign(md(), a)), n);
			}, {});
			const r = {
				controlStates: {
					detached: this.detached,
					start: !1,
					back: !1,
					goto: !1,
					next: !1,
					end: !1
				},
				logItems: []
			};
			(this.channel?.emit(Jr.SYNC, r), this.updateParentWindowState());
		}
		getLog(t) {
			const { calls: r, shadowCalls: n } = this.getState(t),
				o = [...n];
			r.forEach((a, u) => {
				o[u] = a;
			});
			const s = new Set();
			return o.reduceRight(
				(a, u) => (
					u.args.forEach((c) => {
						c?.__callId__ && s.add(c.__callId__);
					}),
					u.path.forEach((c) => {
						c.__callId__ && s.add(c.__callId__);
					}),
					(u.interceptable || u.exception) &&
						!s.has(u.id) &&
						(a.unshift({ callId: u.id, status: u.status, ancestors: u.ancestors }), s.add(u.id)),
					a
				),
				[]
			);
		}
		instrument(t, r, n = 0) {
			if (!F$(t)) return t;
			const { mutate: o = !1, path: s = [] } = r,
				a = r.getKeys ? r.getKeys(t, n) : Object.keys(t);
			return (
				(n += 1),
				a.reduce(
					(u, c) => {
						const d = x0(t, c);
						if (typeof d?.get == 'function') {
							if (d.configurable) {
								const f = i(() => d?.get?.bind(t)?.(), 'getter');
								Object.defineProperty(u, c, {
									get: i(() => this.instrument(f(), { ...r, path: s.concat(c) }, n), 'get')
								});
							}
							return u;
						}
						const p = t[c];
						return typeof p != 'function'
							? ((u[c] = this.instrument(p, { ...r, path: s.concat(c) }, n)), u)
							: '__originalFn__' in p && typeof p.__originalFn__ == 'function'
								? ((u[c] = p), u)
								: ((u[c] = (...f) => this.track(c, p, t, f, r)),
									(u[c].__originalFn__ = p),
									Object.defineProperty(u[c], 'name', { value: c, writable: !1 }),
									Object.keys(p).length > 0 &&
										Object.assign(u[c], this.instrument({ ...p }, { ...r, path: s.concat(c) }, n)),
									u);
					},
					o ? t : B$(t)
				)
			);
		}
		track(t, r, n, o, s) {
			const a = o?.[0]?.__storyId__ || te.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId,
				{ cursor: u, ancestors: c } = this.getState(a);
			this.setState(a, { cursor: u + 1 });
			const d = `${c.slice(-1)[0] || a} [${u}] ${t}`,
				{ path: p = [], intercept: f = !1, retain: m = !1 } = s,
				y = typeof f == 'function' ? f(t, p) : f,
				g = {
					id: d,
					cursor: u,
					storyId: a,
					ancestors: c,
					path: p,
					method: t,
					args: o,
					interceptable: y,
					retain: m
				},
				T = (y && !c.length ? this.intercept : this.invoke).call(this, r, n, g, s);
			return this.instrument(T, { ...s, mutate: !0, path: [{ __callId__: g.id }] });
		}
		intercept(t, r, n, o) {
			const { chainedCallIds: s, isDebugging: a, playUntil: u } = this.getState(n.storyId),
				c = s.has(n.id);
			return !a || c || u
				? (u === n.id && this.setState(n.storyId, { playUntil: void 0 }), this.invoke(t, r, n, o))
				: new Promise((d) => {
						this.setState(n.storyId, ({ resolvers: p }) => ({
							isLocked: !1,
							resolvers: { ...p, [n.id]: d }
						}));
					}).then(
						() => (
							this.setState(n.storyId, (d) => {
								const { [n.id]: p, ...f } = d.resolvers;
								return { isLocked: !0, resolvers: f };
							}),
							this.invoke(t, r, n, o)
						)
					);
		}
		invoke(t, r, n, o) {
			const { callRefsByResult: s, renderPhase: a } = this.getState(n.storyId),
				u = 25,
				c = i((f, m, y) => {
					if (y.includes(f)) return '[Circular]';
					if (((y = [...y, f]), m > u)) return '...';
					if (s.has(f)) return s.get(f);
					if (f instanceof Array) return f.map((g) => c(g, ++m, y));
					if (f instanceof Date) return { __date__: { value: f.toISOString() } };
					if (f instanceof Error) {
						const { name: g, message: E, stack: T } = f;
						return { __error__: { name: g, message: E, stack: T } };
					}
					if (f instanceof RegExp) {
						const { flags: g, source: E } = f;
						return { __regexp__: { flags: g, source: E } };
					}
					if (f instanceof te.window?.HTMLElement) {
						const { prefix: g, localName: E, id: T, classList: b, innerText: w } = f,
							P = Array.from(b);
						return { __element__: { prefix: g, localName: E, id: T, classNames: P, innerText: w } };
					}
					return typeof f == 'function'
						? { __function__: { name: 'getMockName' in f ? f.getMockName() : f.name } }
						: typeof f == 'symbol'
							? { __symbol__: { description: f.description } }
							: typeof f == 'object' && f?.constructor?.name && f?.constructor?.name !== 'Object'
								? { __class__: { name: f.constructor.name } }
								: Object.prototype.toString.call(f) === '[object Object]'
									? Object.fromEntries(Object.entries(f).map(([g, E]) => [g, c(E, ++m, y)]))
									: f;
				}, 'serializeValues'),
				d = { ...n, args: n.args.map((f) => c(f, 0, [])) };
			n.path.forEach((f) => {
				f?.__callId__ &&
					this.setState(n.storyId, ({ chainedCallIds: m }) => ({
						chainedCallIds: new Set(Array.from(m).concat(f.__callId__))
					}));
			});
			const p = i((f) => {
				if (f instanceof Error) {
					const { name: m, message: y, stack: g, callId: E = n.id } = f,
						{
							showDiff: T = void 0,
							diff: b = void 0,
							actual: w = void 0,
							expected: P = void 0
						} = f.name === 'AssertionError' ? Ou(f) : f,
						I = {
							name: m,
							message: y,
							stack: g,
							callId: E,
							showDiff: T,
							diff: b,
							actual: w,
							expected: P
						};
					if (
						(this.update({ ...d, status: 'error', exception: I }),
						this.setState(n.storyId, (q) => ({
							callRefsByResult: new Map([
								...Array.from(q.callRefsByResult.entries()),
								[f, { __callId__: n.id, retain: n.retain }]
							])
						})),
						n.ancestors?.length)
					)
						throw (
							Object.prototype.hasOwnProperty.call(f, 'callId') ||
								Object.defineProperty(f, 'callId', { value: n.id }),
							f
						);
				}
				throw f;
			}, 'handleException');
			try {
				if (a === 'played' && !n.retain) throw k$;
				const m = (o.getArgs ? o.getArgs(n, this.getState(n.storyId)) : n.args).map((g) =>
						typeof g != 'function' || I0(g) || Object.keys(g).length
							? g
							: (...E) => {
									const { cursor: T, ancestors: b } = this.getState(n.storyId);
									this.setState(n.storyId, { cursor: 0, ancestors: [...b, n.id] });
									const w = i(
										() => this.setState(n.storyId, { cursor: T, ancestors: b }),
										'restore'
									);
									let P = !1;
									try {
										const I = g(...E);
										return I instanceof Promise ? ((P = !0), I.finally(w)) : I;
									} finally {
										P || w();
									}
								}
					),
					y = t.apply(r, m);
				return (
					y &&
						['object', 'function', 'symbol'].includes(typeof y) &&
						this.setState(n.storyId, (g) => ({
							callRefsByResult: new Map([
								...Array.from(g.callRefsByResult.entries()),
								[y, { __callId__: n.id, retain: n.retain }]
							])
						})),
					this.update({ ...d, status: y instanceof Promise ? 'active' : 'done' }),
					y instanceof Promise ? y.then((g) => (this.update({ ...d, status: 'done' }), g), p) : y
				);
			} catch (f) {
				return p(f);
			}
		}
		update(t) {
			(this.channel?.emit(Jr.CALL, t),
				this.setState(t.storyId, ({ calls: r }) => {
					const n = r.concat(t).reduce((o, s) => Object.assign(o, { [s.id]: s }), {});
					return {
						calls: Object.values(n).sort((o, s) =>
							o.id.localeCompare(s.id, void 0, { numeric: !0 })
						)
					};
				}),
				this.sync(t.storyId));
		}
		sync(t) {
			const r = i(() => {
				const { isLocked: n, isPlaying: o } = this.getState(t),
					s = this.getLog(t),
					a = s.filter(({ ancestors: f }) => !f.length).find((f) => f.status === 'waiting')?.callId,
					u = s.some((f) => f.status === 'active');
				if (this.detached || n || u || s.length === 0) {
					const m = {
						controlStates: {
							detached: this.detached,
							start: !1,
							back: !1,
							goto: !1,
							next: !1,
							end: !1
						},
						logItems: s
					};
					this.channel?.emit(Jr.SYNC, m);
					return;
				}
				const c = s.some((f) => f.status === 'done' || f.status === 'error'),
					p = {
						controlStates: {
							detached: this.detached,
							start: c,
							back: c,
							goto: !0,
							next: o,
							end: o
						},
						logItems: s,
						pausedAt: a
					};
				this.channel?.emit(Jr.SYNC, p);
			}, 'synchronize');
			this.setState(
				t,
				({ syncTimeout: n }) => (clearTimeout(n), { syncTimeout: setTimeout(r, 0) })
			);
		}
	};
i(C0, 'Instrumenter');
var J$ = C0;
function Oi(e, t = {}) {
	try {
		let r = !1,
			n = !1;
		return (
			te.window?.location?.search?.includes('instrument=true')
				? (r = !0)
				: te.window?.location?.search?.includes('instrument=false') && (n = !0),
			(te.window?.parent === te.window && !r) || n
				? e
				: (te.window &&
						!te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ &&
						(te.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new J$()),
					(te.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__).instrument(e, t))
		);
	} catch (r) {
		return (Ye.warn(r), e);
	}
}
i(Oi, 'instrument');
function x0(e, t) {
	let r = e;
	for (; r != null; ) {
		const n = Object.getOwnPropertyDescriptor(r, t);
		if (n) return n;
		r = Object.getPrototypeOf(r);
	}
}
i(x0, 'getPropertyDescriptor');
function I0(e) {
	if (typeof e != 'function') return !1;
	const t = Object.getOwnPropertyDescriptor(e, 'prototype');
	return t ? !t.writable : !1;
}
i(I0, 'isClass');
var N0 = Object.defineProperty,
	G = i((e, t) => N0(e, 'name', { value: t, configurable: !0 }), '__name'),
	Wm = i((e, t) => {
		for (var r in t) N0(e, r, { get: t[r], enumerable: !0 });
	}, '__export'),
	Rr = {};
Wm(Rr, {
	addChainableMethod: i(() => Bu, 'addChainableMethod'),
	addLengthGuard: i(() => Ii, 'addLengthGuard'),
	addMethod: i(() => ku, 'addMethod'),
	addProperty: i(() => Du, 'addProperty'),
	checkError: i(() => Ut, 'checkError'),
	compareByInspect: i(() => Ys, 'compareByInspect'),
	eql: i(() => q0, 'eql'),
	expectTypes: i(() => th, 'expectTypes'),
	flag: i(() => he, 'flag'),
	getActual: i(() => va, 'getActual'),
	getMessage: i(() => Iu, 'getMessage'),
	getName: i(() => Ta, 'getName'),
	getOperator: i(() => Vu, 'getOperator'),
	getOwnEnumerableProperties: i(() => Uu, 'getOwnEnumerableProperties'),
	getOwnEnumerablePropertySymbols: i(() => $u, 'getOwnEnumerablePropertySymbols'),
	getPathInfo: i(() => ju, 'getPathInfo'),
	hasProperty: i(() => Ea, 'hasProperty'),
	inspect: i(() => Se, 'inspect'),
	isNaN: i(() => Ml, 'isNaN'),
	isNumeric: i(() => ut, 'isNumeric'),
	isProxyEnabled: i(() => xi, 'isProxyEnabled'),
	isRegExp: i(() => Xs, 'isRegExp'),
	objDisplay: i(() => Tn, 'objDisplay'),
	overwriteChainableMethod: i(() => Ju, 'overwriteChainableMethod'),
	overwriteMethod: i(() => Fu, 'overwriteMethod'),
	overwriteProperty: i(() => Lu, 'overwriteProperty'),
	proxify: i(() => Co, 'proxify'),
	test: i(() => Cu, 'test'),
	transferFlags: i(() => ar, 'transferFlags'),
	type: i(() => qe, 'type')
});
var Ut = {};
Wm(Ut, {
	compatibleConstructor: i(() => Xm, 'compatibleConstructor'),
	compatibleInstance: i(() => Ym, 'compatibleInstance'),
	compatibleMessage: i(() => Qm, 'compatibleMessage'),
	getConstructorName: i(() => Zm, 'getConstructorName'),
	getMessage: i(() => eh, 'getMessage')
});
function ba(e) {
	return e instanceof Error || Object.prototype.toString.call(e) === '[object Error]';
}
i(ba, 'isErrorInstance');
G(ba, 'isErrorInstance');
function Km(e) {
	return Object.prototype.toString.call(e) === '[object RegExp]';
}
i(Km, 'isRegExp');
G(Km, 'isRegExp');
function Ym(e, t) {
	return ba(t) && e === t;
}
i(Ym, 'compatibleInstance');
G(Ym, 'compatibleInstance');
function Xm(e, t) {
	return ba(t)
		? e.constructor === t.constructor || e instanceof t.constructor
		: (typeof t == 'object' || typeof t == 'function') && t.prototype
			? e.constructor === t || e instanceof t
			: !1;
}
i(Xm, 'compatibleConstructor');
G(Xm, 'compatibleConstructor');
function Qm(e, t) {
	const r = typeof e == 'string' ? e : e.message;
	return Km(t) ? t.test(r) : typeof t == 'string' ? r.indexOf(t) !== -1 : !1;
}
i(Qm, 'compatibleMessage');
G(Qm, 'compatibleMessage');
function Zm(e) {
	let t = e;
	return (
		ba(e)
			? (t = e.constructor.name)
			: typeof e == 'function' && ((t = e.name), t === '' && (t = new e().name || t)),
		t
	);
}
i(Zm, 'getConstructorName');
G(Zm, 'getConstructorName');
function eh(e) {
	let t = '';
	return (e && e.message ? (t = e.message) : typeof e == 'string' && (t = e), t);
}
i(eh, 'getMessage');
G(eh, 'getMessage');
function he(e, t, r) {
	let n = e.__flags || (e.__flags = Object.create(null));
	if (arguments.length === 3) n[t] = r;
	else return n[t];
}
i(he, 'flag');
G(he, 'flag');
function Cu(e, t) {
	let r = he(e, 'negate'),
		n = t[0];
	return r ? !n : n;
}
i(Cu, 'test');
G(Cu, 'test');
function qe(e) {
	if (typeof e > 'u') return 'undefined';
	if (e === null) return 'null';
	const t = e[Symbol.toStringTag];
	return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
i(qe, 'type');
G(qe, 'type');
var $$ = 'captureStackTrace' in Error,
	ps,
	Ce =
		((ps = class extends Error {
			message;
			get name() {
				return 'AssertionError';
			}
			get ok() {
				return !1;
			}
			constructor(e = 'Unspecified AssertionError', t, r) {
				(super(e), (this.message = e), $$ && Error.captureStackTrace(this, r || ps));
				for (const n in t) n in this || (this[n] = t[n]);
			}
			toJSON(e) {
				return {
					...this,
					name: this.name,
					message: this.message,
					ok: !1,
					stack: e !== !1 ? this.stack : void 0
				};
			}
		}),
		i(ps, '_AssertionError'),
		G(ps, 'AssertionError'),
		ps);
function th(e, t) {
	let r = he(e, 'message'),
		n = he(e, 'ssfi');
	((r = r ? r + ': ' : ''),
		(e = he(e, 'object')),
		(t = t.map(function (a) {
			return a.toLowerCase();
		})),
		t.sort());
	let o = t
			.map(function (a, u) {
				let c = ~['a', 'e', 'i', 'o', 'u'].indexOf(a.charAt(0)) ? 'an' : 'a';
				return (t.length > 1 && u === t.length - 1 ? 'or ' : '') + c + ' ' + a;
			})
			.join(', '),
		s = qe(e).toLowerCase();
	if (
		!t.some(function (a) {
			return s === a;
		})
	)
		throw new Ce(r + 'object tested must be ' + o + ', but ' + s + ' given', void 0, n);
}
i(th, 'expectTypes');
G(th, 'expectTypes');
function va(e, t) {
	return t.length > 4 ? t[4] : e._obj;
}
i(va, 'getActual');
G(va, 'getActual');
var Kb = {
		bold: ['1', '22'],
		dim: ['2', '22'],
		italic: ['3', '23'],
		underline: ['4', '24'],
		inverse: ['7', '27'],
		hidden: ['8', '28'],
		strike: ['9', '29'],
		black: ['30', '39'],
		red: ['31', '39'],
		green: ['32', '39'],
		yellow: ['33', '39'],
		blue: ['34', '39'],
		magenta: ['35', '39'],
		cyan: ['36', '39'],
		white: ['37', '39'],
		brightblack: ['30;1', '39'],
		brightred: ['31;1', '39'],
		brightgreen: ['32;1', '39'],
		brightyellow: ['33;1', '39'],
		brightblue: ['34;1', '39'],
		brightmagenta: ['35;1', '39'],
		brightcyan: ['36;1', '39'],
		brightwhite: ['37;1', '39'],
		grey: ['90', '39']
	},
	U$ = {
		special: 'cyan',
		number: 'yellow',
		bigint: 'yellow',
		boolean: 'yellow',
		undefined: 'grey',
		null: 'bold',
		string: 'green',
		symbol: 'green',
		date: 'magenta',
		regexp: 'red'
	},
	ui = '';
function rh(e, t) {
	const r = Kb[U$[t]] || Kb[t] || '';
	return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
i(rh, 'colorise');
G(rh, 'colorise');
function nh(
	{
		showHidden: e = !1,
		depth: t = 2,
		colors: r = !1,
		customInspect: n = !0,
		showProxy: o = !1,
		maxArrayLength: s = 1 / 0,
		breakLength: a = 1 / 0,
		seen: u = [],
		truncate: c = 1 / 0,
		stylize: d = String
	} = {},
	p
) {
	const f = {
		showHidden: !!e,
		depth: Number(t),
		colors: !!r,
		customInspect: !!n,
		showProxy: !!o,
		maxArrayLength: Number(s),
		breakLength: Number(a),
		truncate: Number(c),
		seen: u,
		inspect: p,
		stylize: d
	};
	return (f.colors && (f.stylize = rh), f);
}
i(nh, 'normaliseOptions');
G(nh, 'normaliseOptions');
function oh(e) {
	return e >= '\uD800' && e <= '\uDBFF';
}
i(oh, 'isHighSurrogate');
G(oh, 'isHighSurrogate');
function qr(e, t, r = ui) {
	e = String(e);
	const n = r.length,
		o = e.length;
	if (n > t && o > n) return r;
	if (o > t && o > n) {
		let s = t - n;
		return (s > 0 && oh(e[s - 1]) && (s = s - 1), `${e.slice(0, s)}${r}`);
	}
	return e;
}
i(qr, 'truncate');
G(qr, 'truncate');
function Kt(e, t, r, n = ', ') {
	r = r || t.inspect;
	const o = e.length;
	if (o === 0) return '';
	const s = t.truncate;
	let a = '',
		u = '',
		c = '';
	for (let d = 0; d < o; d += 1) {
		const p = d + 1 === e.length,
			f = d + 2 === e.length;
		c = `${ui}(${e.length - d})`;
		const m = e[d];
		t.truncate = s - a.length - (p ? 0 : n.length);
		const y = u || r(m, t) + (p ? '' : n),
			g = a.length + y.length,
			E = g + c.length;
		if (
			(p && g > s && a.length + c.length <= s) ||
			(!p && !f && E > s) ||
			((u = p ? '' : r(e[d + 1], t) + (f ? '' : n)), !p && f && E > s && g + u.length > s)
		)
			break;
		if (((a += y), !p && !f && g + u.length >= s)) {
			c = `${ui}(${e.length - d - 1})`;
			break;
		}
		c = '';
	}
	return `${a}${c}`;
}
i(Kt, 'inspectList');
G(Kt, 'inspectList');
function ih(e) {
	return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)
		? e
		: JSON.stringify(e)
				.replace(/'/g, "\\'")
				.replace(/\\"/g, '"')
				.replace(/(^"|"$)/g, "'");
}
i(ih, 'quoteComplexKey');
G(ih, 'quoteComplexKey');
function mo([e, t], r) {
	return (
		(r.truncate -= 2),
		typeof e == 'string' ? (e = ih(e)) : typeof e != 'number' && (e = `[${r.inspect(e, r)}]`),
		(r.truncate -= e.length),
		(t = r.inspect(t, r)),
		`${e}: ${t}`
	);
}
i(mo, 'inspectProperty');
G(mo, 'inspectProperty');
function sh(e, t) {
	const r = Object.keys(e).slice(e.length);
	if (!e.length && !r.length) return '[]';
	t.truncate -= 4;
	const n = Kt(e, t);
	t.truncate -= n.length;
	let o = '';
	return (
		r.length &&
			(o = Kt(
				r.map((s) => [s, e[s]]),
				t,
				mo
			)),
		`[ ${n}${o ? `, ${o}` : ''} ]`
	);
}
i(sh, 'inspectArray');
G(sh, 'inspectArray');
var V$ = G(
	(e) =>
		typeof Buffer == 'function' && e instanceof Buffer
			? 'Buffer'
			: e[Symbol.toStringTag]
				? e[Symbol.toStringTag]
				: e.constructor.name,
	'getArrayName'
);
function cr(e, t) {
	const r = V$(e);
	t.truncate -= r.length + 4;
	const n = Object.keys(e).slice(e.length);
	if (!e.length && !n.length) return `${r}[]`;
	let o = '';
	for (let a = 0; a < e.length; a++) {
		const u = `${t.stylize(qr(e[a], t.truncate), 'number')}${a === e.length - 1 ? '' : ', '}`;
		if (((t.truncate -= u.length), e[a] !== e.length && t.truncate <= 3)) {
			o += `${ui}(${e.length - e[a] + 1})`;
			break;
		}
		o += u;
	}
	let s = '';
	return (
		n.length &&
			(s = Kt(
				n.map((a) => [a, e[a]]),
				t,
				mo
			)),
		`${r}[ ${o}${s ? `, ${s}` : ''} ]`
	);
}
i(cr, 'inspectTypedArray');
G(cr, 'inspectTypedArray');
function ah(e, t) {
	const r = e.toJSON();
	if (r === null) return 'Invalid Date';
	const n = r.split('T'),
		o = n[0];
	return t.stylize(`${o}T${qr(n[1], t.truncate - o.length - 1)}`, 'date');
}
i(ah, 'inspectDate');
G(ah, 'inspectDate');
function vl(e, t) {
	const r = e[Symbol.toStringTag] || 'Function',
		n = e.name;
	return n
		? t.stylize(`[${r} ${qr(n, t.truncate - 11)}]`, 'special')
		: t.stylize(`[${r}]`, 'special');
}
i(vl, 'inspectFunction');
G(vl, 'inspectFunction');
function lh([e, t], r) {
	return (
		(r.truncate -= 4),
		(e = r.inspect(e, r)),
		(r.truncate -= e.length),
		(t = r.inspect(t, r)),
		`${e} => ${t}`
	);
}
i(lh, 'inspectMapEntry');
G(lh, 'inspectMapEntry');
function uh(e) {
	const t = [];
	return (
		e.forEach((r, n) => {
			t.push([n, r]);
		}),
		t
	);
}
i(uh, 'mapToEntries');
G(uh, 'mapToEntries');
function ch(e, t) {
	return e.size === 0 ? 'Map{}' : ((t.truncate -= 7), `Map{ ${Kt(uh(e), t, lh)} }`);
}
i(ch, 'inspectMap');
G(ch, 'inspectMap');
var H$ = Number.isNaN || ((e) => e !== e);
function El(e, t) {
	return H$(e)
		? t.stylize('NaN', 'number')
		: e === 1 / 0
			? t.stylize('Infinity', 'number')
			: e === -1 / 0
				? t.stylize('-Infinity', 'number')
				: e === 0
					? t.stylize(1 / e === 1 / 0 ? '+0' : '-0', 'number')
					: t.stylize(qr(String(e), t.truncate), 'number');
}
i(El, 'inspectNumber');
G(El, 'inspectNumber');
function Tl(e, t) {
	let r = qr(e.toString(), t.truncate - 1);
	return (r !== ui && (r += 'n'), t.stylize(r, 'bigint'));
}
i(Tl, 'inspectBigInt');
G(Tl, 'inspectBigInt');
function dh(e, t) {
	const r = e.toString().split('/')[2],
		n = t.truncate - (2 + r.length),
		o = e.source;
	return t.stylize(`/${qr(o, n)}/${r}`, 'regexp');
}
i(dh, 'inspectRegExp');
G(dh, 'inspectRegExp');
function ph(e) {
	const t = [];
	return (
		e.forEach((r) => {
			t.push(r);
		}),
		t
	);
}
i(ph, 'arrayFromSet');
G(ph, 'arrayFromSet');
function fh(e, t) {
	return e.size === 0 ? 'Set{}' : ((t.truncate -= 7), `Set{ ${Kt(ph(e), t)} }`);
}
i(fh, 'inspectSet');
G(fh, 'inspectSet');
var Yb = new RegExp(
		"['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]",
		'g'
	),
	G$ = { '\b': '\\b', '	': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', "'": "\\'", '\\': '\\\\' },
	z$ = 16;
function mh(e) {
	return G$[e] || `\\u${`0000${e.charCodeAt(0).toString(z$)}`.slice(-4)}`;
}
i(mh, 'escape');
G(mh, 'escape');
function _l(e, t) {
	return (Yb.test(e) && (e = e.replace(Yb, mh)), t.stylize(`'${qr(e, t.truncate - 2)}'`, 'string'));
}
i(_l, 'inspectString');
G(_l, 'inspectString');
function wl(e) {
	return 'description' in Symbol.prototype
		? e.description
			? `Symbol(${e.description})`
			: 'Symbol()'
		: e.toString();
}
i(wl, 'inspectSymbol');
G(wl, 'inspectSymbol');
var W$ = G(() => 'Promise{}', 'getPromiseValue'),
	K$ = W$;
function Xo(e, t) {
	const r = Object.getOwnPropertyNames(e),
		n = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
	if (r.length === 0 && n.length === 0) return '{}';
	if (((t.truncate -= 4), (t.seen = t.seen || []), t.seen.includes(e))) return '[Circular]';
	t.seen.push(e);
	const o = Kt(
			r.map((u) => [u, e[u]]),
			t,
			mo
		),
		s = Kt(
			n.map((u) => [u, e[u]]),
			t,
			mo
		);
	t.seen.pop();
	let a = '';
	return (o && s && (a = ', '), `{ ${o}${a}${s} }`);
}
i(Xo, 'inspectObject');
G(Xo, 'inspectObject');
var hd = typeof Symbol < 'u' && Symbol.toStringTag ? Symbol.toStringTag : !1;
function hh(e, t) {
	let r = '';
	return (
		hd && hd in e && (r = e[hd]),
		(r = r || e.constructor.name),
		(!r || r === '_class') && (r = '<Anonymous Class>'),
		(t.truncate -= r.length),
		`${r}${Xo(e, t)}`
	);
}
i(hh, 'inspectClass');
G(hh, 'inspectClass');
function yh(e, t) {
	return e.length === 0 ? 'Arguments[]' : ((t.truncate -= 13), `Arguments[ ${Kt(e, t)} ]`);
}
i(yh, 'inspectArguments');
G(yh, 'inspectArguments');
var Y$ = [
	'stack',
	'line',
	'column',
	'name',
	'message',
	'fileName',
	'lineNumber',
	'columnNumber',
	'number',
	'description',
	'cause'
];
function gh(e, t) {
	const r = Object.getOwnPropertyNames(e).filter((a) => Y$.indexOf(a) === -1),
		n = e.name;
	t.truncate -= n.length;
	let o = '';
	if (
		(typeof e.message == 'string' ? (o = qr(e.message, t.truncate)) : r.unshift('message'),
		(o = o ? `: ${o}` : ''),
		(t.truncate -= o.length + 5),
		(t.seen = t.seen || []),
		t.seen.includes(e))
	)
		return '[Circular]';
	t.seen.push(e);
	const s = Kt(
		r.map((a) => [a, e[a]]),
		t,
		mo
	);
	return `${n}${o}${s ? ` { ${s} }` : ''}`;
}
i(gh, 'inspectObject2');
G(gh, 'inspectObject');
function bh([e, t], r) {
	return (
		(r.truncate -= 3),
		t
			? `${r.stylize(String(e), 'yellow')}=${r.stylize(`"${t}"`, 'string')}`
			: `${r.stylize(String(e), 'yellow')}`
	);
}
i(bh, 'inspectAttribute');
G(bh, 'inspectAttribute');
function zs(e, t) {
	return Kt(
		e,
		t,
		vh,
		`
`
	);
}
i(zs, 'inspectNodeCollection');
G(zs, 'inspectNodeCollection');
function vh(e, t) {
	switch (e.nodeType) {
		case 1:
			return xu(e, t);
		case 3:
			return t.inspect(e.data, t);
		default:
			return t.inspect(e, t);
	}
}
i(vh, 'inspectNode');
G(vh, 'inspectNode');
function xu(e, t) {
	const r = e.getAttributeNames(),
		n = e.tagName.toLowerCase(),
		o = t.stylize(`<${n}`, 'special'),
		s = t.stylize('>', 'special'),
		a = t.stylize(`</${n}>`, 'special');
	t.truncate -= n.length * 2 + 5;
	let u = '';
	(r.length > 0 &&
		((u += ' '),
		(u += Kt(
			r.map((p) => [p, e.getAttribute(p)]),
			t,
			bh,
			' '
		))),
		(t.truncate -= u.length));
	const c = t.truncate;
	let d = zs(e.children, t);
	return (d && d.length > c && (d = `${ui}(${e.children.length})`), `${o}${u}${s}${d}${a}`);
}
i(xu, 'inspectHTML');
G(xu, 'inspectHTML');
var X$ = typeof Symbol == 'function' && typeof Symbol.for == 'function',
	yd = X$ ? Symbol.for('chai/inspect') : '@@chai/inspect',
	gd = Symbol.for('nodejs.util.inspect.custom'),
	Xb = new WeakMap(),
	Qb = {},
	Zb = {
		undefined: G((e, t) => t.stylize('undefined', 'undefined'), 'undefined'),
		null: G((e, t) => t.stylize('null', 'null'), 'null'),
		boolean: G((e, t) => t.stylize(String(e), 'boolean'), 'boolean'),
		Boolean: G((e, t) => t.stylize(String(e), 'boolean'), 'Boolean'),
		number: El,
		Number: El,
		bigint: Tl,
		BigInt: Tl,
		string: _l,
		String: _l,
		function: vl,
		Function: vl,
		symbol: wl,
		Symbol: wl,
		Array: sh,
		Date: ah,
		Map: ch,
		Set: fh,
		RegExp: dh,
		Promise: K$,
		WeakSet: G((e, t) => t.stylize('WeakSet{}', 'special'), 'WeakSet'),
		WeakMap: G((e, t) => t.stylize('WeakMap{}', 'special'), 'WeakMap'),
		Arguments: yh,
		Int8Array: cr,
		Uint8Array: cr,
		Uint8ClampedArray: cr,
		Int16Array: cr,
		Uint16Array: cr,
		Int32Array: cr,
		Uint32Array: cr,
		Float32Array: cr,
		Float64Array: cr,
		Generator: G(() => '', 'Generator'),
		DataView: G(() => '', 'DataView'),
		ArrayBuffer: G(() => '', 'ArrayBuffer'),
		Error: gh,
		HTMLCollection: zs,
		NodeList: zs
	},
	Q$ = G(
		(e, t, r) =>
			yd in e && typeof e[yd] == 'function'
				? e[yd](t)
				: gd in e && typeof e[gd] == 'function'
					? e[gd](t.depth, t)
					: 'inspect' in e && typeof e.inspect == 'function'
						? e.inspect(t.depth, t)
						: 'constructor' in e && Xb.has(e.constructor)
							? Xb.get(e.constructor)(e, t)
							: Qb[r]
								? Qb[r](e, t)
								: '',
		'inspectCustom'
	),
	Z$ = Object.prototype.toString;
function Ws(e, t = {}) {
	const r = nh(t, Ws),
		{ customInspect: n } = r;
	let o = e === null ? 'null' : typeof e;
	if ((o === 'object' && (o = Z$.call(e).slice(8, -1)), o in Zb)) return Zb[o](e, r);
	if (n && e) {
		const a = Q$(e, r, o);
		if (a) return typeof a == 'string' ? a : Ws(a, r);
	}
	const s = e ? Object.getPrototypeOf(e) : !1;
	return s === Object.prototype || s === null
		? Xo(e, r)
		: e && typeof HTMLElement == 'function' && e instanceof HTMLElement
			? xu(e, r)
			: 'constructor' in e
				? e.constructor !== Object
					? hh(e, r)
					: Xo(e, r)
				: e === Object(e)
					? Xo(e, r)
					: r.stylize(String(e), o);
}
i(Ws, 'inspect');
G(Ws, 'inspect');
var Nt = {
	includeStack: !1,
	showDiff: !0,
	truncateThreshold: 40,
	useProxy: !0,
	proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON'],
	deepEqual: null
};
function Se(e, t, r, n) {
	let o = {
		colors: n,
		depth: typeof r > 'u' ? 2 : r,
		showHidden: t,
		truncate: Nt.truncateThreshold ? Nt.truncateThreshold : 1 / 0
	};
	return Ws(e, o);
}
i(Se, 'inspect2');
G(Se, 'inspect');
function Tn(e) {
	let t = Se(e),
		r = Object.prototype.toString.call(e);
	if (Nt.truncateThreshold && t.length >= Nt.truncateThreshold) {
		if (r === '[object Function]')
			return !e.name || e.name === '' ? '[Function]' : '[Function: ' + e.name + ']';
		if (r === '[object Array]') return '[ Array(' + e.length + ') ]';
		if (r === '[object Object]') {
			let n = Object.keys(e);
			return (
				'{ Object (' + (n.length > 2 ? n.splice(0, 2).join(', ') + ', ...' : n.join(', ')) + ') }'
			);
		} else return t;
	} else return t;
}
i(Tn, 'objDisplay');
G(Tn, 'objDisplay');
function Iu(e, t) {
	let r = he(e, 'negate'),
		n = he(e, 'object'),
		o = t[3],
		s = va(e, t),
		a = r ? t[2] : t[1],
		u = he(e, 'message');
	return (
		typeof a == 'function' && (a = a()),
		(a = a || ''),
		(a = a
			.replace(/#\{this\}/g, function () {
				return Tn(n);
			})
			.replace(/#\{act\}/g, function () {
				return Tn(s);
			})
			.replace(/#\{exp\}/g, function () {
				return Tn(o);
			})),
		u ? u + ': ' + a : a
	);
}
i(Iu, 'getMessage2');
G(Iu, 'getMessage');
function ar(e, t, r) {
	let n = e.__flags || (e.__flags = Object.create(null));
	(t.__flags || (t.__flags = Object.create(null)), (r = arguments.length === 3 ? r : !0));
	for (let o in n)
		(r || (o !== 'object' && o !== 'ssfi' && o !== 'lockSsfi' && o != 'message')) &&
			(t.__flags[o] = n[o]);
}
i(ar, 'transferFlags');
G(ar, 'transferFlags');
function Sl(e) {
	if (typeof e > 'u') return 'undefined';
	if (e === null) return 'null';
	const t = e[Symbol.toStringTag];
	return typeof t == 'string' ? t : Object.prototype.toString.call(e).slice(8, -1);
}
i(Sl, 'type2');
G(Sl, 'type');
function Nu() {
	this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}
i(Nu, 'FakeMap');
G(Nu, 'FakeMap');
Nu.prototype = {
	get: G(
		i(function (t) {
			return t[this._key];
		}, 'get'),
		'get'
	),
	set: G(
		i(function (t, r) {
			Object.isExtensible(t) && Object.defineProperty(t, this._key, { value: r, configurable: !0 });
		}, 'set'),
		'set'
	)
};
var M0 = typeof WeakMap == 'function' ? WeakMap : Nu;
function Rl(e, t, r) {
	if (!r || Nn(e) || Nn(t)) return null;
	var n = r.get(e);
	if (n) {
		var o = n.get(t);
		if (typeof o == 'boolean') return o;
	}
	return null;
}
i(Rl, 'memoizeCompare');
G(Rl, 'memoizeCompare');
function Uo(e, t, r, n) {
	if (!(!r || Nn(e) || Nn(t))) {
		var o = r.get(e);
		o ? o.set(t, n) : ((o = new M0()), o.set(t, n), r.set(e, o));
	}
}
i(Uo, 'memoizeSet');
G(Uo, 'memoizeSet');
var q0 = Ci;
function Ci(e, t, r) {
	if (r && r.comparator) return Pl(e, t, r);
	var n = Mu(e, t);
	return n !== null ? n : Pl(e, t, r);
}
i(Ci, 'deepEqual');
G(Ci, 'deepEqual');
function Mu(e, t) {
	return e === t
		? e !== 0 || 1 / e === 1 / t
		: e !== e && t !== t
			? !0
			: Nn(e) || Nn(t)
				? !1
				: null;
}
i(Mu, 'simpleEqual');
G(Mu, 'simpleEqual');
function Pl(e, t, r) {
	((r = r || {}), (r.memoize = r.memoize === !1 ? !1 : r.memoize || new M0()));
	var n = r && r.comparator,
		o = Rl(e, t, r.memoize);
	if (o !== null) return o;
	var s = Rl(t, e, r.memoize);
	if (s !== null) return s;
	if (n) {
		var a = n(e, t);
		if (a === !1 || a === !0) return (Uo(e, t, r.memoize, a), a);
		var u = Mu(e, t);
		if (u !== null) return u;
	}
	var c = Sl(e);
	if (c !== Sl(t)) return (Uo(e, t, r.memoize, !1), !1);
	Uo(e, t, r.memoize, !0);
	var d = Eh(e, t, c, r);
	return (Uo(e, t, r.memoize, d), d);
}
i(Pl, 'extensiveDeepEqual');
G(Pl, 'extensiveDeepEqual');
function Eh(e, t, r, n) {
	switch (r) {
		case 'String':
		case 'Number':
		case 'Boolean':
		case 'Date':
			return Ci(e.valueOf(), t.valueOf());
		case 'Promise':
		case 'Symbol':
		case 'function':
		case 'WeakMap':
		case 'WeakSet':
			return e === t;
		case 'Error':
			return qu(e, t, ['name', 'message', 'code'], n);
		case 'Arguments':
		case 'Int8Array':
		case 'Uint8Array':
		case 'Uint8ClampedArray':
		case 'Int16Array':
		case 'Uint16Array':
		case 'Int32Array':
		case 'Uint32Array':
		case 'Float32Array':
		case 'Float64Array':
		case 'Array':
			return tn(e, t, n);
		case 'RegExp':
			return Th(e, t);
		case 'Generator':
			return _h(e, t, n);
		case 'DataView':
			return tn(new Uint8Array(e.buffer), new Uint8Array(t.buffer), n);
		case 'ArrayBuffer':
			return tn(new Uint8Array(e), new Uint8Array(t), n);
		case 'Set':
			return Al(e, t, n);
		case 'Map':
			return Al(e, t, n);
		case 'Temporal.PlainDate':
		case 'Temporal.PlainTime':
		case 'Temporal.PlainDateTime':
		case 'Temporal.Instant':
		case 'Temporal.ZonedDateTime':
		case 'Temporal.PlainYearMonth':
		case 'Temporal.PlainMonthDay':
			return e.equals(t);
		case 'Temporal.Duration':
			return e.total('nanoseconds') === t.total('nanoseconds');
		case 'Temporal.TimeZone':
		case 'Temporal.Calendar':
			return e.toString() === t.toString();
		default:
			return Sh(e, t, n);
	}
}
i(Eh, 'extensiveDeepEqualByType');
G(Eh, 'extensiveDeepEqualByType');
function Th(e, t) {
	return e.toString() === t.toString();
}
i(Th, 'regexpEqual');
G(Th, 'regexpEqual');
function Al(e, t, r) {
	try {
		if (e.size !== t.size) return !1;
		if (e.size === 0) return !0;
	} catch {
		return !1;
	}
	var n = [],
		o = [];
	return (
		e.forEach(
			G(
				i(function (a, u) {
					n.push([a, u]);
				}, 'gatherEntries'),
				'gatherEntries'
			)
		),
		t.forEach(
			G(
				i(function (a, u) {
					o.push([a, u]);
				}, 'gatherEntries'),
				'gatherEntries'
			)
		),
		tn(n.sort(), o.sort(), r)
	);
}
i(Al, 'entriesEqual');
G(Al, 'entriesEqual');
function tn(e, t, r) {
	var n = e.length;
	if (n !== t.length) return !1;
	if (n === 0) return !0;
	for (var o = -1; ++o < n; ) if (Ci(e[o], t[o], r) === !1) return !1;
	return !0;
}
i(tn, 'iterableEqual');
G(tn, 'iterableEqual');
function _h(e, t, r) {
	return tn(Ks(e), Ks(t), r);
}
i(_h, 'generatorEqual');
G(_h, 'generatorEqual');
function wh(e) {
	return (
		typeof Symbol < 'u' &&
		typeof e == 'object' &&
		typeof Symbol.iterator < 'u' &&
		typeof e[Symbol.iterator] == 'function'
	);
}
i(wh, 'hasIteratorFunction');
G(wh, 'hasIteratorFunction');
function Ol(e) {
	if (wh(e))
		try {
			return Ks(e[Symbol.iterator]());
		} catch {
			return [];
		}
	return [];
}
i(Ol, 'getIteratorEntries');
G(Ol, 'getIteratorEntries');
function Ks(e) {
	for (var t = e.next(), r = [t.value]; t.done === !1; ) ((t = e.next()), r.push(t.value));
	return r;
}
i(Ks, 'getGeneratorEntries');
G(Ks, 'getGeneratorEntries');
function Cl(e) {
	var t = [];
	for (var r in e) t.push(r);
	return t;
}
i(Cl, 'getEnumerableKeys');
G(Cl, 'getEnumerableKeys');
function xl(e) {
	for (var t = [], r = Object.getOwnPropertySymbols(e), n = 0; n < r.length; n += 1) {
		var o = r[n];
		Object.getOwnPropertyDescriptor(e, o).enumerable && t.push(o);
	}
	return t;
}
i(xl, 'getEnumerableSymbols');
G(xl, 'getEnumerableSymbols');
function qu(e, t, r, n) {
	var o = r.length;
	if (o === 0) return !0;
	for (var s = 0; s < o; s += 1) if (Ci(e[r[s]], t[r[s]], n) === !1) return !1;
	return !0;
}
i(qu, 'keysEqual');
G(qu, 'keysEqual');
function Sh(e, t, r) {
	var n = Cl(e),
		o = Cl(t),
		s = xl(e),
		a = xl(t);
	if (((n = n.concat(s)), (o = o.concat(a)), n.length && n.length === o.length))
		return tn(Il(n).sort(), Il(o).sort()) === !1 ? !1 : qu(e, t, n, r);
	var u = Ol(e),
		c = Ol(t);
	return u.length && u.length === c.length
		? (u.sort(), c.sort(), tn(u, c, r))
		: n.length === 0 && u.length === 0 && o.length === 0 && c.length === 0;
}
i(Sh, 'objectEqual');
G(Sh, 'objectEqual');
function Nn(e) {
	return e === null || typeof e != 'object';
}
i(Nn, 'isPrimitive');
G(Nn, 'isPrimitive');
function Il(e) {
	return e.map(
		G(
			i(function (r) {
				return typeof r == 'symbol' ? r.toString() : r;
			}, 'mapSymbol'),
			'mapSymbol'
		)
	);
}
i(Il, 'mapSymbols');
G(Il, 'mapSymbols');
function Ea(e, t) {
	return typeof e > 'u' || e === null ? !1 : t in Object(e);
}
i(Ea, 'hasProperty');
G(Ea, 'hasProperty');
function Rh(e) {
	return e
		.replace(/([^\\])\[/g, '$1.[')
		.match(/(\\\.|[^.]+?)+/g)
		.map((n) => {
			if (n === 'constructor' || n === '__proto__' || n === 'prototype') return {};
			const s = /^\[(\d+)\]$/.exec(n);
			let a = null;
			return (s ? (a = { i: parseFloat(s[1]) }) : (a = { p: n.replace(/\\([.[\]])/g, '$1') }), a);
		});
}
i(Rh, 'parsePath');
G(Rh, 'parsePath');
function Nl(e, t, r) {
	let n = e,
		o = null;
	r = typeof r > 'u' ? t.length : r;
	for (let s = 0; s < r; s++) {
		const a = t[s];
		n && (typeof a.p > 'u' ? (n = n[a.i]) : (n = n[a.p]), s === r - 1 && (o = n));
	}
	return o;
}
i(Nl, 'internalGetPathValue');
G(Nl, 'internalGetPathValue');
function ju(e, t) {
	const r = Rh(t),
		n = r[r.length - 1],
		o = { parent: r.length > 1 ? Nl(e, r, r.length - 1) : e, name: n.p || n.i, value: Nl(e, r) };
	return ((o.exists = Ea(o.parent, o.name)), o);
}
i(ju, 'getPathInfo');
G(ju, 'getPathInfo');
var fs,
	j =
		((fs = class {
			__flags = {};
			constructor(e, t, r, n) {
				return (
					he(this, 'ssfi', r || fs),
					he(this, 'lockSsfi', n),
					he(this, 'object', e),
					he(this, 'message', t),
					he(this, 'eql', Nt.deepEqual || q0),
					Co(this)
				);
			}
			static get includeStack() {
				return (
					console.warn(
						'Assertion.includeStack is deprecated, use chai.config.includeStack instead.'
					),
					Nt.includeStack
				);
			}
			static set includeStack(e) {
				(console.warn(
					'Assertion.includeStack is deprecated, use chai.config.includeStack instead.'
				),
					(Nt.includeStack = e));
			}
			static get showDiff() {
				return (
					console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
					Nt.showDiff
				);
			}
			static set showDiff(e) {
				(console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.'),
					(Nt.showDiff = e));
			}
			static addProperty(e, t) {
				Du(this.prototype, e, t);
			}
			static addMethod(e, t) {
				ku(this.prototype, e, t);
			}
			static addChainableMethod(e, t, r) {
				Bu(this.prototype, e, t, r);
			}
			static overwriteProperty(e, t) {
				Lu(this.prototype, e, t);
			}
			static overwriteMethod(e, t) {
				Fu(this.prototype, e, t);
			}
			static overwriteChainableMethod(e, t, r) {
				Ju(this.prototype, e, t, r);
			}
			assert(e, t, r, n, o, s) {
				const a = Cu(this, arguments);
				if (
					(s !== !1 && (s = !0),
					n === void 0 && o === void 0 && (s = !1),
					Nt.showDiff !== !0 && (s = !1),
					!a)
				) {
					t = Iu(this, arguments);
					const c = { actual: va(this, arguments), expected: n, showDiff: s },
						d = Vu(this, arguments);
					throw (
						d && (c.operator = d),
						new Ce(t, c, Nt.includeStack ? this.assert : he(this, 'ssfi'))
					);
				}
			}
			get _obj() {
				return he(this, 'object');
			}
			set _obj(e) {
				he(this, 'object', e);
			}
		}),
		i(fs, '_Assertion'),
		G(fs, 'Assertion'),
		fs);
function xi() {
	return Nt.useProxy && typeof Proxy < 'u' && typeof Reflect < 'u';
}
i(xi, 'isProxyEnabled');
G(xi, 'isProxyEnabled');
function Du(e, t, r) {
	((r = r === void 0 ? function () {} : r),
		Object.defineProperty(e, t, {
			get: G(
				i(function n() {
					!xi() && !he(this, 'lockSsfi') && he(this, 'ssfi', n);
					let o = r.call(this);
					if (o !== void 0) return o;
					let s = new j();
					return (ar(this, s), s);
				}, 'propertyGetter'),
				'propertyGetter'
			),
			configurable: !0
		}));
}
i(Du, 'addProperty');
G(Du, 'addProperty');
var eU = Object.getOwnPropertyDescriptor(function () {}, 'length');
function Ii(e, t, r) {
	return (
		eU.configurable &&
			Object.defineProperty(e, 'length', {
				get: G(function () {
					throw Error(
						r
							? 'Invalid Chai property: ' +
									t +
									'.length. Due to a compatibility issue, "length" cannot directly follow "' +
									t +
									'". Use "' +
									t +
									'.lengthOf" instead.'
							: 'Invalid Chai property: ' + t + '.length. See docs for proper usage of "' + t + '".'
					);
				}, 'get')
			}),
		e
	);
}
i(Ii, 'addLengthGuard');
G(Ii, 'addLengthGuard');
function Ph(e) {
	let t = Object.getOwnPropertyNames(e);
	function r(o) {
		t.indexOf(o) === -1 && t.push(o);
	}
	(i(r, 'addProperty2'), G(r, 'addProperty'));
	let n = Object.getPrototypeOf(e);
	for (; n !== null; ) (Object.getOwnPropertyNames(n).forEach(r), (n = Object.getPrototypeOf(n)));
	return t;
}
i(Ph, 'getProperties');
G(Ph, 'getProperties');
var ev = ['__flags', '__methods', '_obj', 'assert'];
function Co(e, t) {
	return xi()
		? new Proxy(e, {
				get: G(
					i(function r(n, o) {
						if (
							typeof o == 'string' &&
							Nt.proxyExcludedKeys.indexOf(o) === -1 &&
							!Reflect.has(n, o)
						) {
							if (t)
								throw Error(
									'Invalid Chai property: ' +
										t +
										'.' +
										o +
										'. See docs for proper usage of "' +
										t +
										'".'
								);
							let s = null,
								a = 4;
							throw (
								Ph(n).forEach(function (u) {
									if (!Object.prototype.hasOwnProperty(u) && ev.indexOf(u) === -1) {
										let c = Ah(o, u, a);
										c < a && ((s = u), (a = c));
									}
								}),
								Error(
									s !== null
										? 'Invalid Chai property: ' + o + '. Did you mean "' + s + '"?'
										: 'Invalid Chai property: ' + o
								)
							);
						}
						return (
							ev.indexOf(o) === -1 && !he(n, 'lockSsfi') && he(n, 'ssfi', r),
							Reflect.get(n, o)
						);
					}, 'proxyGetter'),
					'proxyGetter'
				)
			})
		: e;
}
i(Co, 'proxify');
G(Co, 'proxify');
function Ah(e, t, r) {
	if (Math.abs(e.length - t.length) >= r) return r;
	let n = [];
	for (let o = 0; o <= e.length; o++) ((n[o] = Array(t.length + 1).fill(0)), (n[o][0] = o));
	for (let o = 0; o < t.length; o++) n[0][o] = o;
	for (let o = 1; o <= e.length; o++) {
		let s = e.charCodeAt(o - 1);
		for (let a = 1; a <= t.length; a++) {
			if (Math.abs(o - a) >= r) {
				n[o][a] = r;
				continue;
			}
			n[o][a] = Math.min(
				n[o - 1][a] + 1,
				n[o][a - 1] + 1,
				n[o - 1][a - 1] + (s === t.charCodeAt(a - 1) ? 0 : 1)
			);
		}
	}
	return n[e.length][t.length];
}
i(Ah, 'stringDistanceCapped');
G(Ah, 'stringDistanceCapped');
function ku(e, t, r) {
	let n = G(function () {
		he(this, 'lockSsfi') || he(this, 'ssfi', n);
		let o = r.apply(this, arguments);
		if (o !== void 0) return o;
		let s = new j();
		return (ar(this, s), s);
	}, 'methodWrapper');
	(Ii(n, t, !1), (e[t] = Co(n, t)));
}
i(ku, 'addMethod');
G(ku, 'addMethod');
function Lu(e, t, r) {
	let n = Object.getOwnPropertyDescriptor(e, t),
		o = G(function () {}, '_super');
	(n && typeof n.get == 'function' && (o = n.get),
		Object.defineProperty(e, t, {
			get: G(
				i(function s() {
					!xi() && !he(this, 'lockSsfi') && he(this, 'ssfi', s);
					let a = he(this, 'lockSsfi');
					he(this, 'lockSsfi', !0);
					let u = r(o).call(this);
					if ((he(this, 'lockSsfi', a), u !== void 0)) return u;
					let c = new j();
					return (ar(this, c), c);
				}, 'overwritingPropertyGetter'),
				'overwritingPropertyGetter'
			),
			configurable: !0
		}));
}
i(Lu, 'overwriteProperty');
G(Lu, 'overwriteProperty');
function Fu(e, t, r) {
	let n = e[t],
		o = G(function () {
			throw new Error(t + ' is not a function');
		}, '_super');
	n && typeof n == 'function' && (o = n);
	let s = G(function () {
		he(this, 'lockSsfi') || he(this, 'ssfi', s);
		let a = he(this, 'lockSsfi');
		he(this, 'lockSsfi', !0);
		let u = r(o).apply(this, arguments);
		if ((he(this, 'lockSsfi', a), u !== void 0)) return u;
		let c = new j();
		return (ar(this, c), c);
	}, 'overwritingMethodWrapper');
	(Ii(s, t, !1), (e[t] = Co(s, t)));
}
i(Fu, 'overwriteMethod');
G(Fu, 'overwriteMethod');
var tU = typeof Object.setPrototypeOf == 'function',
	tv = G(function () {}, 'testFn'),
	rU = Object.getOwnPropertyNames(tv).filter(function (e) {
		let t = Object.getOwnPropertyDescriptor(tv, e);
		return typeof t != 'object' ? !0 : !t.configurable;
	}),
	nU = Function.prototype.call,
	oU = Function.prototype.apply;
function Bu(e, t, r, n) {
	typeof n != 'function' && (n = G(function () {}, 'chainingBehavior'));
	let o = { method: r, chainingBehavior: n };
	(e.__methods || (e.__methods = {}),
		(e.__methods[t] = o),
		Object.defineProperty(e, t, {
			get: G(
				i(function () {
					o.chainingBehavior.call(this);
					let a = G(function () {
						he(this, 'lockSsfi') || he(this, 'ssfi', a);
						let u = o.method.apply(this, arguments);
						if (u !== void 0) return u;
						let c = new j();
						return (ar(this, c), c);
					}, 'chainableMethodWrapper');
					if ((Ii(a, t, !0), tU)) {
						let u = Object.create(this);
						((u.call = nU), (u.apply = oU), Object.setPrototypeOf(a, u));
					} else
						Object.getOwnPropertyNames(e).forEach(function (c) {
							if (rU.indexOf(c) !== -1) return;
							let d = Object.getOwnPropertyDescriptor(e, c);
							Object.defineProperty(a, c, d);
						});
					return (ar(this, a), Co(a));
				}, 'chainableMethodGetter'),
				'chainableMethodGetter'
			),
			configurable: !0
		}));
}
i(Bu, 'addChainableMethod');
G(Bu, 'addChainableMethod');
function Ju(e, t, r, n) {
	let o = e.__methods[t],
		s = o.chainingBehavior;
	o.chainingBehavior = G(
		i(function () {
			let c = n(s).call(this);
			if (c !== void 0) return c;
			let d = new j();
			return (ar(this, d), d);
		}, 'overwritingChainableMethodGetter'),
		'overwritingChainableMethodGetter'
	);
	let a = o.method;
	o.method = G(
		i(function () {
			let c = r(a).apply(this, arguments);
			if (c !== void 0) return c;
			let d = new j();
			return (ar(this, d), d);
		}, 'overwritingChainableMethodWrapper'),
		'overwritingChainableMethodWrapper'
	);
}
i(Ju, 'overwriteChainableMethod');
G(Ju, 'overwriteChainableMethod');
function Ys(e, t) {
	return Se(e) < Se(t) ? -1 : 1;
}
i(Ys, 'compareByInspect');
G(Ys, 'compareByInspect');
function $u(e) {
	return typeof Object.getOwnPropertySymbols != 'function'
		? []
		: Object.getOwnPropertySymbols(e).filter(function (t) {
				return Object.getOwnPropertyDescriptor(e, t).enumerable;
			});
}
i($u, 'getOwnEnumerablePropertySymbols');
G($u, 'getOwnEnumerablePropertySymbols');
function Uu(e) {
	return Object.keys(e).concat($u(e));
}
i(Uu, 'getOwnEnumerableProperties');
G(Uu, 'getOwnEnumerableProperties');
var Ml = Number.isNaN;
function Oh(e) {
	let t = qe(e);
	return ['Array', 'Object', 'Function'].indexOf(t) !== -1;
}
i(Oh, 'isObjectType');
G(Oh, 'isObjectType');
function Vu(e, t) {
	let r = he(e, 'operator'),
		n = he(e, 'negate'),
		o = t[3],
		s = n ? t[2] : t[1];
	if (r) return r;
	if ((typeof s == 'function' && (s = s()), (s = s || ''), !s || /\shave\s/.test(s))) return;
	let a = Oh(o);
	return /\snot\s/.test(s)
		? a
			? 'notDeepStrictEqual'
			: 'notStrictEqual'
		: a
			? 'deepStrictEqual'
			: 'strictEqual';
}
i(Vu, 'getOperator');
G(Vu, 'getOperator');
function Ta(e) {
	return e.name;
}
i(Ta, 'getName');
G(Ta, 'getName');
function Xs(e) {
	return Object.prototype.toString.call(e) === '[object RegExp]';
}
i(Xs, 'isRegExp2');
G(Xs, 'isRegExp');
function ut(e) {
	return ['Number', 'BigInt'].includes(qe(e));
}
i(ut, 'isNumeric');
G(ut, 'isNumeric');
var { flag: U } = Rr;
[
	'to',
	'be',
	'been',
	'is',
	'and',
	'has',
	'have',
	'with',
	'that',
	'which',
	'at',
	'of',
	'same',
	'but',
	'does',
	'still',
	'also'
].forEach(function (e) {
	j.addProperty(e);
});
j.addProperty('not', function () {
	U(this, 'negate', !0);
});
j.addProperty('deep', function () {
	U(this, 'deep', !0);
});
j.addProperty('nested', function () {
	U(this, 'nested', !0);
});
j.addProperty('own', function () {
	U(this, 'own', !0);
});
j.addProperty('ordered', function () {
	U(this, 'ordered', !0);
});
j.addProperty('any', function () {
	(U(this, 'any', !0), U(this, 'all', !1));
});
j.addProperty('all', function () {
	(U(this, 'all', !0), U(this, 'any', !1));
});
var rv = {
	function: ['function', 'asyncfunction', 'generatorfunction', 'asyncgeneratorfunction'],
	asyncfunction: ['asyncfunction', 'asyncgeneratorfunction'],
	generatorfunction: ['generatorfunction', 'asyncgeneratorfunction'],
	asyncgeneratorfunction: ['asyncgeneratorfunction']
};
function Hu(e, t) {
	(t && U(this, 'message', t), (e = e.toLowerCase()));
	let r = U(this, 'object'),
		n = ~['a', 'e', 'i', 'o', 'u'].indexOf(e.charAt(0)) ? 'an ' : 'a ';
	const o = qe(r).toLowerCase();
	rv.function.includes(e)
		? this.assert(
				rv[e].includes(o),
				'expected #{this} to be ' + n + e,
				'expected #{this} not to be ' + n + e
			)
		: this.assert(
				e === o,
				'expected #{this} to be ' + n + e,
				'expected #{this} not to be ' + n + e
			);
}
i(Hu, 'an');
G(Hu, 'an');
j.addChainableMethod('an', Hu);
j.addChainableMethod('a', Hu);
function Ch(e, t) {
	return (Ml(e) && Ml(t)) || e === t;
}
i(Ch, 'SameValueZero');
G(Ch, 'SameValueZero');
function Ni() {
	U(this, 'contains', !0);
}
i(Ni, 'includeChainingBehavior');
G(Ni, 'includeChainingBehavior');
function Mi(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = qe(r).toLowerCase(),
		o = U(this, 'message'),
		s = U(this, 'negate'),
		a = U(this, 'ssfi'),
		u = U(this, 'deep'),
		c = u ? 'deep ' : '',
		d = u ? U(this, 'eql') : Ch;
	o = o ? o + ': ' : '';
	let p = !1;
	switch (n) {
		case 'string':
			p = r.indexOf(e) !== -1;
			break;
		case 'weakset':
			if (u) throw new Ce(o + 'unable to use .deep.include with WeakSet', void 0, a);
			p = r.has(e);
			break;
		case 'map':
			r.forEach(function (f) {
				p = p || d(f, e);
			});
			break;
		case 'set':
			u
				? r.forEach(function (f) {
						p = p || d(f, e);
					})
				: (p = r.has(e));
			break;
		case 'array':
			u
				? (p = r.some(function (f) {
						return d(f, e);
					}))
				: (p = r.indexOf(e) !== -1);
			break;
		default: {
			if (e !== Object(e))
				throw new Ce(
					o +
						'the given combination of arguments (' +
						n +
						' and ' +
						qe(e).toLowerCase() +
						') is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a ' +
						qe(e).toLowerCase(),
					void 0,
					a
				);
			let f = Object.keys(e),
				m = null,
				y = 0;
			if (
				(f.forEach(function (g) {
					let E = new j(r);
					if ((ar(this, E, !0), U(E, 'lockSsfi', !0), !s || f.length === 1)) {
						E.property(g, e[g]);
						return;
					}
					try {
						E.property(g, e[g]);
					} catch (T) {
						if (!Ut.compatibleConstructor(T, Ce)) throw T;
						(m === null && (m = T), y++);
					}
				}, this),
				s && f.length > 1 && y === f.length)
			)
				throw m;
			return;
		}
	}
	this.assert(
		p,
		'expected #{this} to ' + c + 'include ' + Se(e),
		'expected #{this} to not ' + c + 'include ' + Se(e)
	);
}
i(Mi, 'include');
G(Mi, 'include');
j.addChainableMethod('include', Mi, Ni);
j.addChainableMethod('contain', Mi, Ni);
j.addChainableMethod('contains', Mi, Ni);
j.addChainableMethod('includes', Mi, Ni);
j.addProperty('ok', function () {
	this.assert(U(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
});
j.addProperty('true', function () {
	this.assert(
		U(this, 'object') === !0,
		'expected #{this} to be true',
		'expected #{this} to be false',
		!U(this, 'negate')
	);
});
j.addProperty('numeric', function () {
	const e = U(this, 'object');
	this.assert(
		['Number', 'BigInt'].includes(qe(e)),
		'expected #{this} to be numeric',
		'expected #{this} to not be numeric',
		!U(this, 'negate')
	);
});
j.addProperty('callable', function () {
	const e = U(this, 'object'),
		t = U(this, 'ssfi'),
		r = U(this, 'message'),
		n = r ? `${r}: ` : '',
		o = U(this, 'negate'),
		s = o
			? `${n}expected ${Se(e)} not to be a callable function`
			: `${n}expected ${Se(e)} to be a callable function`,
		a = ['Function', 'AsyncFunction', 'GeneratorFunction', 'AsyncGeneratorFunction'].includes(
			qe(e)
		);
	if ((a && o) || (!a && !o)) throw new Ce(s, void 0, t);
});
j.addProperty('false', function () {
	this.assert(
		U(this, 'object') === !1,
		'expected #{this} to be false',
		'expected #{this} to be true',
		!!U(this, 'negate')
	);
});
j.addProperty('null', function () {
	this.assert(
		U(this, 'object') === null,
		'expected #{this} to be null',
		'expected #{this} not to be null'
	);
});
j.addProperty('undefined', function () {
	this.assert(
		U(this, 'object') === void 0,
		'expected #{this} to be undefined',
		'expected #{this} not to be undefined'
	);
});
j.addProperty('NaN', function () {
	this.assert(
		Ml(U(this, 'object')),
		'expected #{this} to be NaN',
		'expected #{this} not to be NaN'
	);
});
function Gu() {
	let e = U(this, 'object');
	this.assert(e != null, 'expected #{this} to exist', 'expected #{this} to not exist');
}
i(Gu, 'assertExist');
G(Gu, 'assertExist');
j.addProperty('exist', Gu);
j.addProperty('exists', Gu);
j.addProperty('empty', function () {
	let e = U(this, 'object'),
		t = U(this, 'ssfi'),
		r = U(this, 'message'),
		n;
	switch (((r = r ? r + ': ' : ''), qe(e).toLowerCase())) {
		case 'array':
		case 'string':
			n = e.length;
			break;
		case 'map':
		case 'set':
			n = e.size;
			break;
		case 'weakmap':
		case 'weakset':
			throw new Ce(r + '.empty was passed a weak collection', void 0, t);
		case 'function': {
			const o = r + '.empty was passed a function ' + Ta(e);
			throw new Ce(o.trim(), void 0, t);
		}
		default:
			if (e !== Object(e))
				throw new Ce(r + '.empty was passed non-string primitive ' + Se(e), void 0, t);
			n = Object.keys(e).length;
	}
	this.assert(n === 0, 'expected #{this} to be empty', 'expected #{this} not to be empty');
});
function zu() {
	let e = U(this, 'object'),
		t = qe(e);
	this.assert(
		t === 'Arguments',
		'expected #{this} to be arguments but got ' + t,
		'expected #{this} to not be arguments'
	);
}
i(zu, 'checkArguments');
G(zu, 'checkArguments');
j.addProperty('arguments', zu);
j.addProperty('Arguments', zu);
function _a(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object');
	if (U(this, 'deep')) {
		let n = U(this, 'lockSsfi');
		(U(this, 'lockSsfi', !0), this.eql(e), U(this, 'lockSsfi', n));
	} else
		this.assert(
			e === r,
			'expected #{this} to equal #{exp}',
			'expected #{this} to not equal #{exp}',
			e,
			this._obj,
			!0
		);
}
i(_a, 'assertEqual');
G(_a, 'assertEqual');
j.addMethod('equal', _a);
j.addMethod('equals', _a);
j.addMethod('eq', _a);
function Wu(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'eql');
	this.assert(
		r(e, U(this, 'object')),
		'expected #{this} to deeply equal #{exp}',
		'expected #{this} to not deeply equal #{exp}',
		e,
		this._obj,
		!0
	);
}
i(Wu, 'assertEql');
G(Wu, 'assertEql');
j.addMethod('eql', Wu);
j.addMethod('eqls', Wu);
function wa(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'doLength'),
		o = U(this, 'message'),
		s = o ? o + ': ' : '',
		a = U(this, 'ssfi'),
		u = qe(r).toLowerCase(),
		c = qe(e).toLowerCase();
	if (
		(n && u !== 'map' && u !== 'set' && new j(r, o, a, !0).to.have.property('length'),
		!n && u === 'date' && c !== 'date')
	)
		throw new Ce(s + 'the argument to above must be a date', void 0, a);
	if (!ut(e) && (n || ut(r))) throw new Ce(s + 'the argument to above must be a number', void 0, a);
	if (!n && u !== 'date' && !ut(r)) {
		let d = u === 'string' ? "'" + r + "'" : r;
		throw new Ce(s + 'expected ' + d + ' to be a number or a date', void 0, a);
	}
	if (n) {
		let d = 'length',
			p;
		(u === 'map' || u === 'set' ? ((d = 'size'), (p = r.size)) : (p = r.length),
			this.assert(
				p > e,
				'expected #{this} to have a ' + d + ' above #{exp} but got #{act}',
				'expected #{this} to not have a ' + d + ' above #{exp}',
				e,
				p
			));
	} else
		this.assert(
			r > e,
			'expected #{this} to be above #{exp}',
			'expected #{this} to be at most #{exp}',
			e
		);
}
i(wa, 'assertAbove');
G(wa, 'assertAbove');
j.addMethod('above', wa);
j.addMethod('gt', wa);
j.addMethod('greaterThan', wa);
function Sa(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'doLength'),
		o = U(this, 'message'),
		s = o ? o + ': ' : '',
		a = U(this, 'ssfi'),
		u = qe(r).toLowerCase(),
		c = qe(e).toLowerCase(),
		d,
		p = !0;
	if (
		(n && u !== 'map' && u !== 'set' && new j(r, o, a, !0).to.have.property('length'),
		!n && u === 'date' && c !== 'date')
	)
		d = s + 'the argument to least must be a date';
	else if (!ut(e) && (n || ut(r))) d = s + 'the argument to least must be a number';
	else if (!n && u !== 'date' && !ut(r)) {
		let f = u === 'string' ? "'" + r + "'" : r;
		d = s + 'expected ' + f + ' to be a number or a date';
	} else p = !1;
	if (p) throw new Ce(d, void 0, a);
	if (n) {
		let f = 'length',
			m;
		(u === 'map' || u === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
			this.assert(
				m >= e,
				'expected #{this} to have a ' + f + ' at least #{exp} but got #{act}',
				'expected #{this} to have a ' + f + ' below #{exp}',
				e,
				m
			));
	} else
		this.assert(
			r >= e,
			'expected #{this} to be at least #{exp}',
			'expected #{this} to be below #{exp}',
			e
		);
}
i(Sa, 'assertLeast');
G(Sa, 'assertLeast');
j.addMethod('least', Sa);
j.addMethod('gte', Sa);
j.addMethod('greaterThanOrEqual', Sa);
function Ra(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'doLength'),
		o = U(this, 'message'),
		s = o ? o + ': ' : '',
		a = U(this, 'ssfi'),
		u = qe(r).toLowerCase(),
		c = qe(e).toLowerCase(),
		d,
		p = !0;
	if (
		(n && u !== 'map' && u !== 'set' && new j(r, o, a, !0).to.have.property('length'),
		!n && u === 'date' && c !== 'date')
	)
		d = s + 'the argument to below must be a date';
	else if (!ut(e) && (n || ut(r))) d = s + 'the argument to below must be a number';
	else if (!n && u !== 'date' && !ut(r)) {
		let f = u === 'string' ? "'" + r + "'" : r;
		d = s + 'expected ' + f + ' to be a number or a date';
	} else p = !1;
	if (p) throw new Ce(d, void 0, a);
	if (n) {
		let f = 'length',
			m;
		(u === 'map' || u === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
			this.assert(
				m < e,
				'expected #{this} to have a ' + f + ' below #{exp} but got #{act}',
				'expected #{this} to not have a ' + f + ' below #{exp}',
				e,
				m
			));
	} else
		this.assert(
			r < e,
			'expected #{this} to be below #{exp}',
			'expected #{this} to be at least #{exp}',
			e
		);
}
i(Ra, 'assertBelow');
G(Ra, 'assertBelow');
j.addMethod('below', Ra);
j.addMethod('lt', Ra);
j.addMethod('lessThan', Ra);
function Pa(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'doLength'),
		o = U(this, 'message'),
		s = o ? o + ': ' : '',
		a = U(this, 'ssfi'),
		u = qe(r).toLowerCase(),
		c = qe(e).toLowerCase(),
		d,
		p = !0;
	if (
		(n && u !== 'map' && u !== 'set' && new j(r, o, a, !0).to.have.property('length'),
		!n && u === 'date' && c !== 'date')
	)
		d = s + 'the argument to most must be a date';
	else if (!ut(e) && (n || ut(r))) d = s + 'the argument to most must be a number';
	else if (!n && u !== 'date' && !ut(r)) {
		let f = u === 'string' ? "'" + r + "'" : r;
		d = s + 'expected ' + f + ' to be a number or a date';
	} else p = !1;
	if (p) throw new Ce(d, void 0, a);
	if (n) {
		let f = 'length',
			m;
		(u === 'map' || u === 'set' ? ((f = 'size'), (m = r.size)) : (m = r.length),
			this.assert(
				m <= e,
				'expected #{this} to have a ' + f + ' at most #{exp} but got #{act}',
				'expected #{this} to have a ' + f + ' above #{exp}',
				e,
				m
			));
	} else
		this.assert(
			r <= e,
			'expected #{this} to be at most #{exp}',
			'expected #{this} to be above #{exp}',
			e
		);
}
i(Pa, 'assertMost');
G(Pa, 'assertMost');
j.addMethod('most', Pa);
j.addMethod('lte', Pa);
j.addMethod('lessThanOrEqual', Pa);
j.addMethod('within', function (e, t, r) {
	r && U(this, 'message', r);
	let n = U(this, 'object'),
		o = U(this, 'doLength'),
		s = U(this, 'message'),
		a = s ? s + ': ' : '',
		u = U(this, 'ssfi'),
		c = qe(n).toLowerCase(),
		d = qe(e).toLowerCase(),
		p = qe(t).toLowerCase(),
		f,
		m = !0,
		y = d === 'date' && p === 'date' ? e.toISOString() + '..' + t.toISOString() : e + '..' + t;
	if (
		(o && c !== 'map' && c !== 'set' && new j(n, s, u, !0).to.have.property('length'),
		!o && c === 'date' && (d !== 'date' || p !== 'date'))
	)
		f = a + 'the arguments to within must be dates';
	else if ((!ut(e) || !ut(t)) && (o || ut(n))) f = a + 'the arguments to within must be numbers';
	else if (!o && c !== 'date' && !ut(n)) {
		let g = c === 'string' ? "'" + n + "'" : n;
		f = a + 'expected ' + g + ' to be a number or a date';
	} else m = !1;
	if (m) throw new Ce(f, void 0, u);
	if (o) {
		let g = 'length',
			E;
		(c === 'map' || c === 'set' ? ((g = 'size'), (E = n.size)) : (E = n.length),
			this.assert(
				E >= e && E <= t,
				'expected #{this} to have a ' + g + ' within ' + y,
				'expected #{this} to not have a ' + g + ' within ' + y
			));
	} else
		this.assert(
			n >= e && n <= t,
			'expected #{this} to be within ' + y,
			'expected #{this} to not be within ' + y
		);
});
function Ku(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'ssfi'),
		o = U(this, 'message'),
		s;
	try {
		s = r instanceof e;
	} catch (u) {
		throw u instanceof TypeError
			? ((o = o ? o + ': ' : ''),
				new Ce(
					o + 'The instanceof assertion needs a constructor but ' + qe(e) + ' was given.',
					void 0,
					n
				))
			: u;
	}
	let a = Ta(e);
	(a == null && (a = 'an unnamed constructor'),
		this.assert(
			s,
			'expected #{this} to be an instance of ' + a,
			'expected #{this} to not be an instance of ' + a
		));
}
i(Ku, 'assertInstanceOf');
G(Ku, 'assertInstanceOf');
j.addMethod('instanceof', Ku);
j.addMethod('instanceOf', Ku);
function Yu(e, t, r) {
	r && U(this, 'message', r);
	let n = U(this, 'nested'),
		o = U(this, 'own'),
		s = U(this, 'message'),
		a = U(this, 'object'),
		u = U(this, 'ssfi'),
		c = typeof e;
	if (((s = s ? s + ': ' : ''), n)) {
		if (c !== 'string')
			throw new Ce(
				s + 'the argument to property must be a string when using nested syntax',
				void 0,
				u
			);
	} else if (c !== 'string' && c !== 'number' && c !== 'symbol')
		throw new Ce(s + 'the argument to property must be a string, number, or symbol', void 0, u);
	if (n && o) throw new Ce(s + 'The "nested" and "own" flags cannot be combined.', void 0, u);
	if (a == null) throw new Ce(s + 'Target cannot be null or undefined.', void 0, u);
	let d = U(this, 'deep'),
		p = U(this, 'negate'),
		f = n ? ju(a, e) : null,
		m = n ? f.value : a[e],
		y = d ? U(this, 'eql') : (T, b) => T === b,
		g = '';
	(d && (g += 'deep '), o && (g += 'own '), n && (g += 'nested '), (g += 'property '));
	let E;
	(o ? (E = Object.prototype.hasOwnProperty.call(a, e)) : n ? (E = f.exists) : (E = Ea(a, e)),
		(!p || arguments.length === 1) &&
			this.assert(
				E,
				'expected #{this} to have ' + g + Se(e),
				'expected #{this} to not have ' + g + Se(e)
			),
		arguments.length > 1 &&
			this.assert(
				E && y(t, m),
				'expected #{this} to have ' + g + Se(e) + ' of #{exp}, but got #{act}',
				'expected #{this} to not have ' + g + Se(e) + ' of #{act}',
				t,
				m
			),
		U(this, 'object', m));
}
i(Yu, 'assertProperty');
G(Yu, 'assertProperty');
j.addMethod('property', Yu);
function Xu(e, t, r) {
	(U(this, 'own', !0), Yu.apply(this, arguments));
}
i(Xu, 'assertOwnProperty');
G(Xu, 'assertOwnProperty');
j.addMethod('ownProperty', Xu);
j.addMethod('haveOwnProperty', Xu);
function Qu(e, t, r) {
	(typeof t == 'string' && ((r = t), (t = null)), r && U(this, 'message', r));
	let n = U(this, 'object'),
		o = Object.getOwnPropertyDescriptor(Object(n), e),
		s = U(this, 'eql');
	(o && t
		? this.assert(
				s(t, o),
				'expected the own property descriptor for ' +
					Se(e) +
					' on #{this} to match ' +
					Se(t) +
					', got ' +
					Se(o),
				'expected the own property descriptor for ' + Se(e) + ' on #{this} to not match ' + Se(t),
				t,
				o,
				!0
			)
		: this.assert(
				o,
				'expected #{this} to have an own property descriptor for ' + Se(e),
				'expected #{this} to not have an own property descriptor for ' + Se(e)
			),
		U(this, 'object', o));
}
i(Qu, 'assertOwnPropertyDescriptor');
G(Qu, 'assertOwnPropertyDescriptor');
j.addMethod('ownPropertyDescriptor', Qu);
j.addMethod('haveOwnPropertyDescriptor', Qu);
function Zu() {
	U(this, 'doLength', !0);
}
i(Zu, 'assertLengthChain');
G(Zu, 'assertLengthChain');
function ec(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = qe(r).toLowerCase(),
		o = U(this, 'message'),
		s = U(this, 'ssfi'),
		a = 'length',
		u;
	switch (n) {
		case 'map':
		case 'set':
			((a = 'size'), (u = r.size));
			break;
		default:
			(new j(r, o, s, !0).to.have.property('length'), (u = r.length));
	}
	this.assert(
		u == e,
		'expected #{this} to have a ' + a + ' of #{exp} but got #{act}',
		'expected #{this} to not have a ' + a + ' of #{act}',
		e,
		u
	);
}
i(ec, 'assertLength');
G(ec, 'assertLength');
j.addChainableMethod('length', ec, Zu);
j.addChainableMethod('lengthOf', ec, Zu);
function tc(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object');
	this.assert(e.exec(r), 'expected #{this} to match ' + e, 'expected #{this} not to match ' + e);
}
i(tc, 'assertMatch');
G(tc, 'assertMatch');
j.addMethod('match', tc);
j.addMethod('matches', tc);
j.addMethod('string', function (e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'message'),
		o = U(this, 'ssfi');
	(new j(r, n, o, !0).is.a('string'),
		this.assert(
			~r.indexOf(e),
			'expected #{this} to contain ' + Se(e),
			'expected #{this} to not contain ' + Se(e)
		));
});
function rc(e) {
	let t = U(this, 'object'),
		r = qe(t),
		n = qe(e),
		o = U(this, 'ssfi'),
		s = U(this, 'deep'),
		a,
		u = '',
		c,
		d = !0,
		p = U(this, 'message');
	p = p ? p + ': ' : '';
	let f =
		p +
		'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';
	if (r === 'Map' || r === 'Set')
		((u = s ? 'deeply ' : ''),
			(c = []),
			t.forEach(function (b, w) {
				c.push(w);
			}),
			n !== 'Array' && (e = Array.prototype.slice.call(arguments)));
	else {
		switch (((c = Uu(t)), n)) {
			case 'Array':
				if (arguments.length > 1) throw new Ce(f, void 0, o);
				break;
			case 'Object':
				if (arguments.length > 1) throw new Ce(f, void 0, o);
				e = Object.keys(e);
				break;
			default:
				e = Array.prototype.slice.call(arguments);
		}
		e = e.map(function (b) {
			return typeof b == 'symbol' ? b : String(b);
		});
	}
	if (!e.length) throw new Ce(p + 'keys required', void 0, o);
	let m = e.length,
		y = U(this, 'any'),
		g = U(this, 'all'),
		E = e,
		T = s ? U(this, 'eql') : (b, w) => b === w;
	if (
		(!y && !g && (g = !0),
		y &&
			(d = E.some(function (b) {
				return c.some(function (w) {
					return T(b, w);
				});
			})),
		g &&
			((d = E.every(function (b) {
				return c.some(function (w) {
					return T(b, w);
				});
			})),
			U(this, 'contains') || (d = d && e.length == c.length)),
		m > 1)
	) {
		e = e.map(function (w) {
			return Se(w);
		});
		let b = e.pop();
		(g && (a = e.join(', ') + ', and ' + b), y && (a = e.join(', ') + ', or ' + b));
	} else a = Se(e[0]);
	((a = (m > 1 ? 'keys ' : 'key ') + a),
		(a = (U(this, 'contains') ? 'contain ' : 'have ') + a),
		this.assert(
			d,
			'expected #{this} to ' + u + a,
			'expected #{this} to not ' + u + a,
			E.slice(0).sort(Ys),
			c.sort(Ys),
			!0
		));
}
i(rc, 'assertKeys');
G(rc, 'assertKeys');
j.addMethod('keys', rc);
j.addMethod('key', rc);
function Aa(e, t, r) {
	r && U(this, 'message', r);
	let n = U(this, 'object'),
		o = U(this, 'ssfi'),
		s = U(this, 'message'),
		a = U(this, 'negate') || !1;
	(new j(n, s, o, !0).is.a('function'), (Xs(e) || typeof e == 'string') && ((t = e), (e = null)));
	let u,
		c = !1;
	try {
		n();
	} catch (y) {
		((c = !0), (u = y));
	}
	let d = e === void 0 && t === void 0,
		p = !!(e && t),
		f = !1,
		m = !1;
	if (d || (!d && !a)) {
		let y = 'an error';
		e instanceof Error ? (y = '#{exp}') : e && (y = Ut.getConstructorName(e));
		let g = u;
		if (u instanceof Error) g = u.toString();
		else if (typeof u == 'string') g = u;
		else if (u && (typeof u == 'object' || typeof u == 'function'))
			try {
				g = Ut.getConstructorName(u);
			} catch {}
		this.assert(
			c,
			'expected #{this} to throw ' + y,
			'expected #{this} to not throw an error but #{act} was thrown',
			e && e.toString(),
			g
		);
	}
	if (
		(e &&
			u &&
			(e instanceof Error &&
				Ut.compatibleInstance(u, e) === a &&
				(p && a
					? (f = !0)
					: this.assert(
							a,
							'expected #{this} to throw #{exp} but #{act} was thrown',
							'expected #{this} to not throw #{exp}' + (u && !a ? ' but #{act} was thrown' : ''),
							e.toString(),
							u.toString()
						)),
			Ut.compatibleConstructor(u, e) === a &&
				(p && a
					? (f = !0)
					: this.assert(
							a,
							'expected #{this} to throw #{exp} but #{act} was thrown',
							'expected #{this} to not throw #{exp}' + (u ? ' but #{act} was thrown' : ''),
							e instanceof Error ? e.toString() : e && Ut.getConstructorName(e),
							u instanceof Error ? u.toString() : u && Ut.getConstructorName(u)
						))),
		u && t !== void 0 && t !== null)
	) {
		let y = 'including';
		(Xs(t) && (y = 'matching'),
			Ut.compatibleMessage(u, t) === a &&
				(p && a
					? (m = !0)
					: this.assert(
							a,
							'expected #{this} to throw error ' + y + ' #{exp} but got #{act}',
							'expected #{this} to throw error not ' + y + ' #{exp}',
							t,
							Ut.getMessage(u)
						)));
	}
	(f &&
		m &&
		this.assert(
			a,
			'expected #{this} to throw #{exp} but #{act} was thrown',
			'expected #{this} to not throw #{exp}' + (u ? ' but #{act} was thrown' : ''),
			e instanceof Error ? e.toString() : e && Ut.getConstructorName(e),
			u instanceof Error ? u.toString() : u && Ut.getConstructorName(u)
		),
		U(this, 'object', u));
}
i(Aa, 'assertThrows');
G(Aa, 'assertThrows');
j.addMethod('throw', Aa);
j.addMethod('throws', Aa);
j.addMethod('Throw', Aa);
function nc(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'itself'),
		o = typeof r == 'function' && !n ? r.prototype[e] : r[e];
	this.assert(
		typeof o == 'function',
		'expected #{this} to respond to ' + Se(e),
		'expected #{this} to not respond to ' + Se(e)
	);
}
i(nc, 'respondTo');
G(nc, 'respondTo');
j.addMethod('respondTo', nc);
j.addMethod('respondsTo', nc);
j.addProperty('itself', function () {
	U(this, 'itself', !0);
});
function oc(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = e(r);
	this.assert(
		n,
		'expected #{this} to satisfy ' + Tn(e),
		'expected #{this} to not satisfy' + Tn(e),
		!U(this, 'negate'),
		n
	);
}
i(oc, 'satisfy');
G(oc, 'satisfy');
j.addMethod('satisfy', oc);
j.addMethod('satisfies', oc);
function ic(e, t, r) {
	r && U(this, 'message', r);
	let n = U(this, 'object'),
		o = U(this, 'message'),
		s = U(this, 'ssfi');
	new j(n, o, s, !0).is.numeric;
	let a = 'A `delta` value is required for `closeTo`';
	if (t == null) throw new Ce(o ? `${o}: ${a}` : a, void 0, s);
	if (
		(new j(t, o, s, !0).is.numeric, (a = 'A `expected` value is required for `closeTo`'), e == null)
	)
		throw new Ce(o ? `${o}: ${a}` : a, void 0, s);
	new j(e, o, s, !0).is.numeric;
	const u = G((d) => (d < 0n ? -d : d), 'abs'),
		c = G((d) => parseFloat(parseFloat(d).toPrecision(12)), 'strip');
	this.assert(
		c(u(n - e)) <= t,
		'expected #{this} to be close to ' + e + ' +/- ' + t,
		'expected #{this} not to be close to ' + e + ' +/- ' + t
	);
}
i(ic, 'closeTo');
G(ic, 'closeTo');
j.addMethod('closeTo', ic);
j.addMethod('approximately', ic);
function xh(e, t, r, n, o) {
	let s = Array.from(t),
		a = Array.from(e);
	if (!n) {
		if (a.length !== s.length) return !1;
		s = s.slice();
	}
	return a.every(function (u, c) {
		if (o) return r ? r(u, s[c]) : u === s[c];
		if (!r) {
			let d = s.indexOf(u);
			return d === -1 ? !1 : (n || s.splice(d, 1), !0);
		}
		return s.some(function (d, p) {
			return r(u, d) ? (n || s.splice(p, 1), !0) : !1;
		});
	});
}
i(xh, 'isSubsetOf');
G(xh, 'isSubsetOf');
j.addMethod('members', function (e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'message'),
		o = U(this, 'ssfi');
	(new j(r, n, o, !0).to.be.iterable, new j(e, n, o, !0).to.be.iterable);
	let s = U(this, 'contains'),
		a = U(this, 'ordered'),
		u,
		c,
		d;
	s
		? ((u = a ? 'an ordered superset' : 'a superset'),
			(c = 'expected #{this} to be ' + u + ' of #{exp}'),
			(d = 'expected #{this} to not be ' + u + ' of #{exp}'))
		: ((u = a ? 'ordered members' : 'members'),
			(c = 'expected #{this} to have the same ' + u + ' as #{exp}'),
			(d = 'expected #{this} to not have the same ' + u + ' as #{exp}'));
	let p = U(this, 'deep') ? U(this, 'eql') : void 0;
	this.assert(xh(e, r, p, s, a), c, d, e, r, !0);
});
j.addProperty('iterable', function (e) {
	e && U(this, 'message', e);
	let t = U(this, 'object');
	this.assert(
		t != null && t[Symbol.iterator],
		'expected #{this} to be an iterable',
		'expected #{this} to not be an iterable',
		t
	);
});
function Ih(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'object'),
		n = U(this, 'message'),
		o = U(this, 'ssfi'),
		s = U(this, 'contains'),
		a = U(this, 'deep'),
		u = U(this, 'eql');
	(new j(e, n, o, !0).to.be.an('array'),
		s
			? this.assert(
					e.some(function (c) {
						return r.indexOf(c) > -1;
					}),
					'expected #{this} to contain one of #{exp}',
					'expected #{this} to not contain one of #{exp}',
					e,
					r
				)
			: a
				? this.assert(
						e.some(function (c) {
							return u(r, c);
						}),
						'expected #{this} to deeply equal one of #{exp}',
						'expected #{this} to deeply equal one of #{exp}',
						e,
						r
					)
				: this.assert(
						e.indexOf(r) > -1,
						'expected #{this} to be one of #{exp}',
						'expected #{this} to not be one of #{exp}',
						e,
						r
					));
}
i(Ih, 'oneOf');
G(Ih, 'oneOf');
j.addMethod('oneOf', Ih);
function sc(e, t, r) {
	r && U(this, 'message', r);
	let n = U(this, 'object'),
		o = U(this, 'message'),
		s = U(this, 'ssfi');
	new j(n, o, s, !0).is.a('function');
	let a;
	(t
		? (new j(e, o, s, !0).to.have.property(t), (a = e[t]))
		: (new j(e, o, s, !0).is.a('function'), (a = e())),
		n());
	let u = t == null ? e() : e[t],
		c = t == null ? a : '.' + t;
	(U(this, 'deltaMsgObj', c),
		U(this, 'initialDeltaValue', a),
		U(this, 'finalDeltaValue', u),
		U(this, 'deltaBehavior', 'change'),
		U(this, 'realDelta', u !== a),
		this.assert(a !== u, 'expected ' + c + ' to change', 'expected ' + c + ' to not change'));
}
i(sc, 'assertChanges');
G(sc, 'assertChanges');
j.addMethod('change', sc);
j.addMethod('changes', sc);
function ac(e, t, r) {
	r && U(this, 'message', r);
	let n = U(this, 'object'),
		o = U(this, 'message'),
		s = U(this, 'ssfi');
	new j(n, o, s, !0).is.a('function');
	let a;
	(t
		? (new j(e, o, s, !0).to.have.property(t), (a = e[t]))
		: (new j(e, o, s, !0).is.a('function'), (a = e())),
		new j(a, o, s, !0).is.a('number'),
		n());
	let u = t == null ? e() : e[t],
		c = t == null ? a : '.' + t;
	(U(this, 'deltaMsgObj', c),
		U(this, 'initialDeltaValue', a),
		U(this, 'finalDeltaValue', u),
		U(this, 'deltaBehavior', 'increase'),
		U(this, 'realDelta', u - a),
		this.assert(u - a > 0, 'expected ' + c + ' to increase', 'expected ' + c + ' to not increase'));
}
i(ac, 'assertIncreases');
G(ac, 'assertIncreases');
j.addMethod('increase', ac);
j.addMethod('increases', ac);
function lc(e, t, r) {
	r && U(this, 'message', r);
	let n = U(this, 'object'),
		o = U(this, 'message'),
		s = U(this, 'ssfi');
	new j(n, o, s, !0).is.a('function');
	let a;
	(t
		? (new j(e, o, s, !0).to.have.property(t), (a = e[t]))
		: (new j(e, o, s, !0).is.a('function'), (a = e())),
		new j(a, o, s, !0).is.a('number'),
		n());
	let u = t == null ? e() : e[t],
		c = t == null ? a : '.' + t;
	(U(this, 'deltaMsgObj', c),
		U(this, 'initialDeltaValue', a),
		U(this, 'finalDeltaValue', u),
		U(this, 'deltaBehavior', 'decrease'),
		U(this, 'realDelta', a - u),
		this.assert(u - a < 0, 'expected ' + c + ' to decrease', 'expected ' + c + ' to not decrease'));
}
i(lc, 'assertDecreases');
G(lc, 'assertDecreases');
j.addMethod('decrease', lc);
j.addMethod('decreases', lc);
function Nh(e, t) {
	t && U(this, 'message', t);
	let r = U(this, 'deltaMsgObj'),
		n = U(this, 'initialDeltaValue'),
		o = U(this, 'finalDeltaValue'),
		s = U(this, 'deltaBehavior'),
		a = U(this, 'realDelta'),
		u;
	(s === 'change' ? (u = Math.abs(o - n) === Math.abs(e)) : (u = a === Math.abs(e)),
		this.assert(
			u,
			'expected ' + r + ' to ' + s + ' by ' + e,
			'expected ' + r + ' to not ' + s + ' by ' + e
		));
}
i(Nh, 'assertDelta');
G(Nh, 'assertDelta');
j.addMethod('by', Nh);
j.addProperty('extensible', function () {
	let e = U(this, 'object'),
		t = e === Object(e) && Object.isExtensible(e);
	this.assert(t, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
});
j.addProperty('sealed', function () {
	let e = U(this, 'object'),
		t = e === Object(e) ? Object.isSealed(e) : !0;
	this.assert(t, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
});
j.addProperty('frozen', function () {
	let e = U(this, 'object'),
		t = e === Object(e) ? Object.isFrozen(e) : !0;
	this.assert(t, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
});
j.addProperty('finite', function (e) {
	let t = U(this, 'object');
	this.assert(
		typeof t == 'number' && isFinite(t),
		'expected #{this} to be a finite number',
		'expected #{this} to not be a finite number'
	);
});
function Qs(e, t) {
	return e === t
		? !0
		: typeof t != typeof e
			? !1
			: typeof e != 'object' || e === null
				? e === t
				: t
					? Array.isArray(e)
						? Array.isArray(t)
							? e.every(function (r) {
									return t.some(function (n) {
										return Qs(r, n);
									});
								})
							: !1
						: e instanceof Date
							? t instanceof Date
								? e.getTime() === t.getTime()
								: !1
							: Object.keys(e).every(function (r) {
									let n = e[r],
										o = t[r];
									return typeof n == 'object' && n !== null && o !== null
										? Qs(n, o)
										: typeof n == 'function'
											? n(o)
											: o === n;
								})
					: !1;
}
i(Qs, 'compareSubset');
G(Qs, 'compareSubset');
j.addMethod('containSubset', function (e) {
	const t = he(this, 'object'),
		r = Nt.showDiff;
	this.assert(
		Qs(e, t),
		'expected #{act} to contain subset #{exp}',
		'expected #{act} to not contain subset #{exp}',
		e,
		t,
		r
	);
});
function _n(e, t) {
	return new j(e, t);
}
i(_n, 'expect');
G(_n, 'expect');
_n.fail = function (e, t, r, n) {
	throw (
		arguments.length < 2 && ((r = e), (e = void 0)),
		(r = r || 'expect.fail()'),
		new Ce(r, { actual: e, expected: t, operator: n }, _n.fail)
	);
};
var j0 = {};
Wm(j0, { Should: i(() => sU, 'Should'), should: i(() => iU, 'should') });
function uc() {
	function e() {
		return this instanceof String ||
			this instanceof Number ||
			this instanceof Boolean ||
			(typeof Symbol == 'function' && this instanceof Symbol) ||
			(typeof BigInt == 'function' && this instanceof BigInt)
			? new j(this.valueOf(), null, e)
			: new j(this, null, e);
	}
	(i(e, 'shouldGetter'), G(e, 'shouldGetter'));
	function t(n) {
		Object.defineProperty(this, 'should', {
			value: n,
			enumerable: !0,
			configurable: !0,
			writable: !0
		});
	}
	(i(t, 'shouldSetter'),
		G(t, 'shouldSetter'),
		Object.defineProperty(Object.prototype, 'should', { set: t, get: e, configurable: !0 }));
	let r = {};
	return (
		(r.fail = function (n, o, s, a) {
			throw (
				arguments.length < 2 && ((s = n), (n = void 0)),
				(s = s || 'should.fail()'),
				new Ce(s, { actual: n, expected: o, operator: a }, r.fail)
			);
		}),
		(r.equal = function (n, o, s) {
			new j(n, s).to.equal(o);
		}),
		(r.Throw = function (n, o, s, a) {
			new j(n, a).to.Throw(o, s);
		}),
		(r.exist = function (n, o) {
			new j(n, o).to.exist;
		}),
		(r.not = {}),
		(r.not.equal = function (n, o, s) {
			new j(n, s).to.not.equal(o);
		}),
		(r.not.Throw = function (n, o, s, a) {
			new j(n, a).to.not.Throw(o, s);
		}),
		(r.not.exist = function (n, o) {
			new j(n, o).to.not.exist;
		}),
		(r.throw = r.Throw),
		(r.not.throw = r.not.Throw),
		r
	);
}
i(uc, 'loadShould');
G(uc, 'loadShould');
var iU = uc,
	sU = uc;
function M(e, t) {
	new j(null, null, M, !0).assert(e, t, '[ negation message unavailable ]');
}
i(M, 'assert');
G(M, 'assert');
M.fail = function (e, t, r, n) {
	throw (
		arguments.length < 2 && ((r = e), (e = void 0)),
		(r = r || 'assert.fail()'),
		new Ce(r, { actual: e, expected: t, operator: n }, M.fail)
	);
};
M.isOk = function (e, t) {
	new j(e, t, M.isOk, !0).is.ok;
};
M.isNotOk = function (e, t) {
	new j(e, t, M.isNotOk, !0).is.not.ok;
};
M.equal = function (e, t, r) {
	let n = new j(e, r, M.equal, !0);
	n.assert(
		t == he(n, 'object'),
		'expected #{this} to equal #{exp}',
		'expected #{this} to not equal #{act}',
		t,
		e,
		!0
	);
};
M.notEqual = function (e, t, r) {
	let n = new j(e, r, M.notEqual, !0);
	n.assert(
		t != he(n, 'object'),
		'expected #{this} to not equal #{exp}',
		'expected #{this} to equal #{act}',
		t,
		e,
		!0
	);
};
M.strictEqual = function (e, t, r) {
	new j(e, r, M.strictEqual, !0).to.equal(t);
};
M.notStrictEqual = function (e, t, r) {
	new j(e, r, M.notStrictEqual, !0).to.not.equal(t);
};
M.deepEqual = M.deepStrictEqual = function (e, t, r) {
	new j(e, r, M.deepEqual, !0).to.eql(t);
};
M.notDeepEqual = function (e, t, r) {
	new j(e, r, M.notDeepEqual, !0).to.not.eql(t);
};
M.isAbove = function (e, t, r) {
	new j(e, r, M.isAbove, !0).to.be.above(t);
};
M.isAtLeast = function (e, t, r) {
	new j(e, r, M.isAtLeast, !0).to.be.least(t);
};
M.isBelow = function (e, t, r) {
	new j(e, r, M.isBelow, !0).to.be.below(t);
};
M.isAtMost = function (e, t, r) {
	new j(e, r, M.isAtMost, !0).to.be.most(t);
};
M.isTrue = function (e, t) {
	new j(e, t, M.isTrue, !0).is.true;
};
M.isNotTrue = function (e, t) {
	new j(e, t, M.isNotTrue, !0).to.not.equal(!0);
};
M.isFalse = function (e, t) {
	new j(e, t, M.isFalse, !0).is.false;
};
M.isNotFalse = function (e, t) {
	new j(e, t, M.isNotFalse, !0).to.not.equal(!1);
};
M.isNull = function (e, t) {
	new j(e, t, M.isNull, !0).to.equal(null);
};
M.isNotNull = function (e, t) {
	new j(e, t, M.isNotNull, !0).to.not.equal(null);
};
M.isNaN = function (e, t) {
	new j(e, t, M.isNaN, !0).to.be.NaN;
};
M.isNotNaN = function (e, t) {
	new j(e, t, M.isNotNaN, !0).not.to.be.NaN;
};
M.exists = function (e, t) {
	new j(e, t, M.exists, !0).to.exist;
};
M.notExists = function (e, t) {
	new j(e, t, M.notExists, !0).to.not.exist;
};
M.isUndefined = function (e, t) {
	new j(e, t, M.isUndefined, !0).to.equal(void 0);
};
M.isDefined = function (e, t) {
	new j(e, t, M.isDefined, !0).to.not.equal(void 0);
};
M.isCallable = function (e, t) {
	new j(e, t, M.isCallable, !0).is.callable;
};
M.isNotCallable = function (e, t) {
	new j(e, t, M.isNotCallable, !0).is.not.callable;
};
M.isObject = function (e, t) {
	new j(e, t, M.isObject, !0).to.be.a('object');
};
M.isNotObject = function (e, t) {
	new j(e, t, M.isNotObject, !0).to.not.be.a('object');
};
M.isArray = function (e, t) {
	new j(e, t, M.isArray, !0).to.be.an('array');
};
M.isNotArray = function (e, t) {
	new j(e, t, M.isNotArray, !0).to.not.be.an('array');
};
M.isString = function (e, t) {
	new j(e, t, M.isString, !0).to.be.a('string');
};
M.isNotString = function (e, t) {
	new j(e, t, M.isNotString, !0).to.not.be.a('string');
};
M.isNumber = function (e, t) {
	new j(e, t, M.isNumber, !0).to.be.a('number');
};
M.isNotNumber = function (e, t) {
	new j(e, t, M.isNotNumber, !0).to.not.be.a('number');
};
M.isNumeric = function (e, t) {
	new j(e, t, M.isNumeric, !0).is.numeric;
};
M.isNotNumeric = function (e, t) {
	new j(e, t, M.isNotNumeric, !0).is.not.numeric;
};
M.isFinite = function (e, t) {
	new j(e, t, M.isFinite, !0).to.be.finite;
};
M.isBoolean = function (e, t) {
	new j(e, t, M.isBoolean, !0).to.be.a('boolean');
};
M.isNotBoolean = function (e, t) {
	new j(e, t, M.isNotBoolean, !0).to.not.be.a('boolean');
};
M.typeOf = function (e, t, r) {
	new j(e, r, M.typeOf, !0).to.be.a(t);
};
M.notTypeOf = function (e, t, r) {
	new j(e, r, M.notTypeOf, !0).to.not.be.a(t);
};
M.instanceOf = function (e, t, r) {
	new j(e, r, M.instanceOf, !0).to.be.instanceOf(t);
};
M.notInstanceOf = function (e, t, r) {
	new j(e, r, M.notInstanceOf, !0).to.not.be.instanceOf(t);
};
M.include = function (e, t, r) {
	new j(e, r, M.include, !0).include(t);
};
M.notInclude = function (e, t, r) {
	new j(e, r, M.notInclude, !0).not.include(t);
};
M.deepInclude = function (e, t, r) {
	new j(e, r, M.deepInclude, !0).deep.include(t);
};
M.notDeepInclude = function (e, t, r) {
	new j(e, r, M.notDeepInclude, !0).not.deep.include(t);
};
M.nestedInclude = function (e, t, r) {
	new j(e, r, M.nestedInclude, !0).nested.include(t);
};
M.notNestedInclude = function (e, t, r) {
	new j(e, r, M.notNestedInclude, !0).not.nested.include(t);
};
M.deepNestedInclude = function (e, t, r) {
	new j(e, r, M.deepNestedInclude, !0).deep.nested.include(t);
};
M.notDeepNestedInclude = function (e, t, r) {
	new j(e, r, M.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
M.ownInclude = function (e, t, r) {
	new j(e, r, M.ownInclude, !0).own.include(t);
};
M.notOwnInclude = function (e, t, r) {
	new j(e, r, M.notOwnInclude, !0).not.own.include(t);
};
M.deepOwnInclude = function (e, t, r) {
	new j(e, r, M.deepOwnInclude, !0).deep.own.include(t);
};
M.notDeepOwnInclude = function (e, t, r) {
	new j(e, r, M.notDeepOwnInclude, !0).not.deep.own.include(t);
};
M.match = function (e, t, r) {
	new j(e, r, M.match, !0).to.match(t);
};
M.notMatch = function (e, t, r) {
	new j(e, r, M.notMatch, !0).to.not.match(t);
};
M.property = function (e, t, r) {
	new j(e, r, M.property, !0).to.have.property(t);
};
M.notProperty = function (e, t, r) {
	new j(e, r, M.notProperty, !0).to.not.have.property(t);
};
M.propertyVal = function (e, t, r, n) {
	new j(e, n, M.propertyVal, !0).to.have.property(t, r);
};
M.notPropertyVal = function (e, t, r, n) {
	new j(e, n, M.notPropertyVal, !0).to.not.have.property(t, r);
};
M.deepPropertyVal = function (e, t, r, n) {
	new j(e, n, M.deepPropertyVal, !0).to.have.deep.property(t, r);
};
M.notDeepPropertyVal = function (e, t, r, n) {
	new j(e, n, M.notDeepPropertyVal, !0).to.not.have.deep.property(t, r);
};
M.ownProperty = function (e, t, r) {
	new j(e, r, M.ownProperty, !0).to.have.own.property(t);
};
M.notOwnProperty = function (e, t, r) {
	new j(e, r, M.notOwnProperty, !0).to.not.have.own.property(t);
};
M.ownPropertyVal = function (e, t, r, n) {
	new j(e, n, M.ownPropertyVal, !0).to.have.own.property(t, r);
};
M.notOwnPropertyVal = function (e, t, r, n) {
	new j(e, n, M.notOwnPropertyVal, !0).to.not.have.own.property(t, r);
};
M.deepOwnPropertyVal = function (e, t, r, n) {
	new j(e, n, M.deepOwnPropertyVal, !0).to.have.deep.own.property(t, r);
};
M.notDeepOwnPropertyVal = function (e, t, r, n) {
	new j(e, n, M.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, r);
};
M.nestedProperty = function (e, t, r) {
	new j(e, r, M.nestedProperty, !0).to.have.nested.property(t);
};
M.notNestedProperty = function (e, t, r) {
	new j(e, r, M.notNestedProperty, !0).to.not.have.nested.property(t);
};
M.nestedPropertyVal = function (e, t, r, n) {
	new j(e, n, M.nestedPropertyVal, !0).to.have.nested.property(t, r);
};
M.notNestedPropertyVal = function (e, t, r, n) {
	new j(e, n, M.notNestedPropertyVal, !0).to.not.have.nested.property(t, r);
};
M.deepNestedPropertyVal = function (e, t, r, n) {
	new j(e, n, M.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, r);
};
M.notDeepNestedPropertyVal = function (e, t, r, n) {
	new j(e, n, M.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, r);
};
M.lengthOf = function (e, t, r) {
	new j(e, r, M.lengthOf, !0).to.have.lengthOf(t);
};
M.hasAnyKeys = function (e, t, r) {
	new j(e, r, M.hasAnyKeys, !0).to.have.any.keys(t);
};
M.hasAllKeys = function (e, t, r) {
	new j(e, r, M.hasAllKeys, !0).to.have.all.keys(t);
};
M.containsAllKeys = function (e, t, r) {
	new j(e, r, M.containsAllKeys, !0).to.contain.all.keys(t);
};
M.doesNotHaveAnyKeys = function (e, t, r) {
	new j(e, r, M.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
M.doesNotHaveAllKeys = function (e, t, r) {
	new j(e, r, M.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
M.hasAnyDeepKeys = function (e, t, r) {
	new j(e, r, M.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
M.hasAllDeepKeys = function (e, t, r) {
	new j(e, r, M.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
M.containsAllDeepKeys = function (e, t, r) {
	new j(e, r, M.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
M.doesNotHaveAnyDeepKeys = function (e, t, r) {
	new j(e, r, M.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
M.doesNotHaveAllDeepKeys = function (e, t, r) {
	new j(e, r, M.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
M.throws = function (e, t, r, n) {
	(typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null));
	let o = new j(e, n, M.throws, !0).to.throw(t, r);
	return he(o, 'object');
};
M.doesNotThrow = function (e, t, r, n) {
	((typeof t == 'string' || t instanceof RegExp) && ((r = t), (t = null)),
		new j(e, n, M.doesNotThrow, !0).to.not.throw(t, r));
};
M.operator = function (e, t, r, n) {
	let o;
	switch (t) {
		case '==':
			o = e == r;
			break;
		case '===':
			o = e === r;
			break;
		case '>':
			o = e > r;
			break;
		case '>=':
			o = e >= r;
			break;
		case '<':
			o = e < r;
			break;
		case '<=':
			o = e <= r;
			break;
		case '!=':
			o = e != r;
			break;
		case '!==':
			o = e !== r;
			break;
		default:
			throw ((n = n && n + ': '), new Ce(n + 'Invalid operator "' + t + '"', void 0, M.operator));
	}
	let s = new j(o, n, M.operator, !0);
	s.assert(
		he(s, 'object') === !0,
		'expected ' + Se(e) + ' to be ' + t + ' ' + Se(r),
		'expected ' + Se(e) + ' to not be ' + t + ' ' + Se(r)
	);
};
M.closeTo = function (e, t, r, n) {
	new j(e, n, M.closeTo, !0).to.be.closeTo(t, r);
};
M.approximately = function (e, t, r, n) {
	new j(e, n, M.approximately, !0).to.be.approximately(t, r);
};
M.sameMembers = function (e, t, r) {
	new j(e, r, M.sameMembers, !0).to.have.same.members(t);
};
M.notSameMembers = function (e, t, r) {
	new j(e, r, M.notSameMembers, !0).to.not.have.same.members(t);
};
M.sameDeepMembers = function (e, t, r) {
	new j(e, r, M.sameDeepMembers, !0).to.have.same.deep.members(t);
};
M.notSameDeepMembers = function (e, t, r) {
	new j(e, r, M.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
M.sameOrderedMembers = function (e, t, r) {
	new j(e, r, M.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
M.notSameOrderedMembers = function (e, t, r) {
	new j(e, r, M.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
M.sameDeepOrderedMembers = function (e, t, r) {
	new j(e, r, M.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
M.notSameDeepOrderedMembers = function (e, t, r) {
	new j(e, r, M.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
M.includeMembers = function (e, t, r) {
	new j(e, r, M.includeMembers, !0).to.include.members(t);
};
M.notIncludeMembers = function (e, t, r) {
	new j(e, r, M.notIncludeMembers, !0).to.not.include.members(t);
};
M.includeDeepMembers = function (e, t, r) {
	new j(e, r, M.includeDeepMembers, !0).to.include.deep.members(t);
};
M.notIncludeDeepMembers = function (e, t, r) {
	new j(e, r, M.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
M.includeOrderedMembers = function (e, t, r) {
	new j(e, r, M.includeOrderedMembers, !0).to.include.ordered.members(t);
};
M.notIncludeOrderedMembers = function (e, t, r) {
	new j(e, r, M.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
M.includeDeepOrderedMembers = function (e, t, r) {
	new j(e, r, M.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
M.notIncludeDeepOrderedMembers = function (e, t, r) {
	new j(e, r, M.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
M.oneOf = function (e, t, r) {
	new j(e, r, M.oneOf, !0).to.be.oneOf(t);
};
M.isIterable = function (e, t) {
	if (e == null || !e[Symbol.iterator])
		throw (
			(t = t ? `${t} expected ${Se(e)} to be an iterable` : `expected ${Se(e)} to be an iterable`),
			new Ce(t, void 0, M.isIterable)
		);
};
M.changes = function (e, t, r, n) {
	(arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
		new j(e, n, M.changes, !0).to.change(t, r));
};
M.changesBy = function (e, t, r, n, o) {
	if (arguments.length === 4 && typeof t == 'function') {
		let s = n;
		((n = r), (o = s));
	} else arguments.length === 3 && ((n = r), (r = null));
	new j(e, o, M.changesBy, !0).to.change(t, r).by(n);
};
M.doesNotChange = function (e, t, r, n) {
	return (
		arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
		new j(e, n, M.doesNotChange, !0).to.not.change(t, r)
	);
};
M.changesButNotBy = function (e, t, r, n, o) {
	if (arguments.length === 4 && typeof t == 'function') {
		let s = n;
		((n = r), (o = s));
	} else arguments.length === 3 && ((n = r), (r = null));
	new j(e, o, M.changesButNotBy, !0).to.change(t, r).but.not.by(n);
};
M.increases = function (e, t, r, n) {
	return (
		arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
		new j(e, n, M.increases, !0).to.increase(t, r)
	);
};
M.increasesBy = function (e, t, r, n, o) {
	if (arguments.length === 4 && typeof t == 'function') {
		let s = n;
		((n = r), (o = s));
	} else arguments.length === 3 && ((n = r), (r = null));
	new j(e, o, M.increasesBy, !0).to.increase(t, r).by(n);
};
M.doesNotIncrease = function (e, t, r, n) {
	return (
		arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
		new j(e, n, M.doesNotIncrease, !0).to.not.increase(t, r)
	);
};
M.increasesButNotBy = function (e, t, r, n, o) {
	if (arguments.length === 4 && typeof t == 'function') {
		let s = n;
		((n = r), (o = s));
	} else arguments.length === 3 && ((n = r), (r = null));
	new j(e, o, M.increasesButNotBy, !0).to.increase(t, r).but.not.by(n);
};
M.decreases = function (e, t, r, n) {
	return (
		arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
		new j(e, n, M.decreases, !0).to.decrease(t, r)
	);
};
M.decreasesBy = function (e, t, r, n, o) {
	if (arguments.length === 4 && typeof t == 'function') {
		let s = n;
		((n = r), (o = s));
	} else arguments.length === 3 && ((n = r), (r = null));
	new j(e, o, M.decreasesBy, !0).to.decrease(t, r).by(n);
};
M.doesNotDecrease = function (e, t, r, n) {
	return (
		arguments.length === 3 && typeof t == 'function' && ((n = r), (r = null)),
		new j(e, n, M.doesNotDecrease, !0).to.not.decrease(t, r)
	);
};
M.doesNotDecreaseBy = function (e, t, r, n, o) {
	if (arguments.length === 4 && typeof t == 'function') {
		let s = n;
		((n = r), (o = s));
	} else arguments.length === 3 && ((n = r), (r = null));
	return new j(e, o, M.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(n);
};
M.decreasesButNotBy = function (e, t, r, n, o) {
	if (arguments.length === 4 && typeof t == 'function') {
		let s = n;
		((n = r), (o = s));
	} else arguments.length === 3 && ((n = r), (r = null));
	new j(e, o, M.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(n);
};
M.ifError = function (e) {
	if (e) throw e;
};
M.isExtensible = function (e, t) {
	new j(e, t, M.isExtensible, !0).to.be.extensible;
};
M.isNotExtensible = function (e, t) {
	new j(e, t, M.isNotExtensible, !0).to.not.be.extensible;
};
M.isSealed = function (e, t) {
	new j(e, t, M.isSealed, !0).to.be.sealed;
};
M.isNotSealed = function (e, t) {
	new j(e, t, M.isNotSealed, !0).to.not.be.sealed;
};
M.isFrozen = function (e, t) {
	new j(e, t, M.isFrozen, !0).to.be.frozen;
};
M.isNotFrozen = function (e, t) {
	new j(e, t, M.isNotFrozen, !0).to.not.be.frozen;
};
M.isEmpty = function (e, t) {
	new j(e, t, M.isEmpty, !0).to.be.empty;
};
M.isNotEmpty = function (e, t) {
	new j(e, t, M.isNotEmpty, !0).to.not.be.empty;
};
M.containsSubset = function (e, t, r) {
	new j(e, r).to.containSubset(t);
};
M.doesNotContainSubset = function (e, t, r) {
	new j(e, r).to.not.containSubset(t);
};
var aU = [
	['isOk', 'ok'],
	['isNotOk', 'notOk'],
	['throws', 'throw'],
	['throws', 'Throw'],
	['isExtensible', 'extensible'],
	['isNotExtensible', 'notExtensible'],
	['isSealed', 'sealed'],
	['isNotSealed', 'notSealed'],
	['isFrozen', 'frozen'],
	['isNotFrozen', 'notFrozen'],
	['isEmpty', 'empty'],
	['isNotEmpty', 'notEmpty'],
	['isCallable', 'isFunction'],
	['isNotCallable', 'isNotFunction'],
	['containsSubset', 'containSubset']
];
for (const [e, t] of aU) M[t] = M[e];
var nv = [];
function oo(e) {
	const t = {
		use: oo,
		AssertionError: Ce,
		util: Rr,
		config: Nt,
		expect: _n,
		assert: M,
		Assertion: j,
		...j0
	};
	return (~nv.indexOf(e) || (e(t, Rr), nv.push(e)), t);
}
i(oo, 'use');
G(oo, 'use');
var D0 = {};
Lt(D0, {
	toAppearAfter: () => mP,
	toAppearBefore: () => Jl,
	toBeChecked: () => fy,
	toBeDisabled: () => iy,
	toBeEmpty: () => Vh,
	toBeEmptyDOMElement: () => Hh,
	toBeEnabled: () => sy,
	toBeInTheDOM: () => jl,
	toBeInTheDocument: () => Uh,
	toBeInvalid: () => uy,
	toBePartiallyChecked: () => hy,
	toBePartiallyPressed: () => Ey,
	toBePressed: () => vy,
	toBeRequired: () => ay,
	toBeValid: () => cy,
	toBeVisible: () => ey,
	toContainElement: () => Dl,
	toContainHTML: () => Gh,
	toHaveAccessibleDescription: () => kl,
	toHaveAccessibleErrorMessage: () => Wh,
	toHaveAccessibleName: () => Fl,
	toHaveAttribute: () => Kh,
	toHaveClass: () => Yh,
	toHaveDescription: () => yy,
	toHaveDisplayValue: () => py,
	toHaveErrorMessage: () => gy,
	toHaveFocus: () => Xh,
	toHaveFormValues: () => Qh,
	toHaveRole: () => Ll,
	toHaveSelection: () => by,
	toHaveStyle: () => Bl,
	toHaveTextContent: () => zh,
	toHaveValue: () => dy
});
var ov = et(LE(), 1),
	k0 = class extends Error {
		reason;
		filename;
		line;
		column;
		source;
		constructor(t, r, n, o, s) {
			(super(`${t}:${n}:${o}: ${r}`),
				(this.reason = r),
				(this.filename = t),
				(this.line = n),
				(this.column = o),
				(this.source = s));
		}
	};
i(k0, 't');
var lU = k0,
	L0 = class {
		start;
		end;
		source;
		constructor(t, r, n) {
			((this.start = t), (this.end = r), (this.source = n));
		}
	};
i(L0, 'e');
var uU = L0,
	st;
(function (e) {
	((e.stylesheet = 'stylesheet'),
		(e.rule = 'rule'),
		(e.declaration = 'declaration'),
		(e.comment = 'comment'),
		(e.container = 'container'),
		(e.charset = 'charset'),
		(e.document = 'document'),
		(e.customMedia = 'custom-media'),
		(e.fontFace = 'font-face'),
		(e.host = 'host'),
		(e.import = 'import'),
		(e.keyframes = 'keyframes'),
		(e.keyframe = 'keyframe'),
		(e.layer = 'layer'),
		(e.media = 'media'),
		(e.namespace = 'namespace'),
		(e.page = 'page'),
		(e.startingStyle = 'starting-style'),
		(e.supports = 'supports'));
})(st || (st = {}));
var iv = i((e, t, r) => {
		let n = r,
			o = 1e4;
		do {
			const s = t.map((c) => e.indexOf(c, n));
			s.push(e.indexOf('\\', n));
			const a = s.filter((c) => c !== -1);
			if (a.length === 0) return -1;
			const u = Math.min(...a);
			if (e[u] !== '\\') return u;
			((n = u + 2), o--);
		} while (o > 0);
		throw new Error('Too many escaping');
	}, 's'),
	dp = i((e, t, r) => {
		let n = r,
			o = 1e4;
		do {
			const s = t.map((c) => e.indexOf(c, n));
			(s.push(e.indexOf('(', n)),
				s.push(e.indexOf('"', n)),
				s.push(e.indexOf("'", n)),
				s.push(e.indexOf('\\', n)));
			const a = s.filter((c) => c !== -1);
			if (a.length === 0) return -1;
			const u = Math.min(...a);
			switch (e[u]) {
				case '\\':
					n = u + 2;
					break;
				case '(':
					{
						const c = dp(e, [')'], u + 1);
						if (c === -1) return -1;
						n = c + 1;
					}
					break;
				case '"':
					{
						const c = iv(e, ['"'], u + 1);
						if (c === -1) return -1;
						n = c + 1;
					}
					break;
				case "'":
					{
						const c = iv(e, ["'"], u + 1);
						if (c === -1) return -1;
						n = c + 1;
					}
					break;
				default:
					return u;
			}
			o--;
		} while (o > 0);
		throw new Error('Too many escaping');
	}, 'n'),
	bd = /\/\*[^]*?(?:\*\/|$)/g;
function Bt(e) {
	return e ? e.trim() : '';
}
i(Bt, 'o');
function ql(e, t) {
	const r = e && typeof e.type == 'string',
		n = r ? e : t;
	for (const o in e) {
		const s = e[o];
		Array.isArray(s)
			? s.forEach((a) => {
					ql(a, n);
				})
			: s && typeof s == 'object' && ql(s, n);
	}
	return (
		r &&
			Object.defineProperty(e, 'parent', {
				configurable: !0,
				writable: !0,
				enumerable: !1,
				value: t || null
			}),
		e
	);
}
i(ql, 'c');
var cU = i((e, t) => {
		t = t || {};
		let r = 1,
			n = 1;
		function o() {
			const _ = { line: r, column: n };
			return (S) => ((S.position = new uU(_, { line: r, column: n }, t?.source || '')), f(), S);
		}
		i(o, 'u');
		const s = [];
		function a(_) {
			const S = new lU(t?.source || '', _, r, n, e);
			if (!t?.silent) throw S;
			s.push(S);
		}
		i(a, 'l');
		function u() {
			const _ = /^{\s*/.exec(e);
			return !!_ && (p(_), !0);
		}
		i(u, 'f');
		function c() {
			const _ = /^}/.exec(e);
			return !!_ && (p(_), !0);
		}
		i(c, 'd');
		function d() {
			let _;
			const S = [];
			for (f(), m(S); e.length && e.charAt(0) !== '}' && ((_ = C() || R()), _); ) (S.push(_), m(S));
			return S;
		}
		i(d, 'y');
		function p(_) {
			const S = _[0];
			return (
				(function (D) {
					const N = D.match(/\n/g);
					N && (r += N.length);
					const V = D.lastIndexOf(`
`);
					n = ~V ? D.length - V : n + D.length;
				})(S),
				(e = e.slice(S.length)),
				_
			);
		}
		i(p, 'g');
		function f() {
			const _ = /^\s*/.exec(e);
			_ && p(_);
		}
		i(f, '$');
		function m(_) {
			_ = _ || [];
			let S = y();
			for (; S; ) (_.push(S), (S = y()));
			return _;
		}
		i(m, 'x');
		function y() {
			const _ = o();
			if (e.charAt(0) !== '/' || e.charAt(1) !== '*') return;
			const S = /^\/\*[^]*?\*\//.exec(e);
			return S
				? (p(S), _({ type: st.comment, comment: S[0].slice(2, -2) }))
				: a('End of comment missing');
		}
		i(y, 'V');
		function g() {
			const _ = /^([^{]+)/.exec(e);
			if (_)
				return (
					p(_),
					((S, D) => {
						const N = [];
						let V = 0;
						for (; V < S.length; ) {
							const H = dp(S, D, V);
							if (H === -1) return (N.push(S.substring(V)), N);
							(N.push(S.substring(V, H)), (V = H + 1));
						}
						return N;
					})(Bt(_[0]).replace(bd, ''), [',']).map((S) => Bt(S))
				);
		}
		i(g, 'k');
		function E() {
			const _ = o(),
				S = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/.exec(e);
			if (!S) return;
			p(S);
			const D = Bt(S[0]),
				N = /^:\s*/.exec(e);
			if (!N) return a("property missing ':'");
			p(N);
			let V = '';
			const H = dp(e, [';', '}']);
			H !== -1 && ((V = e.substring(0, H)), p([V]), (V = Bt(V).replace(bd, '')));
			const A = _({ type: st.declaration, property: D.replace(bd, ''), value: V }),
				L = /^[;\s]*/.exec(e);
			return (L && p(L), A);
		}
		i(E, 'v');
		function T() {
			const _ = [];
			if (!u()) return a("missing '{'");
			m(_);
			let S = E();
			for (; S; ) (_.push(S), m(_), (S = E()));
			return c() ? _ : a("missing '}'");
		}
		i(T, 'w');
		function b() {
			const _ = [],
				S = o();
			let D = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e);
			for (; D; ) {
				const N = p(D);
				_.push(N[1]);
				const V = /^,\s*/.exec(e);
				(V && p(V), (D = /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/.exec(e)));
			}
			if (_.length) return S({ type: st.keyframe, values: _, declarations: T() || [] });
		}
		i(b, 'b');
		const w = q('import'),
			P = q('charset'),
			I = q('namespace');
		function q(_) {
			const S = new RegExp(
				'^@' + _ + `\\s*((?::?[^;'"]|"(?:\\\\"|[^"])*?"|'(?:\\\\'|[^'])*?')+)(?:;|$)`
			);
			return () => {
				const D = o(),
					N = S.exec(e);
				if (!N) return;
				const V = p(N),
					H = { type: _ };
				return ((H[_] = V[1].trim()), D(H));
			};
		}
		i(q, 'M');
		function C() {
			if (e[0] === '@')
				return (
					(function () {
						const _ = o(),
							S = /^@([-\w]+)?keyframes\s*/.exec(e);
						if (!S) return;
						const D = p(S)[1],
							N = /^([-\w]+)\s*/.exec(e);
						if (!N) return a('@keyframes missing name');
						const V = p(N)[1];
						if (!u()) return a("@keyframes missing '{'");
						let H = m(),
							A = b();
						for (; A; ) (H.push(A), (H = H.concat(m())), (A = b()));
						return c()
							? _({ type: st.keyframes, name: V, vendor: D, keyframes: H })
							: a("@keyframes missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@media *([^{]+)/.exec(e);
						if (!S) return;
						const D = Bt(p(S)[1]);
						if (!u()) return a("@media missing '{'");
						const N = m().concat(d());
						return c() ? _({ type: st.media, media: D, rules: N }) : a("@media missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@custom-media\s+(--\S+)\s+([^{;\s][^{;]*);/.exec(e);
						if (!S) return;
						const D = p(S);
						return _({ type: st.customMedia, name: Bt(D[1]), media: Bt(D[2]) });
					})() ||
					(function () {
						const _ = o(),
							S = /^@supports *([^{]+)/.exec(e);
						if (!S) return;
						const D = Bt(p(S)[1]);
						if (!u()) return a("@supports missing '{'");
						const N = m().concat(d());
						return c()
							? _({ type: st.supports, supports: D, rules: N })
							: a("@supports missing '}'");
					})() ||
					w() ||
					P() ||
					I() ||
					(function () {
						const _ = o(),
							S = /^@([-\w]+)?document *([^{]+)/.exec(e);
						if (!S) return;
						const D = p(S),
							N = Bt(D[1]),
							V = Bt(D[2]);
						if (!u()) return a("@document missing '{'");
						const H = m().concat(d());
						return c()
							? _({ type: st.document, document: V, vendor: N, rules: H })
							: a("@document missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@page */.exec(e);
						if (!S) return;
						p(S);
						const D = g() || [];
						if (!u()) return a("@page missing '{'");
						let N = m(),
							V = E();
						for (; V; ) (N.push(V), (N = N.concat(m())), (V = E()));
						return c()
							? _({ type: st.page, selectors: D, declarations: N })
							: a("@page missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@host\s*/.exec(e);
						if (!S) return;
						if ((p(S), !u())) return a("@host missing '{'");
						const D = m().concat(d());
						return c() ? _({ type: st.host, rules: D }) : a("@host missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@font-face\s*/.exec(e);
						if (!S) return;
						if ((p(S), !u())) return a("@font-face missing '{'");
						let D = m(),
							N = E();
						for (; N; ) (D.push(N), (D = D.concat(m())), (N = E()));
						return c() ? _({ type: st.fontFace, declarations: D }) : a("@font-face missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@container *([^{]+)/.exec(e);
						if (!S) return;
						const D = Bt(p(S)[1]);
						if (!u()) return a("@container missing '{'");
						const N = m().concat(d());
						return c()
							? _({ type: st.container, container: D, rules: N })
							: a("@container missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@starting-style\s*/.exec(e);
						if (!S) return;
						if ((p(S), !u())) return a("@starting-style missing '{'");
						const D = m().concat(d());
						return c() ? _({ type: st.startingStyle, rules: D }) : a("@starting-style missing '}'");
					})() ||
					(function () {
						const _ = o(),
							S = /^@layer *([^{;@]+)/.exec(e);
						if (!S) return;
						const D = Bt(p(S)[1]);
						if (!u()) {
							const V = /^[;\s]*/.exec(e);
							return (V && p(V), _({ type: st.layer, layer: D }));
						}
						const N = m().concat(d());
						return c() ? _({ type: st.layer, layer: D, rules: N }) : a("@layer missing '}'");
					})()
				);
		}
		i(C, 'A');
		function R() {
			const _ = o(),
				S = g();
			return S
				? (m(), _({ type: st.rule, selectors: S, declarations: T() || [] }))
				: a('selector missing');
		}
		return (
			i(R, 'S'),
			ql(
				(function () {
					const _ = d();
					return {
						type: st.stylesheet,
						stylesheet: { source: t?.source, rules: _, parsingErrors: s }
					};
				})()
			)
		);
	}, 'm'),
	dU = Object.prototype.toString;
function pp(e) {
	return typeof e == 'function' || dU.call(e) === '[object Function]';
}
i(pp, 'isCallable');
function F0(e) {
	var t = Number(e);
	return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
i(F0, 'toInteger');
var pU = Math.pow(2, 53) - 1;
function B0(e) {
	var t = F0(e);
	return Math.min(Math.max(t, 0), pU);
}
i(B0, 'toLength');
function tr(e, t) {
	var r = Array,
		n = Object(e);
	if (e == null)
		throw new TypeError('Array.from requires an array-like object - not null or undefined');
	if (typeof t < 'u' && !pp(t))
		throw new TypeError('Array.from: when provided, the second argument must be a function');
	for (var o = B0(n.length), s = pp(r) ? Object(new r(o)) : new Array(o), a = 0, u; a < o; )
		((u = n[a]), t ? (s[a] = t(u, a)) : (s[a] = u), (a += 1));
	return ((s.length = o), s);
}
i(tr, 'arrayFrom');
function ci(e) {
	'@babel/helpers - typeof';
	return (
		(ci =
			typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
				? function (t) {
						return typeof t;
					}
				: function (t) {
						return t &&
							typeof Symbol == 'function' &&
							t.constructor === Symbol &&
							t !== Symbol.prototype
							? 'symbol'
							: typeof t;
					}),
		ci(e)
	);
}
i(ci, '_typeof');
function J0(e, t) {
	if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
i(J0, '_classCallCheck');
function fp(e, t) {
	for (var r = 0; r < t.length; r++) {
		var n = t[r];
		((n.enumerable = n.enumerable || !1),
			(n.configurable = !0),
			'value' in n && (n.writable = !0),
			Object.defineProperty(e, Mh(n.key), n));
	}
}
i(fp, '_defineProperties');
function $0(e, t, r) {
	return (
		t && fp(e.prototype, t),
		r && fp(e, r),
		Object.defineProperty(e, 'prototype', { writable: !1 }),
		e
	);
}
i($0, '_createClass');
function U0(e, t, r) {
	return (
		(t = Mh(t)),
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(U0, '_defineProperty');
function Mh(e) {
	var t = V0(e, 'string');
	return ci(t) === 'symbol' ? t : String(t);
}
i(Mh, '_toPropertyKey');
function V0(e, t) {
	if (ci(e) !== 'object' || e === null) return e;
	var r = e[Symbol.toPrimitive];
	if (r !== void 0) {
		var n = r.call(e, t || 'default');
		if (ci(n) !== 'object') return n;
		throw new TypeError('@@toPrimitive must return a primitive value.');
	}
	return (t === 'string' ? String : Number)(e);
}
i(V0, '_toPrimitive');
var fU = (function () {
		function e() {
			var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
			(J0(this, e), U0(this, 'items', void 0), (this.items = t));
		}
		return (
			i(e, 'SetLike'),
			$0(e, [
				{
					key: 'add',
					value: i(function (r) {
						return (this.has(r) === !1 && this.items.push(r), this);
					}, 'add')
				},
				{
					key: 'clear',
					value: i(function () {
						this.items = [];
					}, 'clear')
				},
				{
					key: 'delete',
					value: i(function (r) {
						var n = this.items.length;
						return (
							(this.items = this.items.filter(function (o) {
								return o !== r;
							})),
							n !== this.items.length
						);
					}, '_delete')
				},
				{
					key: 'forEach',
					value: i(function (r) {
						var n = this;
						this.items.forEach(function (o) {
							r(o, o, n);
						});
					}, 'forEach')
				},
				{
					key: 'has',
					value: i(function (r) {
						return this.items.indexOf(r) !== -1;
					}, 'has')
				},
				{
					key: 'size',
					get: i(function () {
						return this.items.length;
					}, 'get')
				}
			]),
			e
		);
	})(),
	mU = typeof Set > 'u' ? Set : fU;
function yt(e) {
	var t;
	return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
i(yt, 'getLocalName');
var hU = {
		article: 'article',
		aside: 'complementary',
		button: 'button',
		datalist: 'listbox',
		dd: 'definition',
		details: 'group',
		dialog: 'dialog',
		dt: 'term',
		fieldset: 'group',
		figure: 'figure',
		form: 'form',
		footer: 'contentinfo',
		h1: 'heading',
		h2: 'heading',
		h3: 'heading',
		h4: 'heading',
		h5: 'heading',
		h6: 'heading',
		header: 'banner',
		hr: 'separator',
		html: 'document',
		legend: 'legend',
		li: 'listitem',
		math: 'math',
		main: 'main',
		menu: 'list',
		nav: 'navigation',
		ol: 'list',
		optgroup: 'group',
		option: 'option',
		output: 'status',
		progress: 'progressbar',
		section: 'region',
		summary: 'button',
		table: 'table',
		tbody: 'rowgroup',
		textarea: 'textbox',
		tfoot: 'rowgroup',
		td: 'cell',
		th: 'columnheader',
		thead: 'rowgroup',
		tr: 'row',
		ul: 'list'
	},
	yU = {
		caption: new Set(['aria-label', 'aria-labelledby']),
		code: new Set(['aria-label', 'aria-labelledby']),
		deletion: new Set(['aria-label', 'aria-labelledby']),
		emphasis: new Set(['aria-label', 'aria-labelledby']),
		generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
		insertion: new Set(['aria-label', 'aria-labelledby']),
		none: new Set(['aria-label', 'aria-labelledby']),
		paragraph: new Set(['aria-label', 'aria-labelledby']),
		presentation: new Set(['aria-label', 'aria-labelledby']),
		strong: new Set(['aria-label', 'aria-labelledby']),
		subscript: new Set(['aria-label', 'aria-labelledby']),
		superscript: new Set(['aria-label', 'aria-labelledby'])
	};
function H0(e, t) {
	return [
		'aria-atomic',
		'aria-busy',
		'aria-controls',
		'aria-current',
		'aria-description',
		'aria-describedby',
		'aria-details',
		'aria-dropeffect',
		'aria-flowto',
		'aria-grabbed',
		'aria-hidden',
		'aria-keyshortcuts',
		'aria-label',
		'aria-labelledby',
		'aria-live',
		'aria-owns',
		'aria-relevant',
		'aria-roledescription'
	].some(function (r) {
		var n;
		return e.hasAttribute(r) && !((n = yU[t]) !== null && n !== void 0 && n.has(r));
	});
}
i(H0, 'hasGlobalAriaAttributes');
function qh(e, t) {
	return H0(e, t);
}
i(qh, 'ignorePresentationalRole');
function G0(e) {
	var t = W0(e);
	if (t === null || mp.indexOf(t) !== -1) {
		var r = z0(e);
		if (mp.indexOf(t || '') === -1 || qh(e, r || '')) return r;
	}
	return t;
}
i(G0, 'getRole');
function z0(e) {
	var t = hU[yt(e)];
	if (t !== void 0) return t;
	switch (yt(e)) {
		case 'a':
		case 'area':
		case 'link':
			if (e.hasAttribute('href')) return 'link';
			break;
		case 'img':
			return e.getAttribute('alt') === '' && !qh(e, 'img') ? 'presentation' : 'img';
		case 'input': {
			var r = e,
				n = r.type;
			switch (n) {
				case 'button':
				case 'image':
				case 'reset':
				case 'submit':
					return 'button';
				case 'checkbox':
				case 'radio':
					return n;
				case 'range':
					return 'slider';
				case 'email':
				case 'tel':
				case 'text':
				case 'url':
					return e.hasAttribute('list') ? 'combobox' : 'textbox';
				case 'search':
					return e.hasAttribute('list') ? 'combobox' : 'searchbox';
				case 'number':
					return 'spinbutton';
				default:
					return null;
			}
		}
		case 'select':
			return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
	}
	return null;
}
i(z0, 'getImplicitRole');
function W0(e) {
	var t = e.getAttribute('role');
	if (t !== null) {
		var r = t.trim().split(' ')[0];
		if (r.length > 0) return r;
	}
	return null;
}
i(W0, 'getExplicitRole');
var mp = ['presentation', 'none'];
function Fe(e) {
	return e !== null && e.nodeType === e.ELEMENT_NODE;
}
i(Fe, 'isElement');
function jh(e) {
	return Fe(e) && yt(e) === 'caption';
}
i(jh, 'isHTMLTableCaptionElement');
function Is(e) {
	return Fe(e) && yt(e) === 'input';
}
i(Is, 'isHTMLInputElement');
function K0(e) {
	return Fe(e) && yt(e) === 'optgroup';
}
i(K0, 'isHTMLOptGroupElement');
function Y0(e) {
	return Fe(e) && yt(e) === 'select';
}
i(Y0, 'isHTMLSelectElement');
function X0(e) {
	return Fe(e) && yt(e) === 'table';
}
i(X0, 'isHTMLTableElement');
function Q0(e) {
	return Fe(e) && yt(e) === 'textarea';
}
i(Q0, 'isHTMLTextAreaElement');
function Z0(e) {
	var t = e.ownerDocument === null ? e : e.ownerDocument,
		r = t.defaultView;
	if (r === null) throw new TypeError('no window available');
	return r;
}
i(Z0, 'safeWindow');
function eR(e) {
	return Fe(e) && yt(e) === 'fieldset';
}
i(eR, 'isHTMLFieldSetElement');
function tR(e) {
	return Fe(e) && yt(e) === 'legend';
}
i(tR, 'isHTMLLegendElement');
function rR(e) {
	return Fe(e) && yt(e) === 'slot';
}
i(rR, 'isHTMLSlotElement');
function nR(e) {
	return Fe(e) && e.ownerSVGElement !== void 0;
}
i(nR, 'isSVGElement');
function oR(e) {
	return Fe(e) && yt(e) === 'svg';
}
i(oR, 'isSVGSVGElement');
function iR(e) {
	return nR(e) && yt(e) === 'title';
}
i(iR, 'isSVGTitleElement');
function Zs(e, t) {
	if (Fe(e) && e.hasAttribute(t)) {
		var r = e.getAttribute(t).split(' '),
			n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
		return r
			.map(function (o) {
				return n.getElementById(o);
			})
			.filter(function (o) {
				return o !== null;
			});
	}
	return [];
}
i(Zs, 'queryIdRefs');
function Pr(e, t) {
	return Fe(e) ? t.indexOf(G0(e)) !== -1 : !1;
}
i(Pr, 'hasAnyConcreteRoles');
function sR(e) {
	return e.trim().replace(/\s\s+/g, ' ');
}
i(sR, 'asFlatString');
function aR(e, t) {
	if (!Fe(e)) return !1;
	if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
	var r = t(e);
	return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
i(aR, 'isHidden');
function lR(e) {
	return Pr(e, ['button', 'combobox', 'listbox', 'textbox']) || Dh(e, 'range');
}
i(lR, 'isControl');
function Dh(e, t) {
	if (!Fe(e)) return !1;
	switch (t) {
		case 'range':
			return Pr(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
		default:
			throw new TypeError(
				"No knowledge about abstract role '".concat(t, "'. This is likely a bug :(")
			);
	}
}
i(Dh, 'hasAbstractRole');
function hp(e, t) {
	var r = tr(e.querySelectorAll(t));
	return (
		Zs(e, 'aria-owns').forEach(function (n) {
			r.push.apply(r, tr(n.querySelectorAll(t)));
		}),
		r
	);
}
i(hp, 'querySelectorAllSubtree');
function uR(e) {
	return Y0(e) ? e.selectedOptions || hp(e, '[selected]') : hp(e, '[aria-selected="true"]');
}
i(uR, 'querySelectedOptions');
function cR(e) {
	return Pr(e, mp);
}
i(cR, 'isMarkedPresentational');
function dR(e) {
	return jh(e);
}
i(dR, 'isNativeHostLanguageTextAlternativeElement');
function pR(e) {
	return Pr(e, [
		'button',
		'cell',
		'checkbox',
		'columnheader',
		'gridcell',
		'heading',
		'label',
		'legend',
		'link',
		'menuitem',
		'menuitemcheckbox',
		'menuitemradio',
		'option',
		'radio',
		'row',
		'rowheader',
		'switch',
		'tab',
		'tooltip',
		'treeitem'
	]);
}
i(pR, 'allowsNameFromContent');
function fR(e) {
	return !1;
}
i(fR, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function mR(e) {
	return Is(e) || Q0(e) ? e.value : e.textContent || '';
}
i(mR, 'getValueOfTextbox');
function yp(e) {
	var t = e.getPropertyValue('content');
	return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
i(yp, 'getTextualContent');
function kh(e) {
	var t = yt(e);
	return (
		t === 'button' ||
		(t === 'input' && e.getAttribute('type') !== 'hidden') ||
		t === 'meter' ||
		t === 'output' ||
		t === 'progress' ||
		t === 'select' ||
		t === 'textarea'
	);
}
i(kh, 'isLabelableElement');
function Lh(e) {
	if (kh(e)) return e;
	var t = null;
	return (
		e.childNodes.forEach(function (r) {
			if (t === null && Fe(r)) {
				var n = Lh(r);
				n !== null && (t = n);
			}
		}),
		t
	);
}
i(Lh, 'findLabelableElement');
function hR(e) {
	if (e.control !== void 0) return e.control;
	var t = e.getAttribute('for');
	return t !== null ? e.ownerDocument.getElementById(t) : Lh(e);
}
i(hR, 'getControlOfLabel');
function yR(e) {
	var t = e.labels;
	if (t === null) return t;
	if (t !== void 0) return tr(t);
	if (!kh(e)) return null;
	var r = e.ownerDocument;
	return tr(r.querySelectorAll('label')).filter(function (n) {
		return hR(n) === e;
	});
}
i(yR, 'getLabels');
function gR(e) {
	var t = e.assignedNodes();
	return t.length === 0 ? tr(e.childNodes) : t;
}
i(gR, 'getSlotContents');
function Fh(e) {
	var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
		r = new mU(),
		n = Z0(e),
		o = t.compute,
		s = o === void 0 ? 'name' : o,
		a = t.computedStyleSupportsPseudoElements,
		u = a === void 0 ? t.getComputedStyle !== void 0 : a,
		c = t.getComputedStyle,
		d = c === void 0 ? n.getComputedStyle.bind(n) : c,
		p = t.hidden,
		f = p === void 0 ? !1 : p;
	function m(b, w) {
		var P = '';
		if (Fe(b) && u) {
			var I = d(b, '::before'),
				q = yp(I);
			P = ''.concat(q, ' ').concat(P);
		}
		var C = rR(b) ? gR(b) : tr(b.childNodes).concat(Zs(b, 'aria-owns'));
		if (
			(C.forEach(function (S) {
				var D = T(S, { isEmbeddedInLabel: w.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
					N = Fe(S) ? d(S).getPropertyValue('display') : 'inline',
					V = N !== 'inline' ? ' ' : '';
				P += ''.concat(V).concat(D).concat(V);
			}),
			Fe(b) && u)
		) {
			var R = d(b, '::after'),
				_ = yp(R);
			P = ''.concat(P, ' ').concat(_);
		}
		return P.trim();
	}
	i(m, 'computeMiscTextAlternative');
	function y(b, w) {
		var P = b.getAttributeNode(w);
		return P !== null && !r.has(P) && P.value.trim() !== '' ? (r.add(P), P.value) : null;
	}
	i(y, 'useAttribute');
	function g(b) {
		return Fe(b) ? y(b, 'title') : null;
	}
	i(g, 'computeTooltipAttributeValue');
	function E(b) {
		if (!Fe(b)) return null;
		if (eR(b)) {
			r.add(b);
			for (var w = tr(b.childNodes), P = 0; P < w.length; P += 1) {
				var I = w[P];
				if (tR(I)) return T(I, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
			}
		} else if (X0(b)) {
			r.add(b);
			for (var q = tr(b.childNodes), C = 0; C < q.length; C += 1) {
				var R = q[C];
				if (jh(R)) return T(R, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
			}
		} else if (oR(b)) {
			r.add(b);
			for (var _ = tr(b.childNodes), S = 0; S < _.length; S += 1) {
				var D = _[S];
				if (iR(D)) return D.textContent;
			}
			return null;
		} else if (yt(b) === 'img' || yt(b) === 'area') {
			var N = y(b, 'alt');
			if (N !== null) return N;
		} else if (K0(b)) {
			var V = y(b, 'label');
			if (V !== null) return V;
		}
		if (Is(b) && (b.type === 'button' || b.type === 'submit' || b.type === 'reset')) {
			var H = y(b, 'value');
			if (H !== null) return H;
			if (b.type === 'submit') return 'Submit';
			if (b.type === 'reset') return 'Reset';
		}
		var A = yR(b);
		if (A !== null && A.length !== 0)
			return (
				r.add(b),
				tr(A)
					.map(function (K) {
						return T(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
					})
					.filter(function (K) {
						return K.length > 0;
					})
					.join(' ')
			);
		if (Is(b) && b.type === 'image') {
			var L = y(b, 'alt');
			if (L !== null) return L;
			var B = y(b, 'title');
			return B !== null ? B : 'Submit Query';
		}
		if (Pr(b, ['button'])) {
			var k = m(b, { isEmbeddedInLabel: !1 });
			if (k !== '') return k;
		}
		return null;
	}
	i(E, 'computeElementTextAlternative');
	function T(b, w) {
		if (r.has(b)) return '';
		if (!f && aR(b, d) && !w.isReferenced) return (r.add(b), '');
		var P = Fe(b) ? b.getAttributeNode('aria-labelledby') : null,
			I = P !== null && !r.has(P) ? Zs(b, 'aria-labelledby') : [];
		if (s === 'name' && !w.isReferenced && I.length > 0)
			return (
				r.add(P),
				I.map(function (N) {
					return T(N, { isEmbeddedInLabel: w.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
				}).join(' ')
			);
		var q = w.recursion && lR(b) && s === 'name';
		if (!q) {
			var C = ((Fe(b) && b.getAttribute('aria-label')) || '').trim();
			if (C !== '' && s === 'name') return (r.add(b), C);
			if (!cR(b)) {
				var R = E(b);
				if (R !== null) return (r.add(b), R);
			}
		}
		if (Pr(b, ['menu'])) return (r.add(b), '');
		if (q || w.isEmbeddedInLabel || w.isReferenced) {
			if (Pr(b, ['combobox', 'listbox'])) {
				r.add(b);
				var _ = uR(b);
				return _.length === 0
					? Is(b)
						? b.value
						: ''
					: tr(_)
							.map(function (N) {
								return T(N, {
									isEmbeddedInLabel: w.isEmbeddedInLabel,
									isReferenced: !1,
									recursion: !0
								});
							})
							.join(' ');
			}
			if (Dh(b, 'range'))
				return (
					r.add(b),
					b.hasAttribute('aria-valuetext')
						? b.getAttribute('aria-valuetext')
						: b.hasAttribute('aria-valuenow')
							? b.getAttribute('aria-valuenow')
							: b.getAttribute('value') || ''
				);
			if (Pr(b, ['textbox'])) return (r.add(b), mR(b));
		}
		if (pR(b) || (Fe(b) && w.isReferenced) || dR(b) || fR()) {
			var S = m(b, { isEmbeddedInLabel: w.isEmbeddedInLabel });
			if (S !== '') return (r.add(b), S);
		}
		if (b.nodeType === b.TEXT_NODE) return (r.add(b), b.textContent || '');
		if (w.recursion) return (r.add(b), m(b, { isEmbeddedInLabel: w.isEmbeddedInLabel }));
		var D = g(b);
		return D !== null ? (r.add(b), D) : (r.add(b), '');
	}
	return (
		i(T, 'computeTextAlternative'),
		sR(T(e, { isEmbeddedInLabel: !1, isReferenced: s === 'description', recursion: !1 }))
	);
}
i(Fh, 'computeTextAlternative');
function di(e) {
	'@babel/helpers - typeof';
	return (
		(di =
			typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
				? function (t) {
						return typeof t;
					}
				: function (t) {
						return t &&
							typeof Symbol == 'function' &&
							t.constructor === Symbol &&
							t !== Symbol.prototype
							? 'symbol'
							: typeof t;
					}),
		di(e)
	);
}
i(di, '_typeof');
function gp(e, t) {
	var r = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		(t &&
			(n = n.filter(function (o) {
				return Object.getOwnPropertyDescriptor(e, o).enumerable;
			})),
			r.push.apply(r, n));
	}
	return r;
}
i(gp, 'ownKeys');
function bp(e) {
	for (var t = 1; t < arguments.length; t++) {
		var r = arguments[t] != null ? arguments[t] : {};
		t % 2
			? gp(Object(r), !0).forEach(function (n) {
					bR(e, n, r[n]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
				: gp(Object(r)).forEach(function (n) {
						Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
					});
	}
	return e;
}
i(bp, '_objectSpread');
function bR(e, t, r) {
	return (
		(t = vR(t)),
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(bR, '_defineProperty');
function vR(e) {
	var t = ER(e, 'string');
	return di(t) === 'symbol' ? t : String(t);
}
i(vR, '_toPropertyKey');
function ER(e, t) {
	if (di(e) !== 'object' || e === null) return e;
	var r = e[Symbol.toPrimitive];
	if (r !== void 0) {
		var n = r.call(e, t || 'default');
		if (di(n) !== 'object') return n;
		throw new TypeError('@@toPrimitive must return a primitive value.');
	}
	return (t === 'string' ? String : Number)(e);
}
i(ER, '_toPrimitive');
function TR(e) {
	var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
		r = Zs(e, 'aria-describedby')
			.map(function (s) {
				return Fh(s, bp(bp({}, t), {}, { compute: 'description' }));
			})
			.join(' ');
	if (r === '') {
		var n = e.getAttribute('aria-description');
		r = n === null ? '' : n;
	}
	if (r === '') {
		var o = e.getAttribute('title');
		r = o === null ? '' : o;
	}
	return r;
}
i(TR, 'computeAccessibleDescription');
function _R(e) {
	return Pr(e, [
		'caption',
		'code',
		'deletion',
		'emphasis',
		'generic',
		'insertion',
		'none',
		'paragraph',
		'presentation',
		'strong',
		'subscript',
		'superscript'
	]);
}
i(_R, 'prohibitsNaming');
function wR(e) {
	var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	return _R(e) ? '' : Fh(e, t);
}
i(wR, 'computeAccessibleName');
var Bh = et($f(), 1),
	gU = et(FE(), 1),
	bU = et(BE(), 1),
	SR = class extends Error {
		constructor(t, r, n, o) {
			(super(), Error.captureStackTrace && Error.captureStackTrace(this, n));
			let s = '';
			try {
				s = o.utils.printWithType('Received', r, o.utils.printReceived);
			} catch {}
			this.message = [
				o.utils.matcherHint(`${o.isNot ? '.not' : ''}.${n.name}`, 'received', ''),
				'',
				`${o.utils.RECEIVED_COLOR('received')} value must ${t}.`,
				s
			].join(`
`);
		}
	};
i(SR, 'GenericTypeError');
var RR = SR,
	PR = class extends RR {
		constructor(...t) {
			super('be an HTMLElement or an SVGElement', ...t);
		}
	};
i(PR, 'HtmlElementTypeError');
var sv = PR,
	AR = class extends RR {
		constructor(...t) {
			super('be a Node', ...t);
		}
	};
i(AR, 'NodeTypeError');
var av = AR;
function Jh(e, t, ...r) {
	if (!e || !e.ownerDocument || !e.ownerDocument.defaultView) throw new t(e, ...r);
}
i(Jh, 'checkHasWindow');
function OR(e, ...t) {
	Jh(e, av, ...t);
	const r = e.ownerDocument.defaultView;
	if (!(e instanceof r.Node)) throw new av(e, ...t);
}
i(OR, 'checkNode');
function we(e, ...t) {
	Jh(e, sv, ...t);
	const r = e.ownerDocument.defaultView;
	if (!(e instanceof r.HTMLElement) && !(e instanceof r.SVGElement)) throw new sv(e, ...t);
}
i(we, 'checkHtmlElement');
var CR = class extends Error {
	constructor(t, r, n) {
		(super(),
			Error.captureStackTrace && Error.captureStackTrace(this, r),
			(this.message = [
				t.message,
				'',
				n.utils.RECEIVED_COLOR('Failing css:'),
				n.utils.RECEIVED_COLOR(`${t.css}`)
			].join(`
`)));
	}
};
i(CR, 'InvalidCSSError');
var vU = CR;
function xR(e, ...t) {
	const r = cU(`selector { ${e} }`, { silent: !0 }).stylesheet;
	if (r.parsingErrors && r.parsingErrors.length > 0) {
		const { reason: o, line: s } = r.parsingErrors[0];
		throw new vU(
			{ css: e, message: `Syntax error parsing expected css: ${o} on line: ${s}` },
			...t
		);
	}
	return r.rules[0].declarations
		.filter((o) => o.type === 'declaration')
		.reduce((o, { property: s, value: a }) => Object.assign(o, { [s]: a }), {});
}
i(xR, 'parseCSS');
function vp(e, t) {
	return typeof t == 'string' ? t : e.utils.stringify(t);
}
i(vp, 'display');
function Ze(e, t, r, n, o, s) {
	return [
		`${t}
`,
		`${r}:
${e.utils.EXPECTED_COLOR((0, ov.default)(vp(e, n), 2))}`,
		`${o}:
${e.utils.RECEIVED_COLOR((0, ov.default)(vp(e, s), 2))}`
	].join(`
`);
}
i(Ze, 'getMessage');
function IR(e, t) {
	return t instanceof RegExp ? t.test(e) : e.includes(String(t));
}
i(IR, 'matches');
function Oa(e, t) {
	console.warn(`Warning: ${e} has been deprecated and will be removed in future updates.`, t);
}
i(Oa, 'deprecate');
function Ca(e) {
	return e.replace(/\s+/g, ' ').trim();
}
i(Ca, 'normalize');
function rn(e) {
	return e.tagName && e.tagName.toLowerCase();
}
i(rn, 'getTag');
function NR({ multiple: e, options: t }) {
	const r = [...t].filter((n) => n.selected);
	if (e) return [...r].map((n) => n.value);
	if (r.length !== 0) return r[0].value;
}
i(NR, 'getSelectValue');
function MR(e) {
	switch (e.type) {
		case 'number':
			return e.value === '' ? null : Number(e.value);
		case 'checkbox':
			return e.checked;
		default:
			return e.value;
	}
}
i(MR, 'getInputValue');
var EU = ['meter', 'progressbar', 'slider', 'spinbutton'];
function qR(e) {
	if (EU.includes(e.getAttribute('role'))) return Number(e.getAttribute('aria-valuenow'));
}
i(qR, 'getAccessibleValue');
function $h(e) {
	if (e)
		switch (e.tagName.toLowerCase()) {
			case 'input':
				return MR(e);
			case 'select':
				return NR(e);
			default:
				return e.value ?? qR(e);
		}
}
i($h, 'getSingleElementValue');
function jR(e, { wordConnector: t = ', ', lastWordConnector: r = ' and ' } = {}) {
	return [e.slice(0, -1).join(t), e[e.length - 1]].join(e.length > 1 ? r : '');
}
i(jR, 'toSentence');
function cc(e, t) {
	return Array.isArray(e) && Array.isArray(t)
		? [...new Set(e)].every((r) => new Set(t).has(r))
		: e === t;
}
i(cc, 'compareAsSet');
function jl(e, t) {
	return (
		Oa(
			'toBeInTheDOM',
			'Please use toBeInTheDocument for searching the entire document and toContainElement for searching a specific container.'
		),
		e && we(e, jl, this),
		t && we(t, jl, this),
		{
			pass: t ? t.contains(e) : !!e,
			message: i(
				() =>
					[
						this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDOM`, 'element', ''),
						'',
						'Received:',
						`  ${this.utils.printReceived(e && e.cloneNode(!1))}`
					].join(`
`),
				'message'
			)
		}
	);
}
i(jl, 'toBeInTheDOM');
function Uh(e) {
	(e !== null || !this.isNot) && we(e, Uh, this);
	const t = e === null ? !1 : e.ownerDocument === e.getRootNode({ composed: !0 }),
		r = i(
			() =>
				`expected document not to contain element, found ${this.utils.stringify(e.cloneNode(!0))} instead`,
			'errorFound'
		),
		n = i(() => 'element could not be found in the document', 'errorNotFound');
	return {
		pass: t,
		message: i(
			() =>
				[
					this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInTheDocument`, 'element', ''),
					'',
					this.utils.RECEIVED_COLOR(this.isNot ? r() : n())
				].join(`
`),
			'message'
		)
	};
}
i(Uh, 'toBeInTheDocument');
function Vh(e) {
	return (
		Oa('toBeEmpty', 'Please use instead toBeEmptyDOMElement for finding empty nodes in the DOM.'),
		we(e, Vh, this),
		{
			pass: e.innerHTML === '',
			message: i(
				() =>
					[
						this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEmpty`, 'element', ''),
						'',
						'Received:',
						`  ${this.utils.printReceived(e.innerHTML)}`
					].join(`
`),
				'message'
			)
		}
	);
}
i(Vh, 'toBeEmpty');
function Hh(e) {
	return (
		we(e, Hh, this),
		{
			pass: DR(e),
			message: i(
				() =>
					[
						this.utils.matcherHint(
							`${this.isNot ? '.not' : ''}.toBeEmptyDOMElement`,
							'element',
							''
						),
						'',
						'Received:',
						`  ${this.utils.printReceived(e.innerHTML)}`
					].join(`
`),
				'message'
			)
		}
	);
}
i(Hh, 'toBeEmptyDOMElement');
function DR(e) {
	return [...e.childNodes].filter((r) => r.nodeType !== 8).length === 0;
}
i(DR, 'isEmptyElement');
function Dl(e, t) {
	return (
		we(e, Dl, this),
		t !== null && we(t, Dl, this),
		{
			pass: e.contains(t),
			message: i(
				() =>
					[
						this.utils.matcherHint(
							`${this.isNot ? '.not' : ''}.toContainElement`,
							'element',
							'element'
						),
						'',
						this.utils
							.RECEIVED_COLOR(`${this.utils.stringify(e.cloneNode(!1))} ${this.isNot ? 'contains:' : 'does not contain:'} ${this.utils.stringify(t && t.cloneNode(!1))}
        `)
					].join(`
`),
				'message'
			)
		}
	);
}
i(Dl, 'toContainElement');
function kR(e, t) {
	const r = e.ownerDocument.createElement('div');
	return ((r.innerHTML = t), r.innerHTML);
}
i(kR, 'getNormalizedHtml');
function Gh(e, t) {
	if ((we(e, Gh, this), typeof t != 'string'))
		throw new Error(`.toContainHTML() expects a string value, got ${t}`);
	return {
		pass: e.outerHTML.includes(kR(e, t)),
		message: i(
			() =>
				[
					this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toContainHTML`, 'element', ''),
					'Expected:',
					`  ${this.utils.EXPECTED_COLOR(t)}`,
					'Received:',
					`  ${this.utils.printReceived(e.cloneNode(!0))}`
				].join(`
`),
			'message'
		)
	};
}
i(Gh, 'toContainHTML');
function zh(e, t, r = { normalizeWhitespace: !0 }) {
	OR(e, zh, this);
	const n = r.normalizeWhitespace ? Ca(e.textContent) : e.textContent.replace(/\u00a0/g, ' '),
		o = n !== '' && t === '';
	return {
		pass: !o && IR(n, t),
		message: i(() => {
			const s = this.isNot ? 'not to' : 'to';
			return Ze(
				this,
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveTextContent`, 'element', ''),
				o
					? 'Checking with empty string will always match, use .toBeEmptyDOMElement() instead'
					: `Expected element ${s} have text content`,
				t,
				'Received',
				n
			);
		}, 'message')
	};
}
i(zh, 'toHaveTextContent');
function kl(e, t) {
	we(e, kl, this);
	const r = TR(e),
		n = arguments.length === 1;
	let o = !1;
	return (
		n ? (o = r !== '') : (o = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
		{
			pass: o,
			message: i(() => {
				const s = this.isNot ? 'not to' : 'to';
				return Ze(
					this,
					this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${kl.name}`, 'element', ''),
					`Expected element ${s} have accessible description`,
					t,
					'Received',
					r
				);
			}, 'message')
		}
	);
}
i(kl, 'toHaveAccessibleDescription');
var ms = 'aria-invalid',
	TU = ['false'];
function Wh(e, t) {
	we(e, Wh, this);
	const r = this.isNot ? 'not to' : 'to',
		n = this.isNot ? '.not.toHaveAccessibleErrorMessage' : '.toHaveAccessibleErrorMessage',
		o = e.getAttribute('aria-errormessage');
	if (!!o && /\s+/.test(o))
		return {
			pass: !1,
			message: i(
				() =>
					Ze(
						this,
						this.utils.matcherHint(n, 'element'),
						"Expected element's `aria-errormessage` attribute to be empty or a single, valid ID",
						'',
						'Received',
						`aria-errormessage="${o}"`
					),
				'message'
			)
		};
	const a = e.getAttribute(ms);
	if (!e.hasAttribute(ms) || TU.includes(a))
		return {
			pass: !1,
			message: i(
				() =>
					Ze(
						this,
						this.utils.matcherHint(n, 'element'),
						'Expected element to be marked as invalid with attribute',
						`${ms}="${String(!0)}"`,
						'Received',
						e.hasAttribute('aria-invalid') ? `${ms}="${e.getAttribute(ms)}` : null
					),
				'message'
			)
		};
	const c = Ca(e.ownerDocument.getElementById(o)?.textContent ?? '');
	return {
		pass: t === void 0 ? !!c : t instanceof RegExp ? t.test(c) : this.equals(c, t),
		message: i(
			() =>
				Ze(
					this,
					this.utils.matcherHint(n, 'element'),
					`Expected element ${r} have accessible error message`,
					t ?? '',
					'Received',
					c
				),
			'message'
		)
	};
}
i(Wh, 'toHaveAccessibleErrorMessage');
var _U = BR(Bh.elementRoles);
function Ll(e, t) {
	we(e, Ll, this);
	const r = LR(e);
	return {
		pass: r.some((o) => o === t),
		message: i(() => {
			const o = this.isNot ? 'not to' : 'to';
			return Ze(
				this,
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${Ll.name}`, 'element', ''),
				`Expected element ${o} have role`,
				t,
				'Received',
				r.join(', ')
			);
		}, 'message')
	};
}
i(Ll, 'toHaveRole');
function LR(e) {
	return e.hasAttribute('role') ? e.getAttribute('role').split(' ').filter(Boolean) : FR(e);
}
i(LR, 'getExplicitOrImplicitRoles');
function FR(e) {
	for (const { match: t, roles: r } of _U) if (t(e)) return [...r];
	return [];
}
i(FR, 'getImplicitAriaRoles');
function BR(e) {
	function t({ name: a, attributes: u }) {
		return `${a}${u.map(({ name: c, value: d, constraints: p = [] }) => (p.indexOf('undefined') !== -1 ? `:not([${c}])` : d ? `[${c}="${d}"]` : `[${c}]`)).join('')}`;
	}
	i(t, 'makeElementSelector');
	function r({ attributes: a = [] }) {
		return a.length;
	}
	i(r, 'getSelectorSpecificity');
	function n({ specificity: a }, { specificity: u }) {
		return u - a;
	}
	i(n, 'bySelectorSpecificity');
	function o(a) {
		let { attributes: u = [] } = a;
		const c = u.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
		c >= 0 && (u = [...u.slice(0, c), ...u.slice(c + 1)]);
		const d = t({ ...a, attributes: u });
		return (p) => (c >= 0 && p.type !== 'text' ? !1 : p.matches(d));
	}
	i(o, 'match');
	let s = [];
	for (const [a, u] of e.entries())
		s = [...s, { match: o(a), roles: Array.from(u), specificity: r(a) }];
	return s.sort(n);
}
i(BR, 'buildElementRoleList');
function Fl(e, t) {
	we(e, Fl, this);
	const r = wR(e),
		n = arguments.length === 1;
	let o = !1;
	return (
		n ? (o = r !== '') : (o = t instanceof RegExp ? t.test(r) : this.equals(r, t)),
		{
			pass: o,
			message: i(() => {
				const s = this.isNot ? 'not to' : 'to';
				return Ze(
					this,
					this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${Fl.name}`, 'element', ''),
					`Expected element ${s} have accessible name`,
					t,
					'Received',
					r
				);
			}, 'message')
		}
	);
}
i(Fl, 'toHaveAccessibleName');
function Ep(e, t, r) {
	return r === void 0 ? t : `${t}=${e(r)}`;
}
i(Ep, 'printAttribute');
function JR(e, t, r) {
	return r === void 0
		? `element.hasAttribute(${e(t)})`
		: `element.getAttribute(${e(t)}) === ${e(r)}`;
}
i(JR, 'getAttributeComment');
function Kh(e, t, r) {
	we(e, Kh, this);
	const n = r !== void 0,
		o = e.hasAttribute(t),
		s = e.getAttribute(t);
	return {
		pass: n ? o && this.equals(s, r) : o,
		message: i(() => {
			const a = this.isNot ? 'not to' : 'to',
				u = o ? Ep(this.utils.stringify, t, s) : null,
				c = this.utils.matcherHint(
					`${this.isNot ? '.not' : ''}.toHaveAttribute`,
					'element',
					this.utils.printExpected(t),
					{
						secondArgument: n ? this.utils.printExpected(r) : void 0,
						comment: JR(this.utils.stringify, t, r)
					}
				);
			return Ze(
				this,
				c,
				`Expected the element ${a} have attribute`,
				Ep(this.utils.stringify, t, r),
				'Received',
				u
			);
		}, 'message')
	};
}
i(Kh, 'toHaveAttribute');
function $R(e) {
	const t = e.pop();
	let r, n;
	return (
		typeof t == 'object' && !(t instanceof RegExp)
			? ((r = e), (n = t))
			: ((r = e.concat(t)), (n = { exact: !1 })),
		{ expectedClassNames: r, options: n }
	);
}
i($R, 'getExpectedClassNamesAndOptions');
function Tp(e) {
	return e ? e.split(/\s+/).filter((t) => t.length > 0) : [];
}
i(Tp, 'splitClassNames');
function _p(e, t) {
	return e.every((r) => (typeof r == 'string' ? t.includes(r) : t.some((n) => r.test(n))));
}
i(_p, 'isSubset$1');
function Yh(e, ...t) {
	we(e, Yh, this);
	const { expectedClassNames: r, options: n } = $R(t),
		o = Tp(e.getAttribute('class')),
		s = r.reduce((u, c) => u.concat(typeof c == 'string' || !c ? Tp(c) : c), []),
		a = s.some((u) => u instanceof RegExp);
	if (n.exact && a) throw new Error('Exact option does not support RegExp expected class names');
	return n.exact
		? {
				pass: _p(s, o) && s.length === o.length,
				message: i(() => {
					const u = this.isNot ? 'not to' : 'to';
					return Ze(
						this,
						this.utils.matcherHint(
							`${this.isNot ? '.not' : ''}.toHaveClass`,
							'element',
							this.utils.printExpected(s.join(' '))
						),
						`Expected the element ${u} have EXACTLY defined classes`,
						s.join(' '),
						'Received',
						o.join(' ')
					);
				}, 'message')
			}
		: s.length > 0
			? {
					pass: _p(s, o),
					message: i(() => {
						const u = this.isNot ? 'not to' : 'to';
						return Ze(
							this,
							this.utils.matcherHint(
								`${this.isNot ? '.not' : ''}.toHaveClass`,
								'element',
								this.utils.printExpected(s.join(' '))
							),
							`Expected the element ${u} have class`,
							s.join(' '),
							'Received',
							o.join(' ')
						);
					}, 'message')
				}
			: {
					pass: this.isNot ? o.length > 0 : !1,
					message: i(
						() =>
							this.isNot
								? Ze(
										this,
										this.utils.matcherHint('.not.toHaveClass', 'element', ''),
										'Expected the element to have classes',
										'(none)',
										'Received',
										o.join(' ')
									)
								: [
										this.utils.matcherHint('.toHaveClass', 'element'),
										'At least one expected class must be provided.'
									].join(`
`),
						'message'
					)
				};
}
i(Yh, 'toHaveClass');
function UR(e, t) {
	const r = {},
		n = e.createElement('div');
	return (
		Object.keys(t).forEach((o) => {
			((n.style[o] = t[o]), (r[o] = n.style[o]));
		}),
		r
	);
}
i(UR, 'getStyleDeclaration');
function VR(e, t) {
	return (
		!!Object.keys(e).length &&
		Object.entries(e).every(([r, n]) => {
			const o = r.startsWith('--'),
				s = [r];
			return (
				o || s.push(r.toLowerCase()),
				s.some((a) => t[a] === n || t.getPropertyValue(a) === n)
			);
		})
	);
}
i(VR, 'isSubset');
function wp(e) {
	return Object.keys(e)
		.sort()
		.map((t) => `${t}: ${e[t]};`).join(`
`);
}
i(wp, 'printoutStyles');
function HR(e, t, r) {
	const n = Array.from(r)
		.filter((s) => t[s] !== void 0)
		.reduce((s, a) => Object.assign(s, { [a]: r.getPropertyValue(a) }), {});
	return e(wp(t), wp(n)).replace(
		`${gU.default.red('+ Received')}
`,
		''
	);
}
i(HR, 'expectedDiff');
function Bl(e, t) {
	we(e, Bl, this);
	const r = typeof t == 'object' ? t : xR(t, Bl, this),
		{ getComputedStyle: n } = e.ownerDocument.defaultView,
		o = UR(e.ownerDocument, r),
		s = n(e);
	return {
		pass: VR(o, s),
		message: i(() => {
			const a = `${this.isNot ? '.not' : ''}.toHaveStyle`;
			return [this.utils.matcherHint(a, 'element', ''), HR(this.utils.diff, o, s)].join(`

`);
		}, 'message')
	};
}
i(Bl, 'toHaveStyle');
function Xh(e) {
	return (
		we(e, Xh, this),
		{
			pass: e.ownerDocument.activeElement === e,
			message: i(
				() =>
					[
						this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveFocus`, 'element', ''),
						'',
						...(this.isNot
							? ['Received element is focused:', `  ${this.utils.printReceived(e)}`]
							: [
									'Expected element with focus:',
									`  ${this.utils.printExpected(e)}`,
									'Received element with focus:',
									`  ${this.utils.printReceived(e.ownerDocument.activeElement)}`
								])
					].join(`
`),
				'message'
			)
		}
	);
}
i(Xh, 'toHaveFocus');
function GR(e) {
	const t = [...new Set(e.map((r) => r.type))];
	if (t.length !== 1)
		throw new Error('Multiple form elements with the same name must be of the same type');
	switch (t[0]) {
		case 'radio': {
			const r = e.find((n) => n.checked);
			return r ? r.value : void 0;
		}
		case 'checkbox':
			return e.filter((r) => r.checked).map((r) => r.value);
		default:
			return e.map((r) => r.value);
	}
}
i(GR, 'getMultiElementValue');
function zR(e, t) {
	const r = [...e.querySelectorAll(`[name="${(0, bU.default)(t)}"]`)];
	if (r.length !== 0)
		switch (r.length) {
			case 1:
				return $h(r[0]);
			default:
				return GR(r);
		}
}
i(zR, 'getFormValue');
function WR(e) {
	return /\[\]$/.test(e) ? e.slice(0, -2) : e;
}
i(WR, 'getPureName');
function KR(e) {
	return Array.from(e.elements)
		.map((r) => r.name)
		.reduce((r, n) => ({ ...r, [WR(n)]: zR(e, n) }), {});
}
i(KR, 'getAllFormValues');
function Qh(e, t) {
	if ((we(e, Qh, this), !e.elements))
		throw new Error('toHaveFormValues must be called on a form or a fieldset');
	const r = KR(e);
	return {
		pass: Object.entries(t).every(([n, o]) => cc(r[n], o)),
		message: i(() => {
			const n = this.isNot ? 'not to' : 'to',
				o = `${this.isNot ? '.not' : ''}.toHaveFormValues`,
				s = Object.keys(r)
					.filter((a) => t.hasOwnProperty(a))
					.reduce((a, u) => ({ ...a, [u]: r[u] }), {});
			return [
				this.utils.matcherHint(o, 'element', ''),
				`Expected the element ${n} have form values`,
				this.utils.diff(t, s)
			].join(`

`);
		}, 'message')
	};
}
i(Qh, 'toHaveFormValues');
function YR(e) {
	const { getComputedStyle: t } = e.ownerDocument.defaultView,
		{ display: r, visibility: n, opacity: o } = t(e);
	return r !== 'none' && n !== 'hidden' && n !== 'collapse' && o !== '0' && o !== 0;
}
i(YR, 'isStyleVisible');
function XR(e, t) {
	let r;
	return (
		t
			? (r = e.nodeName === 'DETAILS' && t.nodeName !== 'SUMMARY' ? e.hasAttribute('open') : !0)
			: (r = e.nodeName === 'DETAILS' ? e.hasAttribute('open') : !0),
		!e.hasAttribute('hidden') && r
	);
}
i(XR, 'isAttributeVisible');
function Zh(e, t) {
	return YR(e) && XR(e, t) && (!e.parentElement || Zh(e.parentElement, e));
}
i(Zh, 'isElementVisible');
function ey(e) {
	we(e, ey, this);
	const t = e.ownerDocument === e.getRootNode({ composed: !0 }),
		r = t && Zh(e);
	return {
		pass: r,
		message: i(() => {
			const n = r ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeVisible`, 'element', ''),
				'',
				`Received element ${n} visible${t ? '' : ' (element is not in the document)'}:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(ey, 'toBeVisible');
var wU = ['fieldset', 'input', 'select', 'optgroup', 'option', 'button', 'textarea'];
function QR(e, t) {
	return (
		rn(e) === 'legend' &&
		rn(t) === 'fieldset' &&
		e.isSameNode(Array.from(t.children).find((r) => rn(r) === 'legend'))
	);
}
i(QR, 'isFirstLegendChildOfFieldset');
function ZR(e, t) {
	return ry(t) && !QR(e, t);
}
i(ZR, 'isElementDisabledByParent');
function eP(e) {
	return e.includes('-');
}
i(eP, 'isCustomElement');
function ty(e) {
	const t = rn(e);
	return wU.includes(t) || eP(t);
}
i(ty, 'canElementBeDisabled');
function ry(e) {
	return ty(e) && e.hasAttribute('disabled');
}
i(ry, 'isElementDisabled');
function ny(e) {
	const t = e.parentElement;
	return !!t && (ZR(e, t) || ny(t));
}
i(ny, 'isAncestorDisabled');
function oy(e) {
	return ty(e) && (ry(e) || ny(e));
}
i(oy, 'isElementOrAncestorDisabled');
function iy(e) {
	we(e, iy, this);
	const t = oy(e);
	return {
		pass: t,
		message: i(() => {
			const r = t ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeDisabled`, 'element', ''),
				'',
				`Received element ${r} disabled:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(iy, 'toBeDisabled');
function sy(e) {
	we(e, sy, this);
	const t = !oy(e);
	return {
		pass: t,
		message: i(() => {
			const r = t ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeEnabled`, 'element', ''),
				'',
				`Received element ${r} enabled:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(sy, 'toBeEnabled');
var SU = ['select', 'textarea'],
	RU = ['input', 'select', 'textarea'],
	PU = ['color', 'hidden', 'range', 'submit', 'image', 'reset'],
	AU = [
		'checkbox',
		'combobox',
		'gridcell',
		'listbox',
		'radiogroup',
		'spinbutton',
		'textbox',
		'tree'
	];
function tP(e) {
	return SU.includes(rn(e)) && e.hasAttribute('required');
}
i(tP, 'isRequiredOnFormTagsExceptInput');
function rP(e) {
	return (
		rn(e) === 'input' &&
		e.hasAttribute('required') &&
		((e.hasAttribute('type') && !PU.includes(e.getAttribute('type'))) || !e.hasAttribute('type'))
	);
}
i(rP, 'isRequiredOnSupportedInput');
function nP(e) {
	return (
		e.hasAttribute('aria-required') &&
		e.getAttribute('aria-required') === 'true' &&
		(RU.includes(rn(e)) || (e.hasAttribute('role') && AU.includes(e.getAttribute('role'))))
	);
}
i(nP, 'isElementRequiredByARIA');
function ay(e) {
	we(e, ay, this);
	const t = tP(e) || rP(e) || nP(e);
	return {
		pass: t,
		message: i(() => {
			const r = t ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeRequired`, 'element', ''),
				'',
				`Received element ${r} required:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(ay, 'toBeRequired');
var OU = ['form', 'input', 'select', 'textarea'];
function oP(e) {
	return e.hasAttribute('aria-invalid') && e.getAttribute('aria-invalid') !== 'false';
}
i(oP, 'isElementHavingAriaInvalid');
function iP(e) {
	return OU.includes(rn(e));
}
i(iP, 'isSupportsValidityMethod');
function ly(e) {
	const t = oP(e);
	return iP(e) ? t || !e.checkValidity() : t;
}
i(ly, 'isElementInvalid');
function uy(e) {
	we(e, uy, this);
	const t = ly(e);
	return {
		pass: t,
		message: i(() => {
			const r = t ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeInvalid`, 'element', ''),
				'',
				`Received element ${r} currently invalid:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(uy, 'toBeInvalid');
function cy(e) {
	we(e, cy, this);
	const t = !ly(e);
	return {
		pass: t,
		message: i(() => {
			const r = t ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeValid`, 'element', ''),
				'',
				`Received element ${r} currently valid:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(cy, 'toBeValid');
function dy(e, t) {
	if (
		(we(e, dy, this), e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type))
	)
		throw new Error(
			'input with type=checkbox or type=radio cannot be used with .toHaveValue(). Use .toBeChecked() for type=checkbox or .toHaveFormValues() instead'
		);
	const r = $h(e),
		n = t !== void 0;
	let o = t,
		s = r;
	return (
		t == r && t !== r && ((o = `${t} (${typeof t})`), (s = `${r} (${typeof r})`)),
		{
			pass: n ? cc(r, t) : !!r,
			message: i(() => {
				const a = this.isNot ? 'not to' : 'to',
					u = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveValue`, 'element', t);
				return Ze(this, u, `Expected the element ${a} have value`, n ? o : '(any)', 'Received', s);
			}, 'message')
		}
	);
}
i(dy, 'toHaveValue');
function py(e, t) {
	we(e, py, this);
	const r = e.tagName.toLowerCase();
	if (!['select', 'input', 'textarea'].includes(r))
		throw new Error(
			'.toHaveDisplayValue() currently supports only input, textarea or select elements, try with another matcher instead.'
		);
	if (r === 'input' && ['radio', 'checkbox'].includes(e.type))
		throw new Error(
			`.toHaveDisplayValue() currently does not support input[type="${e.type}"], try with another matcher instead.`
		);
	const n = sP(r, e),
		o = aP(t),
		s = o.filter((c) =>
			n.some((d) => (c instanceof RegExp ? c.test(d) : this.equals(d, String(c))))
		).length,
		a = s === n.length,
		u = s === o.length;
	return {
		pass: a && u,
		message: i(
			() =>
				Ze(
					this,
					this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDisplayValue`, 'element', ''),
					`Expected element ${this.isNot ? 'not ' : ''}to have display value`,
					t,
					'Received',
					n
				),
			'message'
		)
	};
}
i(py, 'toHaveDisplayValue');
function sP(e, t) {
	return e === 'select'
		? Array.from(t)
				.filter((r) => r.selected)
				.map((r) => r.textContent)
		: [t.value];
}
i(sP, 'getValues');
function aP(e) {
	return e instanceof Array ? e : [e];
}
i(aP, 'getExpectedValues');
function fy(e) {
	we(e, fy, this);
	const t = i(
			() => e.tagName.toLowerCase() === 'input' && ['checkbox', 'radio'].includes(e.type),
			'isValidInput'
		),
		r = i(
			() =>
				my(e.getAttribute('role')) && ['true', 'false'].includes(e.getAttribute('aria-checked')),
			'isValidAriaElement'
		);
	if (!t() && !r())
		return {
			pass: !1,
			message: i(
				() =>
					`only inputs with type="checkbox" or type="radio" or elements with ${lP()} and a valid aria-checked attribute can be used with .toBeChecked(). Use .toHaveValue() instead`,
				'message'
			)
		};
	const n = i(() => (t() ? e.checked : e.getAttribute('aria-checked') === 'true'), 'isChecked');
	return {
		pass: n(),
		message: i(() => {
			const o = n() ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBeChecked`, 'element', ''),
				'',
				`Received element ${o} checked:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(fy, 'toBeChecked');
function lP() {
	return jR(
		uP().map((e) => `role="${e}"`),
		{ lastWordConnector: ' or ' }
	);
}
i(lP, 'supportedRolesSentence');
function uP() {
	return Bh.roles.keys().filter(my);
}
i(uP, 'supportedRoles');
function my(e) {
	return Bh.roles.get(e)?.props['aria-checked'] !== void 0;
}
i(my, 'roleSupportsChecked');
function hy(e) {
	we(e, hy, this);
	const t = i(() => e.tagName.toLowerCase() === 'input' && e.type === 'checkbox', 'isValidInput'),
		r = i(() => e.getAttribute('role') === 'checkbox', 'isValidAriaElement');
	if (!t() && !r())
		return {
			pass: !1,
			message: i(
				() =>
					'only inputs with type="checkbox" or elements with role="checkbox" and a valid aria-checked attribute can be used with .toBePartiallyChecked(). Use .toHaveValue() instead',
				'message'
			)
		};
	const n = i(() => {
		const o = e.getAttribute('aria-checked') === 'mixed';
		return (t() && e.indeterminate) || o;
	}, 'isPartiallyChecked');
	return {
		pass: n(),
		message: i(() => {
			const o = n() ? 'is' : 'is not';
			return [
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toBePartiallyChecked`, 'element', ''),
				'',
				`Received element ${o} partially checked:`,
				`  ${this.utils.printReceived(e.cloneNode(!1))}`
			].join(`
`);
		}, 'message')
	};
}
i(hy, 'toBePartiallyChecked');
function yy(e, t) {
	(Oa('toHaveDescription', 'Please use toHaveAccessibleDescription.'), we(e, yy, this));
	const r = t !== void 0,
		o = (e.getAttribute('aria-describedby') || '').split(/\s+/).filter(Boolean);
	let s = '';
	if (o.length > 0) {
		const a = e.ownerDocument,
			u = o.map((c) => a.getElementById(c)).filter(Boolean);
		s = Ca(u.map((c) => c.textContent).join(' '));
	}
	return {
		pass: r ? (t instanceof RegExp ? t.test(s) : this.equals(s, t)) : !!s,
		message: i(() => {
			const a = this.isNot ? 'not to' : 'to';
			return Ze(
				this,
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveDescription`, 'element', ''),
				`Expected the element ${a} have description`,
				this.utils.printExpected(t),
				'Received',
				this.utils.printReceived(s)
			);
		}, 'message')
	};
}
i(yy, 'toHaveDescription');
function gy(e, t) {
	if (
		(Oa('toHaveErrorMessage', 'Please use toHaveAccessibleErrorMessage.'),
		we(e, gy, this),
		!e.hasAttribute('aria-invalid') || e.getAttribute('aria-invalid') === 'false')
	) {
		const a = this.isNot ? '.not' : '';
		return {
			pass: !1,
			message: i(
				() =>
					Ze(
						this,
						this.utils.matcherHint(`${a}.toHaveErrorMessage`, 'element', ''),
						'Expected the element to have invalid state indicated by',
						'aria-invalid="true"',
						'Received',
						e.hasAttribute('aria-invalid')
							? `aria-invalid="${e.getAttribute('aria-invalid')}"`
							: this.utils.printReceived('')
					),
				'message'
			)
		};
	}
	const r = t !== void 0,
		o = (e.getAttribute('aria-errormessage') || '').split(/\s+/).filter(Boolean);
	let s = '';
	if (o.length > 0) {
		const a = e.ownerDocument,
			u = o.map((c) => a.getElementById(c)).filter(Boolean);
		s = Ca(u.map((c) => c.textContent).join(' '));
	}
	return {
		pass: r ? (t instanceof RegExp ? t.test(s) : this.equals(s, t)) : !!s,
		message: i(() => {
			const a = this.isNot ? 'not to' : 'to';
			return Ze(
				this,
				this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveErrorMessage`, 'element', ''),
				`Expected the element ${a} have error message`,
				this.utils.printExpected(t),
				'Received',
				this.utils.printReceived(s)
			);
		}, 'message')
	};
}
i(gy, 'toHaveErrorMessage');
function cP(e) {
	const t = e.ownerDocument.getSelection();
	if (['input', 'textarea'].includes(e.tagName.toLowerCase()))
		return ['radio', 'checkbox'].includes(e.type)
			? ''
			: e.value.toString().substring(e.selectionStart, e.selectionEnd);
	if (t.anchorNode === null || t.focusNode === null) return '';
	const r = t.getRangeAt(0),
		n = e.ownerDocument.createRange();
	if (t.containsNode(e, !1)) (n.selectNodeContents(e), t.removeAllRanges(), t.addRange(n));
	else if (!(e.contains(t.anchorNode) && e.contains(t.focusNode))) {
		const s = e === r.startContainer || e.contains(r.startContainer),
			a = e === r.endContainer || e.contains(r.endContainer);
		(t.removeAllRanges(),
			(s || a) &&
				(n.selectNodeContents(e),
				s && n.setStart(r.startContainer, r.startOffset),
				a && n.setEnd(r.endContainer, r.endOffset),
				t.addRange(n)));
	}
	const o = t.toString();
	return (t.removeAllRanges(), t.addRange(r), o);
}
i(cP, 'getSelection');
function by(e, t) {
	we(e, by, this);
	const r = t !== void 0;
	if (r && typeof t != 'string')
		throw new Error('expected selection must be a string or undefined');
	const n = cP(e);
	return {
		pass: r ? cc(n, t) : !!n,
		message: i(() => {
			const o = this.isNot ? 'not to' : 'to',
				s = this.utils.matcherHint(`${this.isNot ? '.not' : ''}.toHaveSelection`, 'element', t);
			return Ze(
				this,
				s,
				`Expected the element ${o} have selection`,
				r ? t : '(any)',
				'Received',
				n
			);
		}, 'message')
	};
}
i(by, 'toHaveSelection');
function vy(e) {
	we(e, vy, this);
	const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
		r =
			e.tagName.toLowerCase() === 'button' ||
			(e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
			t.includes('button'),
		n = e.getAttribute('aria-pressed');
	return !r || !(n === 'true' || n === 'false')
		? {
				pass: !1,
				message: i(
					() =>
						'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePressed()',
					'message'
				)
			}
		: {
				pass: r && n === 'true',
				message: i(() => {
					const a = this.utils.matcherHint(
						`${this.isNot ? '.not' : ''}.toBePressed`,
						'element',
						''
					);
					return Ze(
						this,
						a,
						'Expected element to have',
						`aria-pressed="${this.isNot ? 'false' : 'true'}"`,
						'Received',
						`aria-pressed="${n}"`
					);
				}, 'message')
			};
}
i(vy, 'toBePressed');
function Ey(e) {
	we(e, Ey, this);
	const t = (e.getAttribute('role') || '').split(' ').map((a) => a.trim()),
		r =
			e.tagName.toLowerCase() === 'button' ||
			(e.tagName.toLowerCase() === 'input' && e.type === 'button') ||
			t.includes('button'),
		n = e.getAttribute('aria-pressed');
	return !r || !(n === 'true' || n === 'false' || n === 'mixed')
		? {
				pass: !1,
				message: i(
					() =>
						'Only button or input with type="button" or element with role="button" and a valid aria-pressed attribute can be used with .toBePartiallyPressed()',
					'message'
				)
			}
		: {
				pass: r && n === 'mixed',
				message: i(() => {
					const a = this.isNot ? 'not to' : 'to',
						u = this.utils.matcherHint(
							`${this.isNot ? '.not' : ''}.toBePartiallyPressed`,
							'element',
							''
						);
					return Ze(
						this,
						u,
						`Expected element ${a} have`,
						'aria-pressed="mixed"',
						'Received',
						`aria-pressed="${n}"`
					);
				}, 'message')
			};
}
i(Ey, 'toBePartiallyPressed');
var CU = 1,
	dP = 2,
	pP = 4,
	xU = 8,
	IU = 16,
	NU = 32,
	lv = {
		[CU]: 'Node.DOCUMENT_POSITION_DISCONNECTED',
		[dP]: 'Node.DOCUMENT_POSITION_PRECEDING',
		[pP]: 'Node.DOCUMENT_POSITION_FOLLOWING',
		[xU]: 'Node.DOCUMENT_POSITION_CONTAINS',
		[IU]: 'Node.DOCUMENT_POSITION_CONTAINED_BY',
		[NU]: 'Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC'
	};
function fP(e) {
	return e in lv ? `${lv[e]} (${e})` : `Unknown document position (${e})`;
}
i(fP, 'makeDocumentPositionErrorString');
function Ty(e, t) {
	return function (r, n) {
		(we(r, Jl, this), we(n, Jl, this));
		const o = r.compareDocumentPosition(n);
		return {
			pass: o === t,
			message: i(
				() =>
					[
						this.utils.matcherHint(`${this.isNot ? '.not' : ''}.${e}`, 'element', 'secondElement'),
						'',
						`Received: ${fP(o)}`
					].join(`
`),
				'message'
			)
		};
	};
}
i(Ty, 'checkToAppear');
function Jl(e, t) {
	return Ty('toAppearBefore', pP).apply(this, [e, t]);
}
i(Jl, 'toAppearBefore');
function mP(e, t) {
	return Ty('toAppearAfter', dP).apply(this, [e, t]);
}
i(mP, 'toAppearAfter');
et(LE(), 1);
et($f(), 1);
et(FE(), 1);
et(BE(), 1);
var vd, uv;
function hP() {
	if (uv) return vd;
	uv = 1;
	var e, t, r, n, o, s, a, u, c, d, p, f, m, y, g, E, T, b, w;
	return (
		(m =
			/\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy),
		(f =
			/--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y),
		(e =
			/(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy),
		(g = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y),
		(p =
			/(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y),
		(E = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y),
		(w = /[\t\v\f\ufeff\p{Zs}]+/uy),
		(u = /\r?\n|[\r\u2028\u2029]/y),
		(c = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y),
		(y = /\/\/.*/y),
		(r = /[<>.:={}]|\/(?![\/*])/y),
		(t = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy),
		(n = /(['"])(?:(?!\1)[^])*(\1)?/y),
		(o = /[^<>{}]+/y),
		(b =
			/^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/),
		(T = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/),
		(s = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/),
		(a = /^(?:return|throw|yield)$/),
		(d = RegExp(u.source)),
		(vd = i(function* (P, { jsx: I = !1 } = {}) {
			var q, C, R, _, S, D, N, V, H, A, L, B, k, K;
			for ({ length: D } = P, _ = 0, S = '', K = [{ tag: 'JS' }], q = [], L = 0, B = !1; _ < D; ) {
				switch (((V = K[K.length - 1]), V.tag)) {
					case 'JS':
					case 'JSNonExpressionParen':
					case 'InterpolationInTemplate':
					case 'InterpolationInJSX':
						if (P[_] === '/' && (b.test(S) || s.test(S)) && ((m.lastIndex = _), (N = m.exec(P)))) {
							((_ = m.lastIndex),
								(S = N[0]),
								(B = !0),
								yield {
									type: 'RegularExpressionLiteral',
									value: N[0],
									closed: N[1] !== void 0 && N[1] !== '\\'
								});
							continue;
						}
						if (((f.lastIndex = _), (N = f.exec(P)))) {
							switch (((k = N[0]), (H = f.lastIndex), (A = k), k)) {
								case '(':
									(S === '?NonExpressionParenKeyword' &&
										K.push({ tag: 'JSNonExpressionParen', nesting: L }),
										L++,
										(B = !1));
									break;
								case ')':
									(L--,
										(B = !0),
										V.tag === 'JSNonExpressionParen' &&
											L === V.nesting &&
											(K.pop(), (A = '?NonExpressionParenEnd'), (B = !1)));
									break;
								case '{':
									((f.lastIndex = 0),
										(R = !T.test(S) && (b.test(S) || s.test(S))),
										q.push(R),
										(B = !1));
									break;
								case '}':
									switch (V.tag) {
										case 'InterpolationInTemplate':
											if (q.length === V.nesting) {
												((E.lastIndex = _),
													(N = E.exec(P)),
													(_ = E.lastIndex),
													(S = N[0]),
													N[1] === '${'
														? ((S = '?InterpolationInTemplate'),
															(B = !1),
															yield { type: 'TemplateMiddle', value: N[0] })
														: (K.pop(),
															(B = !0),
															yield { type: 'TemplateTail', value: N[0], closed: N[1] === '`' }));
												continue;
											}
											break;
										case 'InterpolationInJSX':
											if (q.length === V.nesting) {
												(K.pop(), (_ += 1), (S = '}'), yield { type: 'JSXPunctuator', value: '}' });
												continue;
											}
									}
									((B = q.pop()), (A = B ? '?ExpressionBraceEnd' : '}'));
									break;
								case ']':
									B = !0;
									break;
								case '++':
								case '--':
									A = B ? '?PostfixIncDec' : '?UnaryIncDec';
									break;
								case '<':
									if (I && (b.test(S) || s.test(S))) {
										(K.push({ tag: 'JSXTag' }),
											(_ += 1),
											(S = '<'),
											yield { type: 'JSXPunctuator', value: k });
										continue;
									}
									B = !1;
									break;
								default:
									B = !1;
							}
							((_ = H), (S = A), yield { type: 'Punctuator', value: k });
							continue;
						}
						if (((e.lastIndex = _), (N = e.exec(P)))) {
							switch (((_ = e.lastIndex), (A = N[0]), N[0])) {
								case 'for':
								case 'if':
								case 'while':
								case 'with':
									S !== '.' && S !== '?.' && (A = '?NonExpressionParenKeyword');
							}
							((S = A),
								(B = !s.test(N[0])),
								yield { type: N[1] === '#' ? 'PrivateIdentifier' : 'IdentifierName', value: N[0] });
							continue;
						}
						if (((g.lastIndex = _), (N = g.exec(P)))) {
							((_ = g.lastIndex),
								(S = N[0]),
								(B = !0),
								yield { type: 'StringLiteral', value: N[0], closed: N[2] !== void 0 });
							continue;
						}
						if (((p.lastIndex = _), (N = p.exec(P)))) {
							((_ = p.lastIndex),
								(S = N[0]),
								(B = !0),
								yield { type: 'NumericLiteral', value: N[0] });
							continue;
						}
						if (((E.lastIndex = _), (N = E.exec(P)))) {
							((_ = E.lastIndex),
								(S = N[0]),
								N[1] === '${'
									? ((S = '?InterpolationInTemplate'),
										K.push({ tag: 'InterpolationInTemplate', nesting: q.length }),
										(B = !1),
										yield { type: 'TemplateHead', value: N[0] })
									: ((B = !0),
										yield { type: 'NoSubstitutionTemplate', value: N[0], closed: N[1] === '`' }));
							continue;
						}
						break;
					case 'JSXTag':
					case 'JSXTagEnd':
						if (((r.lastIndex = _), (N = r.exec(P)))) {
							switch (((_ = r.lastIndex), (A = N[0]), N[0])) {
								case '<':
									K.push({ tag: 'JSXTag' });
									break;
								case '>':
									(K.pop(),
										S === '/' || V.tag === 'JSXTagEnd'
											? ((A = '?JSX'), (B = !0))
											: K.push({ tag: 'JSXChildren' }));
									break;
								case '{':
									(K.push({ tag: 'InterpolationInJSX', nesting: q.length }),
										(A = '?InterpolationInJSX'),
										(B = !1));
									break;
								case '/':
									S === '<' &&
										(K.pop(),
										K[K.length - 1].tag === 'JSXChildren' && K.pop(),
										K.push({ tag: 'JSXTagEnd' }));
							}
							((S = A), yield { type: 'JSXPunctuator', value: N[0] });
							continue;
						}
						if (((t.lastIndex = _), (N = t.exec(P)))) {
							((_ = t.lastIndex), (S = N[0]), yield { type: 'JSXIdentifier', value: N[0] });
							continue;
						}
						if (((n.lastIndex = _), (N = n.exec(P)))) {
							((_ = n.lastIndex),
								(S = N[0]),
								yield { type: 'JSXString', value: N[0], closed: N[2] !== void 0 });
							continue;
						}
						break;
					case 'JSXChildren':
						if (((o.lastIndex = _), (N = o.exec(P)))) {
							((_ = o.lastIndex), (S = N[0]), yield { type: 'JSXText', value: N[0] });
							continue;
						}
						switch (P[_]) {
							case '<':
								(K.push({ tag: 'JSXTag' }),
									_++,
									(S = '<'),
									yield { type: 'JSXPunctuator', value: '<' });
								continue;
							case '{':
								(K.push({ tag: 'InterpolationInJSX', nesting: q.length }),
									_++,
									(S = '?InterpolationInJSX'),
									(B = !1),
									yield { type: 'JSXPunctuator', value: '{' });
								continue;
						}
				}
				if (((w.lastIndex = _), (N = w.exec(P)))) {
					((_ = w.lastIndex), yield { type: 'WhiteSpace', value: N[0] });
					continue;
				}
				if (((u.lastIndex = _), (N = u.exec(P)))) {
					((_ = u.lastIndex),
						(B = !1),
						a.test(S) && (S = '?NoLineTerminatorHere'),
						yield { type: 'LineTerminatorSequence', value: N[0] });
					continue;
				}
				if (((c.lastIndex = _), (N = c.exec(P)))) {
					((_ = c.lastIndex),
						d.test(N[0]) && ((B = !1), a.test(S) && (S = '?NoLineTerminatorHere')),
						yield { type: 'MultiLineComment', value: N[0], closed: N[1] !== void 0 });
					continue;
				}
				if (((y.lastIndex = _), (N = y.exec(P)))) {
					((_ = y.lastIndex), (B = !1), yield { type: 'SingleLineComment', value: N[0] });
					continue;
				}
				((C = String.fromCodePoint(P.codePointAt(_))),
					(_ += C.length),
					(S = C),
					(B = !1),
					yield { type: V.tag.startsWith('JSX') ? 'JSXInvalid' : 'Invalid', value: C });
			}
		}, 'jsTokens_1')),
		vd
	);
}
i(hP, 'requireJsTokens');
var MU = hP();
Dm(MU);
var yP = {
	keyword: [
		'break',
		'case',
		'catch',
		'continue',
		'debugger',
		'default',
		'do',
		'else',
		'finally',
		'for',
		'function',
		'if',
		'return',
		'switch',
		'throw',
		'try',
		'var',
		'const',
		'while',
		'with',
		'new',
		'this',
		'super',
		'class',
		'extends',
		'export',
		'import',
		'null',
		'true',
		'false',
		'in',
		'instanceof',
		'typeof',
		'void',
		'delete'
	],
	strict: [
		'implements',
		'interface',
		'let',
		'package',
		'private',
		'protected',
		'public',
		'static',
		'yield'
	]
};
new Set(yP.keyword);
new Set(yP.strict);
function Ns(e, t) {
	if (!e) throw new Error(t);
}
i(Ns, 'S');
function Qn(e, t) {
	return typeof t === e;
}
i(Qn, 'f');
function gP(e) {
	return e instanceof Promise;
}
i(gP, 'w');
function pi(e, t, r) {
	Object.defineProperty(e, t, r);
}
i(pi, 'u');
function io(e, t, r) {
	pi(e, t, { value: r, configurable: !0, writable: !0 });
}
i(io, 'l');
var wn = Symbol.for('tinyspy:spy'),
	qU = new Set(),
	jU = i((e) => {
		((e.called = !1),
			(e.callCount = 0),
			(e.calls = []),
			(e.results = []),
			(e.resolves = []),
			(e.next = []));
	}, 'h'),
	DU = i((e) => (pi(e, wn, { value: { reset: i(() => jU(e[wn]), 'reset') } }), e[wn]), 'k'),
	Sp = i((e) => e[wn] || DU(e), 'T');
function bP(e) {
	Ns(Qn('function', e) || Qn('undefined', e), 'cannot spy on a non-function value');
	let t = i(function (...n) {
		let o = Sp(t);
		((o.called = !0), o.callCount++, o.calls.push(n));
		let s = o.next.shift();
		if (s) {
			o.results.push(s);
			let [p, f] = s;
			if (p === 'ok') return f;
			throw f;
		}
		let a,
			u = 'ok',
			c = o.results.length;
		if (o.impl)
			try {
				(new.target ? (a = Reflect.construct(o.impl, n, new.target)) : (a = o.impl.apply(this, n)),
					(u = 'ok'));
			} catch (p) {
				throw ((a = p), (u = 'error'), o.results.push([u, p]), p);
			}
		let d = [u, a];
		return (
			gP(a) &&
				a.then(
					(p) => (o.resolves[c] = ['ok', p]),
					(p) => (o.resolves[c] = ['error', p])
				),
			o.results.push(d),
			a
		);
	}, 't');
	(io(t, '_isMockFunction', !0),
		io(t, 'length', e ? e.length : 0),
		io(t, 'name', (e && e.name) || 'spy'));
	let r = Sp(t);
	return (r.reset(), (r.impl = e), t);
}
i(bP, 'R');
function vP(e) {
	return !!e && e._isMockFunction === !0;
}
i(vP, 'v');
var EP = i((e, t) => {
		let r = Object.getOwnPropertyDescriptor(e, t);
		if (r) return [e, r];
		let n = Object.getPrototypeOf(e);
		for (; n !== null; ) {
			let o = Object.getOwnPropertyDescriptor(n, t);
			if (o) return [n, o];
			n = Object.getPrototypeOf(n);
		}
	}, 'b'),
	cv = i((e, t) => {
		t != null &&
			typeof t == 'function' &&
			t.prototype != null &&
			Object.setPrototypeOf(e.prototype, t.prototype);
	}, 'P');
function _y(e, t, r) {
	(Ns(!Qn('undefined', e), 'spyOn could not find an object to spy upon'),
		Ns(Qn('object', e) || Qn('function', e), 'cannot spyOn on a primitive value'));
	let [n, o] = (() => {
			if (!Qn('object', t)) return [t, 'value'];
			if ('getter' in t && 'setter' in t) throw new Error('cannot spy on both getter and setter');
			if ('getter' in t) return [t.getter, 'get'];
			if ('setter' in t) return [t.setter, 'set'];
			throw new Error('specify getter or setter to spy on');
		})(),
		[s, a] = EP(e, n) || [];
	Ns(a || n in e, `${String(n)} does not exist`);
	let u = !1;
	o === 'value' && a && !a.value && a.get && ((o = 'get'), (u = !0), (r = a.get()));
	let c;
	(a ? (c = a[o]) : o !== 'value' ? (c = i(() => e[n], 'p')) : (c = e[n]),
		c && wP(c) && (c = c[wn].getOriginal()));
	let d = i((y) => {
			let { value: g, ...E } = a || { configurable: !0, writable: !0 };
			(o !== 'value' && delete E.writable, (E[o] = y), pi(e, n, E));
		}, 'g'),
		p = i(() => {
			s !== e ? Reflect.deleteProperty(e, n) : a && !c ? pi(e, n, a) : d(c);
		}, 'a');
	r || (r = c);
	let f = _P(bP(r), r);
	o === 'value' && cv(f, c);
	let m = f[wn];
	return (
		io(m, 'restore', p),
		io(m, 'getOriginal', () => (u ? c() : c)),
		io(m, 'willCall', (y) => ((m.impl = y), f)),
		d(u ? () => (cv(f, r), f) : f),
		qU.add(f),
		f
	);
}
i(_y, 'M');
var kU = new Set(['length', 'name', 'prototype']);
function TP(e) {
	let t = new Set(),
		r = {};
	for (; e && e !== Object.prototype && e !== Function.prototype; ) {
		let n = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
		for (let o of n)
			r[o] || kU.has(o) || (t.add(o), (r[o] = Object.getOwnPropertyDescriptor(e, o)));
		e = Object.getPrototypeOf(e);
	}
	return { properties: t, descriptors: r };
}
i(TP, 'D');
function _P(e, t) {
	if (!t || wn in t) return e;
	let { properties: r, descriptors: n } = TP(t);
	for (let o of r) {
		let s = n[o];
		EP(e, o) || pi(e, o, s);
	}
	return e;
}
i(_P, 'E');
function wP(e) {
	return vP(e) && 'getOriginal' in e[wn];
}
i(wP, 'j');
var xa = new Set();
function so(e) {
	return typeof e == 'function' && '_isMockFunction' in e && e._isMockFunction;
}
i(so, 'isMockFunction');
function SP(e, t, r) {
	const o = r ? { [{ get: 'getter', set: 'setter' }[r]]: t } : t;
	let s;
	const a = RP(e, t),
		u = a && a[r || 'value'];
	so(u) && (s = u.mock._state());
	try {
		const c = _y(e, o),
			d = wy(c);
		return (s && d.mock._state(s), d);
	} catch (c) {
		throw c instanceof TypeError &&
			Symbol.toStringTag &&
			e[Symbol.toStringTag] === 'Module' &&
			(c.message.includes('Cannot redefine property') ||
				c.message.includes('Cannot replace module namespace') ||
				c.message.includes("can't redefine non-configurable property"))
			? new TypeError(
					`Cannot spy on export "${String(o)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`,
					{ cause: c }
				)
			: c;
	}
}
i(SP, 'spyOn');
var LU = 0;
function wy(e) {
	const t = e;
	let r,
		n = [],
		o = !1,
		s = [],
		a = [],
		u = [];
	const c = Sp(e),
		d = {
			get calls() {
				return c.calls;
			},
			get contexts() {
				return a;
			},
			get instances() {
				return s;
			},
			get invocationCallOrder() {
				return u;
			},
			get results() {
				return c.results.map(([y, g]) => ({ type: y === 'error' ? 'throw' : 'return', value: g }));
			},
			get settledResults() {
				return c.resolves.map(([y, g]) => ({
					type: y === 'error' ? 'rejected' : 'fulfilled',
					value: g
				}));
			},
			get lastCall() {
				return c.calls[c.calls.length - 1];
			},
			_state(y) {
				return (
					y &&
						((r = y.implementation),
						(n = y.onceImplementations),
						(o = y.implementationChangedTemporarily)),
					{ implementation: r, onceImplementations: n, implementationChangedTemporarily: o }
				);
			}
		};
	function p(...y) {
		return (
			s.push(this),
			a.push(this),
			u.push(++LU),
			(o ? r : n.shift() || r || c.getOriginal() || (() => {})).apply(this, y)
		);
	}
	i(p, 'mockCall');
	let f = t.name;
	((t.getMockName = () => f || 'vi.fn()'),
		(t.mockName = (y) => ((f = y), t)),
		(t.mockClear = () => (c.reset(), (s = []), (a = []), (u = []), t)),
		(t.mockReset = () => (t.mockClear(), (r = void 0), (n = []), t)),
		(t.mockRestore = () => (t.mockReset(), c.restore(), t)),
		Symbol.dispose && (t[Symbol.dispose] = () => t.mockRestore()),
		(t.getMockImplementation = () => (o ? r : n.at(0) || r)),
		(t.mockImplementation = (y) => ((r = y), c.willCall(p), t)),
		(t.mockImplementationOnce = (y) => (n.push(y), t)));
	function m(y, g) {
		const E = r;
		((r = y), c.willCall(p), (o = !0));
		const T = i(() => {
				((r = E), (o = !1));
			}, 'reset'),
			b = g();
		return typeof b == 'object' && b && typeof b.then == 'function'
			? b.then(() => (T(), t))
			: (T(), t);
	}
	return (
		i(m, 'withImplementation'),
		(t.withImplementation = m),
		(t.mockReturnThis = () =>
			t.mockImplementation(function () {
				return this;
			})),
		(t.mockReturnValue = (y) => t.mockImplementation(() => y)),
		(t.mockReturnValueOnce = (y) => t.mockImplementationOnce(() => y)),
		(t.mockResolvedValue = (y) => t.mockImplementation(() => Promise.resolve(y))),
		(t.mockResolvedValueOnce = (y) => t.mockImplementationOnce(() => Promise.resolve(y))),
		(t.mockRejectedValue = (y) => t.mockImplementation(() => Promise.reject(y))),
		(t.mockRejectedValueOnce = (y) => t.mockImplementationOnce(() => Promise.reject(y))),
		Object.defineProperty(t, 'mock', { get: i(() => d, 'get') }),
		c.willCall(p),
		xa.add(t),
		t
	);
}
i(wy, 'enhanceSpy');
function Rp(e) {
	const t = wy(_y({ spy: e || function () {} }, 'spy'));
	return (e && t.mockImplementation(e), t);
}
i(Rp, 'fn');
function RP(e, t) {
	const r = Object.getOwnPropertyDescriptor(e, t);
	if (r) return r;
	let n = Object.getPrototypeOf(e);
	for (; n !== null; ) {
		const o = Object.getOwnPropertyDescriptor(n, t);
		if (o) return o;
		n = Object.getPrototypeOf(n);
	}
}
i(RP, 'getDescriptor');
var ea = Symbol.for('matchers-object'),
	ta = Symbol.for('$$jest-matchers-object-storybook'),
	Sy = Symbol.for('expect-global'),
	Pp = Symbol.for('asymmetric-matchers-object'),
	FU = {
		toSatisfy(e, t, r) {
			const { printReceived: n, printExpected: o, matcherHint: s } = this.utils,
				a = t(e);
			return {
				pass: a,
				message: i(
					() =>
						a
							? `${s('.not.toSatisfy', 'received', '')}

Expected value to not satisfy:
${r || o(t)}
Received:
${n(e)}`
							: `${s('.toSatisfy', 'received', '')}

Expected value to satisfy:
${r || o(t)}

Received:
${n(e)}`,
					'message'
				)
			};
		},
		toBeOneOf(e, t) {
			const { equals: r, customTesters: n } = this,
				{ printReceived: o, printExpected: s, matcherHint: a } = this.utils;
			if (!Array.isArray(t))
				throw new TypeError(`You must provide an array to ${a('.toBeOneOf')}, not '${typeof t}'.`);
			const u = t.length === 0 || t.some((c) => r(c, e, n));
			return {
				pass: u,
				message: i(
					() =>
						u
							? `${a('.not.toBeOneOf', 'received', '')}

Expected value to not be one of:
${s(t)}
Received:
${o(e)}`
							: `${a('.toBeOneOf', 'received', '')}

Expected value to be one of:
${s(t)}

Received:
${o(e)}`,
					'message'
				)
			};
		}
	},
	$l = Ke.green,
	Ry = Ke.red,
	BU = Ke.inverse,
	JU = Ke.bold,
	mn = Ke.dim;
function PP(e, t = 'received', r = 'expected', n = {}) {
	const {
		comment: o = '',
		isDirectExpectCall: s = !1,
		isNot: a = !1,
		promise: u = '',
		secondArgument: c = '',
		expectedColor: d = $l,
		receivedColor: p = Ry,
		secondArgumentColor: f = $l
	} = n;
	let m = '',
		y = 'expect';
	return (
		!s && t !== '' && ((m += mn(`${y}(`) + p(t)), (y = ')')),
		u !== '' && ((m += mn(`${y}.`) + u), (y = '')),
		a && ((m += `${mn(`${y}.`)}not`), (y = '')),
		e.includes('.') ? (y += e) : ((m += mn(`${y}.`) + e), (y = '')),
		r === '' ? (y += '()') : ((m += mn(`${y}(`) + d(r)), c && (m += mn(', ') + f(c)), (y = ')')),
		o !== '' && (y += ` // ${o}`),
		y !== '' && (m += mn(y)),
		m
	);
}
i(PP, 'matcherHint');
var $U = '';
function Py(e) {
	return e.replace(/\s+$/gm, (t) => $U.repeat(t.length));
}
i(Py, 'replaceTrailingSpaces');
function AP(e) {
	return Ry(Py(jt(e)));
}
i(AP, 'printReceived');
function OP(e) {
	return $l(Py(jt(e)));
}
i(OP, 'printExpected');
function Ay() {
	return {
		EXPECTED_COLOR: $l,
		RECEIVED_COLOR: Ry,
		INVERTED_COLOR: BU,
		BOLD_WEIGHT: JU,
		DIM_COLOR: mn,
		diff: Oo,
		matcherHint: PP,
		printReceived: AP,
		printExpected: OP,
		printDiffOrStringify: Hm,
		printWithType: CP
	};
}
i(Ay, 'getMatcherUtils');
function CP(e, t, r) {
	const n = Gs(t),
		o =
			n !== 'null' && n !== 'undefined'
				? `${e} has type:  ${n}
`
				: '',
		s = `${e} has value: ${r(t)}`;
	return o + s;
}
i(CP, 'printWithType');
function dc() {
	return globalThis[ta].customEqualityTesters;
}
i(dc, 'getCustomEqualityTesters');
function Oe(e, t, r, n) {
	return ((r = r || []), Qo(e, t, [], [], r, n ? Oy : NP));
}
i(Oe, 'equals');
function Ap(e) {
	return !!e && typeof e == 'object' && 'asymmetricMatch' in e && or('Function', e.asymmetricMatch);
}
i(Ap, 'isAsymmetric');
function xP(e, t) {
	const r = Ap(e),
		n = Ap(t);
	if (!(r && n)) {
		if (r) return e.asymmetricMatch(t);
		if (n) return t.asymmetricMatch(e);
	}
}
i(xP, 'asymmetricMatch');
function Qo(e, t, r, n, o, s) {
	let a = !0;
	const u = xP(e, t);
	if (u !== void 0) return u;
	const c = { equals: Oe };
	for (let g = 0; g < o.length; g++) {
		const E = o[g].call(c, e, t, o);
		if (E !== void 0) return E;
	}
	if (typeof URL == 'function' && e instanceof URL && t instanceof URL) return e.href === t.href;
	if (Object.is(e, t)) return !0;
	if (e === null || t === null) return e === t;
	const d = Object.prototype.toString.call(e);
	if (d !== Object.prototype.toString.call(t)) return !1;
	switch (d) {
		case '[object Boolean]':
		case '[object String]':
		case '[object Number]':
			return typeof e != typeof t
				? !1
				: typeof e != 'object' && typeof t != 'object'
					? Object.is(e, t)
					: Object.is(e.valueOf(), t.valueOf());
		case '[object Date]': {
			const g = +e,
				E = +t;
			return g === E || (Number.isNaN(g) && Number.isNaN(E));
		}
		case '[object RegExp]':
			return e.source === t.source && e.flags === t.flags;
		case '[object Temporal.Instant]':
		case '[object Temporal.ZonedDateTime]':
		case '[object Temporal.PlainDateTime]':
		case '[object Temporal.PlainDate]':
		case '[object Temporal.PlainTime]':
		case '[object Temporal.PlainYearMonth]':
		case '[object Temporal.PlainMonthDay]':
			return e.equals(t);
		case '[object Temporal.Duration]':
			return e.toString() === t.toString();
	}
	if (typeof e != 'object' || typeof t != 'object') return !1;
	if (Cp(e) && Cp(t)) return e.isEqualNode(t);
	let p = r.length;
	for (; p--; ) {
		if (r[p] === e) return n[p] === t;
		if (n[p] === t) return !1;
	}
	if ((r.push(e), n.push(t), d === '[object Array]' && e.length !== t.length)) return !1;
	if (e instanceof Error && t instanceof Error)
		try {
			return IP(e, t, r, n, o, s);
		} finally {
			(r.pop(), n.pop());
		}
	const f = Op(e, s);
	let m,
		y = f.length;
	if (Op(t, s).length !== y) return !1;
	for (; y--; ) if (((m = f[y]), (a = s(t, m) && Qo(e[m], t[m], r, n, o, s)), !a)) return !1;
	return (r.pop(), n.pop(), a);
}
i(Qo, 'eq');
function IP(e, t, r, n, o, s) {
	let a =
		Object.getPrototypeOf(e) === Object.getPrototypeOf(t) &&
		e.name === t.name &&
		e.message === t.message;
	return (
		typeof t.cause < 'u' && a && (a = Qo(e.cause, t.cause, r, n, o, s)),
		e instanceof AggregateError &&
			t instanceof AggregateError &&
			a &&
			(a = Qo(e.errors, t.errors, r, n, o, s)),
		a && (a = Qo({ ...e }, { ...t }, r, n, o, s)),
		a
	);
}
i(IP, 'isErrorEqual');
function Op(e, t) {
	const r = [];
	for (const n in e) t(e, n) && r.push(n);
	return r.concat(
		Object.getOwnPropertySymbols(e).filter((n) => Object.getOwnPropertyDescriptor(e, n).enumerable)
	);
}
i(Op, 'keys');
function NP(e, t) {
	return Oy(e, t) && e[t] !== void 0;
}
i(NP, 'hasDefinedKey');
function Oy(e, t) {
	return Object.prototype.hasOwnProperty.call(e, t);
}
i(Oy, 'hasKey');
function or(e, t) {
	return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
i(or, 'isA');
function Cp(e) {
	return (
		e !== null &&
		typeof e == 'object' &&
		'nodeType' in e &&
		typeof e.nodeType == 'number' &&
		'nodeName' in e &&
		typeof e.nodeName == 'string' &&
		'isEqualNode' in e &&
		typeof e.isEqualNode == 'function'
	);
}
i(Cp, 'isDomNode');
var MP = '@@__IMMUTABLE_KEYED__@@',
	qP = '@@__IMMUTABLE_SET__@@',
	UU = '@@__IMMUTABLE_LIST__@@',
	pc = '@@__IMMUTABLE_ORDERED__@@',
	VU = '@@__IMMUTABLE_RECORD__@@';
function jP(e) {
	return !!(e && e[MP] && !e[pc]);
}
i(jP, 'isImmutableUnorderedKeyed');
function DP(e) {
	return !!(e && e[qP] && !e[pc]);
}
i(DP, 'isImmutableUnorderedSet');
function Ia(e) {
	return e != null && typeof e == 'object' && !Array.isArray(e);
}
i(Ia, 'isObjectLiteral');
function kP(e) {
	return !!(e && Ia(e) && e[UU]);
}
i(kP, 'isImmutableList');
function LP(e) {
	return !!(e && Ia(e) && e[MP] && e[pc]);
}
i(LP, 'isImmutableOrderedKeyed');
function FP(e) {
	return !!(e && Ia(e) && e[qP] && e[pc]);
}
i(FP, 'isImmutableOrderedSet');
function BP(e) {
	return !!(e && Ia(e) && e[VU]);
}
i(BP, 'isImmutableRecord');
var JP = Symbol.iterator;
function xp(e) {
	return !!(e != null && e[JP]);
}
i(xp, 'hasIterator');
function Gt(e, t, r = [], n = [], o = []) {
	if (
		typeof e != 'object' ||
		typeof t != 'object' ||
		Array.isArray(e) ||
		Array.isArray(t) ||
		!xp(e) ||
		!xp(t)
	)
		return;
	if (e.constructor !== t.constructor) return !1;
	let s = n.length;
	for (; s--; ) if (n[s] === e) return o[s] === t;
	(n.push(e), o.push(t));
	const a = [...r.filter((d) => d !== Gt), u];
	function u(d, p) {
		return Gt(d, p, [...r], [...n], [...o]);
	}
	if ((i(u, 'iterableEqualityWithStack'), e.size !== void 0)) {
		if (e.size !== t.size) return !1;
		if (or('Set', e) || DP(e)) {
			let d = !0;
			for (const p of e)
				if (!t.has(p)) {
					let f = !1;
					for (const m of t) Oe(p, m, a) === !0 && (f = !0);
					if (f === !1) {
						d = !1;
						break;
					}
				}
			return (n.pop(), o.pop(), d);
		} else if (or('Map', e) || jP(e)) {
			let d = !0;
			for (const p of e)
				if (!t.has(p[0]) || !Oe(p[1], t.get(p[0]), a)) {
					let f = !1;
					for (const m of t) {
						const y = Oe(p[0], m[0], a);
						let g = !1;
						(y === !0 && (g = Oe(p[1], m[1], a)), g === !0 && (f = !0));
					}
					if (f === !1) {
						d = !1;
						break;
					}
				}
			return (n.pop(), o.pop(), d);
		}
	}
	const c = t[JP]();
	for (const d of e) {
		const p = c.next();
		if (p.done || !Oe(d, p.value, a)) return !1;
	}
	if (!c.next().done) return !1;
	if (!kP(e) && !LP(e) && !FP(e) && !BP(e)) {
		const d = Object.entries(e),
			p = Object.entries(t);
		if (!Oe(d, p, a)) return !1;
	}
	return (n.pop(), o.pop(), !0);
}
i(Gt, 'iterableEquality');
function fc(e, t) {
	return !e || typeof e != 'object' || e === Object.prototype
		? !1
		: Object.prototype.hasOwnProperty.call(e, t) || fc(Object.getPrototypeOf(e), t);
}
i(fc, 'hasPropertyInObject');
function $P(e) {
	return xs(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
i($P, 'isObjectWithKeys');
function qi(e, t, r = []) {
	const n = r.filter((s) => s !== qi),
		o = i(
			(s = new WeakMap()) =>
				(a, u) => {
					if ($P(u))
						return Object.keys(u).every((c) => {
							if (u[c] != null && typeof u[c] == 'object') {
								if (s.has(u[c])) return Oe(a[c], u[c], n);
								s.set(u[c], !0);
							}
							const d = a != null && fc(a, c) && Oe(a[c], u[c], [...n, o(s)]);
							return (s.delete(u[c]), d);
						});
				},
			'subsetEqualityWithContext'
		);
	return o()(e, t);
}
i(qi, 'subsetEquality');
function Ip(e, t) {
	if (!(e == null || t == null || e.constructor === t.constructor)) return !1;
}
i(Ip, 'typeEquality');
function Np(e, t) {
	let r = e,
		n = t;
	if (!(e instanceof DataView && t instanceof DataView)) {
		if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer)) return;
		try {
			((r = new DataView(e)), (n = new DataView(t)));
		} catch {
			return;
		}
	}
	if (r.byteLength !== n.byteLength) return !1;
	for (let o = 0; o < r.byteLength; o++) if (r.getUint8(o) !== n.getUint8(o)) return !1;
	return !0;
}
i(Np, 'arrayBufferEquality');
function Ul(e, t, r = []) {
	if (!Array.isArray(e) || !Array.isArray(t)) return;
	const n = Object.keys(e),
		o = Object.keys(t),
		s = r.filter((a) => a !== Ul);
	return Oe(e, t, s, !0) && Oe(n, o);
}
i(Ul, 'sparseArrayEquality');
function UP(e, t = '#{this}', r = '#{exp}') {
	const n = `expected ${t} to be ${r} // Object.is equality`;
	return ['toStrictEqual', 'toEqual'].includes(e)
		? `${n}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
`
		: n;
}
i(UP, 'generateToBeMessage');
function VP(e, t) {
	return `${t} ${e}${t === 1 ? '' : 's'}`;
}
i(VP, 'pluralize');
function Za(e) {
	return [
		...Object.keys(e),
		...Object.getOwnPropertySymbols(e).filter((t) => {
			var r;
			return (r = Object.getOwnPropertyDescriptor(e, t)) === null || r === void 0
				? void 0
				: r.enumerable;
		})
	];
}
i(Za, 'getObjectKeys');
function HP(e, t, r) {
	let n = 0;
	const o = i(
		(s = new WeakMap()) =>
			(a, u) => {
				if (Array.isArray(a)) {
					if (Array.isArray(u) && u.length === a.length) return u.map((c, d) => o(s)(a[d], c));
				} else {
					if (a instanceof Date) return a;
					if (xs(a) && xs(u)) {
						if (Oe(a, u, [...r, Gt, qi])) return u;
						const c = {};
						(s.set(a, c),
							typeof a.constructor == 'function' &&
								typeof a.constructor.name == 'string' &&
								Object.defineProperty(c, 'constructor', { enumerable: !1, value: a.constructor }));
						for (const d of Za(a))
							fc(u, d)
								? (c[d] = s.has(a[d]) ? s.get(a[d]) : o(s)(a[d], u[d]))
								: s.has(a[d]) || ((n += 1), xs(a[d]) && (n += Za(a[d]).length), o(s)(a[d], u[d]));
						if (Za(c).length > 0) return c;
					}
				}
				return a;
			},
		'getObjectSubsetWithContext'
	);
	return { subset: o()(e, t), stripped: n };
}
i(HP, 'getObjectSubset');
if (!Object.prototype.hasOwnProperty.call(globalThis, ea)) {
	const e = new WeakMap();
	Object.defineProperty(globalThis, ea, { get: i(() => e, 'get') });
}
if (!Object.prototype.hasOwnProperty.call(globalThis, ta)) {
	const e = Object.create(null),
		t = [];
	Object.defineProperty(globalThis, ta, {
		configurable: !0,
		get: i(
			() => ({ state: globalThis[ea].get(globalThis[Sy]), matchers: e, customEqualityTesters: t }),
			'get'
		)
	});
}
if (!Object.prototype.hasOwnProperty.call(globalThis, Pp)) {
	const e = Object.create(null);
	Object.defineProperty(globalThis, Pp, { get: i(() => e, 'get') });
}
function ra(e) {
	return globalThis[ea].get(e);
}
i(ra, 'getState');
function el(e, t) {
	const r = globalThis[ea],
		n = r.get(t) || {},
		o = Object.defineProperties(n, {
			...Object.getOwnPropertyDescriptors(n),
			...Object.getOwnPropertyDescriptors(e)
		});
	r.set(t, o);
}
i(el, 'setState');
var GP = class {
	$$typeof = Symbol.for('jest.asymmetricMatcher');
	constructor(t, r = !1) {
		((this.sample = t), (this.inverse = r));
	}
	getMatcherContext(t) {
		return {
			...ra(t || globalThis[Sy]),
			equals: Oe,
			isNot: this.inverse,
			customTesters: dc(),
			utils: { ...Ay(), diff: Oo, stringify: jt, iterableEquality: Gt, subsetEquality: qi }
		};
	}
};
i(GP, 'AsymmetricMatcher');
var ln = GP;
ln.prototype[Symbol.for('chai/inspect')] = function (e) {
	const t = jt(this, e.depth, { min: !0 });
	return t.length <= e.truncate ? t : `${this.toString()}{}`;
};
var zP = class extends ln {
	constructor(t, r = !1) {
		if (!or('String', t)) throw new Error('Expected is not a string');
		super(t, r);
	}
	asymmetricMatch(t) {
		const r = or('String', t) && t.includes(this.sample);
		return this.inverse ? !r : r;
	}
	toString() {
		return `String${this.inverse ? 'Not' : ''}Containing`;
	}
	getExpectedType() {
		return 'string';
	}
};
i(zP, 'StringContaining');
var dv = zP,
	WP = class extends ln {
		asymmetricMatch(t) {
			return t != null;
		}
		toString() {
			return 'Anything';
		}
		toAsymmetricMatcher() {
			return 'Anything';
		}
	};
i(WP, 'Anything');
var HU = WP,
	KP = class extends ln {
		constructor(t, r = !1) {
			super(t, r);
		}
		getPrototype(t) {
			return Object.getPrototypeOf
				? Object.getPrototypeOf(t)
				: t.constructor.prototype === t
					? null
					: t.constructor.prototype;
		}
		hasProperty(t, r) {
			return t
				? Object.prototype.hasOwnProperty.call(t, r)
					? !0
					: this.hasProperty(this.getPrototype(t), r)
				: !1;
		}
		asymmetricMatch(t) {
			if (typeof this.sample != 'object')
				throw new TypeError(
					`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`
				);
			let r = !0;
			const n = this.getMatcherContext();
			for (const o in this.sample)
				if (!this.hasProperty(t, o) || !Oe(this.sample[o], t[o], n.customTesters)) {
					r = !1;
					break;
				}
			return this.inverse ? !r : r;
		}
		toString() {
			return `Object${this.inverse ? 'Not' : ''}Containing`;
		}
		getExpectedType() {
			return 'object';
		}
	};
i(KP, 'ObjectContaining');
var pv = KP,
	YP = class extends ln {
		constructor(t, r = !1) {
			super(t, r);
		}
		asymmetricMatch(t) {
			if (!Array.isArray(this.sample))
				throw new TypeError(
					`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`
				);
			const r = this.getMatcherContext(),
				n =
					this.sample.length === 0 ||
					(Array.isArray(t) && this.sample.every((o) => t.some((s) => Oe(o, s, r.customTesters))));
			return this.inverse ? !n : n;
		}
		toString() {
			return `Array${this.inverse ? 'Not' : ''}Containing`;
		}
		getExpectedType() {
			return 'array';
		}
	};
i(YP, 'ArrayContaining');
var fv = YP,
	XP = class extends ln {
		constructor(t) {
			if (typeof t > 'u')
				throw new TypeError(
					'any() expects to be passed a constructor function. Please pass one or use anything() to match any object.'
				);
			super(t);
		}
		fnNameFor(t) {
			if (t.name) return t.name;
			const n = Function.prototype.toString
				.call(t)
				.match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
			return n ? n[1] : '<anonymous>';
		}
		asymmetricMatch(t) {
			return this.sample === String
				? typeof t == 'string' || t instanceof String
				: this.sample === Number
					? typeof t == 'number' || t instanceof Number
					: this.sample === Function
						? typeof t == 'function' || typeof t == 'function'
						: this.sample === Boolean
							? typeof t == 'boolean' || t instanceof Boolean
							: this.sample === BigInt
								? typeof t == 'bigint' || t instanceof BigInt
								: this.sample === Symbol
									? typeof t == 'symbol' || t instanceof Symbol
									: this.sample === Object
										? typeof t == 'object'
										: t instanceof this.sample;
		}
		toString() {
			return 'Any';
		}
		getExpectedType() {
			return this.sample === String
				? 'string'
				: this.sample === Number
					? 'number'
					: this.sample === Function
						? 'function'
						: this.sample === Object
							? 'object'
							: this.sample === Boolean
								? 'boolean'
								: this.fnNameFor(this.sample);
		}
		toAsymmetricMatcher() {
			return `Any<${this.fnNameFor(this.sample)}>`;
		}
	};
i(XP, 'Any');
var GU = XP,
	QP = class extends ln {
		constructor(t, r = !1) {
			if (!or('String', t) && !or('RegExp', t))
				throw new Error('Expected is not a String or a RegExp');
			super(new RegExp(t), r);
		}
		asymmetricMatch(t) {
			const r = or('String', t) && this.sample.test(t);
			return this.inverse ? !r : r;
		}
		toString() {
			return `String${this.inverse ? 'Not' : ''}Matching`;
		}
		getExpectedType() {
			return 'string';
		}
	};
i(QP, 'StringMatching');
var mv = QP,
	ZP = class extends ln {
		precision;
		constructor(t, r = 2, n = !1) {
			if (!or('Number', t)) throw new Error('Expected is not a Number');
			if (!or('Number', r)) throw new Error('Precision is not a Number');
			(super(t), (this.inverse = n), (this.precision = r));
		}
		asymmetricMatch(t) {
			if (!or('Number', t)) return !1;
			let r = !1;
			return (
				(t === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) ||
				(t === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY)
					? (r = !0)
					: (r = Math.abs(this.sample - t) < 10 ** -this.precision / 2),
				this.inverse ? !r : r
			);
		}
		toString() {
			return `Number${this.inverse ? 'Not' : ''}CloseTo`;
		}
		getExpectedType() {
			return 'number';
		}
		toAsymmetricMatcher() {
			return [this.toString(), this.sample, `(${VP('digit', this.precision)})`].join(' ');
		}
	};
i(ZP, 'CloseTo');
var hv = ZP,
	zU = i((e, t) => {
		(t.addMethod(e.expect, 'anything', () => new HU()),
			t.addMethod(e.expect, 'any', (r) => new GU(r)),
			t.addMethod(e.expect, 'stringContaining', (r) => new dv(r)),
			t.addMethod(e.expect, 'objectContaining', (r) => new pv(r)),
			t.addMethod(e.expect, 'arrayContaining', (r) => new fv(r)),
			t.addMethod(e.expect, 'stringMatching', (r) => new mv(r)),
			t.addMethod(e.expect, 'closeTo', (r, n) => new hv(r, n)),
			(e.expect.not = {
				stringContaining: i((r) => new dv(r, !0), 'stringContaining'),
				objectContaining: i((r) => new pv(r, !0), 'objectContaining'),
				arrayContaining: i((r) => new fv(r, !0), 'arrayContaining'),
				stringMatching: i((r) => new mv(r, !0), 'stringMatching'),
				closeTo: i((r, n) => new hv(r, n, !0), 'closeTo')
			}));
	}, 'JestAsymmetricMatchers');
function Mp(e, t, r) {
	const n = e.flag(t, 'negate') ? 'not.' : '',
		o = `${e.flag(t, '_name')}(${r ? 'expected' : ''})`,
		s = e.flag(t, 'promise');
	return `expect(actual)${s ? `.${s}` : ''}.${n}${o}`;
}
i(Mp, 'createAssertionMessage');
function qp(e, t, r, n) {
	const o = e;
	if (o && t instanceof Promise) {
		((t = t.finally(() => {
			if (!o.promises) return;
			const a = o.promises.indexOf(t);
			a !== -1 && o.promises.splice(a, 1);
		})),
			o.promises || (o.promises = []),
			o.promises.push(t));
		let s = !1;
		return (
			o.onFinished ?? (o.onFinished = []),
			o.onFinished.push(() => {
				if (!s) {
					var a;
					const c = (
						((a = globalThis.__vitest_worker__) === null || a === void 0
							? void 0
							: a.onFilterStackTrace) || ((d) => d || '')
					)(n.stack);
					console.warn(
						[
							`Promise returned by \`${r}\` was not awaited. `,
							'Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ',
							`Please remember to await the assertion.
`,
							c
						].join('')
					);
				}
			}),
			{
				then(a, u) {
					return ((s = !0), t.then(a, u));
				},
				catch(a) {
					return t.catch(a);
				},
				finally(a) {
					return t.finally(a);
				},
				[Symbol.toStringTag]: 'Promise'
			}
		);
	}
	return t;
}
i(qp, 'recordAsyncExpect');
function jp(e, t) {
	var r;
	(e.result || (e.result = { state: 'fail' }),
		(e.result.state = 'fail'),
		(r = e.result).errors || (r.errors = []),
		e.result.errors.push(Ou(t)));
}
i(jp, 'handleTestError');
function Cy(e, t, r) {
	return function (...n) {
		if ((t !== 'withTest' && e.flag(this, '_name', t), !e.flag(this, 'soft')))
			return r.apply(this, n);
		const o = e.flag(this, 'vitest-test');
		if (!o) throw new Error('expect.soft() can only be used inside a test');
		try {
			const s = r.apply(this, n);
			return s && typeof s == 'object' && typeof s.then == 'function'
				? s.then(YS, (a) => {
						jp(o, a);
					})
				: s;
		} catch (s) {
			jp(o, s);
		}
	};
}
i(Cy, 'wrapAssertion');
var WU = i((e, t) => {
	const { AssertionError: r } = e,
		n = dc();
	function o(d, p) {
		const f = i((m) => {
			const y = Cy(t, m, p);
			(t.addMethod(e.Assertion.prototype, m, y), t.addMethod(globalThis[ta].matchers, m, y));
		}, 'addMethod');
		Array.isArray(d) ? d.forEach((m) => f(m)) : f(d);
	}
	(i(o, 'def'),
		['throw', 'throws', 'Throw'].forEach((d) => {
			t.overwriteMethod(
				e.Assertion.prototype,
				d,
				(p) =>
					function (...f) {
						const m = t.flag(this, 'promise'),
							y = t.flag(this, 'object'),
							g = t.flag(this, 'negate');
						if (m === 'rejects')
							t.flag(this, 'object', () => {
								throw y;
							});
						else if (m === 'resolves' && typeof y != 'function') {
							if (g) return;
							{
								const E =
										t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
									T = { showDiff: !1 };
								throw new r(E, T, t.flag(this, 'ssfi'));
							}
						}
						p.apply(this, f);
					}
			);
		}),
		o('withTest', function (d) {
			return (t.flag(this, 'vitest-test', d), this);
		}),
		o('toEqual', function (d) {
			const p = t.flag(this, 'object'),
				f = Oe(p, d, [...n, Gt]);
			return this.assert(
				f,
				'expected #{this} to deeply equal #{exp}',
				'expected #{this} to not deeply equal #{exp}',
				d,
				p
			);
		}),
		o('toStrictEqual', function (d) {
			const p = t.flag(this, 'object'),
				f = Oe(p, d, [...n, Gt, Ip, Ul, Np], !0);
			return this.assert(
				f,
				'expected #{this} to strictly equal #{exp}',
				'expected #{this} to not strictly equal #{exp}',
				d,
				p
			);
		}),
		o('toBe', function (d) {
			const p = this._obj,
				f = Object.is(p, d);
			let m = '';
			return (
				f ||
					(Oe(p, d, [...n, Gt, Ip, Ul, Np], !0)
						? (m = 'toStrictEqual')
						: Oe(p, d, [...n, Gt]) && (m = 'toEqual')),
				this.assert(f, UP(m), 'expected #{this} not to be #{exp} // Object.is equality', d, p)
			);
		}),
		o('toMatchObject', function (d) {
			const p = this._obj,
				f = Oe(p, d, [...n, Gt, qi]),
				m = t.flag(this, 'negate'),
				{ subset: y, stripped: g } = HP(p, d, n);
			if ((f && m) || (!f && !m)) {
				const E = t.getMessage(this, [
						f,
						'expected #{this} to match object #{exp}',
						'expected #{this} to not match object #{exp}',
						d,
						y,
						!1
					]),
					T =
						g === 0
							? E
							: `${E}
(${g} matching ${g === 1 ? 'property' : 'properties'} omitted from actual)`;
				throw new r(T, { showDiff: !0, expected: d, actual: y });
			}
		}),
		o('toMatch', function (d) {
			const p = this._obj;
			if (typeof p != 'string')
				throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof p}`);
			return this.assert(
				typeof d == 'string' ? p.includes(d) : p.match(d),
				'expected #{this} to match #{exp}',
				'expected #{this} not to match #{exp}',
				d,
				p
			);
		}),
		o('toContain', function (d) {
			const p = this._obj;
			if (typeof Node < 'u' && p instanceof Node) {
				if (!(d instanceof Node))
					throw new TypeError(
						`toContain() expected a DOM node as the argument, but got ${typeof d}`
					);
				return this.assert(
					p.contains(d),
					'expected #{this} to contain element #{exp}',
					'expected #{this} not to contain element #{exp}',
					d,
					p
				);
			}
			if (typeof DOMTokenList < 'u' && p instanceof DOMTokenList) {
				_r(d, 'class name', ['string']);
				const m = t.flag(this, 'negate') ? p.value.replace(d, '').trim() : `${p.value} ${d}`;
				return this.assert(
					p.contains(d),
					`expected "${p.value}" to contain "${d}"`,
					`expected "${p.value}" not to contain "${d}"`,
					m,
					p.value
				);
			}
			return typeof p == 'string' && typeof d == 'string'
				? this.assert(
						p.includes(d),
						'expected #{this} to contain #{exp}',
						'expected #{this} not to contain #{exp}',
						d,
						p
					)
				: (p != null && typeof p != 'string' && t.flag(this, 'object', Array.from(p)),
					this.contain(d));
		}),
		o('toContainEqual', function (d) {
			const p = t.flag(this, 'object'),
				f = Array.from(p).findIndex((m) => Oe(m, d, n));
			this.assert(
				f !== -1,
				'expected #{this} to deep equally contain #{exp}',
				'expected #{this} to not deep equally contain #{exp}',
				d
			);
		}),
		o('toBeTruthy', function () {
			const d = t.flag(this, 'object');
			this.assert(!!d, 'expected #{this} to be truthy', 'expected #{this} to not be truthy', !0, d);
		}),
		o('toBeFalsy', function () {
			const d = t.flag(this, 'object');
			this.assert(!d, 'expected #{this} to be falsy', 'expected #{this} to not be falsy', !1, d);
		}),
		o('toBeGreaterThan', function (d) {
			const p = this._obj;
			return (
				_r(p, 'actual', ['number', 'bigint']),
				_r(d, 'expected', ['number', 'bigint']),
				this.assert(
					p > d,
					`expected ${p} to be greater than ${d}`,
					`expected ${p} to be not greater than ${d}`,
					d,
					p,
					!1
				)
			);
		}),
		o('toBeGreaterThanOrEqual', function (d) {
			const p = this._obj;
			return (
				_r(p, 'actual', ['number', 'bigint']),
				_r(d, 'expected', ['number', 'bigint']),
				this.assert(
					p >= d,
					`expected ${p} to be greater than or equal to ${d}`,
					`expected ${p} to be not greater than or equal to ${d}`,
					d,
					p,
					!1
				)
			);
		}),
		o('toBeLessThan', function (d) {
			const p = this._obj;
			return (
				_r(p, 'actual', ['number', 'bigint']),
				_r(d, 'expected', ['number', 'bigint']),
				this.assert(
					p < d,
					`expected ${p} to be less than ${d}`,
					`expected ${p} to be not less than ${d}`,
					d,
					p,
					!1
				)
			);
		}),
		o('toBeLessThanOrEqual', function (d) {
			const p = this._obj;
			return (
				_r(p, 'actual', ['number', 'bigint']),
				_r(d, 'expected', ['number', 'bigint']),
				this.assert(
					p <= d,
					`expected ${p} to be less than or equal to ${d}`,
					`expected ${p} to be not less than or equal to ${d}`,
					d,
					p,
					!1
				)
			);
		}),
		o('toBeNaN', function () {
			const d = t.flag(this, 'object');
			this.assert(
				Number.isNaN(d),
				'expected #{this} to be NaN',
				'expected #{this} not to be NaN',
				Number.NaN,
				d
			);
		}),
		o('toBeUndefined', function () {
			const d = t.flag(this, 'object');
			this.assert(
				d === void 0,
				'expected #{this} to be undefined',
				'expected #{this} not to be undefined',
				void 0,
				d
			);
		}),
		o('toBeNull', function () {
			const d = t.flag(this, 'object');
			this.assert(
				d === null,
				'expected #{this} to be null',
				'expected #{this} not to be null',
				null,
				d
			);
		}),
		o('toBeDefined', function () {
			const d = t.flag(this, 'object');
			this.assert(
				typeof d < 'u',
				'expected #{this} to be defined',
				'expected #{this} to be undefined',
				d
			);
		}),
		o('toBeTypeOf', function (d) {
			const p = typeof this._obj,
				f = d === p;
			return this.assert(
				f,
				'expected #{this} to be type of #{exp}',
				'expected #{this} not to be type of #{exp}',
				d,
				p
			);
		}),
		o('toBeInstanceOf', function (d) {
			return this.instanceOf(d);
		}),
		o('toHaveLength', function (d) {
			return this.have.length(d);
		}),
		o('toHaveProperty', function (...d) {
			Array.isArray(d[0]) &&
				(d[0] = d[0].map((w) => String(w).replace(/([.[\]])/g, '\\$1')).join('.'));
			const p = this._obj,
				[f, m] = d,
				y = i(
					() =>
						Object.prototype.hasOwnProperty.call(p, f)
							? { value: p[f], exists: !0 }
							: t.getPathInfo(p, f),
					'getValue'
				),
				{ value: g, exists: E } = y(),
				T = E && (d.length === 1 || Oe(m, g, n)),
				b = d.length === 1 ? '' : ` with value ${t.objDisplay(m)}`;
			return this.assert(
				T,
				`expected #{this} to have property "${f}"${b}`,
				`expected #{this} to not have property "${f}"${b}`,
				m,
				E ? g : void 0
			);
		}),
		o('toBeCloseTo', function (d, p = 2) {
			const f = this._obj;
			let m = !1,
				y = 0,
				g = 0;
			return (
				(d === Number.POSITIVE_INFINITY && f === Number.POSITIVE_INFINITY) ||
				(d === Number.NEGATIVE_INFINITY && f === Number.NEGATIVE_INFINITY)
					? (m = !0)
					: ((y = 10 ** -p / 2), (g = Math.abs(f - d)), (m = g < y)),
				this.assert(
					m,
					`expected #{this} to be close to #{exp}, received difference is ${g}, but expected ${y}`,
					`expected #{this} to not be close to #{exp}, received difference is ${g}, but expected ${y}`,
					d,
					f,
					!1
				)
			);
		}));
	function s(d) {
		if (!so(d._obj)) throw new TypeError(`${t.inspect(d._obj)} is not a spy or a call to a spy!`);
	}
	i(s, 'assertIsMock');
	function a(d) {
		return (s(d), d._obj);
	}
	(i(a, 'getSpy'),
		o(['toHaveBeenCalledTimes', 'toBeCalledTimes'], function (d) {
			const p = a(this),
				f = p.getMockName(),
				m = p.mock.calls.length;
			return this.assert(
				m === d,
				`expected "${f}" to be called #{exp} times, but got ${m} times`,
				`expected "${f}" to not be called #{exp} times`,
				d,
				m,
				!1
			);
		}),
		o('toHaveBeenCalledOnce', function () {
			const d = a(this),
				p = d.getMockName(),
				f = d.mock.calls.length;
			return this.assert(
				f === 1,
				`expected "${p}" to be called once, but got ${f} times`,
				`expected "${p}" to not be called once`,
				1,
				f,
				!1
			);
		}),
		o(['toHaveBeenCalled', 'toBeCalled'], function () {
			const d = a(this),
				p = d.getMockName(),
				f = d.mock.calls.length,
				m = f > 0,
				y = t.flag(this, 'negate');
			let g = t.getMessage(this, [
				m,
				`expected "${p}" to be called at least once`,
				`expected "${p}" to not be called at all, but actually been called ${f} times`,
				!0,
				m
			]);
			if ((m && y && (g = tl(d, g)), (m && y) || (!m && !y))) throw new r(g);
		}));
	function u(d, p) {
		return d.length === p.length && d.every((f, m) => Oe(f, p[m], [...n, Gt]));
	}
	(i(u, 'equalsArgumentArray'),
		o(['toHaveBeenCalledWith', 'toBeCalledWith'], function (...d) {
			const p = a(this),
				f = p.getMockName(),
				m = p.mock.calls.some((E) => u(E, d)),
				y = t.flag(this, 'negate'),
				g = t.getMessage(this, [
					m,
					`expected "${f}" to be called with arguments: #{exp}`,
					`expected "${f}" to not be called with arguments: #{exp}`,
					d
				]);
			if ((m && y) || (!m && !y)) throw new r(tl(p, g, d));
		}),
		o('toHaveBeenCalledExactlyOnceWith', function (...d) {
			const p = a(this),
				f = p.getMockName(),
				m = p.mock.calls.length,
				g = p.mock.calls.some((b) => u(b, d)) && m === 1,
				E = t.flag(this, 'negate'),
				T = t.getMessage(this, [
					g,
					`expected "${f}" to be called once with arguments: #{exp}`,
					`expected "${f}" to not be called once with arguments: #{exp}`,
					d
				]);
			if ((g && E) || (!g && !E)) throw new r(tl(p, T, d));
		}),
		o(['toHaveBeenNthCalledWith', 'nthCalledWith'], function (d, ...p) {
			const f = a(this),
				m = f.getMockName(),
				y = f.mock.calls[d - 1],
				g = f.mock.calls.length,
				E = d <= g;
			this.assert(
				y && u(y, p),
				`expected ${Zo(d)} "${m}" call to have been called with #{exp}${E ? '' : `, but called only ${g} times`}`,
				`expected ${Zo(d)} "${m}" call to not have been called with #{exp}`,
				p,
				y,
				E
			);
		}),
		o(['toHaveBeenLastCalledWith', 'lastCalledWith'], function (...d) {
			const p = a(this),
				f = p.getMockName(),
				m = p.mock.calls[p.mock.calls.length - 1];
			this.assert(
				m && u(m, d),
				`expected last "${f}" call to have been called with #{exp}`,
				`expected last "${f}" call to not have been called with #{exp}`,
				d,
				m
			);
		}));
	function c(d, p, f) {
		const m = d.mock.invocationCallOrder,
			y = p.mock.invocationCallOrder;
		return m.length === 0 ? !f : y.length === 0 ? !1 : m[0] < y[0];
	}
	(i(c, 'isSpyCalledBeforeAnotherSpy'),
		o(['toHaveBeenCalledBefore'], function (d, p = !0) {
			const f = a(this);
			if (!so(d)) throw new TypeError(`${t.inspect(d)} is not a spy or a call to a spy`);
			this.assert(
				c(f, d, p),
				`expected "${f.getMockName()}" to have been called before "${d.getMockName()}"`,
				`expected "${f.getMockName()}" to not have been called before "${d.getMockName()}"`,
				d,
				f
			);
		}),
		o(['toHaveBeenCalledAfter'], function (d, p = !0) {
			const f = a(this);
			if (!so(d)) throw new TypeError(`${t.inspect(d)} is not a spy or a call to a spy`);
			this.assert(
				c(d, f, p),
				`expected "${f.getMockName()}" to have been called after "${d.getMockName()}"`,
				`expected "${f.getMockName()}" to not have been called after "${d.getMockName()}"`,
				d,
				f
			);
		}),
		o(['toThrow', 'toThrowError'], function (d) {
			if (typeof d == 'string' || typeof d > 'u' || d instanceof RegExp)
				return this.throws(d === '' ? /^$/ : d);
			const p = this._obj,
				f = t.flag(this, 'promise'),
				m = t.flag(this, 'negate');
			let y = null;
			if (f === 'rejects') y = p;
			else if (f === 'resolves' && typeof p != 'function') {
				if (m) return;
				{
					const g = t.flag(this, 'message') || "expected promise to throw an error, but it didn't",
						E = { showDiff: !1 };
					throw new r(g, E, t.flag(this, 'ssfi'));
				}
			} else {
				let g = !1;
				try {
					p();
				} catch (E) {
					((g = !0), (y = E));
				}
				if (!g && !m) {
					const E = t.flag(this, 'message') || "expected function to throw an error, but it didn't",
						T = { showDiff: !1 };
					throw new r(E, T, t.flag(this, 'ssfi'));
				}
			}
			if (typeof d == 'function') {
				const g = d.name || d.prototype.constructor.name;
				return this.assert(
					y && y instanceof d,
					`expected error to be instance of ${g}`,
					`expected error not to be instance of ${g}`,
					d,
					y
				);
			}
			if (d instanceof Error) {
				const g = Oe(y, d, [...n, Gt]);
				return this.assert(
					g,
					'expected a thrown error to be #{exp}',
					'expected a thrown error not to be #{exp}',
					d,
					y
				);
			}
			if (
				typeof d == 'object' &&
				'asymmetricMatch' in d &&
				typeof d.asymmetricMatch == 'function'
			) {
				const g = d;
				return this.assert(
					y && g.asymmetricMatch(y),
					'expected error to match asymmetric matcher',
					'expected error not to match asymmetric matcher',
					g,
					y
				);
			}
			throw new Error(
				`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof d}"`
			);
		}),
		[
			{
				name: 'toHaveResolved',
				condition: i(
					(d) =>
						d.mock.settledResults.length > 0 &&
						d.mock.settledResults.some(({ type: p }) => p === 'fulfilled'),
					'condition'
				),
				action: 'resolved'
			},
			{
				name: ['toHaveReturned', 'toReturn'],
				condition: i(
					(d) => d.mock.calls.length > 0 && d.mock.results.some(({ type: p }) => p !== 'throw'),
					'condition'
				),
				action: 'called'
			}
		].forEach(({ name: d, condition: p, action: f }) => {
			o(d, function () {
				const m = a(this),
					y = m.getMockName(),
					g = p(m);
				this.assert(
					g,
					`expected "${y}" to be successfully ${f} at least once`,
					`expected "${y}" to not be successfully ${f}`,
					g,
					!g,
					!1
				);
			});
		}),
		[
			{
				name: 'toHaveResolvedTimes',
				condition: i(
					(d, p) =>
						d.mock.settledResults.reduce((f, { type: m }) => (m === 'fulfilled' ? ++f : f), 0) ===
						p,
					'condition'
				),
				action: 'resolved'
			},
			{
				name: ['toHaveReturnedTimes', 'toReturnTimes'],
				condition: i(
					(d, p) => d.mock.results.reduce((f, { type: m }) => (m === 'throw' ? f : ++f), 0) === p,
					'condition'
				),
				action: 'called'
			}
		].forEach(({ name: d, condition: p, action: f }) => {
			o(d, function (m) {
				const y = a(this),
					g = y.getMockName(),
					E = p(y, m);
				this.assert(
					E,
					`expected "${g}" to be successfully ${f} ${m} times`,
					`expected "${g}" to not be successfully ${f} ${m} times`,
					`expected resolved times: ${m}`,
					`received resolved times: ${E}`,
					!1
				);
			});
		}),
		[
			{
				name: 'toHaveResolvedWith',
				condition: i(
					(d, p) =>
						d.mock.settledResults.some(({ type: f, value: m }) => f === 'fulfilled' && Oe(p, m)),
					'condition'
				),
				action: 'resolve'
			},
			{
				name: ['toHaveReturnedWith', 'toReturnWith'],
				condition: i(
					(d, p) => d.mock.results.some(({ type: f, value: m }) => f === 'return' && Oe(p, m)),
					'condition'
				),
				action: 'return'
			}
		].forEach(({ name: d, condition: p, action: f }) => {
			o(d, function (m) {
				const y = a(this),
					g = p(y, m),
					E = t.flag(this, 'negate');
				if ((g && E) || (!g && !E)) {
					const T = y.getMockName(),
						b = t.getMessage(this, [
							g,
							`expected "${T}" to ${f} with: #{exp} at least once`,
							`expected "${T}" to not ${f} with: #{exp}`,
							m
						]),
						w = f === 'return' ? y.mock.results : y.mock.settledResults;
					throw new r(eA(y, w, b, m));
				}
			});
		}),
		[
			{
				name: 'toHaveLastResolvedWith',
				condition: i((d, p) => {
					const f = d.mock.settledResults[d.mock.settledResults.length - 1];
					return f && f.type === 'fulfilled' && Oe(f.value, p);
				}, 'condition'),
				action: 'resolve'
			},
			{
				name: ['toHaveLastReturnedWith', 'lastReturnedWith'],
				condition: i((d, p) => {
					const f = d.mock.results[d.mock.results.length - 1];
					return f && f.type === 'return' && Oe(f.value, p);
				}, 'condition'),
				action: 'return'
			}
		].forEach(({ name: d, condition: p, action: f }) => {
			o(d, function (m) {
				const y = a(this),
					g = f === 'return' ? y.mock.results : y.mock.settledResults,
					E = g[g.length - 1],
					T = y.getMockName();
				this.assert(
					p(y, m),
					`expected last "${T}" call to ${f} #{exp}`,
					`expected last "${T}" call to not ${f} #{exp}`,
					m,
					E?.value
				);
			});
		}),
		[
			{
				name: 'toHaveNthResolvedWith',
				condition: i((d, p, f) => {
					const m = d.mock.settledResults[p - 1];
					return m && m.type === 'fulfilled' && Oe(m.value, f);
				}, 'condition'),
				action: 'resolve'
			},
			{
				name: ['toHaveNthReturnedWith', 'nthReturnedWith'],
				condition: i((d, p, f) => {
					const m = d.mock.results[p - 1];
					return m && m.type === 'return' && Oe(m.value, f);
				}, 'condition'),
				action: 'return'
			}
		].forEach(({ name: d, condition: p, action: f }) => {
			o(d, function (m, y) {
				const g = a(this),
					E = g.getMockName(),
					b = (f === 'return' ? g.mock.results : g.mock.settledResults)[m - 1],
					w = `${Zo(m)} call`;
				this.assert(
					p(g, m, y),
					`expected ${w} "${E}" call to ${f} #{exp}`,
					`expected ${w} "${E}" call to not ${f} #{exp}`,
					y,
					b?.value
				);
			});
		}),
		o('withContext', function (d) {
			for (const p in d) t.flag(this, p, d[p]);
			return this;
		}),
		t.addProperty(
			e.Assertion.prototype,
			'resolves',
			i(function () {
				const p = new Error('resolves');
				(t.flag(this, 'promise', 'resolves'), t.flag(this, 'error', p));
				const f = t.flag(this, 'vitest-test'),
					m = t.flag(this, 'object');
				if (t.flag(this, 'poll'))
					throw new SyntaxError('expect.poll() is not supported in combination with .resolves');
				if (typeof m?.then != 'function')
					throw new TypeError(
						`You must provide a Promise to expect() when using .resolves, not '${typeof m}'.`
					);
				const y = new Proxy(this, {
					get: i((g, E, T) => {
						const b = Reflect.get(g, E, T);
						return typeof b != 'function'
							? b instanceof e.Assertion
								? y
								: b
							: (...w) => {
									t.flag(this, '_name', E);
									const P = m.then(
										(I) => (t.flag(this, 'object', I), b.call(this, ...w)),
										(I) => {
											const q = new r(`promise rejected "${t.inspect(I)}" instead of resolving`, {
												showDiff: !1
											});
											throw ((q.cause = I), (q.stack = p.stack.replace(p.message, q.message)), q);
										}
									);
									return qp(f, P, Mp(t, this, !!w.length), p);
								};
					}, 'get')
				});
				return y;
			}, '__VITEST_RESOLVES__')
		),
		t.addProperty(
			e.Assertion.prototype,
			'rejects',
			i(function () {
				const p = new Error('rejects');
				(t.flag(this, 'promise', 'rejects'), t.flag(this, 'error', p));
				const f = t.flag(this, 'vitest-test'),
					m = t.flag(this, 'object'),
					y = typeof m == 'function' ? m() : m;
				if (t.flag(this, 'poll'))
					throw new SyntaxError('expect.poll() is not supported in combination with .rejects');
				if (typeof y?.then != 'function')
					throw new TypeError(
						`You must provide a Promise to expect() when using .rejects, not '${typeof y}'.`
					);
				const g = new Proxy(this, {
					get: i((E, T, b) => {
						const w = Reflect.get(E, T, b);
						return typeof w != 'function'
							? w instanceof e.Assertion
								? g
								: w
							: (...P) => {
									t.flag(this, '_name', T);
									const I = y.then(
										(q) => {
											const C = new r(`promise resolved "${t.inspect(q)}" instead of rejecting`, {
												showDiff: !0,
												expected: new Error('rejected promise'),
												actual: q
											});
											throw ((C.stack = p.stack.replace(p.message, C.message)), C);
										},
										(q) => (t.flag(this, 'object', q), w.call(this, ...P))
									);
									return qp(f, I, Mp(t, this, !!P.length), p);
								};
					}, 'get')
				});
				return g;
			}, '__VITEST_REJECTS__')
		));
}, 'JestChaiExpect');
function Zo(e) {
	const t = e % 10,
		r = e % 100;
	return t === 1 && r !== 11
		? `${e}st`
		: t === 2 && r !== 12
			? `${e}nd`
			: t === 3 && r !== 13
				? `${e}rd`
				: `${e}th`;
}
i(Zo, 'ordinalOf');
function tl(e, t, r) {
	return (
		e.mock.calls.length &&
			(t += Ke.gray(`

Received: 

${e.mock.calls.map((n, o) => {
	let s = Ke.bold(`  ${Zo(o + 1)} ${e.getMockName()} call:

`);
	return (
		r
			? (s += Oo(r, n, { omitAnnotationLines: !0 }))
			: (s += jt(n)
					.split(
						`
`
					)
					.map((a) => `    ${a}`).join(`
`)),
		(s += `
`),
		s
	);
}).join(`
`)}`)),
		(t += Ke.gray(`

Number of calls: ${Ke.bold(e.mock.calls.length)}
`)),
		t
	);
}
i(tl, 'formatCalls');
function eA(e, t, r, n) {
	return (
		t.length &&
			(r += Ke.gray(`

Received: 

${t.map((o, s) => {
	let a = Ke.bold(`  ${Zo(s + 1)} ${e.getMockName()} call return:

`);
	return (
		n
			? (a += Oo(n, o.value, { omitAnnotationLines: !0 }))
			: (a += jt(o)
					.split(
						`
`
					)
					.map((u) => `    ${u}`).join(`
`)),
		(a += `
`),
		a
	);
}).join(`
`)}`)),
		(r += Ke.gray(`

Number of calls: ${Ke.bold(e.mock.calls.length)}
`)),
		r
	);
}
i(eA, 'formatReturns');
function tA(e, t) {
	const r = e._obj,
		n = Rr.flag(e, 'negate'),
		o = Rr.flag(e, 'promise') || '',
		s = { ...Ay(), diff: Oo, stringify: jt, iterableEquality: Gt, subsetEquality: qi };
	return {
		state: {
			...ra(t),
			customTesters: dc(),
			isNot: n,
			utils: s,
			promise: o,
			equals: Oe,
			suppressedErrors: [],
			soft: Rr.flag(e, 'soft'),
			poll: Rr.flag(e, 'poll')
		},
		isNot: n,
		obj: r
	};
}
i(tA, 'getMatcherState');
var rA = class extends Error {
	constructor(t, r, n) {
		(super(t), (this.actual = r), (this.expected = n));
	}
};
i(rA, 'JestExtendError');
var yv = rA;
function nA(e, t, r) {
	return (n, o) => {
		Object.entries(r).forEach(([s, a]) => {
			function u(...m) {
				const { state: y, isNot: g, obj: E } = tA(this, t),
					T = a.call(y, E, ...m);
				if (T && typeof T == 'object' && typeof T.then == 'function')
					return T.then(({ pass: C, message: R, actual: _, expected: S }) => {
						if ((C && g) || (!C && !g)) throw new yv(R(), _, S);
					});
				const { pass: b, message: w, actual: P, expected: I } = T;
				if ((b && g) || (!b && !g)) throw new yv(w(), P, I);
			}
			i(u, 'expectWrapper');
			const c = Cy(o, s, u);
			(o.addMethod(globalThis[ta].matchers, s, c), o.addMethod(e.Assertion.prototype, s, c));
			const d = class extends ln {
				constructor(y = !1, ...g) {
					super(g, y);
				}
				asymmetricMatch(y) {
					const { pass: g } = a.call(this.getMatcherContext(t), y, ...this.sample);
					return this.inverse ? !g : g;
				}
				toString() {
					return `${this.inverse ? 'not.' : ''}${s}`;
				}
				getExpectedType() {
					return 'any';
				}
				toAsymmetricMatcher() {
					return `${this.toString()}<${this.sample.map((y) => jt(y)).join(', ')}>`;
				}
			};
			i(d, 'CustomMatcher');
			let p = d;
			const f = i((...m) => new p(!1, ...m), 'customMatcher');
			(Object.defineProperty(t, s, { configurable: !0, enumerable: !0, value: f, writable: !0 }),
				Object.defineProperty(t.not, s, {
					configurable: !0,
					enumerable: !0,
					value: i((...m) => new p(!0, ...m), 'value'),
					writable: !0
				}),
				Object.defineProperty(globalThis[Pp], s, {
					configurable: !0,
					enumerable: !0,
					value: f,
					writable: !0
				}));
		});
	};
}
i(nA, 'JestExtendPlugin');
var KU = i((e, t) => {
	t.addMethod(e.expect, 'extend', (r, n) => {
		oo(nA(e, r, n));
	});
}, 'JestExtend');
function oA() {
	(oo(KU), oo(WU), oo(zU));
	const e = i((n, o) => {
		const { assertionCalls: s } = ra(e);
		return (el({ assertionCalls: s + 1, soft: !1 }, e), _n(n, o));
	}, 'expect');
	(Object.assign(e, _n),
		(e.getState = () => ra(e)),
		(e.setState = (n) => el(n, e)),
		(e.extend = (n) => _n.extend(e, n)),
		(e.soft = (...n) => {
			const o = e(...n);
			return (e.setState({ soft: !0 }), o);
		}),
		e.extend(FU),
		(e.unreachable = (n) => {
			M.fail(`expected${n ? ` "${n}" ` : ' '}not to be reached`);
		}));
	function t(n) {
		const o = i(
			() =>
				new Error(
					`expected number of assertions to be ${n}, but got ${e.getState().assertionCalls}`
				),
			'errorGen'
		);
		('captureStackTrace' in Error &&
			typeof Error.captureStackTrace == 'function' &&
			Error.captureStackTrace(o(), t),
			e.setState({ expectedAssertionsNumber: n, expectedAssertionsNumberErrorGen: o }));
	}
	i(t, 'assertions');
	function r() {
		const n = new Error('expected any number of assertion, but got none');
		('captureStackTrace' in Error &&
			typeof Error.captureStackTrace == 'function' &&
			Error.captureStackTrace(n, r),
			e.setState({ isExpectingAssertions: !0, isExpectingAssertionsError: n }));
	}
	return (
		i(r, 'hasAssertions'),
		el(
			{
				assertionCalls: 0,
				isExpectingAssertions: !1,
				isExpectingAssertionsError: null,
				expectedAssertionsNumber: null,
				expectedAssertionsNumberErrorGen: null
			},
			e
		),
		Rr.addMethod(e, 'assertions', t),
		Rr.addMethod(e, 'hasAssertions', r),
		e.extend(D0),
		e
	);
}
i(oA, 'createExpect');
var iA = oA();
Object.defineProperty(globalThis, Sy, { value: iA, writable: !0, configurable: !0 });
function sA(e, t, r) {
	Object.defineProperty(e, t, r);
}
i(sA, 'f');
var rl = Symbol.for('tinyspy:spy'),
	YU = i((e) => {
		((e.called = !1),
			(e.callCount = 0),
			(e.calls = []),
			(e.results = []),
			(e.resolves = []),
			(e.next = []));
	}, 'P'),
	XU = i((e) => (sA(e, rl, { value: { reset: i(() => YU(e[rl]), 'reset') } }), e[rl]), 'K'),
	QU = i((e) => e[rl] || XU(e), 'T'),
	Dp = new Set();
function xy(e) {
	return (Dp.add(e), () => void Dp.delete(e));
}
i(xy, 'onMockCall');
var ZU = i((...e) => {
	const t = SP(...e);
	return Ny(t);
}, 'spyOn');
function Iy(e) {
	const t = e ? Rp(e) : Rp();
	return Ny(t);
}
i(Iy, 'fn');
function Ny(e) {
	const t = kp(e),
		r = t.mockImplementation.bind(null);
	return ((t.mockImplementation = (n) => kp(r(n))), t);
}
i(Ny, 'reactiveMock');
function kp(e) {
	const t = QU(e),
		r = t.impl;
	return (
		t.willCall(function (...n) {
			return (Dp.forEach((o) => o(e, n)), r?.apply(this, n));
		}),
		e
	);
}
i(kp, 'listenWhenCalled');
function My() {
	xa.forEach((e) => e.mockClear());
}
i(My, 'clearAllMocks');
function qy() {
	xa.forEach((e) => e.mockReset());
}
i(qy, 'resetAllMocks');
function jy() {
	xa.forEach((e) => e.mockRestore());
}
i(jy, 'restoreAllMocks');
function aA(e, t = {}) {
	return e;
}
i(aA, 'mocked');
var lA = {};
Lt(lA, {
	buildQueries: () => Dr,
	configure: () => sO,
	createEvent: () => qs,
	findAllByAltText: () => eC,
	findAllByDisplayValue: () => WO,
	findAllByLabelText: () => AO,
	findAllByPlaceholderText: () => DO,
	findAllByRole: () => mC,
	findAllByTestId: () => EC,
	findAllByText: () => $O,
	findAllByTitle: () => sC,
	findByAltText: () => tC,
	findByDisplayValue: () => KO,
	findByLabelText: () => OO,
	findByPlaceholderText: () => kO,
	findByRole: () => hC,
	findByTestId: () => TC,
	findByText: () => UO,
	findByTitle: () => aC,
	fireEvent: () => yi,
	getAllByAltText: () => QO,
	getAllByDisplayValue: () => GO,
	getAllByLabelText: () => CO,
	getAllByPlaceholderText: () => qO,
	getAllByRole: () => pC,
	getAllByTestId: () => bC,
	getAllByText: () => BO,
	getAllByTitle: () => oC,
	getByAltText: () => ZO,
	getByDisplayValue: () => zO,
	getByLabelText: () => xO,
	getByPlaceholderText: () => jO,
	getByRole: () => fC,
	getByTestId: () => vC,
	getByText: () => JO,
	getByTitle: () => iC,
	getConfig: () => _e,
	getDefaultNormalizer: () => yc,
	getElementError: () => Ma,
	getMultipleElementsFoundError: () => qa,
	getNodeText: () => ji,
	getQueriesForElement: () => Gl,
	getRoles: () => tg,
	getSuggestedQuery: () => oa,
	isInaccessible: () => Na,
	logDOM: () => Vp,
	logRoles: () => _V,
	makeFindQuery: () => yo,
	makeGetAllQuery: () => vc,
	makeSingleQuery: () => ho,
	prettyDOM: () => hi,
	prettyFormat: () => Dy,
	queries: () => Hl,
	queryAllByAltText: () => YO,
	queryAllByAttribute: () => Bn,
	queryAllByDisplayValue: () => VO,
	queryAllByLabelText: () => IO,
	queryAllByPlaceholderText: () => NO,
	queryAllByRole: () => cC,
	queryAllByTestId: () => yC,
	queryAllByText: () => LO,
	queryAllByTitle: () => rC,
	queryByAltText: () => XO,
	queryByAttribute: () => ng,
	queryByDisplayValue: () => HO,
	queryByLabelText: () => RO,
	queryByPlaceholderText: () => MO,
	queryByRole: () => dC,
	queryByTestId: () => gC,
	queryByText: () => FO,
	queryByTitle: () => nC,
	queryHelpers: () => wV,
	screen: () => UV,
	waitFor: () => bc,
	waitForElementToBeRemoved: () => wC,
	within: () => Gl,
	wrapAllByQueryWithSuggestion: () => Dt,
	wrapSingleQueryWithSuggestion: () => Sn
});
var Dy = et(FL()),
	eV = Object.prototype.toString;
function Lp(e) {
	return typeof e == 'function' || eV.call(e) === '[object Function]';
}
i(Lp, 'isCallable');
function uA(e) {
	var t = Number(e);
	return isNaN(t) ? 0 : t === 0 || !isFinite(t) ? t : (t > 0 ? 1 : -1) * Math.floor(Math.abs(t));
}
i(uA, 'toInteger');
var tV = Math.pow(2, 53) - 1;
function cA(e) {
	var t = uA(e);
	return Math.min(Math.max(t, 0), tV);
}
i(cA, 'toLength');
function rr(e, t) {
	var r = Array,
		n = Object(e);
	if (e == null)
		throw new TypeError('Array.from requires an array-like object - not null or undefined');
	if (typeof t < 'u' && !Lp(t))
		throw new TypeError('Array.from: when provided, the second argument must be a function');
	for (var o = cA(n.length), s = Lp(r) ? Object(new r(o)) : new Array(o), a = 0, u; a < o; )
		((u = n[a]), t ? (s[a] = t(u, a)) : (s[a] = u), (a += 1));
	return ((s.length = o), s);
}
i(rr, 'arrayFrom');
function fi(e) {
	'@babel/helpers - typeof';
	return (
		(fi =
			typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
				? function (t) {
						return typeof t;
					}
				: function (t) {
						return t &&
							typeof Symbol == 'function' &&
							t.constructor === Symbol &&
							t !== Symbol.prototype
							? 'symbol'
							: typeof t;
					}),
		fi(e)
	);
}
i(fi, '_typeof');
function dA(e, t) {
	if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
}
i(dA, '_classCallCheck');
function Fp(e, t) {
	for (var r = 0; r < t.length; r++) {
		var n = t[r];
		((n.enumerable = n.enumerable || !1),
			(n.configurable = !0),
			'value' in n && (n.writable = !0),
			Object.defineProperty(e, ky(n.key), n));
	}
}
i(Fp, '_defineProperties');
function pA(e, t, r) {
	return (
		t && Fp(e.prototype, t),
		r && Fp(e, r),
		Object.defineProperty(e, 'prototype', { writable: !1 }),
		e
	);
}
i(pA, '_createClass');
function fA(e, t, r) {
	return (
		(t = ky(t)),
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(fA, '_defineProperty');
function ky(e) {
	var t = mA(e, 'string');
	return fi(t) === 'symbol' ? t : String(t);
}
i(ky, '_toPropertyKey');
function mA(e, t) {
	if (fi(e) !== 'object' || e === null) return e;
	var r = e[Symbol.toPrimitive];
	if (r !== void 0) {
		var n = r.call(e, t || 'default');
		if (fi(n) !== 'object') return n;
		throw new TypeError('@@toPrimitive must return a primitive value.');
	}
	return (t === 'string' ? String : Number)(e);
}
i(mA, '_toPrimitive');
var rV = (function () {
		function e() {
			var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
			(dA(this, e), fA(this, 'items', void 0), (this.items = t));
		}
		return (
			i(e, 'SetLike'),
			pA(e, [
				{
					key: 'add',
					value: i(function (r) {
						return (this.has(r) === !1 && this.items.push(r), this);
					}, 'add')
				},
				{
					key: 'clear',
					value: i(function () {
						this.items = [];
					}, 'clear')
				},
				{
					key: 'delete',
					value: i(function (r) {
						var n = this.items.length;
						return (
							(this.items = this.items.filter(function (o) {
								return o !== r;
							})),
							n !== this.items.length
						);
					}, '_delete')
				},
				{
					key: 'forEach',
					value: i(function (r) {
						var n = this;
						this.items.forEach(function (o) {
							r(o, o, n);
						});
					}, 'forEach')
				},
				{
					key: 'has',
					value: i(function (r) {
						return this.items.indexOf(r) !== -1;
					}, 'has')
				},
				{
					key: 'size',
					get: i(function () {
						return this.items.length;
					}, 'get')
				}
			]),
			e
		);
	})(),
	nV = typeof Set > 'u' ? Set : rV;
function gt(e) {
	var t;
	return (t = e.localName) !== null && t !== void 0 ? t : e.tagName.toLowerCase();
}
i(gt, 'getLocalName');
var oV = {
		article: 'article',
		aside: 'complementary',
		button: 'button',
		datalist: 'listbox',
		dd: 'definition',
		details: 'group',
		dialog: 'dialog',
		dt: 'term',
		fieldset: 'group',
		figure: 'figure',
		form: 'form',
		footer: 'contentinfo',
		h1: 'heading',
		h2: 'heading',
		h3: 'heading',
		h4: 'heading',
		h5: 'heading',
		h6: 'heading',
		header: 'banner',
		hr: 'separator',
		html: 'document',
		legend: 'legend',
		li: 'listitem',
		math: 'math',
		main: 'main',
		menu: 'list',
		nav: 'navigation',
		ol: 'list',
		optgroup: 'group',
		option: 'option',
		output: 'status',
		progress: 'progressbar',
		section: 'region',
		summary: 'button',
		table: 'table',
		tbody: 'rowgroup',
		textarea: 'textbox',
		tfoot: 'rowgroup',
		td: 'cell',
		th: 'columnheader',
		thead: 'rowgroup',
		tr: 'row',
		ul: 'list'
	},
	iV = {
		caption: new Set(['aria-label', 'aria-labelledby']),
		code: new Set(['aria-label', 'aria-labelledby']),
		deletion: new Set(['aria-label', 'aria-labelledby']),
		emphasis: new Set(['aria-label', 'aria-labelledby']),
		generic: new Set(['aria-label', 'aria-labelledby', 'aria-roledescription']),
		insertion: new Set(['aria-label', 'aria-labelledby']),
		paragraph: new Set(['aria-label', 'aria-labelledby']),
		presentation: new Set(['aria-label', 'aria-labelledby']),
		strong: new Set(['aria-label', 'aria-labelledby']),
		subscript: new Set(['aria-label', 'aria-labelledby']),
		superscript: new Set(['aria-label', 'aria-labelledby'])
	};
function hA(e, t) {
	return [
		'aria-atomic',
		'aria-busy',
		'aria-controls',
		'aria-current',
		'aria-describedby',
		'aria-details',
		'aria-dropeffect',
		'aria-flowto',
		'aria-grabbed',
		'aria-hidden',
		'aria-keyshortcuts',
		'aria-label',
		'aria-labelledby',
		'aria-live',
		'aria-owns',
		'aria-relevant',
		'aria-roledescription'
	].some(function (r) {
		var n;
		return e.hasAttribute(r) && !((n = iV[t]) !== null && n !== void 0 && n.has(r));
	});
}
i(hA, 'hasGlobalAriaAttributes');
function Ly(e, t) {
	return hA(e, t);
}
i(Ly, 'ignorePresentationalRole');
function yA(e) {
	var t = bA(e);
	if (t === null || t === 'presentation') {
		var r = gA(e);
		if (t !== 'presentation' || Ly(e, r || '')) return r;
	}
	return t;
}
i(yA, 'getRole');
function gA(e) {
	var t = oV[gt(e)];
	if (t !== void 0) return t;
	switch (gt(e)) {
		case 'a':
		case 'area':
		case 'link':
			if (e.hasAttribute('href')) return 'link';
			break;
		case 'img':
			return e.getAttribute('alt') === '' && !Ly(e, 'img') ? 'presentation' : 'img';
		case 'input': {
			var r = e,
				n = r.type;
			switch (n) {
				case 'button':
				case 'image':
				case 'reset':
				case 'submit':
					return 'button';
				case 'checkbox':
				case 'radio':
					return n;
				case 'range':
					return 'slider';
				case 'email':
				case 'tel':
				case 'text':
				case 'url':
					return e.hasAttribute('list') ? 'combobox' : 'textbox';
				case 'search':
					return e.hasAttribute('list') ? 'combobox' : 'searchbox';
				case 'number':
					return 'spinbutton';
				default:
					return null;
			}
		}
		case 'select':
			return e.hasAttribute('multiple') || e.size > 1 ? 'listbox' : 'combobox';
	}
	return null;
}
i(gA, 'getImplicitRole');
function bA(e) {
	var t = e.getAttribute('role');
	if (t !== null) {
		var r = t.trim().split(' ')[0];
		if (r.length > 0) return r;
	}
	return null;
}
i(bA, 'getExplicitRole');
function Be(e) {
	return e !== null && e.nodeType === e.ELEMENT_NODE;
}
i(Be, 'isElement');
function Fy(e) {
	return Be(e) && gt(e) === 'caption';
}
i(Fy, 'isHTMLTableCaptionElement');
function Ms(e) {
	return Be(e) && gt(e) === 'input';
}
i(Ms, 'isHTMLInputElement');
function vA(e) {
	return Be(e) && gt(e) === 'optgroup';
}
i(vA, 'isHTMLOptGroupElement');
function EA(e) {
	return Be(e) && gt(e) === 'select';
}
i(EA, 'isHTMLSelectElement');
function TA(e) {
	return Be(e) && gt(e) === 'table';
}
i(TA, 'isHTMLTableElement');
function _A(e) {
	return Be(e) && gt(e) === 'textarea';
}
i(_A, 'isHTMLTextAreaElement');
function wA(e) {
	var t = e.ownerDocument === null ? e : e.ownerDocument,
		r = t.defaultView;
	if (r === null) throw new TypeError('no window available');
	return r;
}
i(wA, 'safeWindow');
function SA(e) {
	return Be(e) && gt(e) === 'fieldset';
}
i(SA, 'isHTMLFieldSetElement');
function RA(e) {
	return Be(e) && gt(e) === 'legend';
}
i(RA, 'isHTMLLegendElement');
function PA(e) {
	return Be(e) && gt(e) === 'slot';
}
i(PA, 'isHTMLSlotElement');
function AA(e) {
	return Be(e) && e.ownerSVGElement !== void 0;
}
i(AA, 'isSVGElement');
function OA(e) {
	return Be(e) && gt(e) === 'svg';
}
i(OA, 'isSVGSVGElement');
function CA(e) {
	return AA(e) && gt(e) === 'title';
}
i(CA, 'isSVGTitleElement');
function na(e, t) {
	if (Be(e) && e.hasAttribute(t)) {
		var r = e.getAttribute(t).split(' '),
			n = e.getRootNode ? e.getRootNode() : e.ownerDocument;
		return r
			.map(function (o) {
				return n.getElementById(o);
			})
			.filter(function (o) {
				return o !== null;
			});
	}
	return [];
}
i(na, 'queryIdRefs');
function Ar(e, t) {
	return Be(e) ? t.indexOf(yA(e)) !== -1 : !1;
}
i(Ar, 'hasAnyConcreteRoles');
function xA(e) {
	return e.trim().replace(/\s\s+/g, ' ');
}
i(xA, 'asFlatString');
function IA(e, t) {
	if (!Be(e)) return !1;
	if (e.hasAttribute('hidden') || e.getAttribute('aria-hidden') === 'true') return !0;
	var r = t(e);
	return r.getPropertyValue('display') === 'none' || r.getPropertyValue('visibility') === 'hidden';
}
i(IA, 'isHidden');
function NA(e) {
	return Ar(e, ['button', 'combobox', 'listbox', 'textbox']) || By(e, 'range');
}
i(NA, 'isControl');
function By(e, t) {
	if (!Be(e)) return !1;
	switch (t) {
		case 'range':
			return Ar(e, ['meter', 'progressbar', 'scrollbar', 'slider', 'spinbutton']);
		default:
			throw new TypeError(
				"No knowledge about abstract role '".concat(t, "'. This is likely a bug :(")
			);
	}
}
i(By, 'hasAbstractRole');
function Bp(e, t) {
	var r = rr(e.querySelectorAll(t));
	return (
		na(e, 'aria-owns').forEach(function (n) {
			r.push.apply(r, rr(n.querySelectorAll(t)));
		}),
		r
	);
}
i(Bp, 'querySelectorAllSubtree');
function MA(e) {
	return EA(e) ? e.selectedOptions || Bp(e, '[selected]') : Bp(e, '[aria-selected="true"]');
}
i(MA, 'querySelectedOptions');
function qA(e) {
	return Ar(e, ['none', 'presentation']);
}
i(qA, 'isMarkedPresentational');
function jA(e) {
	return Fy(e);
}
i(jA, 'isNativeHostLanguageTextAlternativeElement');
function DA(e) {
	return Ar(e, [
		'button',
		'cell',
		'checkbox',
		'columnheader',
		'gridcell',
		'heading',
		'label',
		'legend',
		'link',
		'menuitem',
		'menuitemcheckbox',
		'menuitemradio',
		'option',
		'radio',
		'row',
		'rowheader',
		'switch',
		'tab',
		'tooltip',
		'treeitem'
	]);
}
i(DA, 'allowsNameFromContent');
function kA(e) {
	return !1;
}
i(kA, 'isDescendantOfNativeHostLanguageTextAlternativeElement');
function LA(e) {
	return Ms(e) || _A(e) ? e.value : e.textContent || '';
}
i(LA, 'getValueOfTextbox');
function Jp(e) {
	var t = e.getPropertyValue('content');
	return /^["'].*["']$/.test(t) ? t.slice(1, -1) : '';
}
i(Jp, 'getTextualContent');
function Jy(e) {
	var t = gt(e);
	return (
		t === 'button' ||
		(t === 'input' && e.getAttribute('type') !== 'hidden') ||
		t === 'meter' ||
		t === 'output' ||
		t === 'progress' ||
		t === 'select' ||
		t === 'textarea'
	);
}
i(Jy, 'isLabelableElement');
function $y(e) {
	if (Jy(e)) return e;
	var t = null;
	return (
		e.childNodes.forEach(function (r) {
			if (t === null && Be(r)) {
				var n = $y(r);
				n !== null && (t = n);
			}
		}),
		t
	);
}
i($y, 'findLabelableElement');
function FA(e) {
	if (e.control !== void 0) return e.control;
	var t = e.getAttribute('for');
	return t !== null ? e.ownerDocument.getElementById(t) : $y(e);
}
i(FA, 'getControlOfLabel');
function BA(e) {
	var t = e.labels;
	if (t === null) return t;
	if (t !== void 0) return rr(t);
	if (!Jy(e)) return null;
	var r = e.ownerDocument;
	return rr(r.querySelectorAll('label')).filter(function (n) {
		return FA(n) === e;
	});
}
i(BA, 'getLabels');
function JA(e) {
	var t = e.assignedNodes();
	return t.length === 0 ? rr(e.childNodes) : t;
}
i(JA, 'getSlotContents');
function Uy(e) {
	var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
		r = new nV(),
		n = wA(e),
		o = t.compute,
		s = o === void 0 ? 'name' : o,
		a = t.computedStyleSupportsPseudoElements,
		u = a === void 0 ? t.getComputedStyle !== void 0 : a,
		c = t.getComputedStyle,
		d = c === void 0 ? n.getComputedStyle.bind(n) : c,
		p = t.hidden,
		f = p === void 0 ? !1 : p;
	function m(b, w) {
		var P = '';
		if (Be(b) && u) {
			var I = d(b, '::before'),
				q = Jp(I);
			P = ''.concat(q, ' ').concat(P);
		}
		var C = PA(b) ? JA(b) : rr(b.childNodes).concat(na(b, 'aria-owns'));
		if (
			(C.forEach(function (S) {
				var D = T(S, { isEmbeddedInLabel: w.isEmbeddedInLabel, isReferenced: !1, recursion: !0 }),
					N = Be(S) ? d(S).getPropertyValue('display') : 'inline',
					V = N !== 'inline' ? ' ' : '';
				P += ''.concat(V).concat(D).concat(V);
			}),
			Be(b) && u)
		) {
			var R = d(b, '::after'),
				_ = Jp(R);
			P = ''.concat(P, ' ').concat(_);
		}
		return P.trim();
	}
	i(m, 'computeMiscTextAlternative');
	function y(b, w) {
		var P = b.getAttributeNode(w);
		return P !== null && !r.has(P) && P.value.trim() !== '' ? (r.add(P), P.value) : null;
	}
	i(y, 'useAttribute');
	function g(b) {
		return Be(b) ? y(b, 'title') : null;
	}
	i(g, 'computeTooltipAttributeValue');
	function E(b) {
		if (!Be(b)) return null;
		if (SA(b)) {
			r.add(b);
			for (var w = rr(b.childNodes), P = 0; P < w.length; P += 1) {
				var I = w[P];
				if (RA(I)) return T(I, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
			}
		} else if (TA(b)) {
			r.add(b);
			for (var q = rr(b.childNodes), C = 0; C < q.length; C += 1) {
				var R = q[C];
				if (Fy(R)) return T(R, { isEmbeddedInLabel: !1, isReferenced: !1, recursion: !1 });
			}
		} else if (OA(b)) {
			r.add(b);
			for (var _ = rr(b.childNodes), S = 0; S < _.length; S += 1) {
				var D = _[S];
				if (CA(D)) return D.textContent;
			}
			return null;
		} else if (gt(b) === 'img' || gt(b) === 'area') {
			var N = y(b, 'alt');
			if (N !== null) return N;
		} else if (vA(b)) {
			var V = y(b, 'label');
			if (V !== null) return V;
		}
		if (Ms(b) && (b.type === 'button' || b.type === 'submit' || b.type === 'reset')) {
			var H = y(b, 'value');
			if (H !== null) return H;
			if (b.type === 'submit') return 'Submit';
			if (b.type === 'reset') return 'Reset';
		}
		var A = BA(b);
		if (A !== null && A.length !== 0)
			return (
				r.add(b),
				rr(A)
					.map(function (K) {
						return T(K, { isEmbeddedInLabel: !0, isReferenced: !1, recursion: !0 });
					})
					.filter(function (K) {
						return K.length > 0;
					})
					.join(' ')
			);
		if (Ms(b) && b.type === 'image') {
			var L = y(b, 'alt');
			if (L !== null) return L;
			var B = y(b, 'title');
			return B !== null ? B : 'Submit Query';
		}
		if (Ar(b, ['button'])) {
			var k = m(b, { isEmbeddedInLabel: !1 });
			if (k !== '') return k;
		}
		return null;
	}
	i(E, 'computeElementTextAlternative');
	function T(b, w) {
		if (r.has(b)) return '';
		if (!f && IA(b, d) && !w.isReferenced) return (r.add(b), '');
		var P = Be(b) ? b.getAttributeNode('aria-labelledby') : null,
			I = P !== null && !r.has(P) ? na(b, 'aria-labelledby') : [];
		if (s === 'name' && !w.isReferenced && I.length > 0)
			return (
				r.add(P),
				I.map(function (N) {
					return T(N, { isEmbeddedInLabel: w.isEmbeddedInLabel, isReferenced: !0, recursion: !1 });
				}).join(' ')
			);
		var q = w.recursion && NA(b) && s === 'name';
		if (!q) {
			var C = ((Be(b) && b.getAttribute('aria-label')) || '').trim();
			if (C !== '' && s === 'name') return (r.add(b), C);
			if (!qA(b)) {
				var R = E(b);
				if (R !== null) return (r.add(b), R);
			}
		}
		if (Ar(b, ['menu'])) return (r.add(b), '');
		if (q || w.isEmbeddedInLabel || w.isReferenced) {
			if (Ar(b, ['combobox', 'listbox'])) {
				r.add(b);
				var _ = MA(b);
				return _.length === 0
					? Ms(b)
						? b.value
						: ''
					: rr(_)
							.map(function (N) {
								return T(N, {
									isEmbeddedInLabel: w.isEmbeddedInLabel,
									isReferenced: !1,
									recursion: !0
								});
							})
							.join(' ');
			}
			if (By(b, 'range'))
				return (
					r.add(b),
					b.hasAttribute('aria-valuetext')
						? b.getAttribute('aria-valuetext')
						: b.hasAttribute('aria-valuenow')
							? b.getAttribute('aria-valuenow')
							: b.getAttribute('value') || ''
				);
			if (Ar(b, ['textbox'])) return (r.add(b), LA(b));
		}
		if (DA(b) || (Be(b) && w.isReferenced) || jA(b) || kA()) {
			var S = m(b, { isEmbeddedInLabel: w.isEmbeddedInLabel });
			if (S !== '') return (r.add(b), S);
		}
		if (b.nodeType === b.TEXT_NODE) return (r.add(b), b.textContent || '');
		if (w.recursion) return (r.add(b), m(b, { isEmbeddedInLabel: w.isEmbeddedInLabel }));
		var D = g(b);
		return D !== null ? (r.add(b), D) : (r.add(b), '');
	}
	return (
		i(T, 'computeTextAlternative'),
		xA(T(e, { isEmbeddedInLabel: !1, isReferenced: s === 'description', recursion: !1 }))
	);
}
i(Uy, 'computeTextAlternative');
function mi(e) {
	'@babel/helpers - typeof';
	return (
		(mi =
			typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
				? function (t) {
						return typeof t;
					}
				: function (t) {
						return t &&
							typeof Symbol == 'function' &&
							t.constructor === Symbol &&
							t !== Symbol.prototype
							? 'symbol'
							: typeof t;
					}),
		mi(e)
	);
}
i(mi, '_typeof');
function $p(e, t) {
	var r = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		(t &&
			(n = n.filter(function (o) {
				return Object.getOwnPropertyDescriptor(e, o).enumerable;
			})),
			r.push.apply(r, n));
	}
	return r;
}
i($p, 'ownKeys');
function Up(e) {
	for (var t = 1; t < arguments.length; t++) {
		var r = arguments[t] != null ? arguments[t] : {};
		t % 2
			? $p(Object(r), !0).forEach(function (n) {
					$A(e, n, r[n]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
				: $p(Object(r)).forEach(function (n) {
						Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
					});
	}
	return e;
}
i(Up, '_objectSpread');
function $A(e, t, r) {
	return (
		(t = UA(t)),
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i($A, '_defineProperty');
function UA(e) {
	var t = VA(e, 'string');
	return mi(t) === 'symbol' ? t : String(t);
}
i(UA, '_toPropertyKey');
function VA(e, t) {
	if (mi(e) !== 'object' || e === null) return e;
	var r = e[Symbol.toPrimitive];
	if (r !== void 0) {
		var n = r.call(e, t || 'default');
		if (mi(n) !== 'object') return n;
		throw new TypeError('@@toPrimitive must return a primitive value.');
	}
	return (t === 'string' ? String : Number)(e);
}
i(VA, '_toPrimitive');
function Vy(e) {
	var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
		r = na(e, 'aria-describedby')
			.map(function (o) {
				return Uy(o, Up(Up({}, t), {}, { compute: 'description' }));
			})
			.join(' ');
	if (r === '') {
		var n = e.getAttribute('title');
		r = n === null ? '' : n;
	}
	return r;
}
i(Vy, 'computeAccessibleDescription');
function HA(e) {
	return Ar(e, [
		'caption',
		'code',
		'deletion',
		'emphasis',
		'generic',
		'insertion',
		'paragraph',
		'presentation',
		'strong',
		'subscript',
		'superscript'
	]);
}
i(HA, 'prohibitsNaming');
function mc(e) {
	var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	return HA(e) ? '' : Uy(e, t);
}
i(mc, 'computeAccessibleName');
var Zt = et($f()),
	sV = et(BL());
function Hy(e) {
	return e.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
i(Hy, 'escapeHTML');
var aV = i((e, t, r, n, o, s, a) => {
		const u = n + r.indent,
			c = r.colors;
		return e
			.map((d) => {
				const p = t[d];
				let f = a(p, r, u, o, s);
				return (
					typeof p != 'string' &&
						(f.indexOf(`
`) !== -1 && (f = r.spacingOuter + u + f + r.spacingOuter + n),
						(f = '{' + f + '}')),
					r.spacingInner +
						n +
						c.prop.open +
						d +
						c.prop.close +
						'=' +
						c.value.open +
						f +
						c.value.close
				);
			})
			.join('');
	}, 'printProps'),
	lV = 3,
	uV = i(
		(e, t, r, n, o, s) =>
			e
				.map((a) => {
					const u = typeof a == 'string' ? GA(a, t) : s(a, t, r, n, o);
					return u === '' && typeof a == 'object' && a !== null && a.nodeType !== lV
						? ''
						: t.spacingOuter + r + u;
				})
				.join(''),
		'printChildren'
	),
	GA = i((e, t) => {
		const r = t.colors.content;
		return r.open + Hy(e) + r.close;
	}, 'printText'),
	cV = i((e, t) => {
		const r = t.colors.comment;
		return r.open + '<!--' + Hy(e) + '-->' + r.close;
	}, 'printComment'),
	dV = i((e, t, r, n, o) => {
		const s = n.colors.tag;
		return (
			s.open +
			'<' +
			e +
			(t && s.close + t + n.spacingOuter + o + s.open) +
			(r
				? '>' + s.close + r + n.spacingOuter + o + s.open + '</' + e
				: (t && !n.min ? '' : ' ') + '/') +
			'>' +
			s.close
		);
	}, 'printElement'),
	pV = i((e, t) => {
		const r = t.colors.tag;
		return r.open + '<' + e + r.close + ' ' + r.open + ' />' + r.close;
	}, 'printElementAsLeaf'),
	fV = 1,
	zA = 3,
	WA = 8,
	KA = 11,
	mV = /^((HTML|SVG)\w*)?Element$/,
	YA = i((e) => {
		const { tagName: t } = e;
		return !!(
			(typeof t == 'string' && t.includes('-')) ||
			(typeof e.hasAttribute == 'function' && e.hasAttribute('is'))
		);
	}, 'isCustomElement'),
	hV = i((e) => {
		const t = e.constructor.name,
			{ nodeType: r } = e;
		return (
			(r === fV && (mV.test(t) || YA(e))) ||
			(r === zA && t === 'Text') ||
			(r === WA && t === 'Comment') ||
			(r === KA && t === 'DocumentFragment')
		);
	}, 'testNode');
function XA(e) {
	return e.nodeType === zA;
}
i(XA, 'nodeIsText');
function QA(e) {
	return e.nodeType === WA;
}
i(QA, 'nodeIsComment');
function nl(e) {
	return e.nodeType === KA;
}
i(nl, 'nodeIsFragment');
function ZA(e) {
	return {
		test: i((t) => {
			var r;
			return ((t == null || (r = t.constructor) == null ? void 0 : r.name) || YA(t)) && hV(t);
		}, 'test'),
		serialize: i((t, r, n, o, s, a) => {
			if (XA(t)) return GA(t.data, r);
			if (QA(t)) return cV(t.data, r);
			const u = nl(t) ? 'DocumentFragment' : t.tagName.toLowerCase();
			return ++o > r.maxDepth
				? pV(u, r)
				: dV(
						u,
						aV(
							nl(t)
								? []
								: Array.from(t.attributes)
										.map((c) => c.name)
										.sort(),
							nl(t)
								? {}
								: Array.from(t.attributes).reduce((c, d) => ((c[d.name] = d.value), c), {}),
							r,
							n + r.indent,
							o,
							s,
							a
						),
						uV(
							Array.prototype.slice.call(t.childNodes || t.children).filter(e),
							r,
							n + r.indent,
							o,
							s,
							a
						),
						r,
						n
					);
		}, 'serialize')
	};
}
i(ZA, 'createDOMElementFilter');
var eO = null,
	Gy = null,
	zy = null;
try {
	const e = module && module.require;
	((Gy = e.call(module, 'fs').readFileSync),
		(zy = e.call(module, '@babel/code-frame').codeFrameColumns),
		(eO = e.call(module, 'picocolors')));
} catch {}
function tO(e) {
	const t = e.indexOf('(') + 1,
		r = e.indexOf(')'),
		n = e.slice(t, r),
		o = n.split(':'),
		[s, a, u] = [o[0], parseInt(o[1], 10), parseInt(o[2], 10)];
	let c = '';
	try {
		c = Gy(s, 'utf-8');
	} catch {
		return '';
	}
	const d = zy(c, { start: { line: a, column: u } }, { highlightCode: !0, linesBelow: 0 });
	return (
		eO.dim(n) +
		`
` +
		d +
		`
`
	);
}
i(tO, 'getCodeFrame');
function rO() {
	if (!Gy || !zy) return '';
	const t = new Error().stack
		.split(
			`
`
		)
		.slice(1)
		.find((r) => !r.includes('node_modules/'));
	return tO(t);
}
i(rO, 'getUserCodeFrame');
var nO = 3;
function ol() {
	return typeof jest < 'u' && jest !== null
		? setTimeout._isMockFunction === !0 || Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
		: !1;
}
i(ol, 'jestFakeTimersAreEnabled');
function hc() {
	if (typeof window > 'u') throw new Error('Could not find default container');
	return window.document;
}
i(hc, 'getDocument');
function Wy(e) {
	if (e.defaultView) return e.defaultView;
	if (e.ownerDocument && e.ownerDocument.defaultView) return e.ownerDocument.defaultView;
	if (e.window) return e.window;
	throw e.ownerDocument && e.ownerDocument.defaultView === null
		? new Error('It looks like the window object is not available for the provided node.')
		: e.then instanceof Function
			? new Error(
					'It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?'
				)
			: Array.isArray(e)
				? new Error(
						'It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?'
					)
				: typeof e.debug == 'function' && typeof e.logTestingPlaygroundURL == 'function'
					? new Error(
							'It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?'
						)
					: new Error('The given node is not an Element, the node type is: ' + typeof e + '.');
}
i(Wy, 'getWindowFromNode');
function jr(e) {
	if (!e || typeof e.querySelector != 'function' || typeof e.querySelectorAll != 'function')
		throw new TypeError(
			'Expected container to be an Element, a Document or a DocumentFragment but got ' + t(e) + '.'
		);
	function t(r) {
		return typeof r == 'object' ? (r === null ? 'null' : r.constructor.name) : typeof r;
	}
	i(t, 'getTypeName');
}
i(jr, 'checkContainerType');
var yV = i(() => {
		if (typeof process > 'u') return !1;
		let e;
		try {
			var t;
			const r = (t = Id) == null ? void 0 : t.COLORS;
			r && (e = JSON.parse(r));
		} catch {}
		return typeof e == 'boolean'
			? e
			: process.versions !== void 0 && process.versions.node !== void 0;
	}, 'shouldHighlight'),
	{ DOMCollection: gV } = Dy.plugins,
	bV = 1,
	vV = 8;
function oO(e) {
	return e.nodeType !== vV && (e.nodeType !== bV || !e.matches(_e().defaultIgnore));
}
i(oO, 'filterCommentsAndDefaultIgnoreTagsTags');
function hi(e, t, r) {
	if (
		(r === void 0 && (r = {}),
		e || (e = hc().body),
		typeof t != 'number' &&
			(t = (typeof process < 'u' && typeof Id < 'u' && Id.DEBUG_PRINT_LIMIT) || 7e3),
		t === 0)
	)
		return '';
	e.documentElement && (e = e.documentElement);
	let n = typeof e;
	if ((n === 'object' ? (n = e.constructor.name) : (e = {}), !('outerHTML' in e)))
		throw new TypeError('Expected an element or document but got ' + n);
	const { filterNode: o = oO, ...s } = r,
		a = Dy.format(e, { plugins: [ZA(o), gV], printFunctionName: !1, highlight: yV(), ...s });
	return t !== void 0 && e.outerHTML.length > t ? a.slice(0, t) + '...' : a;
}
i(hi, 'prettyDOM');
var Vp = i(function () {
		const e = rO();
		console.log(
			e
				? hi(...arguments) +
						`

` +
						e
				: hi(...arguments)
		);
	}, 'logDOM'),
	ao = {
		testIdAttribute: 'data-testid',
		asyncUtilTimeout: 1e3,
		asyncWrapper: i((e) => e(), 'asyncWrapper'),
		unstable_advanceTimersWrapper: i((e) => e(), 'unstable_advanceTimersWrapper'),
		eventWrapper: i((e) => e(), 'eventWrapper'),
		defaultHidden: !1,
		defaultIgnore: 'script, style',
		showOriginalStackTrace: !1,
		throwSuggestions: !1,
		getElementError(e, t) {
			const r = hi(t),
				n = new Error(
					[
						e,
						'Ignored nodes: comments, ' +
							ao.defaultIgnore +
							`
` +
							r
					].filter(Boolean).join(`

`)
				);
			return ((n.name = 'TestingLibraryElementError'), n);
		},
		_disableExpensiveErrorDiagnostics: !1,
		computedStyleSupportsPseudoElements: !1
	};
function iO(e) {
	try {
		return ((ao._disableExpensiveErrorDiagnostics = !0), e());
	} finally {
		ao._disableExpensiveErrorDiagnostics = !1;
	}
}
i(iO, 'runWithExpensiveErrorDiagnosticsDisabled');
function sO(e) {
	(typeof e == 'function' && (e = e(ao)), (ao = { ...ao, ...e }));
}
i(sO, 'configure');
function _e() {
	return ao;
}
i(_e, 'getConfig');
var EV = ['button', 'meter', 'output', 'progress', 'select', 'textarea', 'input'];
function Ky(e) {
	return EV.includes(e.nodeName.toLowerCase())
		? ''
		: e.nodeType === nO
			? e.textContent
			: Array.from(e.childNodes)
					.map((t) => Ky(t))
					.join('');
}
i(Ky, 'getTextContent');
function Vl(e) {
	let t;
	return (e.tagName.toLowerCase() === 'label' ? (t = Ky(e)) : (t = e.value || e.textContent), t);
}
i(Vl, 'getLabelContent');
function Yy(e) {
	if (e.labels !== void 0) {
		var t;
		return (t = e.labels) != null ? t : [];
	}
	if (!aO(e)) return [];
	const r = e.ownerDocument.querySelectorAll('label');
	return Array.from(r).filter((n) => n.control === e);
}
i(Yy, 'getRealLabels');
function aO(e) {
	return (
		/BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) ||
		(e.tagName === 'INPUT' && e.getAttribute('type') !== 'hidden')
	);
}
i(aO, 'isLabelable');
function Xy(e, t, r) {
	let { selector: n = '*' } = r === void 0 ? {} : r;
	const o = t.getAttribute('aria-labelledby'),
		s = o ? o.split(' ') : [];
	return s.length
		? s.map((a) => {
				const u = e.querySelector('[id="' + a + '"]');
				return u ? { content: Vl(u), formControl: null } : { content: '', formControl: null };
			})
		: Array.from(Yy(t)).map((a) => {
				const u = Vl(a),
					d = Array.from(
						a.querySelectorAll('button, input, meter, output, progress, select, textarea')
					).filter((p) => p.matches(n))[0];
				return { content: u, formControl: d };
			});
}
i(Xy, 'getLabels');
function Qy(e) {
	if (e == null)
		throw new Error(
			'It looks like ' +
				e +
				' was passed instead of a matcher. Did you do something like getByText(' +
				e +
				')?'
		);
}
i(Qy, 'assertNotNullOrUndefined');
function xo(e, t, r, n) {
	if (typeof e != 'string') return !1;
	Qy(r);
	const o = n(e);
	return typeof r == 'string' || typeof r == 'number'
		? o.toLowerCase().includes(r.toString().toLowerCase())
		: typeof r == 'function'
			? r(o, t)
			: Zy(r, o);
}
i(xo, 'fuzzyMatches');
function xr(e, t, r, n) {
	if (typeof e != 'string') return !1;
	Qy(r);
	const o = n(e);
	return r instanceof Function ? r(o, t) : r instanceof RegExp ? Zy(r, o) : o === String(r);
}
i(xr, 'matches');
function yc(e) {
	let { trim: t = !0, collapseWhitespace: r = !0 } = e === void 0 ? {} : e;
	return (n) => {
		let o = n;
		return ((o = t ? o.trim() : o), (o = r ? o.replace(/\s+/g, ' ') : o), o);
	};
}
i(yc, 'getDefaultNormalizer');
function Fn(e) {
	let { trim: t, collapseWhitespace: r, normalizer: n } = e;
	if (!n) return yc({ trim: t, collapseWhitespace: r });
	if (typeof t < 'u' || typeof r < 'u')
		throw new Error(
			'trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer'
		);
	return n;
}
i(Fn, 'makeNormalizer');
function Zy(e, t) {
	const r = e.test(t);
	return (
		e.global &&
			e.lastIndex !== 0 &&
			(console.warn(
				'To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.'
			),
			(e.lastIndex = 0)),
		r
	);
}
i(Zy, 'matchRegExp');
function ji(e) {
	return e.matches('input[type=submit], input[type=button], input[type=reset]')
		? e.value
		: Array.from(e.childNodes)
				.filter((t) => t.nodeType === nO && !!t.textContent)
				.map((t) => t.textContent)
				.join('');
}
i(ji, 'getNodeText');
var TV = lO(Zt.elementRoles);
function eg(e) {
	return (
		e.hidden === !0 ||
		e.getAttribute('aria-hidden') === 'true' ||
		e.ownerDocument.defaultView.getComputedStyle(e).display === 'none'
	);
}
i(eg, 'isSubtreeInaccessible');
function Na(e, t) {
	t === void 0 && (t = {});
	const { isSubtreeInaccessible: r = eg } = t;
	if (e.ownerDocument.defaultView.getComputedStyle(e).visibility === 'hidden') return !0;
	let o = e;
	for (; o; ) {
		if (r(o)) return !0;
		o = o.parentElement;
	}
	return !1;
}
i(Na, 'isInaccessible');
function gc(e) {
	for (const { match: t, roles: r } of TV) if (t(e)) return [...r];
	return [];
}
i(gc, 'getImplicitAriaRoles');
function lO(e) {
	function t(a) {
		let { name: u, attributes: c } = a;
		return (
			'' +
			u +
			c
				.map((d) => {
					let { name: p, value: f, constraints: m = [] } = d;
					const y = m.indexOf('undefined') !== -1,
						g = m.indexOf('set') !== -1;
					return typeof f < 'u'
						? '[' + p + '="' + f + '"]'
						: y
							? ':not([' + p + '])'
							: g
								? '[' + p + ']:not([' + p + '=""])'
								: '[' + p + ']';
				})
				.join('')
		);
	}
	i(t, 'makeElementSelector');
	function r(a) {
		let { attributes: u = [] } = a;
		return u.length;
	}
	i(r, 'getSelectorSpecificity');
	function n(a, u) {
		let { specificity: c } = a,
			{ specificity: d } = u;
		return d - c;
	}
	i(n, 'bySelectorSpecificity');
	function o(a) {
		let { attributes: u = [] } = a;
		const c = u.findIndex((p) => p.value && p.name === 'type' && p.value === 'text');
		c >= 0 && (u = [...u.slice(0, c), ...u.slice(c + 1)]);
		const d = t({ ...a, attributes: u });
		return (p) => (c >= 0 && p.type !== 'text' ? !1 : p.matches(d));
	}
	i(o, 'match');
	let s = [];
	for (const [a, u] of e.entries())
		s = [...s, { match: o(a), roles: Array.from(u), specificity: r(a) }];
	return s.sort(n);
}
i(lO, 'buildElementRoleList');
function tg(e, t) {
	let { hidden: r = !1 } = t === void 0 ? {} : t;
	function n(o) {
		return [o, ...Array.from(o.children).reduce((s, a) => [...s, ...n(a)], [])];
	}
	return (
		i(n, 'flattenDOM'),
		n(e)
			.filter((o) => (r === !1 ? Na(o) === !1 : !0))
			.reduce((o, s) => {
				let a = [];
				return (
					s.hasAttribute('role')
						? (a = s.getAttribute('role').split(' ').slice(0, 1))
						: (a = gc(s)),
					a.reduce(
						(u, c) => (Array.isArray(u[c]) ? { ...u, [c]: [...u[c], s] } : { ...u, [c]: [s] }),
						o
					)
				);
			}, {})
	);
}
i(tg, 'getRoles');
function rg(e, t) {
	let { hidden: r, includeDescription: n } = t;
	const o = tg(e, { hidden: r });
	return Object.entries(o)
		.filter((s) => {
			let [a] = s;
			return a !== 'generic';
		})
		.map((s) => {
			let [a, u] = s;
			const c = '-'.repeat(50),
				d = u.map((p) => {
					const f =
							'Name "' +
							mc(p, {
								computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
							}) +
							`":
`,
						m = hi(p.cloneNode(!1));
					if (n) {
						const y =
							'Description "' +
							Vy(p, {
								computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
							}) +
							`":
`;
						return '' + f + y + m;
					}
					return '' + f + m;
				}).join(`

`);
			return (
				a +
				`:

` +
				d +
				`

` +
				c
			);
		}).join(`
`);
}
i(rg, 'prettyRoles');
var _V = i(function (e, t) {
	let { hidden: r = !1 } = t === void 0 ? {} : t;
	return console.log(rg(e, { hidden: r }));
}, 'logRoles');
function uO(e) {
	return e.tagName === 'OPTION' ? e.selected : Di(e, 'aria-selected');
}
i(uO, 'computeAriaSelected');
function cO(e) {
	return e.getAttribute('aria-busy') === 'true';
}
i(cO, 'computeAriaBusy');
function dO(e) {
	if (!('indeterminate' in e && e.indeterminate))
		return 'checked' in e ? e.checked : Di(e, 'aria-checked');
}
i(dO, 'computeAriaChecked');
function pO(e) {
	return Di(e, 'aria-pressed');
}
i(pO, 'computeAriaPressed');
function fO(e) {
	var t, r;
	return (t = (r = Di(e, 'aria-current')) != null ? r : e.getAttribute('aria-current')) != null
		? t
		: !1;
}
i(fO, 'computeAriaCurrent');
function mO(e) {
	return Di(e, 'aria-expanded');
}
i(mO, 'computeAriaExpanded');
function Di(e, t) {
	const r = e.getAttribute(t);
	if (r === 'true') return !0;
	if (r === 'false') return !1;
}
i(Di, 'checkBooleanAttribute');
function hO(e) {
	const t = { H1: 1, H2: 2, H3: 3, H4: 4, H5: 5, H6: 6 };
	return (e.getAttribute('aria-level') && Number(e.getAttribute('aria-level'))) || t[e.tagName];
}
i(hO, 'computeHeadingLevel');
function yO(e) {
	const t = e.getAttribute('aria-valuenow');
	return t === null ? void 0 : +t;
}
i(yO, 'computeAriaValueNow');
function gO(e) {
	const t = e.getAttribute('aria-valuemax');
	return t === null ? void 0 : +t;
}
i(gO, 'computeAriaValueMax');
function bO(e) {
	const t = e.getAttribute('aria-valuemin');
	return t === null ? void 0 : +t;
}
i(bO, 'computeAriaValueMin');
function vO(e) {
	const t = e.getAttribute('aria-valuetext');
	return t === null ? void 0 : t;
}
i(vO, 'computeAriaValueText');
var gv = yc();
function EO(e) {
	return e.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
}
i(EO, 'escapeRegExp');
function Hp(e) {
	return new RegExp(EO(e.toLowerCase()), 'i');
}
i(Hp, 'getRegExpMatcher');
function Ur(e, t, r, n) {
	let { variant: o, name: s } = n,
		a = '';
	const u = {},
		c = [['Role', 'TestId'].includes(e) ? r : Hp(r)];
	(s && (u.name = Hp(s)),
		e === 'Role' &&
			Na(t) &&
			((u.hidden = !0),
			(a = `Element is inaccessible. This means that the element and all its children are invisible to screen readers.
    If you are using the aria-hidden prop, make sure this is the right choice for your case.
    `)),
		Object.keys(u).length > 0 && c.push(u));
	const d = o + 'By' + e;
	return {
		queryName: e,
		queryMethod: d,
		queryArgs: c,
		variant: o,
		warning: a,
		toString() {
			a && console.warn(a);
			let [p, f] = c;
			return (
				(p = typeof p == 'string' ? "'" + p + "'" : p),
				(f = f
					? ', { ' +
						Object.entries(f)
							.map((m) => {
								let [y, g] = m;
								return y + ': ' + g;
							})
							.join(', ') +
						' }'
					: ''),
				d + '(' + p + f + ')'
			);
		}
	};
}
i(Ur, 'makeSuggestion');
function Vr(e, t, r) {
	return r && (!t || t.toLowerCase() === e.toLowerCase());
}
i(Vr, 'canSuggest');
function oa(e, t, r) {
	var n, o;
	if ((t === void 0 && (t = 'get'), e.matches(_e().defaultIgnore))) return;
	const s = (n = e.getAttribute('role')) != null ? n : (o = gc(e)) == null ? void 0 : o[0];
	if (s !== 'generic' && Vr('Role', r, s))
		return Ur('Role', e, s, {
			variant: t,
			name: mc(e, { computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements })
		});
	const a = Xy(document, e)
		.map((m) => m.content)
		.join(' ');
	if (Vr('LabelText', r, a)) return Ur('LabelText', e, a, { variant: t });
	const u = e.getAttribute('placeholder');
	if (Vr('PlaceholderText', r, u)) return Ur('PlaceholderText', e, u, { variant: t });
	const c = gv(ji(e));
	if (Vr('Text', r, c)) return Ur('Text', e, c, { variant: t });
	if (Vr('DisplayValue', r, e.value)) return Ur('DisplayValue', e, gv(e.value), { variant: t });
	const d = e.getAttribute('alt');
	if (Vr('AltText', r, d)) return Ur('AltText', e, d, { variant: t });
	const p = e.getAttribute('title');
	if (Vr('Title', r, p)) return Ur('Title', e, p, { variant: t });
	const f = e.getAttribute(_e().testIdAttribute);
	if (Vr('TestId', r, f)) return Ur('TestId', e, f, { variant: t });
}
i(oa, 'getSuggestedQuery');
function vs(e, t) {
	e.stack = t.stack.replace(t.message, e.message);
}
i(vs, 'copyStackTrace');
function TO(e, t) {
	let {
		container: r = hc(),
		timeout: n = _e().asyncUtilTimeout,
		showOriginalStackTrace: o = _e().showOriginalStackTrace,
		stackTraceError: s,
		interval: a = 50,
		onTimeout: u = i(
			(d) => (
				Object.defineProperty(d, 'message', { value: _e().getElementError(d.message, r).message }),
				d
			),
			'onTimeout'
		),
		mutationObserverOptions: c = { subtree: !0, childList: !0, attributes: !0, characterData: !0 }
	} = t;
	if (typeof e != 'function') throw new TypeError('Received `callback` arg must be a function');
	return new Promise(async (d, p) => {
		let f,
			m,
			y,
			g = !1,
			E = 'idle';
		const T = setTimeout(q, n),
			b = ol();
		if (b) {
			const { unstable_advanceTimersWrapper: C } = _e();
			for (I(); !g; ) {
				if (!ol()) {
					const R = new Error(
						"Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830"
					);
					(o || vs(R, s), p(R));
					return;
				}
				if (
					(await C(async () => {
						jest.advanceTimersByTime(a);
					}),
					g)
				)
					break;
				I();
			}
		} else {
			try {
				jr(r);
			} catch (R) {
				p(R);
				return;
			}
			m = setInterval(P, a);
			const { MutationObserver: C } = Wy(r);
			((y = new C(P)), y.observe(r, c), I());
		}
		function w(C, R) {
			((g = !0), clearTimeout(T), b || (clearInterval(m), y.disconnect()), C ? p(C) : d(R));
		}
		i(w, 'onDone');
		function P() {
			if (ol()) {
				const C = new Error(
					"Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830"
				);
				return (o || vs(C, s), p(C));
			} else return I();
		}
		i(P, 'checkRealTimersCallback');
		function I() {
			if (E !== 'pending')
				try {
					const C = iO(e);
					typeof C?.then == 'function'
						? ((E = 'pending'),
							C.then(
								(R) => {
									((E = 'resolved'), w(null, R));
								},
								(R) => {
									((E = 'rejected'), (f = R));
								}
							))
						: w(null, C);
				} catch (C) {
					f = C;
				}
		}
		i(I, 'checkCallback');
		function q() {
			let C;
			(f
				? ((C = f), !o && C.name === 'TestingLibraryElementError' && vs(C, s))
				: ((C = new Error('Timed out in waitFor.')), o || vs(C, s)),
				w(u(C), null));
		}
		i(q, 'handleTimeout');
	});
}
i(TO, 'waitFor');
function bc(e, t) {
	const r = new Error('STACK_TRACE_MESSAGE');
	return _e().asyncWrapper(() => TO(e, { stackTraceError: r, ...t }));
}
i(bc, 'waitForWrapper');
function Ma(e, t) {
	return _e().getElementError(e, t);
}
i(Ma, 'getElementError');
function qa(e, t) {
	return Ma(
		e +
			'\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).',
		t
	);
}
i(qa, 'getMultipleElementsFoundError');
function Bn(e, t, r, n) {
	let { exact: o = !0, collapseWhitespace: s, trim: a, normalizer: u } = n === void 0 ? {} : n;
	const c = o ? xr : xo,
		d = Fn({ collapseWhitespace: s, trim: a, normalizer: u });
	return Array.from(t.querySelectorAll('[' + e + ']')).filter((p) => c(p.getAttribute(e), p, r, d));
}
i(Bn, 'queryAllByAttribute');
function ng(e, t, r, n) {
	const o = Bn(e, t, r, n);
	if (o.length > 1) throw qa('Found multiple elements by [' + e + '=' + r + ']', t);
	return o[0] || null;
}
i(ng, 'queryByAttribute');
function ho(e, t) {
	return function (r) {
		for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
			o[s - 1] = arguments[s];
		const a = e(r, ...o);
		if (a.length > 1) {
			const u = a.map((c) => Ma(null, c).message).join(`

`);
			throw qa(
				t(r, ...o) +
					`

Here are the matching elements:

` +
					u,
				r
			);
		}
		return a[0] || null;
	};
}
i(ho, 'makeSingleQuery');
function og(e, t) {
	return _e().getElementError(
		`A better query is available, try this:
` +
			e.toString() +
			`
`,
		t
	);
}
i(og, 'getSuggestionError');
function vc(e, t) {
	return function (r) {
		for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
			o[s - 1] = arguments[s];
		const a = e(r, ...o);
		if (!a.length) throw _e().getElementError(t(r, ...o), r);
		return a;
	};
}
i(vc, 'makeGetAllQuery');
function yo(e) {
	return (t, r, n, o) => bc(() => e(t, r, n), { container: t, ...o });
}
i(yo, 'makeFindQuery');
var Sn = i(
		(e, t, r) =>
			function (n) {
				for (var o = arguments.length, s = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++)
					s[a - 1] = arguments[a];
				const u = e(n, ...s),
					[{ suggest: c = _e().throwSuggestions } = {}] = s.slice(-1);
				if (u && c) {
					const d = oa(u, r);
					if (d && !t.endsWith(d.queryName)) throw og(d.toString(), n);
				}
				return u;
			},
		'wrapSingleQueryWithSuggestion'
	),
	Dt = i(
		(e, t, r) =>
			function (n) {
				for (var o = arguments.length, s = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++)
					s[a - 1] = arguments[a];
				const u = e(n, ...s),
					[{ suggest: c = _e().throwSuggestions } = {}] = s.slice(-1);
				if (u.length && c) {
					const d = [
						...new Set(
							u.map((p) => {
								var f;
								return (f = oa(p, r)) == null ? void 0 : f.toString();
							})
						)
					];
					if (d.length === 1 && !t.endsWith(oa(u[0], r).queryName)) throw og(d[0], n);
				}
				return u;
			},
		'wrapAllByQueryWithSuggestion'
	);
function Dr(e, t, r) {
	const n = Sn(ho(e, t), e.name, 'query'),
		o = vc(e, r),
		s = ho(o, t),
		a = Sn(s, e.name, 'get'),
		u = Dt(o, e.name.replace('query', 'get'), 'getAll'),
		c = yo(Dt(o, e.name, 'findAll')),
		d = yo(Sn(s, e.name, 'find'));
	return [n, u, a, c, d];
}
i(Dr, 'buildQueries');
var wV = Object.freeze({
	__proto__: null,
	getElementError: Ma,
	wrapAllByQueryWithSuggestion: Dt,
	wrapSingleQueryWithSuggestion: Sn,
	getMultipleElementsFoundError: qa,
	queryAllByAttribute: Bn,
	queryByAttribute: ng,
	makeSingleQuery: ho,
	makeGetAllQuery: vc,
	makeFindQuery: yo,
	buildQueries: Dr
});
function _O(e) {
	return Array.from(e.querySelectorAll('label,input'))
		.map((t) => ({ node: t, textToMatch: Vl(t) }))
		.filter((t) => {
			let { textToMatch: r } = t;
			return r !== null;
		});
}
i(_O, 'queryAllLabels');
var SV = i(function (e, t, r) {
		let { exact: n = !0, trim: o, collapseWhitespace: s, normalizer: a } = r === void 0 ? {} : r;
		const u = n ? xr : xo,
			c = Fn({ collapseWhitespace: s, trim: o, normalizer: a });
		return _O(e)
			.filter((p) => {
				let { node: f, textToMatch: m } = p;
				return u(m, f, t, c);
			})
			.map((p) => {
				let { node: f } = p;
				return f;
			});
	}, 'queryAllLabelsByText'),
	ia = i(function (e, t, r) {
		let {
			selector: n = '*',
			exact: o = !0,
			collapseWhitespace: s,
			trim: a,
			normalizer: u
		} = r === void 0 ? {} : r;
		jr(e);
		const c = o ? xr : xo,
			d = Fn({ collapseWhitespace: s, trim: a, normalizer: u }),
			p = Array.from(e.querySelectorAll('*'))
				.filter((f) => Yy(f).length || f.hasAttribute('aria-labelledby'))
				.reduce((f, m) => {
					const y = Xy(e, m, { selector: n });
					y.filter((E) => !!E.formControl).forEach((E) => {
						c(E.content, E.formControl, t, d) && E.formControl && f.push(E.formControl);
					});
					const g = y.filter((E) => !!E.content).map((E) => E.content);
					return (
						c(g.join(' '), m, t, d) && f.push(m),
						g.length > 1 &&
							g.forEach((E, T) => {
								c(E, m, t, d) && f.push(m);
								const b = [...g];
								(b.splice(T, 1), b.length > 1 && c(b.join(' '), m, t, d) && f.push(m));
							}),
						f
					);
				}, [])
				.concat(Bn('aria-label', e, t, { exact: o, normalizer: d }));
		return Array.from(new Set(p)).filter((f) => f.matches(n));
	}, 'queryAllByLabelText'),
	go = i(function (e, t) {
		for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
			n[o - 2] = arguments[o];
		const s = ia(e, t, ...n);
		if (!s.length) {
			const a = SV(e, t, ...n);
			if (a.length) {
				const u = a.map((c) => wO(e, c)).filter((c) => !!c);
				throw u.length
					? _e().getElementError(
							u.map(
								(c) =>
									'Found a label with the text of: ' +
									t +
									', however the element associated with this label (<' +
									c +
									' />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <' +
									c +
									' />, you can use aria-label or aria-labelledby instead.'
							).join(`

`),
							e
						)
					: _e().getElementError(
							'Found a label with the text of: ' +
								t +
								`, however no form control was found associated to that label. Make sure you're using the "for" attribute or "aria-labelledby" attribute correctly.`,
							e
						);
			} else throw _e().getElementError('Unable to find a label with the text of: ' + t, e);
		}
		return s;
	}, 'getAllByLabelText');
function wO(e, t) {
	const r = t.getAttribute('for');
	if (!r) return null;
	const n = e.querySelector('[id="' + r + '"]');
	return n ? n.tagName.toLowerCase() : null;
}
i(wO, 'getTagNameOfElementAssociatedWithLabelViaFor');
var SO = i((e, t) => 'Found multiple elements with the text of: ' + t, 'getMultipleError$7'),
	RO = Sn(ho(ia, SO), ia.name, 'query'),
	PO = ho(go, SO),
	AO = yo(Dt(go, go.name, 'findAll')),
	OO = yo(Sn(PO, go.name, 'find')),
	CO = Dt(go, go.name, 'getAll'),
	xO = Sn(PO, go.name, 'get'),
	IO = Dt(ia, ia.name, 'queryAll'),
	Gp = i(function () {
		for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
		return (jr(t[0]), Bn('placeholder', ...t));
	}, 'queryAllByPlaceholderText'),
	RV = i(
		(e, t) => 'Found multiple elements with the placeholder text of: ' + t,
		'getMultipleError$6'
	),
	PV = i(
		(e, t) => 'Unable to find an element with the placeholder text of: ' + t,
		'getMissingError$6'
	),
	NO = Dt(Gp, Gp.name, 'queryAll'),
	[MO, qO, jO, DO, kO] = Dr(Gp, RV, PV),
	zp = i(function (e, t, r) {
		let {
			selector: n = '*',
			exact: o = !0,
			collapseWhitespace: s,
			trim: a,
			ignore: u = _e().defaultIgnore,
			normalizer: c
		} = r === void 0 ? {} : r;
		jr(e);
		const d = o ? xr : xo,
			p = Fn({ collapseWhitespace: s, trim: a, normalizer: c });
		let f = [];
		return (
			typeof e.matches == 'function' && e.matches(n) && (f = [e]),
			[...f, ...Array.from(e.querySelectorAll(n))]
				.filter((m) => !u || !m.matches(u))
				.filter((m) => d(ji(m), m, t, p))
		);
	}, 'queryAllByText'),
	AV = i((e, t) => 'Found multiple elements with the text: ' + t, 'getMultipleError$5'),
	OV = i(function (e, t, r) {
		r === void 0 && (r = {});
		const { collapseWhitespace: n, trim: o, normalizer: s, selector: a } = r,
			c = Fn({ collapseWhitespace: n, trim: o, normalizer: s })(t.toString()),
			d = c !== t.toString(),
			p = (a ?? '*') !== '*';
		return (
			'Unable to find an element with the text: ' +
			(d ? c + " (normalized from '" + t + "')" : t) +
			(p ? ", which matches selector '" + a + "'" : '') +
			'. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.'
		);
	}, 'getMissingError$5'),
	LO = Dt(zp, zp.name, 'queryAll'),
	[FO, BO, JO, $O, UO] = Dr(zp, AV, OV),
	Wp = i(function (e, t, r) {
		let { exact: n = !0, collapseWhitespace: o, trim: s, normalizer: a } = r === void 0 ? {} : r;
		jr(e);
		const u = n ? xr : xo,
			c = Fn({ collapseWhitespace: o, trim: s, normalizer: a });
		return Array.from(e.querySelectorAll('input,textarea,select')).filter((d) =>
			d.tagName === 'SELECT'
				? Array.from(d.options)
						.filter((f) => f.selected)
						.some((f) => u(ji(f), f, t, c))
				: u(d.value, d, t, c)
		);
	}, 'queryAllByDisplayValue'),
	CV = i(
		(e, t) => 'Found multiple elements with the display value: ' + t + '.',
		'getMultipleError$4'
	),
	xV = i(
		(e, t) => 'Unable to find an element with the display value: ' + t + '.',
		'getMissingError$4'
	),
	VO = Dt(Wp, Wp.name, 'queryAll'),
	[HO, GO, zO, WO, KO] = Dr(Wp, CV, xV),
	IV = /^(img|input|area|.+-.+)$/i,
	Kp = i(function (e, t, r) {
		return (r === void 0 && (r = {}), jr(e), Bn('alt', e, t, r).filter((n) => IV.test(n.tagName)));
	}, 'queryAllByAltText'),
	NV = i((e, t) => 'Found multiple elements with the alt text: ' + t, 'getMultipleError$3'),
	MV = i((e, t) => 'Unable to find an element with the alt text: ' + t, 'getMissingError$3'),
	YO = Dt(Kp, Kp.name, 'queryAll'),
	[XO, QO, ZO, eC, tC] = Dr(Kp, NV, MV),
	qV = i((e) => {
		var t;
		return (
			e.tagName.toLowerCase() === 'title' &&
			((t = e.parentElement) == null ? void 0 : t.tagName.toLowerCase()) === 'svg'
		);
	}, 'isSvgTitle'),
	Yp = i(function (e, t, r) {
		let { exact: n = !0, collapseWhitespace: o, trim: s, normalizer: a } = r === void 0 ? {} : r;
		jr(e);
		const u = n ? xr : xo,
			c = Fn({ collapseWhitespace: o, trim: s, normalizer: a });
		return Array.from(e.querySelectorAll('[title], svg > title')).filter(
			(d) => u(d.getAttribute('title'), d, t, c) || (qV(d) && u(ji(d), d, t, c))
		);
	}, 'queryAllByTitle'),
	jV = i((e, t) => 'Found multiple elements with the title: ' + t + '.', 'getMultipleError$2'),
	DV = i((e, t) => 'Unable to find an element with the title: ' + t + '.', 'getMissingError$2'),
	rC = Dt(Yp, Yp.name, 'queryAll'),
	[nC, oC, iC, sC, aC] = Dr(Yp, jV, DV),
	Xp = i(function (e, t, r) {
		let {
			hidden: n = _e().defaultHidden,
			name: o,
			description: s,
			queryFallbacks: a = !1,
			selected: u,
			busy: c,
			checked: d,
			pressed: p,
			current: f,
			level: m,
			expanded: y,
			value: { now: g, min: E, max: T, text: b } = {}
		} = r === void 0 ? {} : r;
		if ((jr(e), u !== void 0)) {
			var w;
			if (((w = Zt.roles.get(t)) == null ? void 0 : w.props['aria-selected']) === void 0)
				throw new Error('"aria-selected" is not supported on role "' + t + '".');
		}
		if (c !== void 0) {
			var P;
			if (((P = Zt.roles.get(t)) == null ? void 0 : P.props['aria-busy']) === void 0)
				throw new Error('"aria-busy" is not supported on role "' + t + '".');
		}
		if (d !== void 0) {
			var I;
			if (((I = Zt.roles.get(t)) == null ? void 0 : I.props['aria-checked']) === void 0)
				throw new Error('"aria-checked" is not supported on role "' + t + '".');
		}
		if (p !== void 0) {
			var q;
			if (((q = Zt.roles.get(t)) == null ? void 0 : q.props['aria-pressed']) === void 0)
				throw new Error('"aria-pressed" is not supported on role "' + t + '".');
		}
		if (f !== void 0) {
			var C;
			if (((C = Zt.roles.get(t)) == null ? void 0 : C.props['aria-current']) === void 0)
				throw new Error('"aria-current" is not supported on role "' + t + '".');
		}
		if (m !== void 0 && t !== 'heading')
			throw new Error('Role "' + t + '" cannot have "level" property.');
		if (g !== void 0) {
			var R;
			if (((R = Zt.roles.get(t)) == null ? void 0 : R.props['aria-valuenow']) === void 0)
				throw new Error('"aria-valuenow" is not supported on role "' + t + '".');
		}
		if (T !== void 0) {
			var _;
			if (((_ = Zt.roles.get(t)) == null ? void 0 : _.props['aria-valuemax']) === void 0)
				throw new Error('"aria-valuemax" is not supported on role "' + t + '".');
		}
		if (E !== void 0) {
			var S;
			if (((S = Zt.roles.get(t)) == null ? void 0 : S.props['aria-valuemin']) === void 0)
				throw new Error('"aria-valuemin" is not supported on role "' + t + '".');
		}
		if (b !== void 0) {
			var D;
			if (((D = Zt.roles.get(t)) == null ? void 0 : D.props['aria-valuetext']) === void 0)
				throw new Error('"aria-valuetext" is not supported on role "' + t + '".');
		}
		if (y !== void 0) {
			var N;
			if (((N = Zt.roles.get(t)) == null ? void 0 : N.props['aria-expanded']) === void 0)
				throw new Error('"aria-expanded" is not supported on role "' + t + '".');
		}
		const V = new WeakMap();
		function H(A) {
			return (V.has(A) || V.set(A, eg(A)), V.get(A));
		}
		return (
			i(H, 'cachedIsSubtreeInaccessible'),
			Array.from(e.querySelectorAll(lC(t)))
				.filter((A) => {
					if (A.hasAttribute('role')) {
						const k = A.getAttribute('role');
						if (a)
							return k
								.split(' ')
								.filter(Boolean)
								.some((X) => X === t);
						const [K] = k.split(' ');
						return K === t;
					}
					return gc(A).some((k) => k === t);
				})
				.filter((A) => {
					if (u !== void 0) return u === uO(A);
					if (c !== void 0) return c === cO(A);
					if (d !== void 0) return d === dO(A);
					if (p !== void 0) return p === pO(A);
					if (f !== void 0) return f === fO(A);
					if (y !== void 0) return y === mO(A);
					if (m !== void 0) return m === hO(A);
					if (g !== void 0 || T !== void 0 || E !== void 0 || b !== void 0) {
						let B = !0;
						if (
							(g !== void 0 && B && (B = g === yO(A)),
							T !== void 0 && B && (B = T === gO(A)),
							E !== void 0 && B && (B = E === bO(A)),
							b !== void 0)
						) {
							var L;
							B && (B = xr((L = vO(A)) != null ? L : null, A, b, (k) => k));
						}
						return B;
					}
					return !0;
				})
				.filter((A) =>
					o === void 0
						? !0
						: xr(
								mc(A, {
									computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
								}),
								A,
								o,
								(L) => L
							)
				)
				.filter((A) =>
					s === void 0
						? !0
						: xr(
								Vy(A, {
									computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
								}),
								A,
								s,
								(L) => L
							)
				)
				.filter((A) => (n === !1 ? Na(A, { isSubtreeInaccessible: H }) === !1 : !0))
		);
	}, 'queryAllByRole');
function lC(e) {
	var t;
	const r = '*[role~="' + e + '"]',
		n = (t = Zt.roleElements.get(e)) != null ? t : new Set(),
		o = new Set(
			Array.from(n).map((s) => {
				let { name: a } = s;
				return a;
			})
		);
	return [r].concat(Array.from(o)).join(',');
}
i(lC, 'makeRoleSelector');
var uC = i((e) => {
		let t = '';
		return (
			e === void 0
				? (t = '')
				: typeof e == 'string'
					? (t = ' and name "' + e + '"')
					: (t = ' and name `' + e + '`'),
			t
		);
	}, 'getNameHint'),
	kV = i(function (e, t, r) {
		let { name: n } = r === void 0 ? {} : r;
		return 'Found multiple elements with the role "' + t + '"' + uC(n);
	}, 'getMultipleError$1'),
	LV = i(function (e, t, r) {
		let { hidden: n = _e().defaultHidden, name: o, description: s } = r === void 0 ? {} : r;
		if (_e()._disableExpensiveErrorDiagnostics) return 'Unable to find role="' + t + '"' + uC(o);
		let a = '';
		Array.from(e.children).forEach((p) => {
			a += rg(p, { hidden: n, includeDescription: s !== void 0 });
		});
		let u;
		a.length === 0
			? n === !1
				? (u =
						'There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole')
				: (u = 'There are no available roles.')
			: (u = (
					`
Here are the ` +
					(n === !1 ? 'accessible' : 'available') +
					` roles:

  ` +
					a
						.replace(
							/\n/g,
							`
  `
						)
						.replace(
							/\n\s\s\n/g,
							`

`
						) +
					`
`
				).trim());
		let c = '';
		o === void 0
			? (c = '')
			: typeof o == 'string'
				? (c = ' and name "' + o + '"')
				: (c = ' and name `' + o + '`');
		let d = '';
		return (
			s === void 0
				? (d = '')
				: typeof s == 'string'
					? (d = ' and description "' + s + '"')
					: (d = ' and description `' + s + '`'),
			(
				`
Unable to find an ` +
				(n === !1 ? 'accessible ' : '') +
				'element with the role "' +
				t +
				'"' +
				c +
				d +
				`

` +
				u
			).trim()
		);
	}, 'getMissingError$1'),
	cC = Dt(Xp, Xp.name, 'queryAll'),
	[dC, pC, fC, mC, hC] = Dr(Xp, kV, LV),
	ig = i(() => _e().testIdAttribute, 'getTestIdAttribute'),
	Qp = i(function () {
		for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
		return (jr(t[0]), Bn(ig(), ...t));
	}, 'queryAllByTestId'),
	FV = i((e, t) => 'Found multiple elements by: [' + ig() + '="' + t + '"]', 'getMultipleError'),
	BV = i((e, t) => 'Unable to find an element by: [' + ig() + '="' + t + '"]', 'getMissingError'),
	yC = Dt(Qp, Qp.name, 'queryAll'),
	[gC, bC, vC, EC, TC] = Dr(Qp, FV, BV),
	Hl = Object.freeze({
		__proto__: null,
		queryAllByLabelText: IO,
		queryByLabelText: RO,
		getAllByLabelText: CO,
		getByLabelText: xO,
		findAllByLabelText: AO,
		findByLabelText: OO,
		queryByPlaceholderText: MO,
		queryAllByPlaceholderText: NO,
		getByPlaceholderText: jO,
		getAllByPlaceholderText: qO,
		findAllByPlaceholderText: DO,
		findByPlaceholderText: kO,
		queryByText: FO,
		queryAllByText: LO,
		getByText: JO,
		getAllByText: BO,
		findAllByText: $O,
		findByText: UO,
		queryByDisplayValue: HO,
		queryAllByDisplayValue: VO,
		getByDisplayValue: zO,
		getAllByDisplayValue: GO,
		findAllByDisplayValue: WO,
		findByDisplayValue: KO,
		queryByAltText: XO,
		queryAllByAltText: YO,
		getByAltText: ZO,
		getAllByAltText: QO,
		findAllByAltText: eC,
		findByAltText: tC,
		queryByTitle: nC,
		queryAllByTitle: rC,
		getByTitle: iC,
		getAllByTitle: oC,
		findAllByTitle: sC,
		findByTitle: aC,
		queryByRole: dC,
		queryAllByRole: cC,
		getAllByRole: pC,
		getByRole: fC,
		findAllByRole: mC,
		findByRole: hC,
		queryByTestId: gC,
		queryAllByTestId: yC,
		getByTestId: vC,
		getAllByTestId: bC,
		findAllByTestId: EC,
		findByTestId: TC
	});
function Gl(e, t, r) {
	return (
		t === void 0 && (t = Hl),
		r === void 0 && (r = {}),
		Object.keys(t).reduce((n, o) => {
			const s = t[o];
			return ((n[o] = s.bind(null, e)), n);
		}, r)
	);
}
i(Gl, 'getQueriesForElement');
var _C = i((e) => !e || (Array.isArray(e) && !e.length), 'isRemoved');
function Zp(e) {
	if (_C(e))
		throw new Error(
			'The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.'
		);
}
i(Zp, 'initialCheck');
async function wC(e, t) {
	const r = new Error('Timed out in waitForElementToBeRemoved.');
	if (typeof e != 'function') {
		Zp(e);
		const o = (Array.isArray(e) ? e : [e]).map((s) => {
			let a = s.parentElement;
			if (a === null) return () => null;
			for (; a.parentElement; ) a = a.parentElement;
			return () => (a.contains(s) ? s : null);
		});
		e = i(() => o.map((s) => s()).filter(Boolean), 'callback');
	}
	return (
		Zp(e()),
		bc(() => {
			let n;
			try {
				n = e();
			} catch (o) {
				if (o.name === 'TestingLibraryElementError') return;
				throw o;
			}
			if (!_C(n)) throw r;
		}, t)
	);
}
i(wC, 'waitForElementToBeRemoved');
var bv = {
		copy: {
			EventType: 'ClipboardEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		cut: {
			EventType: 'ClipboardEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		paste: {
			EventType: 'ClipboardEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		compositionEnd: {
			EventType: 'CompositionEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		compositionStart: {
			EventType: 'CompositionEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		compositionUpdate: {
			EventType: 'CompositionEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		keyDown: {
			EventType: 'KeyboardEvent',
			defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 }
		},
		keyPress: {
			EventType: 'KeyboardEvent',
			defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 }
		},
		keyUp: {
			EventType: 'KeyboardEvent',
			defaultInit: { bubbles: !0, cancelable: !0, charCode: 0, composed: !0 }
		},
		focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
		blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
		focusIn: {
			EventType: 'FocusEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		focusOut: {
			EventType: 'FocusEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
		input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
		invalid: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !0 } },
		submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
		reset: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } },
		click: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, button: 0, composed: !0 }
		},
		contextMenu: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		dblClick: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		drag: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
		dragEnd: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
		dragEnter: {
			EventType: 'DragEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		dragExit: {
			EventType: 'DragEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		dragLeave: {
			EventType: 'DragEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		dragOver: {
			EventType: 'DragEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		dragStart: {
			EventType: 'DragEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		drop: { EventType: 'DragEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
		mouseDown: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		mouseEnter: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !1, cancelable: !1, composed: !0 }
		},
		mouseLeave: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !1, cancelable: !1, composed: !0 }
		},
		mouseMove: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		mouseOut: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		mouseOver: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		mouseUp: {
			EventType: 'MouseEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		select: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
		touchCancel: {
			EventType: 'TouchEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		touchEnd: {
			EventType: 'TouchEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		touchMove: {
			EventType: 'TouchEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		touchStart: {
			EventType: 'TouchEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		resize: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
		scroll: { EventType: 'UIEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
		wheel: { EventType: 'WheelEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
		abort: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		canPlay: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		canPlayThrough: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		durationChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		emptied: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		encrypted: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		ended: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		loadedData: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		loadedMetadata: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		loadStart: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
		pause: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		play: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		playing: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		progress: { EventType: 'ProgressEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
		rateChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		seeked: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		seeking: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		stalled: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		suspend: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		timeUpdate: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		volumeChange: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		waiting: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		load: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		error: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		animationStart: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
		animationEnd: { EventType: 'AnimationEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
		animationIteration: {
			EventType: 'AnimationEvent',
			defaultInit: { bubbles: !0, cancelable: !1 }
		},
		transitionCancel: {
			EventType: 'TransitionEvent',
			defaultInit: { bubbles: !0, cancelable: !1 }
		},
		transitionEnd: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
		transitionRun: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
		transitionStart: { EventType: 'TransitionEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
		pointerOver: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		pointerEnter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
		pointerDown: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		pointerMove: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		pointerUp: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		pointerCancel: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		pointerOut: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
		},
		pointerLeave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
		gotPointerCapture: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		lostPointerCapture: {
			EventType: 'PointerEvent',
			defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
		},
		popState: { EventType: 'PopStateEvent', defaultInit: { bubbles: !0, cancelable: !1 } },
		offline: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		online: { EventType: 'Event', defaultInit: { bubbles: !1, cancelable: !1 } },
		pageHide: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } },
		pageShow: { EventType: 'PageTransitionEvent', defaultInit: { bubbles: !0, cancelable: !0 } }
	},
	vv = { doubleClick: 'dblClick' };
function yi(e, t) {
	return _e().eventWrapper(() => {
		if (!t) throw new Error('Unable to fire an event - please provide an event object.');
		if (!e)
			throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
		return e.dispatchEvent(t);
	});
}
i(yi, 'fireEvent');
function qs(e, t, r, n) {
	let { EventType: o = 'Event', defaultInit: s = {} } = n === void 0 ? {} : n;
	if (!t) throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
	const a = { ...s, ...r },
		{ target: { value: u, files: c, ...d } = {} } = a;
	(u !== void 0 && SC(t, u),
		c !== void 0 &&
			Object.defineProperty(t, 'files', {
				configurable: !0,
				enumerable: !0,
				writable: !0,
				value: c
			}),
		Object.assign(t, d));
	const p = Wy(t),
		f = p[o] || p.Event;
	let m;
	if (typeof f == 'function') m = new f(e, a);
	else {
		m = p.document.createEvent(o);
		const { bubbles: g, cancelable: E, detail: T, ...b } = a;
		(m.initEvent(e, g, E, T),
			Object.keys(b).forEach((w) => {
				m[w] = b[w];
			}));
	}
	return (
		['dataTransfer', 'clipboardData'].forEach((g) => {
			const E = a[g];
			typeof E == 'object' &&
				(typeof p.DataTransfer == 'function'
					? Object.defineProperty(m, g, {
							value: Object.getOwnPropertyNames(E).reduce(
								(T, b) => (Object.defineProperty(T, b, { value: E[b] }), T),
								new p.DataTransfer()
							)
						})
					: Object.defineProperty(m, g, { value: E }));
		}),
		m
	);
}
i(qs, 'createEvent');
Object.keys(bv).forEach((e) => {
	const { EventType: t, defaultInit: r } = bv[e],
		n = e.toLowerCase();
	((qs[e] = (o, s) => qs(n, o, s, { EventType: t, defaultInit: r })),
		(yi[e] = (o, s) => yi(o, qs[e](o, s))));
});
function SC(e, t) {
	const { set: r } = Object.getOwnPropertyDescriptor(e, 'value') || {},
		n = Object.getPrototypeOf(e),
		{ set: o } = Object.getOwnPropertyDescriptor(n, 'value') || {};
	if (o && r !== o) o.call(e, t);
	else if (r) r.call(e, t);
	else throw new Error('The given element does not have a value setter');
}
i(SC, 'setNativeValue');
Object.keys(vv).forEach((e) => {
	const t = vv[e];
	yi[e] = function () {
		return yi[t](...arguments);
	};
});
function RC(e) {
	return e.replace(
		/[ \t]*[\n][ \t]*/g,
		`
`
	);
}
i(RC, 'unindent');
function PC(e) {
	return sV.default.compressToEncodedURIComponent(RC(e));
}
i(PC, 'encode');
function AC(e) {
	return 'https://testing-playground.com/#markup=' + PC(e);
}
i(AC, 'getPlaygroundUrl');
var JV = i((e, t, r) => (Array.isArray(e) ? e.forEach((n) => Vp(n, t, r)) : Vp(e, t, r)), 'debug'),
	$V = i(function (e) {
		if ((e === void 0 && (e = hc().body), !e || !('innerHTML' in e))) {
			console.log("The element you're providing isn't a valid DOM element.");
			return;
		}
		if (!e.innerHTML) {
			console.log("The provided element doesn't have any children.");
			return;
		}
		const t = AC(e.innerHTML);
		return (
			console.log(
				`Open this URL in your browser

` + t
			),
			t
		);
	}, 'logTestingPlaygroundURL'),
	Ev = { debug: JV, logTestingPlaygroundURL: $V },
	UV =
		typeof document < 'u' && document.body
			? Gl(document.body, Hl, Ev)
			: Object.keys(Hl).reduce(
					(e, t) => (
						(e[t] = () => {
							throw new TypeError(
								'For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error'
							);
						}),
						e
					),
					Ev
				);
function ge(e, t, r) {
	return (e.namespaceURI && e.namespaceURI !== 'http://www.w3.org/1999/xhtml') ||
		((t = Array.isArray(t) ? t : [t]), !t.includes(e.tagName.toLowerCase()))
		? !1
		: r
			? Object.entries(r).every(([n, o]) => e[n] === o)
			: !0;
}
i(ge, 'isElementType');
function Yt(e) {
	var t;
	if (OC(e) && e.defaultView) return e.defaultView;
	if (!((t = e.ownerDocument) === null || t === void 0) && t.defaultView)
		return e.ownerDocument.defaultView;
	throw new Error(`Could not determine window of node. Node was ${CC(e)}`);
}
i(Yt, 'getWindow');
function OC(e) {
	return e.nodeType === 9;
}
i(OC, 'isDocument');
function CC(e) {
	return typeof e == 'function' ? `function ${e.name}` : e === null ? 'null' : String(e);
}
i(CC, 'describe');
function sg(e, t) {
	return new Promise((r, n) => {
		const o = new t();
		((o.onerror = n),
			(o.onabort = n),
			(o.onload = () => {
				r(String(o.result));
			}),
			o.readAsText(e));
	});
}
i(sg, 'readBlobText');
function Ec(e, t) {
	const r = {
		...t,
		length: t.length,
		item: i((n) => r[n], 'item'),
		[Symbol.iterator]: i(function* () {
			for (let o = 0; o < r.length; o++) yield r[o];
		}, 'nextFile')
	};
	return (
		(r.constructor = e.FileList),
		e.FileList && Object.setPrototypeOf(r, e.FileList.prototype),
		Object.freeze(r),
		r
	);
}
i(Ec, 'createFileList');
function Qr(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(Qr, '_define_property');
var xC = class {
	getAsFile() {
		return this.file;
	}
	getAsString(t) {
		typeof this.data == 'string' && t(this.data);
	}
	webkitGetAsEntry() {
		throw new Error('not implemented');
	}
	constructor(t, r) {
		(Qr(this, 'kind', void 0),
			Qr(this, 'type', void 0),
			Qr(this, 'file', null),
			Qr(this, 'data', void 0),
			typeof t == 'string'
				? ((this.kind = 'string'), (this.type = String(r)), (this.data = t))
				: ((this.kind = 'file'), (this.type = t.type), (this.file = t)));
	}
};
i(xC, 'DataTransferItemStub');
var IC = xC,
	NC = class extends Array {
		add(...t) {
			const r = new IC(t[0], t[1]);
			return (this.push(r), r);
		}
		clear() {
			this.splice(0, this.length);
		}
		remove(t) {
			this.splice(t, 1);
		}
	};
i(NC, 'DataTransferItemListStub');
var VV = NC;
function Es(e, t) {
	const [r, n] = e.split('/'),
		o = !n || n === '*';
	return (s) => (t ? s.type === (o ? r : e) : o ? s.type.startsWith(`${r}/`) : s.type === r);
}
i(Es, 'getTypeMatcher');
function MC(e) {
	var t;
	return new ((t = class {
		getData(r) {
			var n;
			const o =
				(n = this.items.find(Es(r, !0))) !== null && n !== void 0 ? n : this.items.find(Es(r, !1));
			let s = '';
			return (
				o?.getAsString((a) => {
					s = a;
				}),
				s
			);
		}
		setData(r, n) {
			const o = this.items.findIndex(Es(r, !0)),
				s = new IC(n, r);
			o >= 0 ? this.items.splice(o, 1, s) : this.items.push(s);
		}
		clearData(r) {
			if (r) {
				const n = this.items.findIndex(Es(r, !0));
				n >= 0 && this.items.remove(n);
			} else this.items.clear();
		}
		get types() {
			const r = [];
			return (
				this.files.length && r.push('Files'),
				this.items.forEach((n) => r.push(n.type)),
				Object.freeze(r),
				r
			);
		}
		setDragImage() {}
		constructor() {
			(Qr(this, 'dropEffect', 'none'),
				Qr(this, 'effectAllowed', 'uninitialized'),
				Qr(this, 'items', new VV()),
				Qr(this, 'files', Ec(e, [])));
		}
	}),
	i(t, 'DataTransferStub'),
	t)();
}
i(MC, 'createDataTransferStub');
function Tc(e, t = []) {
	const r = typeof e.DataTransfer > 'u' ? MC(e) : new e.DataTransfer();
	return (Object.defineProperty(r, 'files', { get: i(() => Ec(e, t), 'get') }), r);
}
i(Tc, 'createDataTransfer');
async function qC(e, t) {
	return t.kind === 'file'
		? t.getAsFile()
		: new e.Blob([await new Promise((r) => t.getAsString(r))], { type: t.type });
}
i(qC, 'getBlobFromDataTransferItem');
function ag(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(ag, '_define_property');
function lg(e, ...t) {
	var r;
	const n = Object.fromEntries(
		t.map((o) => [typeof o == 'string' ? 'text/plain' : o.type, Promise.resolve(o)])
	);
	return typeof e.ClipboardItem < 'u'
		? new e.ClipboardItem(n)
		: new ((r = class {
				get types() {
					return Array.from(Object.keys(this.data));
				}
				async getType(o) {
					const s = await this.data[o];
					if (!s) throw new Error(`${o} is not one of the available MIME types on this item.`);
					return s instanceof e.Blob ? s : new e.Blob([s], { type: o });
				}
				constructor(o) {
					(ag(this, 'data', void 0), (this.data = o));
				}
			}),
			i(r, 'ClipboardItem'),
			r)(n);
}
i(lg, 'createClipboardItem');
var gi = Symbol('Manage ClipboardSub');
function ef(e, t) {
	var r;
	return Object.assign(
		new ((r = class extends e.EventTarget {
			async read() {
				return Array.from(this.items);
			}
			async readText() {
				let n = '';
				for (const o of this.items) {
					const s = o.types.includes('text/plain')
						? 'text/plain'
						: o.types.find((a) => a.startsWith('text/'));
					s && (n += await o.getType(s).then((a) => sg(a, e.FileReader)));
				}
				return n;
			}
			async write(n) {
				this.items = n;
			}
			async writeText(n) {
				this.items = [lg(e, n)];
			}
			constructor(...n) {
				(super(...n), ag(this, 'items', []));
			}
		}),
		i(r, 'Clipboard'),
		r)(),
		{ [gi]: t }
	);
}
i(ef, 'createClipboardStub');
function _c(e) {
	return !!e?.[gi];
}
i(_c, 'isClipboardStub');
function jC(e) {
	if (_c(e.navigator.clipboard)) return e.navigator.clipboard[gi];
	const t = Object.getOwnPropertyDescriptor(e.navigator, 'clipboard');
	let r;
	const n = {
		resetClipboardStub: i(() => {
			r = ef(e, n);
		}, 'resetClipboardStub'),
		detachClipboardStub: i(() => {
			t
				? Object.defineProperty(e.navigator, 'clipboard', t)
				: Object.defineProperty(e.navigator, 'clipboard', { value: void 0, configurable: !0 });
		}, 'detachClipboardStub')
	};
	return (
		(r = ef(e, n)),
		Object.defineProperty(e.navigator, 'clipboard', { get: i(() => r, 'get'), configurable: !0 }),
		r[gi]
	);
}
i(jC, 'attachClipboardStubToView');
function DC(e) {
	_c(e.navigator.clipboard) && e.navigator.clipboard[gi].resetClipboardStub();
}
i(DC, 'resetClipboardStubOnView');
function kC(e) {
	_c(e.navigator.clipboard) && e.navigator.clipboard[gi].detachClipboardStub();
}
i(kC, 'detachClipboardStubFromView');
async function LC(e) {
	const t = e.defaultView,
		r = t?.navigator.clipboard,
		n = r && (await r.read());
	if (!n) throw new Error('The Clipboard API is unavailable.');
	const o = Tc(t);
	for (const s of n)
		for (const a of s.types) o.setData(a, await s.getType(a).then((u) => sg(u, t.FileReader)));
	return o;
}
i(LC, 'readDataTransferFromClipboard');
async function ug(e, t) {
	const r = Yt(e),
		n = r.navigator.clipboard,
		o = [];
	for (let a = 0; a < t.items.length; a++) {
		const u = t.items[a],
			c = await qC(r, u);
		o.push(lg(r, c));
	}
	if (
		!(
			n &&
			(await n.write(o).then(
				() => !0,
				() => !1
			))
		)
	)
		throw new Error('The Clipboard API is unavailable.');
}
i(ug, 'writeDataTransferToClipboard');
var zl = globalThis;
typeof zl.afterEach == 'function' &&
	zl.afterEach(() => {
		typeof globalThis.window < 'u' && DC(globalThis.window);
	});
typeof zl.afterAll == 'function' &&
	zl.afterAll(() => {
		typeof globalThis.window < 'u' && kC(globalThis.window);
	});
var FC = [
	'input:not([type=hidden]):not([disabled])',
	'button:not([disabled])',
	'select:not([disabled])',
	'textarea:not([disabled])',
	'[contenteditable=""]',
	'[contenteditable="true"]',
	'a[href]',
	'[tabindex]:not([disabled])'
].join(', ');
function wc(e) {
	return e.matches(FC);
}
i(wc, 'isFocusable');
function BC(e) {
	return new e.constructor(e.type, e);
}
i(BC, 'cloneEvent');
function Nr(e) {
	for (let r = e; r; r = r.parentElement)
		if (ge(r, ['button', 'input', 'select', 'textarea', 'optgroup', 'option'])) {
			if (r.hasAttribute('disabled')) return !0;
		} else if (ge(r, 'fieldset')) {
			var t;
			if (
				r.hasAttribute('disabled') &&
				!(!((t = r.querySelector(':scope > legend')) === null || t === void 0) && t.contains(e))
			)
				return !0;
		} else if (
			r.tagName.includes('-') &&
			r.constructor.formAssociated &&
			r.hasAttribute('disabled')
		)
			return !0;
	return !1;
}
i(Nr, 'isDisabled');
function ki(e) {
	const t = e.activeElement;
	return t?.shadowRoot
		? ki(t.shadowRoot)
		: Nr(t)
			? e.ownerDocument
				? e.ownerDocument.body
				: e.body
			: t;
}
i(ki, 'getActiveElement');
function il(e) {
	var t;
	return (t = ki(e)) !== null && t !== void 0 ? t : e.body;
}
i(il, 'getActiveElementOrBody');
function JC(e, t) {
	let r = e;
	do {
		if (t(r)) return r;
		r = r.parentElement;
	} while (r && r !== e.ownerDocument.body);
}
i(JC, 'findClosest');
function Mn(e) {
	return (
		e.hasAttribute('contenteditable') &&
		(e.getAttribute('contenteditable') == 'true' || e.getAttribute('contenteditable') == '')
	);
}
i(Mn, 'isContentEditable');
function bi(e) {
	const t = $C(e);
	return t && (t.closest('[contenteditable=""]') || t.closest('[contenteditable="true"]'));
}
i(bi, 'getContentEditable');
function $C(e) {
	return e.nodeType === 1 ? e : e.parentElement;
}
i($C, 'getElement');
var UC = (function (e) {
	return (
		(e.button = 'button'),
		(e.color = 'color'),
		(e.file = 'file'),
		(e.image = 'image'),
		(e.reset = 'reset'),
		(e.submit = 'submit'),
		(e.checkbox = 'checkbox'),
		(e.radio = 'radio'),
		e
	);
})(UC || {});
function cg(e) {
	return ge(e, 'button') || (ge(e, 'input') && e.type in UC);
}
i(cg, 'isClickableInput');
function bo(e) {
	return (dg(e) && !e.readOnly) || Mn(e);
}
i(bo, 'isEditable');
var VC = (function (e) {
	return (
		(e.text = 'text'),
		(e.date = 'date'),
		(e['datetime-local'] = 'datetime-local'),
		(e.email = 'email'),
		(e.month = 'month'),
		(e.number = 'number'),
		(e.password = 'password'),
		(e.search = 'search'),
		(e.tel = 'tel'),
		(e.time = 'time'),
		(e.url = 'url'),
		(e.week = 'week'),
		e
	);
})(VC || {});
function dg(e) {
	return ge(e, 'textarea') || (ge(e, 'input') && e.type in VC);
}
i(dg, 'isEditableInputOrTextArea');
function gr(e) {
	return pg(e) && dg(e);
}
i(gr, 'hasOwnSelection');
function HC(e) {
	return pg(e) && cg(e);
}
i(HC, 'hasNoSelection');
function pg(e) {
	return e.nodeType === 1;
}
i(pg, 'isElement');
function GC(e) {
	const t = e.ownerDocument.getSelection();
	if (t?.focusNode && gr(e)) {
		const n = bi(t.focusNode);
		if (n) {
			if (!t.isCollapsed) {
				var r;
				const o =
					((r = n.firstChild) === null || r === void 0 ? void 0 : r.nodeType) === 3
						? n.firstChild
						: n;
				t.setBaseAndExtent(o, 0, o, 0);
			}
		} else t.setBaseAndExtent(e, 0, e, 0);
	}
}
i(GC, 'updateSelectionOnFocus');
function vo(e, t) {
	return _e().eventWrapper(e);
}
i(vo, 'wrapEvent');
function sn(e) {
	const t = JC(e, wc),
		r = ki(e.ownerDocument);
	(t ?? e.ownerDocument.body) !== r &&
		(vo(t ? () => t.focus() : () => r?.blur()), GC(t ?? e.ownerDocument.body));
}
i(sn, 'focusElement');
function zC(e) {
	!wc(e) || !(ki(e.ownerDocument) === e) || vo(() => e.blur());
}
i(zC, 'blurElement');
var qn = {};
qn.click = (e, t, r) => {
	const n = t.closest('button,input,label,select,textarea'),
		o = n && ge(n, 'label') && n.control;
	if (o && o !== t)
		return () => {
			wc(o) && (sn(o), r.dispatchEvent(o, BC(e)));
		};
	if (ge(t, 'input', { type: 'file' }))
		return () => {
			(zC(t), t.dispatchEvent(new (Yt(t).Event)('fileDialog')), sn(t));
		};
};
var vi = Symbol('Displayed value in UI'),
	Zr = Symbol('Displayed selection in UI'),
	Wl = Symbol('Initial value to compare on blur');
function WC(e) {
	return typeof e == 'object' && vi in e;
}
i(WC, 'isUIValue');
function KC(e) {
	return !!e && typeof e == 'object' && Zr in e;
}
i(KC, 'isUISelectionStart');
function YC(e, t) {
	(e[Wl] === void 0 && (e[Wl] = e.value),
		(e[vi] = t),
		(e.value = Object.assign(new String(t), { [vi]: !0 })));
}
i(YC, 'setUIValue');
function br(e) {
	return e[vi] === void 0 ? e.value : String(e[vi]);
}
i(br, 'getUIValue');
function Sc(e) {
	e[vi] = void 0;
}
i(Sc, 'setUIValueClean');
function fg(e) {
	e[Wl] = void 0;
}
i(fg, 'clearInitialValue');
function XC(e) {
	return e[Wl];
}
i(XC, 'getInitialValue');
function QC(e, t) {
	e[Zr] = t;
}
i(QC, 'setUISelectionRaw');
function Io(e, { focusOffset: t, anchorOffset: r = t }, n = 'replace') {
	const o = br(e).length,
		s = i((f) => Math.max(0, Math.min(o, f)), 'sanitizeOffset'),
		a = n === 'replace' || e[Zr] === void 0 ? s(r) : e[Zr].anchorOffset,
		u = s(t),
		c = Math.min(a, u),
		d = Math.max(a, u);
	if (
		((e[Zr] = { anchorOffset: a, focusOffset: u }), e.selectionStart === c && e.selectionEnd === d)
	)
		return;
	const p = Object.assign(new Number(c), { [Zr]: !0 });
	try {
		e.setSelectionRange(p, d);
	} catch {}
}
i(Io, 'setUISelection');
function Ei(e) {
	var t, r, n;
	const o =
		(n = e[Zr]) !== null && n !== void 0
			? n
			: {
					anchorOffset: (t = e.selectionStart) !== null && t !== void 0 ? t : 0,
					focusOffset: (r = e.selectionEnd) !== null && r !== void 0 ? r : 0
				};
	return {
		...o,
		startOffset: Math.min(o.anchorOffset, o.focusOffset),
		endOffset: Math.max(o.anchorOffset, o.focusOffset)
	};
}
i(Ei, 'getUISelection');
function ZC(e) {
	return !!e[Zr];
}
i(ZC, 'hasUISelection');
function js(e) {
	e[Zr] = void 0;
}
i(js, 'setUISelectionClean');
var Kl = globalThis.parseInt;
function ex(e) {
	const t = e.replace(/\D/g, '');
	if (t.length < 2) return e;
	const r = Kl(t[0], 10),
		n = Kl(t[1], 10);
	if (r >= 3 || (r === 2 && n >= 4)) {
		let o;
		return (r >= 3 ? (o = 1) : (o = 2), tf(t, o));
	}
	return e.length === 2 ? e : tf(t, 2);
}
i(ex, 'buildTimeValue');
function tf(e, t) {
	const r = e.slice(0, t),
		n = Math.min(Kl(r, 10), 23),
		o = e.slice(t),
		s = Kl(o, 10),
		a = Math.min(s, 59);
	return `${n.toString().padStart(2, '0')}:${a.toString().padStart(2, '0')}`;
}
i(tf, 'build');
function mg(e, t) {
	const r = e.cloneNode();
	return ((r.value = t), r.value === t);
}
i(mg, 'isValidDateOrTimeValue');
var tx = (function (e) {
	return (
		(e.email = 'email'),
		(e.password = 'password'),
		(e.search = 'search'),
		(e.telephone = 'telephone'),
		(e.text = 'text'),
		(e.url = 'url'),
		e
	);
})(tx || {});
function rx(e) {
	var t;
	const r = (t = e.getAttribute('maxlength')) !== null && t !== void 0 ? t : '';
	return /^\d+$/.test(r) && Number(r) >= 0 ? Number(r) : void 0;
}
i(rx, 'getMaxLength');
function nx(e) {
	return ge(e, 'textarea') || (ge(e, 'input') && e.type in tx);
}
i(nx, 'supportsMaxLength');
function hg(e, t, r, n) {
	if (Ds(e) && t + r >= 0 && t + r <= e.nodeValue.length) return { node: e, offset: t + r };
	const o = rf(e, t, r);
	if (o) {
		if (Ds(o))
			return {
				node: o,
				offset: r > 0 ? Math.min(1, o.nodeValue.length) : Math.max(o.nodeValue.length - 1, 0)
			};
		if (ge(o, 'br')) {
			const s = rf(o, void 0, r);
			return s
				? Ds(s)
					? { node: s, offset: r > 0 ? 0 : s.nodeValue.length }
					: r < 0 && ge(s, 'br')
						? { node: o.parentNode, offset: Ts(o) }
						: { node: s.parentNode, offset: Ts(s) + (r > 0 ? 0 : 1) }
				: r < 0 && n === 'deleteContentBackward'
					? { node: o.parentNode, offset: Ts(o) }
					: void 0;
		} else return { node: o.parentNode, offset: Ts(o) + (r > 0 ? 1 : 0) };
	}
}
i(hg, 'getNextCursorPosition');
function rf(e, t, r) {
	const n = Number(t) + (r < 0 ? -1 : 0);
	return (
		t !== void 0 && Rc(e) && n >= 0 && n < e.children.length && (e = e.children[n]),
		ix(e, r === 1 ? 'next' : 'previous', ox)
	);
}
i(rf, 'getNextCharacterContentNode');
function ox(e) {
	if (Ds(e)) return !0;
	if (Rc(e)) {
		if (ge(e, ['input', 'textarea'])) return e.type !== 'hidden';
		if (ge(e, 'br')) return !0;
	}
	return !1;
}
i(ox, 'isTreatedAsCharacterContent');
function Ts(e) {
	let t = 0;
	for (; e.previousSibling; ) (t++, (e = e.previousSibling));
	return t;
}
i(Ts, 'getOffset');
function Rc(e) {
	return e.nodeType === 1;
}
i(Rc, 'isElement');
function Ds(e) {
	return e.nodeType === 3;
}
i(Ds, 'isTextNode');
function ix(e, t, r) {
	for (;;) {
		var n;
		const o = e[`${t}Sibling`];
		if (o) {
			if (((e = sx(o, t === 'next' ? 'first' : 'last')), r(e))) return e;
		} else if (
			e.parentNode &&
			(!Rc(e.parentNode) ||
				(!Mn(e.parentNode) &&
					e.parentNode !== ((n = e.ownerDocument) === null || n === void 0 ? void 0 : n.body)))
		)
			e = e.parentNode;
		else break;
	}
}
i(ix, 'walkNodes');
function sx(e, t) {
	for (; e.hasChildNodes(); ) e = e[`${t}Child`];
	return e;
}
i(sx, 'getDescendant');
var sa = Symbol('Track programmatic changes for React workaround');
function ax(e) {
	return (
		Object.getOwnPropertyNames(e).some((t) => t.startsWith('__react')) && Yt(e).REACT_VERSION === 17
	);
}
i(ax, 'isReact17Element');
function lx(e) {
	ax(e) && (e[sa] = { previousValue: String(e.value), tracked: [] });
}
i(lx, 'startTrackValue');
function ux(e, t) {
	var r, n;
	((n = e[sa]) === null || n === void 0 || (r = n.tracked) === null || r === void 0 || r.push(t),
		e[sa] || (Sc(e), Io(e, { focusOffset: t.length })));
}
i(ux, 'trackOrSetValue');
function cx(e, t) {
	var r;
	const n = e[sa];
	if (((e[sa] = void 0), !(!(n == null || (r = n.tracked) === null || r === void 0) && r.length)))
		return;
	const o = n.tracked.length === 2 && n.tracked[0] === n.previousValue && n.tracked[1] === e.value;
	(o || Sc(e), ZC(e) && Io(e, { focusOffset: o ? t : e.value.length }));
}
i(cx, 'commitValueAfterInput');
function yg(e) {
	const t = dx(e);
	if (t && gr(t)) return { type: 'input', selection: Ei(t) };
	const r = t?.ownerDocument.getSelection();
	return {
		type: bi(e) && r?.anchorNode && bi(r.anchorNode) ? 'contenteditable' : 'default',
		selection: r
	};
}
i(yg, 'getTargetTypeAndSelection');
function dx(e) {
	return e.nodeType === 1 ? e : e.parentElement;
}
i(dx, 'getElement');
function px(e) {
	const t = yg(e);
	if (t.type === 'input') return t.selection;
	if (t.type === 'contenteditable') {
		var r;
		return (r = t.selection) === null || r === void 0 ? void 0 : r.getRangeAt(0);
	}
}
i(px, 'getInputRange');
function jn({ focusNode: e, focusOffset: t, anchorNode: r = e, anchorOffset: n = t }) {
	var o, s;
	if (yg(e).type === 'input') return Io(e, { anchorOffset: n, focusOffset: t });
	(s = r.ownerDocument) === null ||
		s === void 0 ||
		(o = s.getSelection()) === null ||
		o === void 0 ||
		o.setBaseAndExtent(r, n, e, t);
}
i(jn, 'setSelection');
function gg(e) {
	return ge(e, 'input') && ['date', 'time'].includes(e.type);
}
i(gg, 'isDateOrTime');
function Eo(e, t, r, n = 'insertText') {
	const o = px(t);
	o &&
		((!gg(t) && !e.dispatchUIEvent(t, 'beforeinput', { inputType: n, data: r })) ||
			('startContainer' in o ? fx(e, t, o, r, n) : mx(e, t, o, r, n)));
}
i(Eo, 'input');
function fx(e, t, r, n, o) {
	let s = !1;
	if (!r.collapsed) ((s = !0), r.deleteContents());
	else if (['deleteContentBackward', 'deleteContentForward'].includes(o)) {
		const a = hg(r.startContainer, r.startOffset, o === 'deleteContentBackward' ? -1 : 1, o);
		if (a) {
			s = !0;
			const u = r.cloneRange();
			(u.comparePoint(a.node, a.offset) < 0
				? u.setStart(a.node, a.offset)
				: u.setEnd(a.node, a.offset),
				u.deleteContents());
		}
	}
	if (n)
		if (r.endContainer.nodeType === 3) {
			const a = r.endOffset;
			(r.endContainer.insertData(a, n),
				r.setStart(r.endContainer, a + n.length),
				r.setEnd(r.endContainer, a + n.length));
		} else {
			const a = t.ownerDocument.createTextNode(n);
			(r.insertNode(a), r.setStart(a, n.length), r.setEnd(a, n.length));
		}
	(s || n) && e.dispatchUIEvent(t, 'input', { inputType: o });
}
i(fx, 'editContenteditable');
function mx(e, t, r, n, o) {
	let s = n;
	if (nx(t)) {
		const d = rx(t);
		if (d !== void 0 && n.length > 0) {
			const p = d - t.value.length;
			if (p > 0) s = n.substring(0, p);
			else return;
		}
	}
	const { newValue: a, newOffset: u, oldValue: c } = hx(s, t, r, o);
	(a === c && u === r.startOffset && u === r.endOffset) ||
		(ge(t, 'input', { type: 'number' }) && !yx(a)) ||
		(YC(t, a),
		jn({ focusNode: t, anchorOffset: u, focusOffset: u }),
		gg(t)
			? mg(t, a) && (nf(e, t, u, {}), e.dispatchUIEvent(t, 'change'), fg(t))
			: nf(e, t, u, { data: n, inputType: o }));
}
i(mx, 'editInputElement');
function hx(e, t, { startOffset: r, endOffset: n }, o) {
	const s = br(t),
		a = Math.max(0, r === n && o === 'deleteContentBackward' ? r - 1 : r),
		u = s.substring(0, a),
		c = Math.min(s.length, r === n && o === 'deleteContentForward' ? r + 1 : n),
		d = s.substring(c, s.length);
	let p = `${u}${e}${d}`,
		f = a + e.length;
	if (ge(t, 'input', { type: 'time' })) {
		const m = ex(p);
		m !== '' && mg(t, m) && ((p = m), (f = m.length));
	}
	return { oldValue: s, newValue: p, newOffset: f };
}
i(hx, 'calculateNewValue');
function nf(e, t, r, n) {
	(e.dispatchUIEvent(t, 'input', n), cx(t, r));
}
i(nf, 'commitInput');
function yx(e) {
	var t, r;
	const n = e.split('e', 2);
	return !(
		/[^\d.\-e]/.test(e) ||
		Number((t = e.match(/-/g)) === null || t === void 0 ? void 0 : t.length) > 2 ||
		Number((r = e.match(/\./g)) === null || r === void 0 ? void 0 : r.length) > 1 ||
		(n[1] && !/^-?\d*$/.test(n[1]))
	);
}
i(yx, 'isValidNumberInput');
qn.cut = (e, t, r) => () => {
	bo(t) && Eo(r, t, '', 'deleteByCut');
};
function gx(e) {
	return e ? (Mn(e) ? e.textContent : br(e)) : null;
}
i(gx, 'getValueOrTextContent');
function bx(e) {
	const t = Yt(e);
	for (let r = e; r?.ownerDocument; r = r.parentElement) {
		const { display: n, visibility: o } = t.getComputedStyle(r);
		if (n === 'none' || o === 'hidden') return !1;
	}
	return !0;
}
i(bx, 'isVisible');
function vx(e, t) {
	const r = e.ownerDocument,
		n = r.querySelectorAll(FC),
		o = Array.from(n).filter((c) => c === e || !(Number(c.getAttribute('tabindex')) < 0 || Nr(c)));
	Number(e.getAttribute('tabindex')) >= 0 &&
		o.sort((c, d) => {
			const p = Number(c.getAttribute('tabindex')),
				f = Number(d.getAttribute('tabindex'));
			return p === f ? 0 : p === 0 ? 1 : f === 0 ? -1 : p - f;
		});
	const s = {};
	let a = [r.body];
	const u = ge(e, 'input', { type: 'radio' }) ? e.name : void 0;
	o.forEach((c) => {
		const d = c;
		if (ge(d, 'input', { type: 'radio' }) && d.name) {
			if (d === e) {
				a.push(d);
				return;
			} else if (d.name === u) return;
			if (d.checked) {
				((a = a.filter((p) => !ge(p, 'input', { type: 'radio', name: d.name }))),
					a.push(d),
					(s[d.name] = d));
				return;
			}
			if (typeof s[d.name] < 'u') return;
		}
		a.push(d);
	});
	for (let c = a.findIndex((d) => d === e); ; )
		if (
			((c += t ? -1 : 1),
			c === a.length ? (c = 0) : c === -1 && (c = a.length - 1),
			a[c] === e || a[c] === r.body || bx(a[c]))
		)
			return a[c];
}
i(vx, 'getTabDestination');
function of(e, t) {
	if (gr(e)) {
		const r = Ei(e);
		jn({
			focusNode: e,
			focusOffset:
				r.startOffset === r.endOffset ? r.focusOffset + t : t < 0 ? r.startOffset : r.endOffset
		});
	} else {
		const r = e.ownerDocument.getSelection();
		if (!r?.focusNode) return;
		if (r.isCollapsed) {
			const n = hg(r.focusNode, r.focusOffset, t);
			n && jn({ focusNode: n.node, focusOffset: n.offset });
		} else r[t < 0 ? 'collapseToStart' : 'collapseToEnd']();
	}
}
i(of, 'moveSelection');
function bg(e) {
	if (gr(e)) return jn({ focusNode: e, anchorOffset: 0, focusOffset: br(e).length });
	var t;
	const r = (t = bi(e)) !== null && t !== void 0 ? t : e.ownerDocument.body;
	jn({ focusNode: r, anchorOffset: 0, focusOffset: r.childNodes.length });
}
i(bg, 'selectAll');
function Ex(e) {
	if (gr(e)) return Ei(e).startOffset === 0 && Ei(e).endOffset === br(e).length;
	var t;
	const r = (t = bi(e)) !== null && t !== void 0 ? t : e.ownerDocument.body,
		n = e.ownerDocument.getSelection();
	return (
		n?.anchorNode === r &&
		n.focusNode === r &&
		n.anchorOffset === 0 &&
		n.focusOffset === r.childNodes.length
	);
}
i(Ex, 'isAllSelected');
function Vo(e, t, r) {
	var n;
	if (gr(e)) return jn({ focusNode: e, anchorOffset: t, focusOffset: r });
	if (Mn(e) && ((n = e.firstChild) === null || n === void 0 ? void 0 : n.nodeType) === 3)
		return jn({ focusNode: e.firstChild, anchorOffset: t, focusOffset: r });
	throw new Error('Not implemented. The result of this interaction is unreliable.');
}
i(Vo, 'setSelectionRange');
function _s(e, t, r) {
	const n = Yt(t),
		o = Array.from(
			t.ownerDocument.querySelectorAll(
				t.name
					? `input[type="radio"][name="${n.CSS.escape(t.name)}"]`
					: 'input[type="radio"][name=""], input[type="radio"]:not([name])'
			)
		);
	for (let s = o.findIndex((a) => a === t) + r; ; s += r) {
		if ((o[s] || (s = r > 0 ? 0 : o.length - 1), o[s] === t)) return;
		if (!Nr(o[s])) {
			(sn(o[s]), e.dispatchUIEvent(o[s], 'click'));
			return;
		}
	}
}
i(_s, 'walkRadio');
qn.keydown = (e, t, r) => {
	var n, o;
	return (o = (n = Tv[e.key]) === null || n === void 0 ? void 0 : n.call(Tv, e, t, r)) !== null &&
		o !== void 0
		? o
		: HV(e, t, r);
};
var Tv = {
		ArrowDown: i((e, t, r) => {
			if (ge(t, 'input', { type: 'radio' })) return () => _s(r, t, 1);
		}, 'ArrowDown'),
		ArrowLeft: i(
			(e, t, r) => (ge(t, 'input', { type: 'radio' }) ? () => _s(r, t, -1) : () => of(t, -1)),
			'ArrowLeft'
		),
		ArrowRight: i(
			(e, t, r) => (ge(t, 'input', { type: 'radio' }) ? () => _s(r, t, 1) : () => of(t, 1)),
			'ArrowRight'
		),
		ArrowUp: i((e, t, r) => {
			if (ge(t, 'input', { type: 'radio' })) return () => _s(r, t, -1);
		}, 'ArrowUp'),
		Backspace: i((e, t, r) => {
			if (bo(t))
				return () => {
					Eo(r, t, '', 'deleteContentBackward');
				};
		}, 'Backspace'),
		Delete: i((e, t, r) => {
			if (bo(t))
				return () => {
					Eo(r, t, '', 'deleteContentForward');
				};
		}, 'Delete'),
		End: i((e, t) => {
			if (ge(t, ['input', 'textarea']) || Mn(t))
				return () => {
					var r, n;
					const o =
						(n = (r = gx(t)) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0
							? n
							: 0;
					Vo(t, o, o);
				};
		}, 'End'),
		Home: i((e, t) => {
			if (ge(t, ['input', 'textarea']) || Mn(t))
				return () => {
					Vo(t, 0, 0);
				};
		}, 'Home'),
		PageDown: i((e, t) => {
			if (ge(t, ['input']))
				return () => {
					const r = br(t).length;
					Vo(t, r, r);
				};
		}, 'PageDown'),
		PageUp: i((e, t) => {
			if (ge(t, ['input']))
				return () => {
					Vo(t, 0, 0);
				};
		}, 'PageUp'),
		Tab: i(
			(e, t, r) => () => {
				const n = vx(t, r.system.keyboard.modifiers.Shift);
				(sn(n), gr(n) && Io(n, { anchorOffset: 0, focusOffset: n.value.length }));
			},
			'Tab'
		)
	},
	HV = i((e, t, r) => {
		if (e.code === 'KeyA' && r.system.keyboard.modifiers.Control) return () => bg(t);
	}, 'combinationBehavior');
qn.keypress = (e, t, r) => {
	if (e.key === 'Enter') {
		if (ge(t, 'button') || (ge(t, 'input') && GV.includes(t.type)) || (ge(t, 'a') && t.href))
			return () => {
				r.dispatchUIEvent(t, 'click');
			};
		if (ge(t, 'input')) {
			const n = t.form,
				o = n?.querySelector('input[type="submit"], button:not([type]), button[type="submit"]');
			return o
				? () => r.dispatchUIEvent(o, 'click')
				: n && zV.includes(t.type) && n.querySelectorAll('input').length === 1
					? () => r.dispatchUIEvent(n, 'submit')
					: void 0;
		}
	}
	if (bo(t)) {
		const n =
				e.key === 'Enter'
					? Mn(t) && !r.system.keyboard.modifiers.Shift
						? 'insertParagraph'
						: 'insertLineBreak'
					: 'insertText',
			o =
				e.key === 'Enter'
					? `
`
					: e.key;
		return () => Eo(r, t, o, n);
	}
};
var GV = ['button', 'color', 'file', 'image', 'reset', 'submit'],
	zV = ['email', 'month', 'password', 'search', 'tel', 'text', 'url', 'week'];
qn.keyup = (e, t, r) => {
	var n;
	return (n = _v[e.key]) === null || n === void 0 ? void 0 : n.call(_v, e, t, r);
};
var _v = {
	' ': i((e, t, r) => {
		if (cg(t)) return () => r.dispatchUIEvent(t, 'click');
	}, ' ')
};
qn.paste = (e, t, r) => {
	if (bo(t))
		return () => {
			var n;
			const o = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.getData('text');
			o && Eo(r, t, o, 'insertFromPaste');
		};
};
var Tx = {
	auxclick: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	beforeinput: {
		EventType: 'InputEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	blur: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
	click: { EventType: 'PointerEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
	contextmenu: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	copy: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
	change: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !1 } },
	cut: { EventType: 'ClipboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
	dblclick: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
	focus: { EventType: 'FocusEvent', defaultInit: { bubbles: !1, cancelable: !1, composed: !0 } },
	focusin: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
	focusout: { EventType: 'FocusEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
	keydown: {
		EventType: 'KeyboardEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	keypress: {
		EventType: 'KeyboardEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	keyup: { EventType: 'KeyboardEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
	paste: {
		EventType: 'ClipboardEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	input: { EventType: 'InputEvent', defaultInit: { bubbles: !0, cancelable: !1, composed: !0 } },
	mousedown: {
		EventType: 'MouseEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	mouseenter: {
		EventType: 'MouseEvent',
		defaultInit: { bubbles: !1, cancelable: !1, composed: !0 }
	},
	mouseleave: {
		EventType: 'MouseEvent',
		defaultInit: { bubbles: !1, cancelable: !1, composed: !0 }
	},
	mousemove: {
		EventType: 'MouseEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	mouseout: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
	mouseover: {
		EventType: 'MouseEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	mouseup: { EventType: 'MouseEvent', defaultInit: { bubbles: !0, cancelable: !0, composed: !0 } },
	pointerover: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	pointerenter: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
	pointerdown: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	pointermove: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	pointerup: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	pointercancel: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !1, composed: !0 }
	},
	pointerout: {
		EventType: 'PointerEvent',
		defaultInit: { bubbles: !0, cancelable: !0, composed: !0 }
	},
	pointerleave: { EventType: 'PointerEvent', defaultInit: { bubbles: !1, cancelable: !1 } },
	submit: { EventType: 'Event', defaultInit: { bubbles: !0, cancelable: !0 } }
};
function vg(e) {
	return Tx[e].EventType;
}
i(vg, 'getEventClass');
var WV = ['MouseEvent', 'PointerEvent'];
function _x(e) {
	return WV.includes(vg(e));
}
i(_x, 'isMouseEvent');
function wx(e) {
	return vg(e) === 'KeyboardEvent';
}
i(wx, 'isKeyboardEvent');
var KV = {
	ClipboardEvent: [Rx],
	Event: [],
	FocusEvent: [Bo, Px],
	InputEvent: [Bo, Ax],
	MouseEvent: [Bo, sl, sf],
	PointerEvent: [Bo, sl, sf, Cx],
	KeyboardEvent: [Bo, sl, Ox]
};
function Eg(e, t, r) {
	const n = Yt(t),
		{ EventType: o, defaultInit: s } = Tx[e],
		a = new (Sx(n)[o])(e, s);
	return (KV[o].forEach((u) => u(a, r ?? {})), a);
}
i(Eg, 'createEvent');
function Sx(e) {
	var t, r, n, o, s, a, u, c, d, p, f, m, y, g, E, T;
	const b = (T = e.Event) !== null && T !== void 0 ? T : ((t = class {}), i(t, 'Event'), t);
	var w;
	const P =
		(w = e.AnimationEvent) !== null && w !== void 0
			? w
			: ((r = class extends b {}), i(r, 'AnimationEvent'), r);
	var I;
	const q =
		(I = e.ClipboardEvent) !== null && I !== void 0
			? I
			: ((n = class extends b {}), i(n, 'ClipboardEvent'), n);
	var C;
	const R =
		(C = e.PopStateEvent) !== null && C !== void 0
			? C
			: ((o = class extends b {}), i(o, 'PopStateEvent'), o);
	var _;
	const S =
		(_ = e.ProgressEvent) !== null && _ !== void 0
			? _
			: ((s = class extends b {}), i(s, 'ProgressEvent'), s);
	var D;
	const N =
		(D = e.TransitionEvent) !== null && D !== void 0
			? D
			: ((a = class extends b {}), i(a, 'TransitionEvent'), a);
	var V;
	const H =
		(V = e.UIEvent) !== null && V !== void 0 ? V : ((u = class extends b {}), i(u, 'UIEvent'), u);
	var A;
	const L =
		(A = e.CompositionEvent) !== null && A !== void 0
			? A
			: ((c = class extends H {}), i(c, 'CompositionEvent'), c);
	var B;
	const k =
		(B = e.FocusEvent) !== null && B !== void 0
			? B
			: ((d = class extends H {}), i(d, 'FocusEvent'), d);
	var K;
	const X =
		(K = e.InputEvent) !== null && K !== void 0
			? K
			: ((p = class extends H {}), i(p, 'InputEvent'), p);
	var ie;
	const ae =
		(ie = e.KeyboardEvent) !== null && ie !== void 0
			? ie
			: ((f = class extends H {}), i(f, 'KeyboardEvent'), f);
	var W;
	const le =
		(W = e.MouseEvent) !== null && W !== void 0
			? W
			: ((m = class extends H {}), i(m, 'MouseEvent'), m);
	var ve;
	const de =
		(ve = e.DragEvent) !== null && ve !== void 0
			? ve
			: ((y = class extends le {}), i(y, 'DragEvent'), y);
	var ee;
	const xe =
		(ee = e.PointerEvent) !== null && ee !== void 0
			? ee
			: ((g = class extends le {}), i(g, 'PointerEvent'), g);
	var Ie;
	const Xe =
		(Ie = e.TouchEvent) !== null && Ie !== void 0
			? Ie
			: ((E = class extends H {}), i(E, 'TouchEvent'), E);
	return {
		Event: b,
		AnimationEvent: P,
		ClipboardEvent: q,
		PopStateEvent: R,
		ProgressEvent: S,
		TransitionEvent: N,
		UIEvent: H,
		CompositionEvent: L,
		FocusEvent: k,
		InputEvent: X,
		KeyboardEvent: ae,
		MouseEvent: le,
		DragEvent: de,
		PointerEvent: xe,
		TouchEvent: Xe
	};
}
i(Sx, 'getEventConstructors');
function un(e, t) {
	for (const [r, n] of Object.entries(t))
		Object.defineProperty(e, r, { get: i(() => n ?? null, 'get') });
}
i(un, 'assignProps');
function $e(e) {
	return Number(e ?? 0);
}
i($e, 'sanitizeNumber');
function Rx(e, { clipboardData: t }) {
	un(e, { clipboardData: t });
}
i(Rx, 'initClipboardEvent');
function Px(e, { relatedTarget: t }) {
	un(e, { relatedTarget: t });
}
i(Px, 'initFocusEvent');
function Ax(e, { data: t, inputType: r, isComposing: n }) {
	un(e, { data: t, isComposing: !!n, inputType: String(r) });
}
i(Ax, 'initInputEvent');
function Bo(e, { view: t, detail: r }) {
	un(e, { view: t, detail: $e(r ?? 0) });
}
i(Bo, 'initUIEvent');
function sl(
	e,
	{
		altKey: t,
		ctrlKey: r,
		metaKey: n,
		shiftKey: o,
		modifierAltGraph: s,
		modifierCapsLock: a,
		modifierFn: u,
		modifierFnLock: c,
		modifierNumLock: d,
		modifierScrollLock: p,
		modifierSymbol: f,
		modifierSymbolLock: m
	}
) {
	un(e, {
		altKey: !!t,
		ctrlKey: !!r,
		metaKey: !!n,
		shiftKey: !!o,
		getModifierState(y) {
			return !!{
				Alt: t,
				AltGraph: s,
				CapsLock: a,
				Control: r,
				Fn: u,
				FnLock: c,
				Meta: n,
				NumLock: d,
				ScrollLock: p,
				Shift: o,
				Symbol: f,
				SymbolLock: m
			}[y];
		}
	});
}
i(sl, 'initUIEventModifiers');
function Ox(e, { key: t, code: r, location: n, repeat: o, isComposing: s, charCode: a }) {
	un(e, {
		key: String(t),
		code: String(r),
		location: $e(n),
		repeat: !!o,
		isComposing: !!s,
		charCode: a
	});
}
i(Ox, 'initKeyboardEvent');
function sf(
	e,
	{
		x: t,
		y: r,
		screenX: n,
		screenY: o,
		clientX: s = t,
		clientY: a = r,
		button: u,
		buttons: c,
		relatedTarget: d,
		offsetX: p,
		offsetY: f,
		pageX: m,
		pageY: y
	}
) {
	un(e, {
		screenX: $e(n),
		screenY: $e(o),
		clientX: $e(s),
		x: $e(s),
		clientY: $e(a),
		y: $e(a),
		button: $e(u),
		buttons: $e(c),
		relatedTarget: d,
		offsetX: $e(p),
		offsetY: $e(f),
		pageX: $e(m),
		pageY: $e(y)
	});
}
i(sf, 'initMouseEvent');
function Cx(
	e,
	{
		pointerId: t,
		width: r,
		height: n,
		pressure: o,
		tangentialPressure: s,
		tiltX: a,
		tiltY: u,
		twist: c,
		pointerType: d,
		isPrimary: p
	}
) {
	un(e, {
		pointerId: $e(t),
		width: $e(r ?? 1),
		height: $e(n ?? 1),
		pressure: $e(o),
		tangentialPressure: $e(s),
		tiltX: $e(a),
		tiltY: $e(u),
		twist: $e(c),
		pointerType: String(d),
		isPrimary: !!p
	});
}
i(Cx, 'initPointerEvent');
function xx(e, t, r, n = !1) {
	(_x(t) || wx(t)) && (r = { ...r, ...this.system.getUIEventModifiers() });
	const o = Eg(t, e, r);
	return Tg.call(this, e, o, n);
}
i(xx, 'dispatchUIEvent');
function Tg(e, t, r = !1) {
	var n;
	const o = t.type,
		s = r ? () => {} : (n = qn[o]) === null || n === void 0 ? void 0 : n.call(qn, t, e, this);
	if (s) {
		t.preventDefault();
		let a = !1;
		return (
			Object.defineProperty(t, 'defaultPrevented', { get: i(() => a, 'get') }),
			Object.defineProperty(t, 'preventDefault', {
				value: i(() => {
					a = t.cancelable;
				}, 'value')
			}),
			vo(() => e.dispatchEvent(t)),
			a || s(),
			!a
		);
	}
	return vo(() => e.dispatchEvent(t));
}
i(Tg, 'dispatchEvent');
function bn(e, t, r) {
	const n = Eg(t, e, r);
	vo(() => e.dispatchEvent(n));
}
i(bn, 'dispatchDOMEvent');
var wv = Symbol('patched focus/blur methods');
function _g(e) {
	if (e.prototype[wv]) return;
	const { focus: t, blur: r } = e.prototype;
	Object.defineProperties(e.prototype, {
		focus: { configurable: !0, get: i(() => o, 'get') },
		blur: { configurable: !0, get: i(() => s, 'get') },
		[wv]: { configurable: !0, get: i(() => ({ focus: t, blur: r }), 'get') }
	});
	let n;
	function o(a) {
		if (this.ownerDocument.visibilityState !== 'hidden') return t.call(this, a);
		const u = af(this.ownerDocument);
		if (u === this) return;
		const c = Symbol('focus call');
		((n = c),
			u &&
				(r.call(u),
				bn(u, 'blur', { relatedTarget: this }),
				bn(u, 'focusout', { relatedTarget: n === c ? this : null })),
			n === c && (t.call(this, a), bn(this, 'focus', { relatedTarget: u })),
			n === c && bn(this, 'focusin', { relatedTarget: u }));
	}
	i(o, 'patchedFocus');
	function s() {
		if (this.ownerDocument.visibilityState !== 'hidden') return r.call(this);
		const a = af(this.ownerDocument);
		if (a !== this) return;
		((n = Symbol('blur call')),
			r.call(this),
			bn(a, 'blur', { relatedTarget: null }),
			bn(a, 'focusout', { relatedTarget: null }));
	}
	i(s, 'patchedBlur');
}
i(_g, 'patchFocus');
function af(e) {
	const t = ki(e);
	return t?.tagName === 'BODY' ? null : t;
}
i(af, 'getActiveTarget');
var Ed = Symbol('Interceptor for programmatical calls');
function Zn(e, t, r) {
	const n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
		o = Object.getOwnPropertyDescriptor(e, t),
		s = n?.set ? 'set' : 'value';
	if (typeof n?.[s] != 'function' || n[s][Ed])
		throw new Error(`Element ${e.tagName} does not implement "${String(t)}".`);
	function a(...u) {
		const { applyNative: c = !1, realArgs: d, then: p } = r.call(this, ...u),
			f = ((!c && o) || n)[s];
		(s === 'set' ? f.call(this, d) : f.call(this, ...d), p?.());
	}
	(i(a, 'intercept'), (a[Ed] = Ed), Object.defineProperty(e, t, { ...(o ?? n), [s]: a }));
}
i(Zn, 'prepareInterceptor');
function Ix(e) {
	Zn(
		e,
		'value',
		i(function (r) {
			const n = WC(r);
			return (
				n && lx(this),
				{ applyNative: !!n, realArgs: Nx(this, r), then: n ? void 0 : () => ux(this, String(r)) }
			);
		}, 'interceptorImpl')
	);
}
i(Ix, 'prepareValueInterceptor');
function Nx(e, t) {
	return ge(e, 'input', { type: 'number' }) && String(t) !== '' && !Number.isNaN(Number(t))
		? String(Number(t))
		: String(t);
}
i(Nx, 'sanitizeValue');
function Mx(e) {
	(Zn(
		e,
		'setSelectionRange',
		i(function (r, ...n) {
			const o = KC(r);
			return {
				applyNative: !!o,
				realArgs: [Number(r), ...n],
				then: i(() => (o ? void 0 : js(e)), 'then')
			};
		}, 'interceptorImpl')
	),
		Zn(
			e,
			'selectionStart',
			i(function (r) {
				return { realArgs: r, then: i(() => js(e), 'then') };
			}, 'interceptorImpl')
		),
		Zn(
			e,
			'selectionEnd',
			i(function (r) {
				return { realArgs: r, then: i(() => js(e), 'then') };
			}, 'interceptorImpl')
		),
		Zn(
			e,
			'select',
			i(function () {
				return {
					realArgs: [],
					then: i(() => QC(e, { anchorOffset: 0, focusOffset: br(e).length }), 'then')
				};
			}, 'interceptorImpl')
		));
}
i(Mx, 'prepareSelectionInterceptor');
function qx(e) {
	Zn(
		e,
		'setRangeText',
		i(function (...r) {
			return {
				realArgs: r,
				then: i(() => {
					(Sc(e), js(e));
				}, 'then')
			};
		}, 'interceptorImpl')
	);
}
i(qx, 'prepareRangeTextInterceptor');
var ei = Symbol('Node prepared with document state workarounds');
function wg(e) {
	e[ei] ||
		(e.addEventListener(
			'focus',
			(t) => {
				const r = t.target;
				lf(r);
			},
			{ capture: !0, passive: !0 }
		),
		e.activeElement && lf(e.activeElement),
		e.addEventListener(
			'blur',
			(t) => {
				const r = t.target,
					n = XC(r);
				n !== void 0 && (r.value !== n && bn(r, 'change'), fg(r));
			},
			{ capture: !0, passive: !0 }
		),
		(e[ei] = ei));
}
i(wg, 'prepareDocument');
function lf(e) {
	e[ei] || (ge(e, ['input', 'textarea']) && (Ix(e), Mx(e), qx(e)), (e[ei] = ei));
}
i(lf, 'prepareElement');
function jx(e) {
	return Dx(e) ? e : e.ownerDocument;
}
i(jx, 'getDocumentFromNode');
function Dx(e) {
	return e.nodeType === 9;
}
i(Dx, 'isDocument');
var Ht = (function (e) {
	return ((e[(e.Trigger = 2)] = 'Trigger'), (e[(e.Call = 1)] = 'Call'), e);
})({});
function Ho(e, t) {
	e.levelRefs[t] = {};
}
i(Ho, 'setLevelRef');
function ws(e, t) {
	return e.levelRefs[t];
}
i(ws, 'getLevelRef');
function To(e) {
	const t = e.delay;
	if (typeof t == 'number')
		return Promise.all([
			new Promise((r) => globalThis.setTimeout(() => r(), t)),
			e.advanceTimers(t)
		]);
}
i(To, 'wait');
var al = (function (e) {
	return (
		(e[(e.EachTrigger = 4)] = 'EachTrigger'),
		(e[(e.EachApiCall = 2)] = 'EachApiCall'),
		(e[(e.EachTarget = 1)] = 'EachTarget'),
		(e[(e.Never = 0)] = 'Never'),
		e
	);
})({});
function hn(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(hn, '_define_property');
var Er = (function (e) {
		return (
			(e[(e.STANDARD = 0)] = 'STANDARD'),
			(e[(e.LEFT = 1)] = 'LEFT'),
			(e[(e.RIGHT = 2)] = 'RIGHT'),
			(e[(e.NUMPAD = 3)] = 'NUMPAD'),
			e
		);
	})({}),
	YV = ['Alt', 'AltGraph', 'Control', 'Fn', 'Meta', 'Shift', 'Symbol'];
function uf(e) {
	return YV.includes(e);
}
i(uf, 'isModifierKey');
var XV = ['CapsLock', 'FnLock', 'NumLock', 'ScrollLock', 'SymbolLock'];
function cf(e) {
	return XV.includes(e);
}
i(cf, 'isModifierLock');
var kx = class {
	isKeyPressed(t) {
		return this.pressed.has(String(t.code));
	}
	getPressedKeys() {
		return this.pressed.values().map((t) => t.keyDef);
	}
	async keydown(t, r) {
		const n = String(r.key),
			o = String(r.code),
			s = il(t.config.document);
		(this.setKeydownTarget(s), this.pressed.add(o, r), uf(n) && (this.modifiers[n] = !0));
		const a = t.dispatchUIEvent(s, 'keydown', { key: n, code: o });
		(cf(n) && !this.modifiers[n] && ((this.modifiers[n] = !0), (this.modifierLockStart[n] = !0)),
			a && this.pressed.setUnprevented(o),
			a &&
				this.hasKeyPress(n) &&
				t.dispatchUIEvent(il(t.config.document), 'keypress', {
					key: n,
					code: o,
					charCode: r.key === 'Enter' ? 13 : String(r.key).charCodeAt(0)
				}));
	}
	async keyup(t, r) {
		const n = String(r.key),
			o = String(r.code),
			s = this.pressed.isUnprevented(o);
		(this.pressed.delete(o),
			uf(n) && !this.pressed.values().find((a) => a.keyDef.key === n) && (this.modifiers[n] = !1),
			t.dispatchUIEvent(il(t.config.document), 'keyup', { key: n, code: o }, !s),
			cf(n) &&
				this.modifiers[n] &&
				(this.modifierLockStart[n] ? (this.modifierLockStart[n] = !1) : (this.modifiers[n] = !1)));
	}
	setKeydownTarget(t) {
		(t !== this.lastKeydownTarget && (this.carryChar = ''), (this.lastKeydownTarget = t));
	}
	hasKeyPress(t) {
		return (t.length === 1 || t === 'Enter') && !this.modifiers.Control && !this.modifiers.Alt;
	}
	constructor(t) {
		(hn(this, 'system', void 0),
			hn(this, 'modifiers', {
				Alt: !1,
				AltGraph: !1,
				CapsLock: !1,
				Control: !1,
				Fn: !1,
				FnLock: !1,
				Meta: !1,
				NumLock: !1,
				ScrollLock: !1,
				Shift: !1,
				Symbol: !1,
				SymbolLock: !1
			}),
			hn(
				this,
				'pressed',
				new (class {
					add(r, n) {
						var o, s, a;
						((a = (o = this.registry)[(s = r)]) !== null && a !== void 0) ||
							(o[s] = { keyDef: n, unpreventedDefault: !1 });
					}
					has(r) {
						return !!this.registry[r];
					}
					setUnprevented(r) {
						const n = this.registry[r];
						n && (n.unpreventedDefault = !0);
					}
					isUnprevented(r) {
						var n;
						return !!(!((n = this.registry[r]) === null || n === void 0) && n.unpreventedDefault);
					}
					delete(r) {
						delete this.registry[r];
					}
					values() {
						return Object.values(this.registry);
					}
					constructor() {
						hn(this, 'registry', {});
					}
				})()
			),
			hn(this, 'carryChar', ''),
			hn(this, 'lastKeydownTarget', void 0),
			hn(this, 'modifierLockStart', {}),
			(this.system = t));
	}
};
i(kx, 'KeyboardHost');
var QV = kx,
	ZV = [
		...'0123456789'.split('').map((e) => ({ code: `Digit${e}`, key: e })),
		...')!@#$%^&*('.split('').map((e, t) => ({ code: `Digit${t}`, key: e, shiftKey: !0 })),
		...'abcdefghijklmnopqrstuvwxyz'
			.split('')
			.map((e) => ({ code: `Key${e.toUpperCase()}`, key: e })),
		...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
			.split('')
			.map((e) => ({ code: `Key${e}`, key: e, shiftKey: !0 })),
		{ code: 'BracketLeft', key: '[' },
		{ code: 'BracketLeft', key: '{', shiftKey: !0 },
		{ code: 'BracketRight', key: ']' },
		{ code: 'BracketRight', key: '}', shiftKey: !0 },
		{ code: 'Space', key: ' ' },
		{ code: 'AltLeft', key: 'Alt', location: Er.LEFT },
		{ code: 'AltRight', key: 'Alt', location: Er.RIGHT },
		{ code: 'ShiftLeft', key: 'Shift', location: Er.LEFT },
		{ code: 'ShiftRight', key: 'Shift', location: Er.RIGHT },
		{ code: 'ControlLeft', key: 'Control', location: Er.LEFT },
		{ code: 'ControlRight', key: 'Control', location: Er.RIGHT },
		{ code: 'MetaLeft', key: 'Meta', location: Er.LEFT },
		{ code: 'MetaRight', key: 'Meta', location: Er.RIGHT },
		{ code: 'OSLeft', key: 'OS', location: Er.LEFT },
		{ code: 'OSRight', key: 'OS', location: Er.RIGHT },
		{ code: 'ContextMenu', key: 'ContextMenu' },
		{ code: 'Tab', key: 'Tab' },
		{ code: 'CapsLock', key: 'CapsLock' },
		{ code: 'Backspace', key: 'Backspace' },
		{ code: 'Enter', key: 'Enter' },
		{ code: 'Escape', key: 'Escape' },
		{ code: 'ArrowUp', key: 'ArrowUp' },
		{ code: 'ArrowDown', key: 'ArrowDown' },
		{ code: 'ArrowLeft', key: 'ArrowLeft' },
		{ code: 'ArrowRight', key: 'ArrowRight' },
		{ code: 'Home', key: 'Home' },
		{ code: 'End', key: 'End' },
		{ code: 'Delete', key: 'Delete' },
		{ code: 'PageUp', key: 'PageUp' },
		{ code: 'PageDown', key: 'PageDown' },
		{ code: 'Fn', key: 'Fn' },
		{ code: 'Symbol', key: 'Symbol' },
		{ code: 'AltRight', key: 'AltGraph' }
	],
	eH = [
		{ name: 'MouseLeft', pointerType: 'mouse', button: 'primary' },
		{ name: 'MouseRight', pointerType: 'mouse', button: 'secondary' },
		{ name: 'MouseMiddle', pointerType: 'mouse', button: 'auxiliary' },
		{ name: 'TouchA', pointerType: 'touch' },
		{ name: 'TouchB', pointerType: 'touch' },
		{ name: 'TouchC', pointerType: 'touch' }
	];
function Lx(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(Lx, '_define_property');
var Fx = class {
	getButtons() {
		let t = 0;
		for (const r of Object.keys(this.pressed)) t |= 2 ** Number(r);
		return t;
	}
	down(t) {
		const r = Yl(t.button);
		if (r in this.pressed) {
			this.pressed[r].push(t);
			return;
		}
		return ((this.pressed[r] = [t]), r);
	}
	up(t) {
		const r = Yl(t.button);
		if (
			r in this.pressed &&
			((this.pressed[r] = this.pressed[r].filter((n) => n.name !== t.name)),
			this.pressed[r].length === 0)
		)
			return (delete this.pressed[r], r);
	}
	constructor() {
		Lx(this, 'pressed', {});
	}
};
i(Fx, 'Buttons');
var Bx = Fx,
	Sv = { primary: 0, secondary: 1, auxiliary: 2, back: 3, X1: 3, forward: 4, X2: 4 };
function Yl(e = 0) {
	return e in Sv ? Sv[e] : Number(e);
}
i(Yl, 'getMouseButtonId');
var Rv = { 1: 2, 2: 1 };
function Xl(e) {
	return ((e = Yl(e)), e in Rv ? Rv[e] : e);
}
i(Xl, 'getMouseEventButton');
function Jx(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(Jx, '_define_property');
var $x = class {
	get countPressed() {
		return this.pressedKeys.size;
	}
	isPressed(t) {
		return this.pressedKeys.has(t.name);
	}
	addPressed(t) {
		return this.pressedKeys.add(t.name);
	}
	removePressed(t) {
		return this.pressedKeys.delete(t.name);
	}
	constructor() {
		Jx(this, 'pressedKeys', new Set());
	}
};
i($x, 'Device');
var tH = $x;
function ti(e, t) {
	const r = [];
	for (let s = e; s; s = s.parentElement) r.push(s);
	const n = [];
	for (let s = t; s; s = s.parentElement) n.push(s);
	let o = 0;
	for (; !(o >= r.length || o >= n.length || r[r.length - 1 - o] !== n[n.length - 1 - o]); o++);
	return [r.slice(0, r.length - o), n.slice(0, n.length - o), n.slice(n.length - o)];
}
i(ti, 'getTreeDiff');
function Ql({ target: e, node: t, offset: r }) {
	return gr(e)
		? { node: e, offset: r ?? br(e).length }
		: t
			? { node: t, offset: r ?? (t.nodeType === 3 ? t.nodeValue.length : t.childNodes.length) }
			: Sg(e, r);
}
i(Ql, 'resolveCaretPosition');
function Sg(e, t, r = !0) {
	let n = t === void 0 ? e.childNodes.length - 1 : 0;
	const o = t === void 0 ? -1 : 1;
	for (
		;
		t === void 0 ? n >= (r ? Math.max(e.childNodes.length - 1, 0) : 0) : n <= e.childNodes.length;

	) {
		if (t && n === e.childNodes.length) throw new Error('The given offset is out of bounds.');
		const s = e.childNodes.item(n),
			a = String(s.textContent);
		if (a.length)
			if (t !== void 0 && a.length < t) t -= a.length;
			else {
				if (s.nodeType === 1) return Sg(s, t, !1);
				if (s.nodeType === 3) return { node: s, offset: t ?? s.nodeValue.length };
			}
		n += o;
	}
	return { node: e, offset: e.childNodes.length };
}
i(Sg, 'findNodeAtTextOffset');
function Ux({ document: e, target: t, clickCount: r, node: n, offset: o }) {
	if (HC(t)) return;
	const s = gr(t),
		a = String(s ? br(t) : t.textContent),
		[u, c] = n ? [o, o] : Vx(a, o, r);
	if (s)
		return (
			Io(t, { anchorOffset: u ?? a.length, focusOffset: c ?? a.length }),
			{ node: t, start: u ?? 0, end: c ?? a.length }
		);
	{
		const { node: d, offset: p } = Ql({ target: t, node: n, offset: u }),
			{ node: f, offset: m } = Ql({ target: t, node: n, offset: c }),
			y = t.ownerDocument.createRange();
		try {
			(y.setStart(d, p), y.setEnd(f, m));
		} catch {
			throw new Error('The given offset is out of bounds.');
		}
		const g = e.getSelection();
		return (g?.removeAllRanges(), g?.addRange(y.cloneRange()), y);
	}
}
i(Ux, 'setSelectionPerMouseDown');
function Vx(e, t, r) {
	if (r % 3 === 1 || e.length === 0) return [t, t];
	const n = t ?? e.length;
	return r % 3 === 2
		? [
				n - e.substr(0, t).match(/(\w+|\s+|\W)?$/)[0].length,
				t === void 0 ? t : t + e.substr(t).match(/^(\w+|\s+|\W)?/)[0].length
			]
		: [
				n - e.substr(0, t).match(/[^\r\n]*$/)[0].length,
				t === void 0 ? t : t + e.substr(t).match(/^[^\r\n]*/)[0].length
			];
}
i(Vx, 'getTextRange');
function Hx(e, { document: t, target: r, node: n, offset: o }) {
	const s = Ql({ target: r, node: n, offset: o });
	if ('node' in e) {
		if (s.node === e.node) {
			const a = s.offset < e.start ? e.end : e.start,
				u = s.offset > e.end || s.offset < e.start ? s.offset : e.end;
			Io(e.node, { anchorOffset: a, focusOffset: u });
		}
	} else {
		const a = e.cloneRange(),
			u = a.comparePoint(s.node, s.offset);
		u < 0 ? a.setStart(s.node, s.offset) : u > 0 && a.setEnd(s.node, s.offset);
		const c = t.getSelection();
		(c?.removeAllRanges(), c?.addRange(a.cloneRange()));
	}
}
i(Hx, 'modifySelectionPerMouseMove');
function Rg(e, t) {
	var r, n, o, s, a, u, c, d, p, f, m, y, g, E, T, b, w, P, I, q, C, R, _, S;
	return (
		e.target !== t.target ||
		((r = e.coords) === null || r === void 0 ? void 0 : r.x) !==
			((n = t.coords) === null || n === void 0 ? void 0 : n.x) ||
		((o = e.coords) === null || o === void 0 ? void 0 : o.y) !==
			((s = t.coords) === null || s === void 0 ? void 0 : s.y) ||
		((a = e.coords) === null || a === void 0 ? void 0 : a.clientX) !==
			((u = t.coords) === null || u === void 0 ? void 0 : u.clientX) ||
		((c = e.coords) === null || c === void 0 ? void 0 : c.clientY) !==
			((d = t.coords) === null || d === void 0 ? void 0 : d.clientY) ||
		((p = e.coords) === null || p === void 0 ? void 0 : p.offsetX) !==
			((f = t.coords) === null || f === void 0 ? void 0 : f.offsetX) ||
		((m = e.coords) === null || m === void 0 ? void 0 : m.offsetY) !==
			((y = t.coords) === null || y === void 0 ? void 0 : y.offsetY) ||
		((g = e.coords) === null || g === void 0 ? void 0 : g.pageX) !==
			((E = t.coords) === null || E === void 0 ? void 0 : E.pageX) ||
		((T = e.coords) === null || T === void 0 ? void 0 : T.pageY) !==
			((b = t.coords) === null || b === void 0 ? void 0 : b.pageY) ||
		((w = e.coords) === null || w === void 0 ? void 0 : w.screenX) !==
			((P = t.coords) === null || P === void 0 ? void 0 : P.screenX) ||
		((I = e.coords) === null || I === void 0 ? void 0 : I.screenY) !==
			((q = t.coords) === null || q === void 0 ? void 0 : q.screenY) ||
		((C = e.caret) === null || C === void 0 ? void 0 : C.node) !==
			((R = t.caret) === null || R === void 0 ? void 0 : R.node) ||
		((_ = e.caret) === null || _ === void 0 ? void 0 : _.offset) !==
			((S = t.caret) === null || S === void 0 ? void 0 : S.offset)
	);
}
i(Rg, 'isDifferentPointerPosition');
function yn(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(yn, '_define_property');
var Gx = class {
	move(t, r, n) {
		const o = this.position,
			s = this.getTarget(t);
		if (((this.position = r), !Rg(o, r))) return;
		const a = this.getTarget(t),
			u = this.getEventInit('mousemove'),
			[c, d] = ti(s, a);
		return {
			leave: i(() => {
				s !== a &&
					(t.dispatchUIEvent(s, 'mouseout', u),
					c.forEach((p) => t.dispatchUIEvent(p, 'mouseleave', u)));
			}, 'leave'),
			enter: i(() => {
				s !== a &&
					(t.dispatchUIEvent(a, 'mouseover', u),
					d.forEach((p) => t.dispatchUIEvent(p, 'mouseenter', u)));
			}, 'enter'),
			move: i(() => {
				n || (t.dispatchUIEvent(a, 'mousemove', u), this.modifySelecting(t));
			}, 'move')
		};
	}
	down(t, r, n) {
		const o = this.buttons.down(r);
		if (o === void 0) return;
		const s = this.getTarget(t);
		this.buttonDownTarget[o] = s;
		const a = this.getEventInit('mousedown', r.button),
			u = Nr(s);
		(!n && (u || t.dispatchUIEvent(s, 'mousedown', a)) && (this.startSelecting(t, a.detail), sn(s)),
			!u &&
				Xl(r.button) === 2 &&
				t.dispatchUIEvent(s, 'contextmenu', this.getEventInit('contextmenu', r.button)));
	}
	up(t, r, n) {
		const o = this.buttons.up(r);
		if (o === void 0) return;
		const s = this.getTarget(t);
		if (!Nr(s)) {
			if (!n) {
				const u = this.getEventInit('mouseup', r.button);
				(t.dispatchUIEvent(s, 'mouseup', u), this.endSelecting());
			}
			const a = ti(this.buttonDownTarget[o], s)[2][0];
			if (a) {
				const u = this.getEventInit('click', r.button);
				u.detail &&
					(t.dispatchUIEvent(a, u.button === 0 ? 'click' : 'auxclick', u),
					u.button === 0 &&
						u.detail === 2 &&
						t.dispatchUIEvent(a, 'dblclick', {
							...this.getEventInit('dblclick', r.button),
							detail: u.detail
						}));
			}
		}
	}
	resetClickCount() {
		this.clickCount.reset();
	}
	getEventInit(t, r) {
		const n = { ...this.position.coords };
		return (
			(n.button = Xl(r)),
			(n.buttons = this.buttons.getButtons()),
			t === 'mousedown'
				? (n.detail = this.clickCount.getOnDown(n.button))
				: t === 'mouseup'
					? (n.detail = this.clickCount.getOnUp(n.button))
					: (t === 'click' || t === 'auxclick') &&
						(n.detail = this.clickCount.incOnClick(n.button)),
			n
		);
	}
	getTarget(t) {
		var r;
		return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
	}
	startSelecting(t, r) {
		var n, o;
		this.selecting = Ux({
			document: t.config.document,
			target: this.getTarget(t),
			node: (n = this.position.caret) === null || n === void 0 ? void 0 : n.node,
			offset: (o = this.position.caret) === null || o === void 0 ? void 0 : o.offset,
			clickCount: r
		});
	}
	modifySelecting(t) {
		var r, n;
		this.selecting &&
			Hx(this.selecting, {
				document: t.config.document,
				target: this.getTarget(t),
				node: (r = this.position.caret) === null || r === void 0 ? void 0 : r.node,
				offset: (n = this.position.caret) === null || n === void 0 ? void 0 : n.offset
			});
	}
	endSelecting() {
		this.selecting = void 0;
	}
	constructor() {
		(yn(this, 'position', {}),
			yn(this, 'buttons', new Bx()),
			yn(this, 'selecting', void 0),
			yn(this, 'buttonDownTarget', {}),
			yn(
				this,
				'clickCount',
				new (class {
					incOnClick(t) {
						const r = this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
						return (
							(this.count = this.count[t] === void 0 ? {} : { [t]: Number(this.count[t]) + 1 }),
							r
						);
					}
					getOnDown(t) {
						var r;
						this.down = { [t]: (r = this.count[t]) !== null && r !== void 0 ? r : 0 };
						var n;
						return (
							(this.count = { [t]: (n = this.count[t]) !== null && n !== void 0 ? n : 0 }),
							Number(this.count[t]) + 1
						);
					}
					getOnUp(t) {
						return this.down[t] === void 0 ? void 0 : Number(this.down[t]) + 1;
					}
					reset() {
						this.count = {};
					}
					constructor() {
						(yn(this, 'down', {}), yn(this, 'count', {}));
					}
				})()
			));
	}
};
i(Gx, 'Mouse');
var rH = Gx;
function aa(e, t) {
	var r;
	return ((r = Pg(e, t)) === null || r === void 0 ? void 0 : r.pointerEvents) !== 'none';
}
i(aa, 'hasPointerEvents');
function zx(e) {
	const t = Yt(e);
	for (let r = e, n = []; r?.ownerDocument; r = r.parentElement) {
		n.push(r);
		const o = t.getComputedStyle(r).pointerEvents;
		if (o && !['inherit', 'unset'].includes(o)) return { pointerEvents: o, tree: n };
	}
}
i(zx, 'closestPointerEventsDeclaration');
var Pv = Symbol('Last check for pointer-events');
function Pg(e, t) {
	const r = t[Pv];
	if (
		!(
			e.config.pointerEventsCheck !== al.Never &&
			(!r ||
				(df(e.config.pointerEventsCheck, al.EachApiCall) && r[Ht.Call] !== ws(e, Ht.Call)) ||
				(df(e.config.pointerEventsCheck, al.EachTrigger) && r[Ht.Trigger] !== ws(e, Ht.Trigger)))
		)
	)
		return r?.result;
	const o = zx(t);
	return ((t[Pv] = { [Ht.Call]: ws(e, Ht.Call), [Ht.Trigger]: ws(e, Ht.Trigger), result: o }), o);
}
i(Pg, 'checkPointerEvents');
function Go(e, t) {
	const r = Pg(e, t);
	if (r?.pointerEvents === 'none')
		throw new Error(
			[
				`Unable to perform pointer interaction as the element ${r.tree.length > 1 ? 'inherits' : 'has'} \`pointer-events: none\`:`,
				'',
				Wx(r.tree)
			].join(`
`)
		);
}
i(Go, 'assertPointerEvents');
function Wx(e) {
	return e
		.reverse()
		.map((t, r) =>
			[
				''.padEnd(r),
				t.tagName,
				t.id && `#${t.id}`,
				t.hasAttribute('data-testid') && `(testId=${t.getAttribute('data-testid')})`,
				Kx(t),
				e.length > 1 && r === 0 && '  <-- This element declared `pointer-events: none`',
				e.length > 1 && r === e.length - 1 && '  <-- Asserted pointer events here'
			]
				.filter(Boolean)
				.join('')
		).join(`
`);
}
i(Wx, 'printTree');
function Kx(e) {
	var t;
	let r;
	if (e.hasAttribute('aria-label')) r = e.getAttribute('aria-label');
	else if (e.hasAttribute('aria-labelledby')) {
		var n, o;
		r =
			(o = e.ownerDocument.getElementById(e.getAttribute('aria-labelledby'))) === null ||
			o === void 0 ||
			(n = o.textContent) === null ||
			n === void 0
				? void 0
				: n.trim();
	} else if (
		ge(e, ['button', 'input', 'meter', 'output', 'progress', 'select', 'textarea']) &&
		!((t = e.labels) === null || t === void 0) &&
		t.length
	)
		r = Array.from(e.labels)
			.map((a) => {
				var u;
				return (u = a.textContent) === null || u === void 0 ? void 0 : u.trim();
			})
			.join('|');
	else if (ge(e, 'button')) {
		var s;
		r = (s = e.textContent) === null || s === void 0 ? void 0 : s.trim();
	}
	return (
		(r = r?.replace(/\n/g, '  ')),
		Number(r?.length) > 30 && (r = `${r?.substring(0, 29)}`),
		r ? `(label=${r})` : ''
	);
}
i(Kx, 'getLabelDescr');
function df(e, t) {
	return (e & t) > 0;
}
i(df, 'hasBitFlag');
function wr(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(wr, '_define_property');
var Yx = class {
	init(t) {
		const r = this.getTarget(t),
			[, n] = ti(null, r),
			o = this.getEventInit();
		return (
			Go(t, r),
			t.dispatchUIEvent(r, 'pointerover', o),
			n.forEach((s) => t.dispatchUIEvent(s, 'pointerenter', o)),
			this
		);
	}
	move(t, r) {
		const n = this.position,
			o = this.getTarget(t);
		if (((this.position = r), !Rg(n, r))) return;
		const s = this.getTarget(t),
			a = this.getEventInit(-1),
			[u, c] = ti(o, s);
		return {
			leave: i(() => {
				aa(t, o) &&
					o !== s &&
					(t.dispatchUIEvent(o, 'pointerout', a),
					u.forEach((d) => t.dispatchUIEvent(d, 'pointerleave', a)));
			}, 'leave'),
			enter: i(() => {
				(Go(t, s),
					o !== s &&
						(t.dispatchUIEvent(s, 'pointerover', a),
						c.forEach((d) => t.dispatchUIEvent(d, 'pointerenter', a))));
			}, 'enter'),
			move: i(() => {
				t.dispatchUIEvent(s, 'pointermove', a);
			}, 'move')
		};
	}
	down(t, r = 0) {
		if (this.isDown) return;
		const n = this.getTarget(t);
		(Go(t, n),
			(this.isDown = !0),
			(this.isPrevented = !t.dispatchUIEvent(n, 'pointerdown', this.getEventInit(r))));
	}
	up(t, r = 0) {
		if (!this.isDown) return;
		const n = this.getTarget(t);
		(Go(t, n),
			(this.isPrevented = !1),
			(this.isDown = !1),
			t.dispatchUIEvent(n, 'pointerup', this.getEventInit(r)));
	}
	release(t) {
		const r = this.getTarget(t),
			[n] = ti(r, null),
			o = this.getEventInit();
		(aa(t, r) &&
			(t.dispatchUIEvent(r, 'pointerout', o),
			n.forEach((s) => t.dispatchUIEvent(s, 'pointerleave', o))),
			(this.isCancelled = !0));
	}
	getTarget(t) {
		var r;
		return (r = this.position.target) !== null && r !== void 0 ? r : t.config.document.body;
	}
	getEventInit(t) {
		return {
			...this.position.coords,
			pointerId: this.pointerId,
			pointerType: this.pointerType,
			isPrimary: this.isPrimary,
			button: Xl(t),
			buttons: this.buttons.getButtons()
		};
	}
	constructor({ pointerId: t, pointerType: r, isPrimary: n }, o) {
		(wr(this, 'pointerId', void 0),
			wr(this, 'pointerType', void 0),
			wr(this, 'isPrimary', void 0),
			wr(this, 'buttons', void 0),
			wr(this, 'isMultitouch', !1),
			wr(this, 'isCancelled', !1),
			wr(this, 'isDown', !1),
			wr(this, 'isPrevented', !1),
			wr(this, 'position', {}),
			(this.pointerId = t),
			(this.pointerType = r),
			(this.isPrimary = n),
			(this.isMultitouch = !n),
			(this.buttons = o));
	}
};
i(Yx, 'Pointer');
var nH = Yx;
function Hr(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(Hr, '_define_property');
var Xx = class {
	isKeyPressed(t) {
		return this.devices.get(t.pointerType).isPressed(t);
	}
	async press(t, r, n) {
		(this.devices.get(r.pointerType).addPressed(r), this.buttons.down(r));
		const o = this.getPointerName(r),
			s =
				r.pointerType === 'touch'
					? this.pointers.new(o, r.pointerType, this.buttons)
					: this.pointers.get(o);
		((s.position = n),
			s.pointerType !== 'touch' && (this.mouse.position = n),
			s.pointerType === 'touch' && s.init(t),
			s.down(t, r.button),
			s.pointerType !== 'touch' && this.mouse.down(t, r, s.isPrevented));
	}
	async move(t, r, n) {
		const o = this.pointers.get(r),
			s = o.move(t, n),
			a = o.pointerType === 'touch' ? void 0 : this.mouse.move(t, n, o.isPrevented);
		(s?.leave(), a?.leave(), s?.enter(), a?.enter(), s?.move(), a?.move());
	}
	async release(t, r, n) {
		const o = this.devices.get(r.pointerType);
		(o.removePressed(r), this.buttons.up(r));
		const s = this.pointers.get(this.getPointerName(r)),
			a = s.isPrevented;
		if (
			((s.position = n),
			s.pointerType !== 'touch' && (this.mouse.position = n),
			o.countPressed === 0 && s.up(t, r.button),
			s.pointerType === 'touch' && s.release(t),
			s.pointerType === 'touch' && !s.isMultitouch)
		) {
			const u = this.mouse.move(t, n, a);
			(u?.leave(), u?.enter(), u?.move(), this.mouse.down(t, r, a));
		}
		if (!s.isMultitouch) {
			const u = this.mouse.move(t, n, a);
			(u?.leave(), u?.enter(), u?.move(), this.mouse.up(t, r, a));
		}
	}
	getPointerName(t) {
		return t.pointerType === 'touch' ? t.name : t.pointerType;
	}
	getPreviousPosition(t) {
		return this.pointers.has(t) ? this.pointers.get(t).position : void 0;
	}
	resetClickCount() {
		this.mouse.resetClickCount();
	}
	getMouseTarget(t) {
		var r;
		return (r = this.mouse.position.target) !== null && r !== void 0 ? r : t.config.document.body;
	}
	setMousePosition(t) {
		((this.mouse.position = t), (this.pointers.get('mouse').position = t));
	}
	constructor(t) {
		(Hr(this, 'system', void 0),
			Hr(this, 'mouse', void 0),
			Hr(this, 'buttons', void 0),
			Hr(
				this,
				'devices',
				new (class {
					get(r) {
						var n, o, s;
						return (s = (n = this.registry)[(o = r)]) !== null && s !== void 0
							? s
							: (n[o] = new tH());
					}
					constructor() {
						Hr(this, 'registry', {});
					}
				})()
			),
			Hr(
				this,
				'pointers',
				new (class {
					new(r, n, o) {
						const s =
							n !== 'touch' ||
							!Object.values(this.registry).some(
								(a) => a.pointerType === 'touch' && !a.isCancelled
							);
						return (
							s ||
								Object.values(this.registry).forEach((a) => {
									a.pointerType === n && !a.isCancelled && (a.isMultitouch = !0);
								}),
							(this.registry[r] = new nH(
								{ pointerId: this.nextId++, pointerType: n, isPrimary: s },
								o
							)),
							this.registry[r]
						);
					}
					get(r) {
						if (!this.has(r))
							throw new Error(`Trying to access pointer "${r}" which does not exist.`);
						return this.registry[r];
					}
					has(r) {
						return r in this.registry;
					}
					constructor() {
						(Hr(this, 'registry', {}), Hr(this, 'nextId', 1));
					}
				})()
			),
			(this.system = t),
			(this.buttons = new Bx()),
			(this.mouse = new rH()),
			this.pointers.new('mouse', 'mouse', this.buttons));
	}
};
i(Xx, 'PointerHost');
var oH = Xx;
function pf(e, t, r) {
	return (
		t in e
			? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 })
			: (e[t] = r),
		e
	);
}
i(pf, '_define_property');
var Qx = class {
	getUIEventModifiers() {
		return {
			altKey: this.keyboard.modifiers.Alt,
			ctrlKey: this.keyboard.modifiers.Control,
			metaKey: this.keyboard.modifiers.Meta,
			shiftKey: this.keyboard.modifiers.Shift,
			modifierAltGraph: this.keyboard.modifiers.AltGraph,
			modifierCapsLock: this.keyboard.modifiers.CapsLock,
			modifierFn: this.keyboard.modifiers.Fn,
			modifierFnLock: this.keyboard.modifiers.FnLock,
			modifierNumLock: this.keyboard.modifiers.NumLock,
			modifierScrollLock: this.keyboard.modifiers.ScrollLock,
			modifierSymbol: this.keyboard.modifiers.Symbol,
			modifierSymbolLock: this.keyboard.modifiers.SymbolLock
		};
	}
	constructor() {
		(pf(this, 'keyboard', new QV(this)), pf(this, 'pointer', new oH(this)));
	}
};
i(Qx, 'System');
var Zx = Qx;
async function eI(e) {
	const t = [];
	return (
		this.config.skipHover || t.push({ target: e }),
		t.push({ keys: '[MouseLeft]', target: e }),
		this.pointer(t)
	);
}
i(eI, 'click');
async function tI(e) {
	return this.pointer([{ target: e }, '[MouseLeft][MouseLeft]']);
}
i(tI, 'dblClick');
async function rI(e) {
	return this.pointer([{ target: e }, '[MouseLeft][MouseLeft][MouseLeft]']);
}
i(rI, 'tripleClick');
async function nI(e) {
	return this.pointer({ target: e });
}
i(nI, 'hover');
async function oI(e) {
	return (
		Go(this, this.system.pointer.getMouseTarget(this)),
		this.pointer({ target: e.ownerDocument.body })
	);
}
i(oI, 'unhover');
async function iI({ shift: e } = {}) {
	return this.keyboard(
		e === !0 ? '{Shift>}{Tab}{/Shift}' : e === !1 ? '[/ShiftLeft][/ShiftRight]{Tab}' : '{Tab}'
	);
}
i(iI, 'tab');
var Ag = (function (e) {
	return ((e['{'] = '}'), (e['['] = ']'), e);
})(Ag || {});
function Og(e, t) {
	let r = 0;
	const n = e[r] in Ag ? e[r] : '';
	r += n.length;
	const s = new RegExp(`^\\${n}{2}`).test(e) ? '' : n;
	return { type: s, ...(s === '' ? sI(e, r, t) : aI(e, r, s, t)) };
}
i(Og, 'readNextDescriptor');
function sI(e, t, r) {
	const n = e[t];
	return (
		Cg(n, e, t, r),
		(t += n.length),
		{ consumedLength: t, descriptor: n, releasePrevious: !1, releaseSelf: !0, repeat: 1 }
	);
}
i(sI, 'readPrintableChar');
function aI(e, t, r, n) {
	var o, s;
	const a = e[t] === '/' ? '/' : '';
	t += a.length;
	const u = r === '{' && e[t] === '\\';
	t += Number(u);
	const c = u
		? e[t]
		: (o = e.slice(t).match(r === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || o === void 0
			? void 0
			: o[0];
	(Cg(c, e, t, n), (t += c.length));
	var d;
	const p =
		(d = (s = e.slice(t).match(/^>\d+/)) === null || s === void 0 ? void 0 : s[0]) !== null &&
		d !== void 0
			? d
			: '';
	t += p.length;
	const f = e[t] === '/' || (!p && e[t] === '>') ? e[t] : '';
	t += f.length;
	const m = Ag[r],
		y = e[t] === m ? m : '';
	if (!y)
		throw new Error(
			xg(
				[!p && 'repeat modifier', !f && 'release modifier', `"${m}"`].filter(Boolean).join(' or '),
				e[t],
				e,
				n
			)
		);
	return (
		(t += y.length),
		{
			consumedLength: t,
			descriptor: c,
			releasePrevious: !!a,
			repeat: p ? Math.max(Number(p.substr(1)), 1) : 1,
			releaseSelf: lI(f, p)
		}
	);
}
i(aI, 'readTag');
function Cg(e, t, r, n) {
	if (!e) throw new Error(xg('key descriptor', t[r], t, n));
}
i(Cg, 'assertDescriptor');
function lI(e, t) {
	if (e) return e === '/';
	if (t) return !1;
}
i(lI, 'hasReleaseSelf');
function xg(e, t, r, n) {
	return `Expected ${e} but found "${t ?? ''}" in "${r}"
    See ${n === 'pointer' ? 'https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen' : 'https://testing-library.com/docs/user-event/keyboard'}
    for more information about how userEvent parses your input.`;
}
i(xg, 'getErrorMessage');
function uI(e, t) {
	const r = [];
	do {
		const {
			type: o,
			descriptor: s,
			consumedLength: a,
			releasePrevious: u,
			releaseSelf: c = !0,
			repeat: d
		} = Og(t, 'keyboard');
		var n;
		const p =
			(n = e.find((f) => {
				if (o === '[') {
					var m;
					return (
						((m = f.code) === null || m === void 0 ? void 0 : m.toLowerCase()) === s.toLowerCase()
					);
				} else if (o === '{') {
					var y;
					return (
						((y = f.key) === null || y === void 0 ? void 0 : y.toLowerCase()) === s.toLowerCase()
					);
				}
				return f.key === s;
			})) !== null && n !== void 0
				? n
				: { key: 'Unknown', code: 'Unknown', [o === '[' ? 'code' : 'key']: s };
		(r.push({ keyDef: p, releasePrevious: u, releaseSelf: c, repeat: d }), (t = t.slice(a)));
	} while (t);
	return r;
}
i(uI, 'parseKeyDef');
async function cI(e) {
	const t = uI(this.config.keyboardMap, e);
	for (let r = 0; r < t.length; r++) (await To(this.config), await dI(this, t[r]));
}
i(cI, 'keyboard');
async function dI(e, { keyDef: t, releasePrevious: r, releaseSelf: n, repeat: o }) {
	const { system: s } = e;
	if ((s.keyboard.isKeyPressed(t) && (await s.keyboard.keyup(e, t)), !r)) {
		for (let a = 1; a <= o; a++) (await s.keyboard.keydown(e, t), a < o && (await To(e.config)));
		n && (await s.keyboard.keyup(e, t));
	}
}
i(dI, 'keyboardAction');
async function pI(e) {
	for (const t of e.system.keyboard.getPressedKeys()) await e.system.keyboard.keyup(e, t);
}
i(pI, 'releaseAllKeys');
function Ig(e) {
	const t = gr(e)
			? { 'text/plain': fI(e) }
			: { 'text/plain': String(e.ownerDocument.getSelection()) },
		r = Tc(Yt(e));
	for (const n in t) t[n] && r.setData(n, t[n]);
	return r;
}
i(Ig, 'copySelection');
function fI(e) {
	const t = Ei(e);
	return br(e).substring(t.startOffset, t.endOffset);
}
i(fI, 'readSelectedValueFromInput');
async function mI() {
	const e = this.config.document;
	var t;
	const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
		n = Ig(r);
	if (n.items.length !== 0)
		return (
			this.dispatchUIEvent(r, 'copy', { clipboardData: n }) &&
				this.config.writeToClipboard &&
				(await ug(e, n)),
			n
		);
}
i(mI, 'copy');
async function hI() {
	const e = this.config.document;
	var t;
	const r = (t = e.activeElement) !== null && t !== void 0 ? t : e.body,
		n = Ig(r);
	if (n.items.length !== 0)
		return (
			this.dispatchUIEvent(r, 'cut', { clipboardData: n }) &&
				this.config.writeToClipboard &&
				(await ug(r.ownerDocument, n)),
			n
		);
}
i(hI, 'cut');
async function yI(e) {
	const t = this.config.document;
	var r;
	const n = (r = t.activeElement) !== null && r !== void 0 ? r : t.body;
	var o;
	const s =
		(o = typeof e == 'string' ? gI(t, e) : e) !== null && o !== void 0
			? o
			: await LC(t).catch(() => {
					throw new Error(
						'`userEvent.paste()` without `clipboardData` requires the `ClipboardAPI` to be available.'
					);
				});
	this.dispatchUIEvent(n, 'paste', { clipboardData: s });
}
i(yI, 'paste');
function gI(e, t) {
	const r = Tc(Yt(e));
	return (r.setData('text', t), r);
}
i(gI, 'getClipboardDataFromString');
function ff(e, t) {
	const r = [];
	do {
		const {
				descriptor: n,
				consumedLength: o,
				releasePrevious: s,
				releaseSelf: a = !0
			} = Og(t, 'pointer'),
			u = e.find((c) => c.name === n);
		(u && r.push({ keyDef: u, releasePrevious: s, releaseSelf: a }), (t = t.slice(o)));
	} while (t);
	return r;
}
i(ff, 'parseKeyDef');
async function bI(e) {
	const { pointerMap: t } = this.config,
		r = [];
	(Array.isArray(e) ? e : [e]).forEach((n) => {
		typeof n == 'string'
			? r.push(...ff(t, n))
			: 'keys' in n
				? r.push(...ff(t, n.keys).map((o) => ({ ...n, ...o })))
				: r.push(n);
	});
	for (let n = 0; n < r.length; n++) (await To(this.config), await vI(this, r[n]));
	this.system.pointer.resetClickCount();
}
i(bI, 'pointer');
async function vI(e, t) {
	var r, n;
	const o =
			'pointerName' in t && t.pointerName
				? t.pointerName
				: 'keyDef' in t
					? e.system.pointer.getPointerName(t.keyDef)
					: 'mouse',
		s = e.system.pointer.getPreviousPosition(o);
	var a, u, c, d;
	const p = {
		target: (a = t.target) !== null && a !== void 0 ? a : EI(e, s),
		coords: (u = t.coords) !== null && u !== void 0 ? u : s?.coords,
		caret: {
			node:
				(c = t.node) !== null && c !== void 0
					? c
					: mf(t) || s == null || (r = s.caret) === null || r === void 0
						? void 0
						: r.node,
			offset:
				(d = t.offset) !== null && d !== void 0
					? d
					: mf(t) || s == null || (n = s.caret) === null || n === void 0
						? void 0
						: n.offset
		}
	};
	'keyDef' in t
		? (e.system.pointer.isKeyPressed(t.keyDef) &&
				(Ho(e, Ht.Trigger), await e.system.pointer.release(e, t.keyDef, p)),
			t.releasePrevious ||
				(Ho(e, Ht.Trigger),
				await e.system.pointer.press(e, t.keyDef, p),
				t.releaseSelf && (Ho(e, Ht.Trigger), await e.system.pointer.release(e, t.keyDef, p))))
		: (Ho(e, Ht.Trigger), await e.system.pointer.move(e, o, p));
}
i(vI, 'pointerAction');
function mf(e) {
	var t, r;
	return !!((r = (t = e.target) !== null && t !== void 0 ? t : e.node) !== null && r !== void 0
		? r
		: e.offset !== void 0);
}
i(mf, 'hasCaretPosition');
function EI(e, t) {
	if (!t) throw new Error('This pointer has no previous position. Provide a target property!');
	var r;
	return (r = t.target) !== null && r !== void 0 ? r : e.config.document.body;
}
i(EI, 'getPrevTarget');
async function TI(e) {
	if (!bo(e) || Nr(e)) throw new Error('clear()` is only supported on editable elements.');
	if ((sn(e), e.ownerDocument.activeElement !== e))
		throw new Error('The element to be cleared could not be focused.');
	if ((bg(e), !Ex(e))) throw new Error('The element content to be cleared could not be selected.');
	Eo(this, e, '', 'deleteContentBackward');
}
i(TI, 'clear');
async function _I(e, t) {
	return Ng.call(this, !0, e, t);
}
i(_I, 'selectOptions');
async function wI(e, t) {
	return Ng.call(this, !1, e, t);
}
i(wI, 'deselectOptions');
async function Ng(e, t, r) {
	if (!e && !t.multiple)
		throw _e().getElementError(
			'Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.',
			t
		);
	const n = Array.isArray(r) ? r : [r],
		o = Array.from(t.querySelectorAll('option, [role="option"]')),
		s = n
			.map((u) => {
				if (typeof u != 'string' && o.includes(u)) return u;
				{
					const c = o.find((d) => d.value === u || d.innerHTML === u);
					if (c) return c;
					throw _e().getElementError(`Value "${String(u)}" not found in options`, t);
				}
			})
			.filter((u) => !Nr(u));
	if (Nr(t) || !s.length) return;
	const a = i((u) => {
		((u.selected = e),
			this.dispatchUIEvent(t, 'input', { bubbles: !0, cancelable: !1, composed: !0 }),
			this.dispatchUIEvent(t, 'change'));
	}, 'selectOption');
	if (ge(t, 'select'))
		if (t.multiple)
			for (const u of s) {
				const c = this.config.pointerEventsCheck === 0 ? !0 : aa(this, u);
				(c &&
					(this.dispatchUIEvent(u, 'pointerover'),
					this.dispatchUIEvent(t, 'pointerenter'),
					this.dispatchUIEvent(u, 'mouseover'),
					this.dispatchUIEvent(t, 'mouseenter'),
					this.dispatchUIEvent(u, 'pointermove'),
					this.dispatchUIEvent(u, 'mousemove'),
					this.dispatchUIEvent(u, 'pointerdown'),
					this.dispatchUIEvent(u, 'mousedown')),
					sn(t),
					c && (this.dispatchUIEvent(u, 'pointerup'), this.dispatchUIEvent(u, 'mouseup')),
					a(u),
					c && this.dispatchUIEvent(u, 'click'),
					await To(this.config));
			}
		else if (s.length === 1) {
			const u = this.config.pointerEventsCheck === 0 ? !0 : aa(this, t);
			(u ? await this.click(t) : sn(t),
				a(s[0]),
				u &&
					(this.dispatchUIEvent(t, 'pointerover'),
					this.dispatchUIEvent(t, 'pointerenter'),
					this.dispatchUIEvent(t, 'mouseover'),
					this.dispatchUIEvent(t, 'mouseenter'),
					this.dispatchUIEvent(t, 'pointerup'),
					this.dispatchUIEvent(t, 'mouseup'),
					this.dispatchUIEvent(t, 'click')),
				await To(this.config));
		} else throw _e().getElementError('Cannot select multiple options on a non-multiple select', t);
	else if (t.getAttribute('role') === 'listbox')
		for (const u of s) (await this.click(u), await this.unhover(u));
	else
		throw _e().getElementError(
			'Cannot select options on elements that are neither select nor listbox elements',
			t
		);
}
i(Ng, 'selectOptionsBase');
async function SI(
	e,
	t,
	{
		skipClick: r = this.config.skipClick,
		skipAutoClose: n = this.config.skipAutoClose,
		initialSelectionStart: o,
		initialSelectionEnd: s
	} = {}
) {
	e.disabled ||
		(r || (await this.click(e)),
		o !== void 0 && Vo(e, o, s ?? o),
		await this.keyboard(t),
		n || (await pI(this)));
}
i(SI, 'type');
var Av = Symbol('files and value properties are mocked');
function ll(e, t, r) {
	r ? Object.defineProperty(e, t, r) : delete e[t];
}
i(ll, 'restoreProperty');
function RI(e, t) {
	var r;
	(r = e[Av]) === null || r === void 0 || r.restore();
	const n = Object.getOwnPropertyDescriptor(e, 'type'),
		o = Object.getOwnPropertyDescriptor(e, 'value'),
		s = Object.getOwnPropertyDescriptor(e, 'files');
	function a() {
		(ll(e, 'type', n), ll(e, 'value', o), ll(e, 'files', s));
	}
	(i(a, 'restore'),
		(e[Av] = { restore: a }),
		Object.defineProperties(e, {
			files: { configurable: !0, get: i(() => t, 'get') },
			value: {
				configurable: !0,
				get: i(() => (t.length ? `C:\\fakepath\\${t[0].name}` : ''), 'get'),
				set(u) {
					if (u === '') a();
					else {
						var c;
						o == null || (c = o.set) === null || c === void 0 || c.call(e, u);
					}
				}
			},
			type: {
				configurable: !0,
				get: i(() => 'file', 'get'),
				set(u) {
					u !== 'file' && (a(), (e.type = u));
				}
			}
		}));
}
i(RI, 'setFiles');
async function PI(e, t) {
	const r = ge(e, 'label') ? e.control : e;
	if (!r || !ge(r, 'input', { type: 'file' }))
		throw new TypeError(
			`The ${r === e ? 'given' : 'associated'} ${r?.tagName} element does not accept file uploads`
		);
	if (Nr(e)) return;
	const n = (Array.isArray(t) ? t : [t])
			.filter((s) => !this.config.applyAccept || AI(s, r.accept))
			.slice(0, r.multiple ? void 0 : 1),
		o = i(() => {
			var s;
			(n.length === ((s = r.files) === null || s === void 0 ? void 0 : s.length) &&
				n.every((a, u) => {
					var c;
					return a === ((c = r.files) === null || c === void 0 ? void 0 : c.item(u));
				})) ||
				(RI(r, Ec(Yt(e), n)), this.dispatchUIEvent(r, 'input'), this.dispatchUIEvent(r, 'change'));
		}, 'fileDialog');
	(r.addEventListener('fileDialog', o),
		await this.click(e),
		r.removeEventListener('fileDialog', o));
}
i(PI, 'upload');
function Ss(e) {
	return e.toLowerCase().replace(/(\.|\/)jpg\b/g, '$1jpeg');
}
i(Ss, 'normalize');
function AI(e, t) {
	if (!t) return !0;
	const r = ['audio/*', 'image/*', 'video/*'];
	return Ss(t)
		.trim()
		.split(/\s*,\s*/)
		.some((n) =>
			n.startsWith('.')
				? Ss(e.name).endsWith(n)
				: r.includes(n)
					? Ss(e.type).startsWith(n.replace('*', ''))
					: Ss(e.type) === n
		);
}
i(AI, 'isAcceptableFile');
var Ov = {
	click: eI,
	dblClick: tI,
	tripleClick: rI,
	hover: nI,
	unhover: oI,
	tab: iI,
	keyboard: cI,
	copy: mI,
	cut: hI,
	paste: yI,
	pointer: bI,
	clear: TI,
	deselectOptions: wI,
	selectOptions: _I,
	type: SI,
	upload: PI
};
function OI(e) {
	return _e().asyncWrapper(e);
}
i(OI, 'wrapAsync');
var CI = {
		applyAccept: !0,
		autoModify: !0,
		delay: 0,
		document: globalThis.document,
		keyboardMap: ZV,
		pointerMap: eH,
		pointerEventsCheck: al.EachApiCall,
		skipAutoClose: !1,
		skipClick: !1,
		skipHover: !1,
		writeToClipboard: !1,
		advanceTimers: i(() => Promise.resolve(), 'advanceTimers')
	},
	iH = { ...CI, writeToClipboard: !0 };
function Mg(e = {}, t = iH, r) {
	const n = MI(e, r, t);
	return { ...t, ...e, document: n };
}
i(Mg, 'createConfig');
function xI(e = {}) {
	const t = Mg(e);
	(wg(t.document), _g(Yt(t.document).HTMLElement));
	var r;
	const n = (r = t.document.defaultView) !== null && r !== void 0 ? r : globalThis.window;
	return (jC(n), Pc(t).api);
}
i(xI, 'setupMain');
function bt({ keyboardState: e, pointerState: t, ...r } = {}, n) {
	const o = Mg(r, CI, n);
	(wg(o.document), _g(Yt(o.document).HTMLElement));
	var s;
	const a = (s = t ?? e) !== null && s !== void 0 ? s : new Zx();
	return { api: Pc(o, a).api, system: a };
}
i(bt, 'setupDirect');
function II(e) {
	return Pc({ ...this.config, ...e }, this.system).api;
}
i(II, 'setupSub');
function NI(e, t) {
	function r(...n) {
		return (Ho(e, Ht.Call), OI(() => t.apply(e, n).then(async (o) => (await To(e.config), o))));
	}
	return (i(r, 'method'), Object.defineProperty(r, 'name', { get: i(() => t.name, 'get') }), r);
}
i(NI, 'wrapAndBindImpl');
function Pc(e, t = new Zx()) {
	const r = {};
	return (
		Object.assign(r, {
			config: e,
			dispatchEvent: Tg.bind(r),
			dispatchUIEvent: xx.bind(r),
			system: t,
			levelRefs: {},
			...Ov
		}),
		{
			instance: r,
			api: {
				...Object.fromEntries(Object.entries(Ov).map(([n, o]) => [n, NI(r, o)])),
				setup: II.bind(r)
			}
		}
	);
}
i(Pc, 'createInstance');
function MI(e, t, r) {
	var n, o;
	return (o = (n = e.document) !== null && n !== void 0 ? n : t && jx(t)) !== null && o !== void 0
		? o
		: r.document;
}
i(MI, 'getDocument');
var qI = {};
Lt(qI, {
	clear: () => jI,
	click: () => DI,
	copy: () => kI,
	cut: () => LI,
	dblClick: () => FI,
	deselectOptions: () => BI,
	hover: () => JI,
	keyboard: () => $I,
	paste: () => VI,
	pointer: () => UI,
	selectOptions: () => HI,
	tab: () => YI,
	tripleClick: () => GI,
	type: () => zI,
	unhover: () => WI,
	upload: () => KI
});
function jI(e) {
	return bt().api.clear(e);
}
i(jI, 'clear');
function DI(e, t = {}) {
	return bt(t, e).api.click(e);
}
i(DI, 'click');
function kI(e = {}) {
	return bt(e).api.copy();
}
i(kI, 'copy');
function LI(e = {}) {
	return bt(e).api.cut();
}
i(LI, 'cut');
function FI(e, t = {}) {
	return bt(t).api.dblClick(e);
}
i(FI, 'dblClick');
function BI(e, t, r = {}) {
	return bt(r).api.deselectOptions(e, t);
}
i(BI, 'deselectOptions');
function JI(e, t = {}) {
	return bt(t).api.hover(e);
}
i(JI, 'hover');
async function $I(e, t = {}) {
	const { api: r, system: n } = bt(t);
	return r.keyboard(e).then(() => n);
}
i($I, 'keyboard');
async function UI(e, t = {}) {
	const { api: r, system: n } = bt(t);
	return r.pointer(e).then(() => n);
}
i(UI, 'pointer');
function VI(e, t) {
	return bt(t).api.paste(e);
}
i(VI, 'paste');
function HI(e, t, r = {}) {
	return bt(r).api.selectOptions(e, t);
}
i(HI, 'selectOptions');
function GI(e, t = {}) {
	return bt(t).api.tripleClick(e);
}
i(GI, 'tripleClick');
function zI(e, t, r = {}) {
	return bt(r, e).api.type(e, t, r);
}
i(zI, 'type');
function WI(e, t = {}) {
	const { api: r, system: n } = bt(t);
	return (n.pointer.setMousePosition({ target: e }), r.unhover(e));
}
i(WI, 'unhover');
function KI(e, t, r = {}) {
	return bt(r).api.upload(e, t);
}
i(KI, 'upload');
function YI(e = {}) {
	return bt().api.tab(e);
}
i(YI, 'tab');
var XI = { ...qI, setup: xI },
	hf = Oi(
		{ ...lA },
		{
			getKeys: i((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys'),
			intercept: i(
				(e, t) => t[0] === 'fireEvent' || e.startsWith('find') || e.startsWith('waitFor'),
				'intercept'
			)
		}
	);
hf.screen = new Proxy(hf.screen, {
	get(e, t, r) {
		return (
			typeof window < 'u' &&
				globalThis.location?.href?.includes('viewMode=docs') &&
				Ye.warn(Ee`
        You are using Testing Library's \`screen\` object while the story is rendered in docs mode. This will likely lead to issues, as multiple stories are rendered in the same page and therefore screen will potentially find multiple elements. Use the \`canvas\` utility from the story context instead, which will scope the queries to each story's canvas.

        More info: https://storybook.js.org/docs/writing-tests/interaction-testing?ref=error#querying-the-canvas
      `),
			Reflect.get(e, t, r)
		);
	}
});
var {
		buildQueries: sH,
		configure: aH,
		createEvent: lH,
		fireEvent: uH,
		findAllByAltText: cH,
		findAllByDisplayValue: dH,
		findAllByLabelText: pH,
		findAllByPlaceholderText: fH,
		findAllByRole: mH,
		findAllByTestId: hH,
		findAllByText: yH,
		findAllByTitle: gH,
		findByAltText: bH,
		findByDisplayValue: vH,
		findByLabelText: EH,
		findByPlaceholderText: TH,
		findByRole: _H,
		findByTestId: wH,
		findByText: SH,
		findByTitle: RH,
		getAllByAltText: PH,
		getAllByDisplayValue: AH,
		getAllByLabelText: OH,
		getAllByPlaceholderText: CH,
		getAllByRole: xH,
		getAllByTestId: IH,
		getAllByText: NH,
		getAllByTitle: MH,
		getByAltText: qH,
		getByDisplayValue: jH,
		getByLabelText: DH,
		getByPlaceholderText: kH,
		getByRole: LH,
		getByTestId: FH,
		getByText: BH,
		getByTitle: JH,
		getConfig: $H,
		getDefaultNormalizer: UH,
		getElementError: VH,
		getNodeText: HH,
		getQueriesForElement: GH,
		getRoles: zH,
		getSuggestedQuery: WH,
		isInaccessible: KH,
		logDOM: YH,
		logRoles: XH,
		prettyDOM: QH,
		queries: ZH,
		queryAllByAltText: e3,
		queryAllByAttribute: t3,
		queryAllByDisplayValue: r3,
		queryAllByLabelText: n3,
		queryAllByPlaceholderText: o3,
		queryAllByRole: i3,
		queryAllByTestId: s3,
		queryAllByText: a3,
		queryAllByTitle: l3,
		queryByAltText: u3,
		queryByAttribute: c3,
		queryByDisplayValue: d3,
		queryByLabelText: p3,
		queryByPlaceholderText: f3,
		queryByRole: m3,
		queryByTestId: h3,
		queryByText: y3,
		queryByTitle: g3,
		queryHelpers: b3,
		screen: v3,
		waitFor: E3,
		waitForElementToBeRemoved: T3,
		within: QI,
		prettyFormat: _3
	} = hf,
	ZI = XI,
	{ userEvent: w3 } = Oi(
		{ userEvent: XI },
		{
			intercept: !0,
			getKeys: i((e) => Object.keys(e).filter((t) => t !== 'eventWrapper'), 'getKeys')
		}
	),
	{ expect: S3 } = Oi(
		{ expect: iA },
		{
			getKeys: i((e, t) => {
				if ('constructor' in e && e.constructor === j) {
					const r = ['assert', '__methods', '__flags', '_obj'],
						n = Object.keys(Object.getPrototypeOf(e)).filter((o) => !r.includes(o));
					return t > 2 ? n : [...n, 'not'];
				}
				return 'any' in e ? Object.keys(e).filter((r) => r !== 'any') : Object.keys(e);
			}, 'getKeys'),
			mutate: !0,
			intercept: i((e) => e !== 'expect', 'intercept')
		}
	),
	R3 = { mock: i(() => {}, 'mock') },
	Cv = !1,
	P3 = i((e) => {
		const { parameters: t } = e;
		t?.actions?.disable ||
			Cv ||
			(xy((r, n) => {
				const o = r.getMockName();
				o !== 'spy' &&
					o !== 'vi.fn()' &&
					(!/^next\/.*::/.test(o) ||
						[
							'next/router::useRouter()',
							'next/navigation::useRouter()',
							'next/navigation::redirect',
							'next/cache::',
							'next/headers::cookies().set',
							'next/headers::cookies().delete',
							'next/headers::headers().set',
							'next/headers::headers().delete'
						].some((s) => o.startsWith(s))) &&
					Li(o)(n);
			}),
			(Cv = !0));
	}, 'logActionsWhenMockCalled'),
	A3 = [P3],
	xv = i(() => ({ ...Lw, ...Bw }), 'default'),
	Zl = 'backgrounds',
	O3 = { light: { name: 'light', value: '#F8F8F8' }, dark: { name: 'dark', value: '#333' } },
	{ document: pr } = globalThis,
	C3 = i(
		() =>
			globalThis?.matchMedia
				? !!globalThis.matchMedia('(prefers-reduced-motion: reduce)')?.matches
				: !1,
		'isReduceMotionEnabled'
	),
	Iv = i((e) => {
		(Array.isArray(e) ? e : [e]).forEach(x3);
	}, 'clearStyles'),
	x3 = i((e) => {
		if (!pr) return;
		const t = pr.getElementById(e);
		t && t.parentElement && t.parentElement.removeChild(t);
	}, 'clearStyle'),
	I3 = i((e, t) => {
		if (!pr) return;
		const r = pr.getElementById(e);
		if (r) r.innerHTML !== t && (r.innerHTML = t);
		else {
			const n = pr.createElement('style');
			(n.setAttribute('id', e), (n.innerHTML = t), pr.head.appendChild(n));
		}
	}, 'addGridStyle'),
	N3 = i((e, t, r) => {
		if (!pr) return;
		const n = pr.getElementById(e);
		if (n) n.innerHTML !== t && (n.innerHTML = t);
		else {
			const o = pr.createElement('style');
			(o.setAttribute('id', e), (o.innerHTML = t));
			const s = `addon-backgrounds-grid${r ? `-docs-${r}` : ''}`,
				a = pr.getElementById(s);
			a ? a.parentElement?.insertBefore(o, a) : pr.head.appendChild(o);
		}
	}, 'addBackgroundStyle'),
	M3 = { cellSize: 100, cellAmount: 10, opacity: 0.8 },
	Nv = 'addon-backgrounds',
	Mv = 'addon-backgrounds-grid',
	q3 = C3() ? '' : 'transition: background-color 0.3s;',
	j3 = i((e, t) => {
		const { globals: r = {}, parameters: n = {}, viewMode: o, id: s } = t,
			{ options: a = O3, disable: u, grid: c = M3 } = n[Zl] || {},
			d = r[Zl] || {},
			p = typeof d == 'string' ? d : d?.value,
			f = p ? a[p] : void 0,
			m = typeof f == 'string' ? f : f?.value || 'transparent',
			y = typeof d == 'string' ? !1 : d.grid || !1,
			g = !!f && !u,
			E = o === 'docs' ? `#anchor--${s} .docs-story` : '.sb-show-main',
			T = o === 'docs' ? `#anchor--${s} .docs-story` : '.sb-show-main',
			b = n.layout === void 0 || n.layout === 'padded',
			w = o === 'docs' ? 20 : b ? 16 : 0,
			{ cellAmount: P, cellSize: I, opacity: q, offsetX: C = w, offsetY: R = w } = c,
			_ = o === 'docs' ? `${Nv}-docs-${s}` : `${Nv}-color`,
			S = o === 'docs' ? s : null;
		In(() => {
			const N = `
    ${E} {
      background: ${m} !important;
      ${q3}
      }`;
			if (!g) {
				Iv(_);
				return;
			}
			N3(_, N, S);
		}, [E, _, S, g, m]);
		const D = o === 'docs' ? `${Mv}-docs-${s}` : `${Mv}`;
		return (
			In(() => {
				if (!y) {
					Iv(D);
					return;
				}
				const N = [
						`${I * P}px ${I * P}px`,
						`${I * P}px ${I * P}px`,
						`${I}px ${I}px`,
						`${I}px ${I}px`
					].join(', '),
					V = `
        ${T} {
          background-size: ${N} !important;
          background-position: ${C}px ${R}px, ${C}px ${R}px, ${C}px ${R}px, ${C}px ${R}px !important;
          background-blend-mode: difference !important;
          background-image: linear-gradient(rgba(130, 130, 130, ${q}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${q}) 1px, transparent 1px),
           linear-gradient(rgba(130, 130, 130, ${q / 2}) 1px, transparent 1px),
           linear-gradient(90deg, rgba(130, 130, 130, ${q / 2}) 1px, transparent 1px) !important;
        }
      `;
				I3(D, V);
			}, [P, I, T, D, y, C, R, q]),
			e()
		);
	}, 'withBackgroundAndGrid'),
	D3 = globalThis.FEATURES?.backgrounds ? [j3] : [],
	k3 = { [Zl]: { grid: { cellSize: 20, opacity: 0.5, cellAmount: 5 }, disable: !1 } },
	L3 = { [Zl]: { value: void 0, grid: !1 } },
	qv = i(() => ({ decorators: D3, parameters: k3, initialGlobals: L3 }), 'default'),
	{ step: F3 } = Oi({ step: i(async (e, t, r) => t(r), 'step') }, { intercept: !0 }),
	jv = i(() => ({ parameters: { throwPlayFunctionExceptions: !1 }, runStep: F3 }), 'default'),
	Ac = 'storybook/highlight',
	B3 = `${Ac}/add`,
	J3 = `${Ac}/remove`,
	$3 = `${Ac}/reset`,
	U3 = `${Ac}/scroll-into-view`,
	Dv = 2147483647,
	vn = 28,
	kv = {
		chevronLeft: [
			'M9.10355 10.1464C9.29882 10.3417 9.29882 10.6583 9.10355 10.8536C8.90829 11.0488 8.59171 11.0488 8.39645 10.8536L4.89645 7.35355C4.70118 7.15829 4.70118 6.84171 4.89645 6.64645L8.39645 3.14645C8.59171 2.95118 8.90829 2.95118 9.10355 3.14645C9.29882 3.34171 9.29882 3.65829 9.10355 3.85355L5.95711 7L9.10355 10.1464Z'
		],
		chevronRight: [
			'M4.89645 10.1464C4.70118 10.3417 4.70118 10.6583 4.89645 10.8536C5.09171 11.0488 5.40829 11.0488 5.60355 10.8536L9.10355 7.35355C9.29882 7.15829 9.29882 6.84171 9.10355 6.64645L5.60355 3.14645C5.40829 2.95118 5.09171 2.95118 4.89645 3.14645C4.70118 3.34171 4.70118 3.65829 4.89645 3.85355L8.04289 7L4.89645 10.1464Z'
		],
		info: [
			'M7 5.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V6a.5.5 0 01.5-.5zM7 4.5A.75.75 0 107 3a.75.75 0 000 1.5z',
			'M7 14A7 7 0 107 0a7 7 0 000 14zm0-1A6 6 0 107 1a6 6 0 000 12z'
		],
		shareAlt: [
			'M2 1.004a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1v-4.5a.5.5 0 00-1 0v4.5H2v-10h4.5a.5.5 0 000-1H2z',
			'M7.354 7.357L12 2.711v1.793a.5.5 0 001 0v-3a.5.5 0 00-.5-.5h-3a.5.5 0 100 1h1.793L6.646 6.65a.5.5 0 10.708.707z'
		]
	},
	V3 = 'svg,path,rect,circle,line,polyline,polygon,ellipse,text'.split(','),
	at = i((e, t = {}, r) => {
		const n = V3.includes(e)
			? document.createElementNS('http://www.w3.org/2000/svg', e)
			: document.createElement(e);
		return (
			Object.entries(t).forEach(([o, s]) => {
				/[A-Z]/.test(o)
					? (o === 'onClick' &&
							(n.addEventListener('click', s),
							n.addEventListener('keydown', (a) => {
								(a.key === 'Enter' || a.key === ' ') && (a.preventDefault(), s());
							})),
						o === 'onMouseEnter' && n.addEventListener('mouseenter', s),
						o === 'onMouseLeave' && n.addEventListener('mouseleave', s))
					: n.setAttribute(o, s);
			}),
			r?.forEach((o) => {
				if (!(o == null || o === !1))
					try {
						n.appendChild(o);
					} catch {
						n.appendChild(document.createTextNode(String(o)));
					}
			}),
			n
		);
	}, 'createElement'),
	$a = i(
		(e) =>
			kv[e] &&
			at(
				'svg',
				{ width: '14', height: '14', viewBox: '0 0 14 14', xmlns: 'http://www.w3.org/2000/svg' },
				kv[e].map((t) =>
					at('path', { fill: 'currentColor', 'fill-rule': 'evenodd', 'clip-rule': 'evenodd', d: t })
				)
			),
		'createIcon'
	),
	H3 = i((e) => {
		if ('elements' in e) {
			const { elements: n, color: o, style: s } = e;
			return {
				id: void 0,
				priority: 0,
				selectors: n,
				styles: {
					outline: `2px ${s} ${o}`,
					outlineOffset: '2px',
					boxShadow: '0 0 0 6px rgba(255,255,255,0.6)'
				},
				menu: void 0
			};
		}
		const { menu: t, ...r } = e;
		return {
			id: void 0,
			priority: 0,
			styles: { outline: '2px dashed #029cfd' },
			...r,
			menu: Array.isArray(t) ? (t.every(Array.isArray) ? t : [t]) : void 0
		};
	}, 'normalizeOptions'),
	G3 = i((e) => e instanceof Function, 'isFunction'),
	hs = new Map(),
	Wn = new Map(),
	Ua = new Map(),
	$r = i((e) => {
		const t = Symbol();
		return (
			Wn.set(t, []),
			hs.set(t, e),
			{
				get: i(() => hs.get(t), 'get'),
				set: i((a) => {
					const u = hs.get(t),
						c = G3(a) ? a(u) : a;
					c !== u &&
						(hs.set(t, c),
						Wn.get(t)?.forEach((d) => {
							(Ua.get(d)?.(), Ua.set(d, d(c)));
						}));
				}, 'set'),
				subscribe: i(
					(a) => (
						Wn.get(t)?.push(a),
						() => {
							const u = Wn.get(t);
							u &&
								Wn.set(
									t,
									u.filter((c) => c !== a)
								);
						}
					),
					'subscribe'
				),
				teardown: i(() => {
					(Wn.get(t)?.forEach((a) => {
						(Ua.get(a)?.(), Ua.delete(a));
					}),
						Wn.delete(t),
						hs.delete(t));
				}, 'teardown')
			}
		);
	}, 'useStore'),
	Lv = i((e) => {
		const t = document.getElementById('storybook-root'),
			r = new Map();
		for (const n of e) {
			const { priority: o = 0 } = n;
			for (const s of n.selectors) {
				const a = [
					...document.querySelectorAll(
						`:is(${s}):not([id^="storybook-"], [id^="storybook-"] *, [class^="sb-"], [class^="sb-"] *)`
					),
					...(t?.querySelectorAll(s) || [])
				];
				for (const u of a) {
					const c = r.get(u);
					(!c || c.priority <= o) &&
						r.set(u, {
							...n,
							priority: o,
							selectors: Array.from(new Set((c?.selectors || []).concat(s)))
						});
				}
			}
		}
		return r;
	}, 'mapElements'),
	z3 = i(
		(e) =>
			Array.from(e.entries())
				.map(([t, { selectors: r, styles: n, hoverStyles: o, focusStyles: s, menu: a }]) => {
					const { top: u, left: c, width: d, height: p } = t.getBoundingClientRect(),
						{ position: f } = getComputedStyle(t);
					return {
						element: t,
						selectors: r,
						styles: n,
						hoverStyles: o,
						focusStyles: s,
						menu: a,
						top: f === 'fixed' ? u : u + window.scrollY,
						left: f === 'fixed' ? c : c + window.scrollX,
						width: d,
						height: p
					};
				})
				.sort((t, r) => r.width * r.height - t.width * t.height),
		'mapBoxes'
	),
	Fv = i((e, t) => {
		const r = e.getBoundingClientRect(),
			{ x: n, y: o } = t;
		return (
			r?.top &&
			r?.left &&
			n >= r.left &&
			n <= r.left + r.width &&
			o >= r.top &&
			o <= r.top + r.height
		);
	}, 'isOverMenu'),
	Bv = i((e, t, r) => {
		if (!t || !r) return !1;
		let { left: n, top: o, width: s, height: a } = e;
		(a < vn && ((o = o - Math.round((vn - a) / 2)), (a = vn)),
			s < vn && ((n = n - Math.round((vn - s) / 2)), (s = vn)),
			t.style.position === 'fixed' && ((n += window.scrollX), (o += window.scrollY)));
		const { x: u, y: c } = r;
		return u >= n && u <= n + s && c >= o && c <= o + a;
	}, 'isTargeted'),
	W3 = i((e, t, r = {}) => {
		const { x: n, y: o } = t,
			{ margin: s = 5, topOffset: a = 0, centered: u = !1 } = r,
			{ scrollX: c, scrollY: d, innerHeight: p, innerWidth: f } = window,
			m = Math.min(e.style.position === 'fixed' ? o - d : o, p - e.clientHeight - s - a + d),
			y = u ? e.clientWidth / 2 : 0,
			g =
				e.style.position === 'fixed'
					? Math.max(Math.min(n - c, f - y - s), y + s)
					: Math.max(Math.min(n, f - y - s + c), y + s + c);
		Object.assign(e.style, {
			...(g !== n && { left: `${g}px` }),
			...(m !== o && { top: `${m}px` })
		});
	}, 'keepInViewport'),
	Jv = i((e) => {
		window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.showPopover();
	}, 'showPopover'),
	K3 = i((e) => {
		window.HTMLElement.prototype.hasOwnProperty('showPopover') && e.hidePopover();
	}, 'hidePopover'),
	Y3 = i(
		(e) => ({
			top: e.top,
			left: e.left,
			width: e.width,
			height: e.height,
			selectors: e.selectors,
			element: {
				attributes: Object.fromEntries(
					Array.from(e.element.attributes).map((t) => [t.name, t.value])
				),
				localName: e.element.localName,
				tagName: e.element.tagName,
				outerHTML: e.element.outerHTML
			}
		}),
		'getEventDetails'
	),
	Le = 'storybook-highlights-menu',
	$v = 'storybook-highlights-root',
	X3 = 'storybook-root',
	Q3 = i((e) => {
		if (globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED) return;
		globalThis.__STORYBOOK_HIGHLIGHT_INITIALIZED = !0;
		const { document: t } = globalThis,
			r = $r([]),
			n = $r(new Map()),
			o = $r([]),
			s = $r(),
			a = $r(),
			u = $r([]),
			c = $r([]),
			d = $r(),
			p = $r();
		let f = t.getElementById($v);
		(r.subscribe(() => {
			f || ((f = at('div', { id: $v })), t.body.appendChild(f));
		}),
			r.subscribe((R) => {
				const _ = t.getElementById(X3);
				if (!_) return;
				n.set(Lv(R));
				const S = new MutationObserver(() => n.set(Lv(R)));
				return (
					S.observe(_, { subtree: !0, childList: !0 }),
					() => {
						S.disconnect();
					}
				);
			}),
			n.subscribe((R) => {
				const _ = i(() => requestAnimationFrame(() => o.set(z3(R))), 'updateBoxes'),
					S = new ResizeObserver(_);
				(S.observe(t.body), Array.from(R.keys()).forEach((N) => S.observe(N)));
				const D = Array.from(t.body.querySelectorAll('*')).filter((N) => {
					const { overflow: V, overflowX: H, overflowY: A } = window.getComputedStyle(N);
					return ['auto', 'scroll'].some((L) => [V, H, A].includes(L));
				});
				return (
					D.forEach((N) => N.addEventListener('scroll', _)),
					() => {
						(S.disconnect(), D.forEach((N) => N.removeEventListener('scroll', _)));
					}
				);
			}),
			n.subscribe((R) => {
				const _ = Array.from(R.keys()).filter(({ style: D }) => D.position === 'sticky'),
					S = i(
						() =>
							requestAnimationFrame(() => {
								o.set((D) =>
									D.map((N) => {
										if (_.includes(N.element)) {
											const { top: V, left: H } = N.element.getBoundingClientRect();
											return { ...N, top: V + window.scrollY, left: H + window.scrollX };
										}
										return N;
									})
								);
							}),
						'updateBoxes'
					);
				return (t.addEventListener('scroll', S), () => t.removeEventListener('scroll', S));
			}),
			n.subscribe((R) => {
				u.set((_) => _.filter(({ element: S }) => R.has(S)));
			}),
			u.subscribe((R) => {
				R.length
					? (p.set((_) => (R.some((S) => S.element === _?.element) ? _ : void 0)),
						d.set((_) => (R.some((S) => S.element === _?.element) ? _ : void 0)))
					: (p.set(void 0), d.set(void 0), s.set(void 0));
			}));
		const m = new Map(new Map());
		r.subscribe((R) => {
			(R.forEach(({ keyframes: _ }) => {
				if (_) {
					let S = m.get(_);
					(S ||
						((S = t.createElement('style')),
						S.setAttribute('data-highlight', 'keyframes'),
						m.set(_, S),
						t.head.appendChild(S)),
						(S.innerHTML = _));
				}
			}),
				m.forEach((_, S) => {
					R.some((D) => D.keyframes === S) || (_.remove(), m.delete(S));
				}));
		});
		const y = new Map(new Map());
		(o.subscribe((R) => {
			(R.forEach((_) => {
				let S = y.get(_.element);
				if (f && !S) {
					const D = {
						popover: 'manual',
						'data-highlight-dimensions': `w${_.width.toFixed(0)}h${_.height.toFixed(0)}`,
						'data-highlight-coordinates': `x${_.left.toFixed(0)}y${_.top.toFixed(0)}`
					};
					((S = f.appendChild(at('div', D, [at('div')]))), y.set(_.element, S));
				}
			}),
				y.forEach((_, S) => {
					R.some(({ element: D }) => D === S) || (_.remove(), y.delete(S));
				}));
		}),
			o.subscribe((R) => {
				const _ = R.filter((D) => D.menu);
				if (!_.length) return;
				const S = i((D) => {
					requestAnimationFrame(() => {
						const N = t.getElementById(Le),
							V = { x: D.pageX, y: D.pageY };
						if (N && !Fv(N, V)) {
							const H = _.filter((A) => {
								const L = y.get(A.element);
								return Bv(A, L, V);
							});
							(s.set(H.length ? V : void 0), u.set(H));
						}
					});
				}, 'onClick');
				return (t.addEventListener('click', S), () => t.removeEventListener('click', S));
			}));
		const g = i(() => {
			const R = t.getElementById(Le),
				_ = a.get();
			!_ ||
				(R && Fv(R, _)) ||
				c.set((S) => {
					const D = o.get().filter((A) => {
							const L = y.get(A.element);
							return Bv(A, L, _);
						}),
						N = S.filter((A) => D.includes(A)),
						V = D.filter((A) => !S.includes(A)),
						H = S.length - N.length;
					return V.length || H ? [...N, ...V] : S;
				});
		}, 'updateHovered');
		(a.subscribe(g), o.subscribe(g));
		const E = i(() => {
			const R = p.get(),
				_ = R ? [R] : u.get(),
				S = _.length === 1 ? _[0] : d.get(),
				D = s.get() !== void 0;
			o.get().forEach((N) => {
				const V = y.get(N.element);
				if (V) {
					const H = S === N,
						A = D ? (S ? H : _.includes(N)) : c.get()?.includes(N);
					(Object.assign(V.style, {
						animation: 'none',
						background: 'transparent',
						border: 'none',
						boxSizing: 'border-box',
						outline: 'none',
						outlineOffset: '0px',
						...N.styles,
						...(A ? N.hoverStyles : {}),
						...(H ? N.focusStyles : {}),
						position: getComputedStyle(N.element).position === 'fixed' ? 'fixed' : 'absolute',
						zIndex: Dv - 10,
						top: `${N.top}px`,
						left: `${N.left}px`,
						width: `${N.width}px`,
						height: `${N.height}px`,
						margin: 0,
						padding: 0,
						cursor: N.menu && A ? 'pointer' : 'default',
						pointerEvents: N.menu ? 'auto' : 'none',
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						overflow: 'visible'
					}),
						Object.assign(V.children[0].style, {
							width: '100%',
							height: '100%',
							minHeight: `${vn}px`,
							minWidth: `${vn}px`,
							boxSizing: 'content-box',
							padding: V.style.outlineWidth || '0px'
						}),
						Jv(V));
				}
			});
		}, 'updateBoxStyles');
		(o.subscribe(E), u.subscribe(E), c.subscribe(E), d.subscribe(E), p.subscribe(E));
		const T = i(() => {
			if (!f) return;
			let R = t.getElementById(Le);
			if (R) R.innerHTML = '';
			else {
				const N = { id: Le, popover: 'manual' };
				((R = f.appendChild(at('div', N))),
					f.appendChild(
						at('style', {}, [
							`
            #${Le} {
              position: absolute;
              z-index: ${Dv};
              width: 300px;
              padding: 0px;
              margin: 15px 0 0 0;
              transform: translateX(-50%);
              font-family: "Nunito Sans", -apple-system, ".SFNSText-Regular", "San Francisco", BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
              font-size: 12px;
              background: white;
              border: none;
              border-radius: 6px;
              box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.05), 0 5px 15px 0 rgba(0, 0, 0, 0.1);
              color: #2E3438;
            }
            #${Le} ul {
              list-style: none;
              margin: 0;
              padding: 0;
            }
            #${Le} > ul {
              max-height: 300px;
              overflow-y: auto;
              padding: 4px 0;
            }
            #${Le} li {
              padding: 0 4px;
              margin: 0;
            }
            #${Le} li > :not(ul) {
              display: flex;
              padding: 8px;
              margin: 0;
              align-items: center;
              gap: 8px;
              border-radius: 4px;
            }
            #${Le} button {
              width: 100%;
              border: 0;
              background: transparent;
              color: inherit;
              text-align: left;
              font-family: inherit;
              font-size: inherit;
            }
            #${Le} button:focus-visible {
              outline-color: #029CFD;
            }
            #${Le} button:hover {
              background: rgba(2, 156, 253, 0.07);
              color: #029CFD;
              cursor: pointer;
            }
            #${Le} li code {
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              line-height: 16px;
              font-size: 11px;
            }
            #${Le} li svg {
              flex-shrink: 0;
              margin: 1px;
              color: #73828C;
            }
            #${Le} li > button:hover svg, #${Le} li > button:focus-visible svg {
              color: #029CFD;
            }
            #${Le} .element-list li svg {
              display: none;
            }
            #${Le} li.selectable svg, #${Le} li.selected svg {
              display: block;
            }
            #${Le} .menu-list {
              border-top: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Le} .menu-list > li:not(:last-child) {
              padding-bottom: 4px;
              margin-bottom: 4px;
              border-bottom: 1px solid rgba(38, 85, 115, 0.15);
            }
            #${Le} .menu-items, #${Le} .menu-items li {
              padding: 0;
            }
            #${Le} .menu-item {
              display: flex;
            }
            #${Le} .menu-item-content {
              display: flex;
              flex-direction: column;
              flex-grow: 1;
            }
          `
						])
					));
			}
			const _ = p.get(),
				S = _ ? [_] : u.get();
			if (
				(S.length &&
					((R.style.position =
						getComputedStyle(S[0].element).position === 'fixed' ? 'fixed' : 'absolute'),
					R.appendChild(
						at(
							'ul',
							{ class: 'element-list' },
							S.map((N) => {
								const V =
										S.length > 1 &&
										!!N.menu?.some((L) =>
											L.some(
												(B) => !B.selectors || B.selectors.some((k) => N.selectors.includes(k))
											)
										),
									H = V
										? {
												class: 'selectable',
												onClick: i(() => p.set(N), 'onClick'),
												onMouseEnter: i(() => d.set(N), 'onMouseEnter'),
												onMouseLeave: i(() => d.set(void 0), 'onMouseLeave')
											}
										: _
											? { class: 'selected', onClick: i(() => p.set(void 0), 'onClick') }
											: {},
									A = V || _;
								return at('li', H, [
									at(A ? 'button' : 'div', A ? { type: 'button' } : {}, [
										_ ? $a('chevronLeft') : null,
										at('code', {}, [N.element.outerHTML]),
										V ? $a('chevronRight') : null
									])
								]);
							})
						)
					)),
				p.get() || u.get().length === 1)
			) {
				const N = p.get() || u.get()[0],
					V = N.menu?.filter((H) =>
						H.some((A) => !A.selectors || A.selectors.some((L) => N.selectors.includes(L)))
					);
				V?.length &&
					R.appendChild(
						at(
							'ul',
							{ class: 'menu-list' },
							V.map((H) =>
								at('li', {}, [
									at(
										'ul',
										{ class: 'menu-items' },
										H.map(
											({
												id: A,
												title: L,
												description: B,
												iconLeft: k,
												iconRight: K,
												clickEvent: X
											}) => {
												const ie = X && (() => e.emit(X, A, Y3(N)));
												return at('li', {}, [
													at(
														ie ? 'button' : 'div',
														ie
															? { class: 'menu-item', type: 'button', onClick: ie }
															: { class: 'menu-item' },
														[
															k ? $a(k) : null,
															at('div', { class: 'menu-item-content' }, [
																at(B ? 'strong' : 'span', {}, [L]),
																B && at('span', {}, [B])
															]),
															K ? $a(K) : null
														]
													)
												]);
											}
										)
									)
								])
							)
						)
					);
			}
			const D = s.get();
			D
				? (Object.assign(R.style, {
						display: 'block',
						left: `${R.style.position === 'fixed' ? D.x - window.scrollX : D.x}px`,
						top: `${R.style.position === 'fixed' ? D.y - window.scrollY : D.y}px`
					}),
					Jv(R),
					requestAnimationFrame(() => W3(R, D, { topOffset: 15, centered: !0 })))
				: (K3(R), Object.assign(R.style, { display: 'none' }));
		}, 'renderMenu');
		(u.subscribe(T), p.subscribe(T));
		const b = i((R) => {
				const _ = H3(R);
				r.set((S) => {
					const D = _.id ? S.filter((N) => N.id !== _.id) : S;
					return _.selectors?.length ? [...D, _] : D;
				});
			}, 'addHighlight'),
			w = i((R) => {
				R && r.set((_) => _.filter((S) => S.id !== R));
			}, 'removeHighlight'),
			P = i(() => {
				(r.set([]),
					n.set(new Map()),
					o.set([]),
					s.set(void 0),
					a.set(void 0),
					u.set([]),
					c.set([]),
					d.set(void 0),
					p.set(void 0));
			}, 'resetState');
		let I;
		const q = i((R, _) => {
				const S = 'scrollIntoView-highlight';
				(clearTimeout(I), w(S));
				const D = t.querySelector(R);
				if (!D) {
					console.warn(`Cannot scroll into view: ${R} not found`);
					return;
				}
				D.scrollIntoView({ behavior: 'smooth', block: 'center', ..._ });
				const N = `kf-${Math.random().toString(36).substring(2, 15)}`;
				(r.set((V) => [
					...V,
					{
						id: S,
						priority: 1e3,
						selectors: [R],
						styles: {
							outline: '2px solid #1EA7FD',
							outlineOffset: '-1px',
							animation: `${N} 3s linear forwards`
						},
						keyframes: `@keyframes ${N} {
          0% { outline: 2px solid #1EA7FD; }
          20% { outline: 2px solid #1EA7FD00; }
          40% { outline: 2px solid #1EA7FD; }
          60% { outline: 2px solid #1EA7FD00; }
          80% { outline: 2px solid #1EA7FD; }
          100% { outline: 2px solid #1EA7FD00; }
        }`
					}
				]),
					(I = setTimeout(() => w(S), 3500)));
			}, 'scrollIntoView'),
			C = i((R) => {
				requestAnimationFrame(() => a.set({ x: R.pageX, y: R.pageY }));
			}, 'onMouseMove');
		(t.body.addEventListener('mousemove', C),
			e.on(B3, b),
			e.on(J3, w),
			e.on($3, P),
			e.on(U3, q),
			e.on(fo, ({ newPhase: R }) => {
				R === 'loading' && P();
			}));
	}, 'useHighlights');
globalThis?.FEATURES?.highlight && ir?.ready && ir.ready().then(Q3);
var Uv = i(() => ({}), 'default'),
	Z3 = 'measureEnabled';
function qg() {
	const e = te.document.documentElement,
		t = Math.max(e.scrollHeight, e.offsetHeight);
	return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
i(qg, 'getDocumentWidthAndHeight');
function eN() {
	const e = te.document.createElement('canvas');
	e.id = 'storybook-addon-measure';
	const t = e.getContext('2d');
	Cr(t != null);
	const { width: r, height: n } = qg();
	return (
		eu(e, t, { width: r, height: n }),
		(e.style.position = 'absolute'),
		(e.style.left = '0'),
		(e.style.top = '0'),
		(e.style.zIndex = '2147483647'),
		(e.style.pointerEvents = 'none'),
		te.document.body.appendChild(e),
		{ canvas: e, context: t, width: r, height: n }
	);
}
i(eN, 'createCanvas');
function eu(e, t, { width: r, height: n }) {
	((e.style.width = `${r}px`), (e.style.height = `${n}px`));
	const o = te.window.devicePixelRatio;
	((e.width = Math.floor(r * o)), (e.height = Math.floor(n * o)), t.scale(o, o));
}
i(eu, 'setCanvasWidthAndHeight');
var lt = {};
function tN() {
	lt.canvas || (lt = eN());
}
i(tN, 'init');
function jg() {
	lt.context && lt.context.clearRect(0, 0, lt.width ?? 0, lt.height ?? 0);
}
i(jg, 'clear');
function rN(e) {
	(jg(), e(lt.context));
}
i(rN, 'draw');
function nN() {
	(Cr(lt.canvas), Cr(lt.context), eu(lt.canvas, lt.context, { width: 0, height: 0 }));
	const { width: e, height: t } = qg();
	(eu(lt.canvas, lt.context, { width: e, height: t }), (lt.width = e), (lt.height = t));
}
i(nN, 'rescale');
function oN() {
	lt.canvas && (jg(), lt.canvas.parentNode?.removeChild(lt.canvas), (lt = {}));
}
i(oN, 'destroy');
var Do = {
		margin: '#f6b26b',
		border: '#ffe599',
		padding: '#93c47d',
		content: '#6fa8dc',
		text: '#232020'
	},
	en = 6;
function yf(e, { x: t, y: r, w: n, h: o, r: s }) {
	((t = t - n / 2),
		(r = r - o / 2),
		n < 2 * s && (s = n / 2),
		o < 2 * s && (s = o / 2),
		e.beginPath(),
		e.moveTo(t + s, r),
		e.arcTo(t + n, r, t + n, r + o, s),
		e.arcTo(t + n, r + o, t, r + o, s),
		e.arcTo(t, r + o, t, r, s),
		e.arcTo(t, r, t + n, r, s),
		e.closePath());
}
i(yf, 'roundedRect');
function iN(e, { padding: t, border: r, width: n, height: o, top: s, left: a }) {
	const u = n - r.left - r.right - t.left - t.right,
		c = o - t.top - t.bottom - r.top - r.bottom;
	let d = a + r.left + t.left,
		p = s + r.top + t.top;
	return (
		e === 'top'
			? (d += u / 2)
			: e === 'right'
				? ((d += u), (p += c / 2))
				: e === 'bottom'
					? ((d += u / 2), (p += c))
					: e === 'left'
						? (p += c / 2)
						: e === 'center' && ((d += u / 2), (p += c / 2)),
		{ x: d, y: p }
	);
}
i(iN, 'positionCoordinate');
function sN(e, t, { margin: r, border: n, padding: o }, s, a) {
	let u = i((m) => 0, 'shift'),
		c = 0,
		d = 0;
	const p = a ? 1 : 0.5,
		f = a ? s * 2 : 0;
	return (
		e === 'padding'
			? (u = i((m) => o[m] * p + f, 'shift'))
			: e === 'border'
				? (u = i((m) => o[m] + n[m] * p + f, 'shift'))
				: e === 'margin' && (u = i((m) => o[m] + n[m] + r[m] * p + f, 'shift')),
		t === 'top'
			? (d = -u('top'))
			: t === 'right'
				? (c = u('right'))
				: t === 'bottom'
					? (d = u('bottom'))
					: t === 'left' && (c = -u('left')),
		{ offsetX: c, offsetY: d }
	);
}
i(sN, 'offset');
function aN(e, t) {
	return (
		Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2
	);
}
i(aN, 'collide');
function lN(e, t, r) {
	return (
		e === 'top'
			? (t.y = r.y - r.h - en)
			: e === 'right'
				? (t.x = r.x + r.w / 2 + en + t.w / 2)
				: e === 'bottom'
					? (t.y = r.y + r.h + en)
					: e === 'left' && (t.x = r.x - r.w / 2 - en - t.w / 2),
		{ x: t.x, y: t.y }
	);
}
i(lN, 'overlapAdjustment');
function Dg(e, t, { x: r, y: n, w: o, h: s }, a) {
	return (
		yf(e, { x: r, y: n, w: o, h: s, r: 3 }),
		(e.fillStyle = `${Do[t]}dd`),
		e.fill(),
		(e.strokeStyle = Do[t]),
		e.stroke(),
		(e.fillStyle = Do.text),
		e.fillText(a, r, n),
		yf(e, { x: r, y: n, w: o, h: s, r: 3 }),
		(e.fillStyle = `${Do[t]}dd`),
		e.fill(),
		(e.strokeStyle = Do[t]),
		e.stroke(),
		(e.fillStyle = Do.text),
		e.fillText(a, r, n),
		{ x: r, y: n, w: o, h: s }
	);
}
i(Dg, 'textWithRect');
function kg(e, t) {
	((e.font = '600 12px monospace'), (e.textBaseline = 'middle'), (e.textAlign = 'center'));
	const r = e.measureText(t),
		n = r.actualBoundingBoxAscent + r.actualBoundingBoxDescent,
		o = r.width + en * 2,
		s = n + en * 2;
	return { w: o, h: s };
}
i(kg, 'configureText');
function uN(e, t, { type: r, position: n = 'center', text: o }, s, a = !1) {
	let { x: u, y: c } = iN(n, t);
	const { offsetX: d, offsetY: p } = sN(r, n, t, en + 1, a);
	((u += d), (c += p));
	const { w: f, h: m } = kg(e, o);
	if (s && aN({ x: u, y: c, w: f, h: m }, s)) {
		const y = lN(n, { x: u, y: c, w: f }, s);
		((u = y.x), (c = y.y));
	}
	return Dg(e, r, { x: u, y: c, w: f, h: m }, o);
}
i(uN, 'drawLabel');
function cN(e, { w: t, h: r }) {
	const n = t * 0.5 + en,
		o = r * 0.5 + en;
	return { offsetX: (e.x === 'left' ? -1 : 1) * n, offsetY: (e.y === 'top' ? -1 : 1) * o };
}
i(cN, 'floatingOffset');
function dN(e, t, { type: r, text: n }) {
	const { floatingAlignment: o, extremities: s } = t;
	let a = s[o.x],
		u = s[o.y];
	const { w: c, h: d } = kg(e, n),
		{ offsetX: p, offsetY: f } = cN(o, { w: c, h: d });
	return ((a += p), (u += f), Dg(e, r, { x: a, y: u, w: c, h: d }, n));
}
i(dN, 'drawFloatingLabel');
function Jo(e, t, r, n) {
	const o = [];
	r.forEach((s, a) => {
		const u = n && s.position === 'center' ? dN(e, t, s) : uN(e, t, s, o[a - 1], n);
		o[a] = u;
	});
}
i(Jo, 'drawStack');
function pN(e, t, r, n) {
	const o = r.reduce(
		(s, a) => (
			Object.prototype.hasOwnProperty.call(s, a.position) || (s[a.position] = []),
			s[a.position]?.push(a),
			s
		),
		{}
	);
	(o.top && Jo(e, t, o.top, n),
		o.right && Jo(e, t, o.right, n),
		o.bottom && Jo(e, t, o.bottom, n),
		o.left && Jo(e, t, o.left, n),
		o.center && Jo(e, t, o.center, n));
}
i(pN, 'labelStacks');
var Oc = { margin: '#f6b26ba8', border: '#ffe599a8', padding: '#93c47d8c', content: '#6fa8dca8' },
	Vv = 30;
function Jt(e) {
	return parseInt(e.replace('px', ''), 10);
}
i(Jt, 'pxToNumber');
function eo(e) {
	return Number.isInteger(e) ? e : e.toFixed(2);
}
i(eo, 'round');
function Cc(e) {
	return e.filter((t) => t.text !== 0 && t.text !== '0');
}
i(Cc, 'filterZeroValues');
function fN(e) {
	const t = {
			top: te.window.scrollY,
			bottom: te.window.scrollY + te.window.innerHeight,
			left: te.window.scrollX,
			right: te.window.scrollX + te.window.innerWidth
		},
		r = {
			top: Math.abs(t.top - e.top),
			bottom: Math.abs(t.bottom - e.bottom),
			left: Math.abs(t.left - e.left),
			right: Math.abs(t.right - e.right)
		};
	return { x: r.left > r.right ? 'left' : 'right', y: r.top > r.bottom ? 'top' : 'bottom' };
}
i(fN, 'floatingAlignment');
function mN(e) {
	const t = te.getComputedStyle(e);
	let { top: r, left: n, right: o, bottom: s, width: a, height: u } = e.getBoundingClientRect();
	const {
		marginTop: c,
		marginBottom: d,
		marginLeft: p,
		marginRight: f,
		paddingTop: m,
		paddingBottom: y,
		paddingLeft: g,
		paddingRight: E,
		borderBottomWidth: T,
		borderTopWidth: b,
		borderLeftWidth: w,
		borderRightWidth: P
	} = t;
	((r = r + te.window.scrollY),
		(n = n + te.window.scrollX),
		(s = s + te.window.scrollY),
		(o = o + te.window.scrollX));
	const I = { top: Jt(c), bottom: Jt(d), left: Jt(p), right: Jt(f) },
		q = { top: Jt(m), bottom: Jt(y), left: Jt(g), right: Jt(E) },
		C = { top: Jt(b), bottom: Jt(T), left: Jt(w), right: Jt(P) },
		R = { top: r - I.top, bottom: s + I.bottom, left: n - I.left, right: o + I.right };
	return {
		margin: I,
		padding: q,
		border: C,
		top: r,
		left: n,
		bottom: s,
		right: o,
		width: a,
		height: u,
		extremities: R,
		floatingAlignment: fN(R)
	};
}
i(mN, 'measureElement');
function hN(e, { margin: t, width: r, height: n, top: o, left: s, bottom: a, right: u }) {
	const c = n + t.bottom + t.top;
	((e.fillStyle = Oc.margin),
		e.fillRect(s, o - t.top, r, t.top),
		e.fillRect(u, o - t.top, t.right, c),
		e.fillRect(s, a, r, t.bottom),
		e.fillRect(s - t.left, o - t.top, t.left, c));
	const d = [
		{ type: 'margin', text: eo(t.top), position: 'top' },
		{ type: 'margin', text: eo(t.right), position: 'right' },
		{ type: 'margin', text: eo(t.bottom), position: 'bottom' },
		{ type: 'margin', text: eo(t.left), position: 'left' }
	];
	return Cc(d);
}
i(hN, 'drawMargin');
function yN(
	e,
	{ padding: t, border: r, width: n, height: o, top: s, left: a, bottom: u, right: c }
) {
	const d = n - r.left - r.right,
		p = o - t.top - t.bottom - r.top - r.bottom;
	((e.fillStyle = Oc.padding),
		e.fillRect(a + r.left, s + r.top, d, t.top),
		e.fillRect(c - t.right - r.right, s + t.top + r.top, t.right, p),
		e.fillRect(a + r.left, u - t.bottom - r.bottom, d, t.bottom),
		e.fillRect(a + r.left, s + t.top + r.top, t.left, p));
	const f = [
		{ type: 'padding', text: t.top, position: 'top' },
		{ type: 'padding', text: t.right, position: 'right' },
		{ type: 'padding', text: t.bottom, position: 'bottom' },
		{ type: 'padding', text: t.left, position: 'left' }
	];
	return Cc(f);
}
i(yN, 'drawPadding');
function gN(e, { border: t, width: r, height: n, top: o, left: s, bottom: a, right: u }) {
	const c = n - t.top - t.bottom;
	((e.fillStyle = Oc.border),
		e.fillRect(s, o, r, t.top),
		e.fillRect(s, a - t.bottom, r, t.bottom),
		e.fillRect(s, o + t.top, t.left, c),
		e.fillRect(u - t.right, o + t.top, t.right, c));
	const d = [
		{ type: 'border', text: t.top, position: 'top' },
		{ type: 'border', text: t.right, position: 'right' },
		{ type: 'border', text: t.bottom, position: 'bottom' },
		{ type: 'border', text: t.left, position: 'left' }
	];
	return Cc(d);
}
i(gN, 'drawBorder');
function bN(e, { padding: t, border: r, width: n, height: o, top: s, left: a }) {
	const u = n - r.left - r.right - t.left - t.right,
		c = o - t.top - t.bottom - r.top - r.bottom;
	return (
		(e.fillStyle = Oc.content),
		e.fillRect(a + r.left + t.left, s + r.top + t.top, u, c),
		[{ type: 'content', position: 'center', text: `${eo(u)} x ${eo(c)}` }]
	);
}
i(bN, 'drawContent');
function vN(e) {
	return (t) => {
		if (e && t) {
			const r = mN(e),
				n = hN(t, r),
				o = yN(t, r),
				s = gN(t, r),
				a = bN(t, r),
				u = r.width <= Vv * 3 || r.height <= Vv;
			pN(t, r, [...a, ...o, ...s, ...n], u);
		}
	};
}
i(vN, 'drawBoxModel');
function EN(e) {
	rN(vN(e));
}
i(EN, 'drawSelectedElement');
var eG = i((e, t) => {
		const r = te.document.elementFromPoint(e, t),
			n = i((s) => {
				if (s && s.shadowRoot) {
					const a = s.shadowRoot.elementFromPoint(e, t);
					return s.isEqualNode(a) ? s : a.shadowRoot ? n(a) : a;
				}
				return s;
			}, 'crawlShadows');
		return n(r) || r;
	}, 'deepElementFromPoint'),
	Hv,
	Va = { x: 0, y: 0 };
function gf(e, t) {
	((Hv = eG(e, t)), EN(Hv));
}
i(gf, 'findAndDrawElement');
var tG = i((e, t) => {
		const { measureEnabled: r } = t.globals || {};
		return (
			In(() => {
				if (typeof globalThis.document > 'u') return;
				const n = i((o) => {
					window.requestAnimationFrame(() => {
						(o.stopPropagation(), (Va.x = o.clientX), (Va.y = o.clientY));
					});
				}, 'onPointerMove');
				return (
					globalThis.document.addEventListener('pointermove', n),
					() => {
						globalThis.document.removeEventListener('pointermove', n);
					}
				);
			}, []),
			In(() => {
				const n = i((s) => {
						window.requestAnimationFrame(() => {
							(s.stopPropagation(), gf(s.clientX, s.clientY));
						});
					}, 'onPointerOver'),
					o = i(() => {
						window.requestAnimationFrame(() => {
							nN();
						});
					}, 'onResize');
				return (
					t.viewMode === 'story' &&
						r &&
						(globalThis.document.addEventListener('pointerover', n),
						tN(),
						globalThis.window.addEventListener('resize', o),
						gf(Va.x, Va.y)),
					() => {
						(globalThis.window.removeEventListener('resize', o), oN());
					}
				);
			}, [r, t.viewMode]),
			e()
		);
	}, 'withMeasure'),
	rG = globalThis.FEATURES?.measure ? [tG] : [],
	nG = { [Z3]: !1 },
	Gv = i(() => ({ decorators: rG, initialGlobals: nG }), 'default'),
	TN = 'outline',
	zv = i((e) => {
		(Array.isArray(e) ? e : [e]).forEach(oG);
	}, 'clearStyles'),
	oG = i((e) => {
		const t = typeof e == 'string' ? e : e.join(''),
			r = te.document.getElementById(t);
		r && r.parentElement && r.parentElement.removeChild(r);
	}, 'clearStyle'),
	iG = i((e, t) => {
		const r = te.document.getElementById(e);
		if (r) r.innerHTML !== t && (r.innerHTML = t);
		else {
			const n = te.document.createElement('style');
			(n.setAttribute('id', e), (n.innerHTML = t), te.document.head.appendChild(n));
		}
	}, 'addOutlineStyles');
function _N(e) {
	return Ee`
    ${e} body {
      outline: 1px solid #2980b9 !important;
    }

    ${e} article {
      outline: 1px solid #3498db !important;
    }

    ${e} nav {
      outline: 1px solid #0088c3 !important;
    }

    ${e} aside {
      outline: 1px solid #33a0ce !important;
    }

    ${e} section {
      outline: 1px solid #66b8da !important;
    }

    ${e} header {
      outline: 1px solid #99cfe7 !important;
    }

    ${e} footer {
      outline: 1px solid #cce7f3 !important;
    }

    ${e} h1 {
      outline: 1px solid #162544 !important;
    }

    ${e} h2 {
      outline: 1px solid #314e6e !important;
    }

    ${e} h3 {
      outline: 1px solid #3e5e85 !important;
    }

    ${e} h4 {
      outline: 1px solid #449baf !important;
    }

    ${e} h5 {
      outline: 1px solid #c7d1cb !important;
    }

    ${e} h6 {
      outline: 1px solid #4371d0 !important;
    }

    ${e} main {
      outline: 1px solid #2f4f90 !important;
    }

    ${e} address {
      outline: 1px solid #1a2c51 !important;
    }

    ${e} div {
      outline: 1px solid #036cdb !important;
    }

    ${e} p {
      outline: 1px solid #ac050b !important;
    }

    ${e} hr {
      outline: 1px solid #ff063f !important;
    }

    ${e} pre {
      outline: 1px solid #850440 !important;
    }

    ${e} blockquote {
      outline: 1px solid #f1b8e7 !important;
    }

    ${e} ol {
      outline: 1px solid #ff050c !important;
    }

    ${e} ul {
      outline: 1px solid #d90416 !important;
    }

    ${e} li {
      outline: 1px solid #d90416 !important;
    }

    ${e} dl {
      outline: 1px solid #fd3427 !important;
    }

    ${e} dt {
      outline: 1px solid #ff0043 !important;
    }

    ${e} dd {
      outline: 1px solid #e80174 !important;
    }

    ${e} figure {
      outline: 1px solid #ff00bb !important;
    }

    ${e} figcaption {
      outline: 1px solid #bf0032 !important;
    }

    ${e} table {
      outline: 1px solid #00cc99 !important;
    }

    ${e} caption {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} thead {
      outline: 1px solid #98daca !important;
    }

    ${e} tbody {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} tfoot {
      outline: 1px solid #22746b !important;
    }

    ${e} tr {
      outline: 1px solid #86c0b2 !important;
    }

    ${e} th {
      outline: 1px solid #a1e7d6 !important;
    }

    ${e} td {
      outline: 1px solid #3f5a54 !important;
    }

    ${e} col {
      outline: 1px solid #6c9a8f !important;
    }

    ${e} colgroup {
      outline: 1px solid #6c9a9d !important;
    }

    ${e} button {
      outline: 1px solid #da8301 !important;
    }

    ${e} datalist {
      outline: 1px solid #c06000 !important;
    }

    ${e} fieldset {
      outline: 1px solid #d95100 !important;
    }

    ${e} form {
      outline: 1px solid #d23600 !important;
    }

    ${e} input {
      outline: 1px solid #fca600 !important;
    }

    ${e} keygen {
      outline: 1px solid #b31e00 !important;
    }

    ${e} label {
      outline: 1px solid #ee8900 !important;
    }

    ${e} legend {
      outline: 1px solid #de6d00 !important;
    }

    ${e} meter {
      outline: 1px solid #e8630c !important;
    }

    ${e} optgroup {
      outline: 1px solid #b33600 !important;
    }

    ${e} option {
      outline: 1px solid #ff8a00 !important;
    }

    ${e} output {
      outline: 1px solid #ff9619 !important;
    }

    ${e} progress {
      outline: 1px solid #e57c00 !important;
    }

    ${e} select {
      outline: 1px solid #e26e0f !important;
    }

    ${e} textarea {
      outline: 1px solid #cc5400 !important;
    }

    ${e} details {
      outline: 1px solid #33848f !important;
    }

    ${e} summary {
      outline: 1px solid #60a1a6 !important;
    }

    ${e} command {
      outline: 1px solid #438da1 !important;
    }

    ${e} menu {
      outline: 1px solid #449da6 !important;
    }

    ${e} del {
      outline: 1px solid #bf0000 !important;
    }

    ${e} ins {
      outline: 1px solid #400000 !important;
    }

    ${e} img {
      outline: 1px solid #22746b !important;
    }

    ${e} iframe {
      outline: 1px solid #64a7a0 !important;
    }

    ${e} embed {
      outline: 1px solid #98daca !important;
    }

    ${e} object {
      outline: 1px solid #00cc99 !important;
    }

    ${e} param {
      outline: 1px solid #37ffc4 !important;
    }

    ${e} video {
      outline: 1px solid #6ee866 !important;
    }

    ${e} audio {
      outline: 1px solid #027353 !important;
    }

    ${e} source {
      outline: 1px solid #012426 !important;
    }

    ${e} canvas {
      outline: 1px solid #a2f570 !important;
    }

    ${e} track {
      outline: 1px solid #59a600 !important;
    }

    ${e} map {
      outline: 1px solid #7be500 !important;
    }

    ${e} area {
      outline: 1px solid #305900 !important;
    }

    ${e} a {
      outline: 1px solid #ff62ab !important;
    }

    ${e} em {
      outline: 1px solid #800b41 !important;
    }

    ${e} strong {
      outline: 1px solid #ff1583 !important;
    }

    ${e} i {
      outline: 1px solid #803156 !important;
    }

    ${e} b {
      outline: 1px solid #cc1169 !important;
    }

    ${e} u {
      outline: 1px solid #ff0430 !important;
    }

    ${e} s {
      outline: 1px solid #f805e3 !important;
    }

    ${e} small {
      outline: 1px solid #d107b2 !important;
    }

    ${e} abbr {
      outline: 1px solid #4a0263 !important;
    }

    ${e} q {
      outline: 1px solid #240018 !important;
    }

    ${e} cite {
      outline: 1px solid #64003c !important;
    }

    ${e} dfn {
      outline: 1px solid #b4005a !important;
    }

    ${e} sub {
      outline: 1px solid #dba0c8 !important;
    }

    ${e} sup {
      outline: 1px solid #cc0256 !important;
    }

    ${e} time {
      outline: 1px solid #d6606d !important;
    }

    ${e} code {
      outline: 1px solid #e04251 !important;
    }

    ${e} kbd {
      outline: 1px solid #5e001f !important;
    }

    ${e} samp {
      outline: 1px solid #9c0033 !important;
    }

    ${e} var {
      outline: 1px solid #d90047 !important;
    }

    ${e} mark {
      outline: 1px solid #ff0053 !important;
    }

    ${e} bdi {
      outline: 1px solid #bf3668 !important;
    }

    ${e} bdo {
      outline: 1px solid #6f1400 !important;
    }

    ${e} ruby {
      outline: 1px solid #ff7b93 !important;
    }

    ${e} rt {
      outline: 1px solid #ff2f54 !important;
    }

    ${e} rp {
      outline: 1px solid #803e49 !important;
    }

    ${e} span {
      outline: 1px solid #cc2643 !important;
    }

    ${e} br {
      outline: 1px solid #db687d !important;
    }

    ${e} wbr {
      outline: 1px solid #db175b !important;
    }`;
}
i(_N, 'outlineCSS');
var sG = i((e, t) => {
		const r = t.globals || {},
			n = [!0, 'true'].includes(r[TN]),
			o = t.viewMode === 'docs',
			s = bm(() => _N(o ? '[data-story-block="true"]' : '.sb-show-main'), [t]);
		return (
			In(() => {
				const a = o ? `addon-outline-docs-${t.id}` : 'addon-outline';
				return (
					n ? iG(a, s) : zv(a),
					() => {
						zv(a);
					}
				);
			}, [n, s, t]),
			e()
		);
	}, 'withOutline'),
	aG = globalThis.FEATURES?.outline ? [sG] : [],
	lG = { [TN]: !1 },
	Wv = i(() => ({ decorators: aG, initialGlobals: lG }), 'default'),
	uG = i(({ parameters: e }) => {
		e?.test?.mockReset === !0
			? qy()
			: e?.test?.clearMocks === !0
				? My()
				: e?.test?.restoreMocks !== !1 && jy();
	}, 'resetAllMocksLoader'),
	bf = i((e, t = 0, r) => {
		if (t > 5 || e == null) return e;
		if (so(e)) return (r && e.mockName(r), e);
		if (
			typeof e == 'function' &&
			'isAction' in e &&
			e.isAction &&
			!('implicit' in e && e.implicit)
		) {
			const n = Iy(e);
			return (r && n.mockName(r), n);
		}
		if (Array.isArray(e)) {
			t++;
			for (let n = 0; n < e.length; n++)
				Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = bf(e[n], t));
			return e;
		}
		if (typeof e == 'object' && e.constructor === Object) {
			t++;
			for (const [n, o] of Object.entries(e))
				Object.getOwnPropertyDescriptor(e, n)?.writable && (e[n] = bf(o, t, n));
			return e;
		}
		return e;
	}, 'traverseArgs'),
	cG = i(({ initialArgs: e }) => {
		bf(e);
	}, 'nameSpiesAndWrapActionsInSpies'),
	Kv = !1,
	dG = i(async (e) => {
		globalThis.HTMLElement &&
			e.canvasElement instanceof globalThis.HTMLElement &&
			(e.canvas = QI(e.canvasElement));
		const t = globalThis.window?.navigator?.clipboard;
		if (
			t &&
			((e.userEvent = Oi(
				{ userEvent: ZI.setup() },
				{
					intercept: !0,
					getKeys: i((r) => Object.keys(r).filter((n) => n !== 'eventWrapper'), 'getKeys')
				}
			).userEvent),
			Object.defineProperty(globalThis.window.navigator, 'clipboard', {
				get: i(() => t, 'get'),
				configurable: !0
			}),
			!Kv)
		) {
			const r = HTMLElement.prototype.focus;
			let n = HTMLElement.prototype.focus;
			const o = new Set();
			(Object.defineProperties(HTMLElement.prototype, {
				focus: {
					configurable: !0,
					set: i((s) => {
						n = s;
					}, 'set'),
					get() {
						return o.has(this) ? r : (o.add(this), setTimeout(() => o.delete(this), 0), n);
					}
				}
			}),
				(Kv = !0));
		}
	}, 'enhanceContext'),
	Yv = i(() => ({ loaders: [uG, cG, dG] }), 'default'),
	pG = 'viewport',
	fG = { [pG]: { value: void 0, isRotated: !1 } },
	Xv = i(() => ({ initialGlobals: fG }), 'default');
function Lg() {
	return [
		(Gv.default ?? Gv)(),
		(qv.default ?? qv)(),
		(Uv.default ?? Uv)(),
		(Wv.default ?? Wv)(),
		(Xv.default ?? Xv)(),
		(xv.default ?? xv)(),
		(jv.default ?? jv)(),
		(Yv.default ?? Yv)()
	];
}
i(Lg, 'getCoreAnnotations');
function mG(e) {
	return e;
}
i(mG, 'definePreviewAddon');
function wN(e) {
	return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Meta';
}
i(wN, 'isMeta');
function xc(e) {
	return e != null && typeof e == 'object' && '_tag' in e && e?._tag === 'Story';
}
i(xc, 'isStory');
function SN(e) {
	return '__children' in e ? e.__children : [];
}
i(SN, 'getStoryChildren');
var RN = i(
		(e) =>
			e
				.toLowerCase()
				.replace(/[ '`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '-')
				.replace(/-+/g, '-')
				.replace(/^-+/, '')
				.replace(/-+$/, ''),
		'sanitize'
	),
	vf = i((e, t) => {
		const r = RN(e);
		if (r === '') throw new Error(`Invalid ${t} '${e}', must include alphanumeric characters`);
		return r;
	}, 'sanitizeSafe'),
	hG = i((e, t) => `${vf(e, 'kind')}${t ? `--${vf(t, 'name')}` : ''}`, 'toId'),
	yG = i((e, t) => `${e}:${vf(t, 'test')}`, 'toTestId'),
	gG = i((e) => qw(e), 'storyNameFromExport');
function Ef(e, t) {
	return Array.isArray(t) ? t.includes(e) : e.match(t);
}
i(Ef, 'matches');
function tu(e, { includeStories: t, excludeStories: r }) {
	return e !== '__esModule' && (!t || Ef(e, t)) && (!r || !Ef(e, r));
}
i(tu, 'isExportStory');
var bG = i((...e) => {
	const t = e.reduce((r, n) => (n.startsWith('!') ? r.delete(n.slice(1)) : r.add(n), r), new Set());
	return Array.from(t);
}, 'combineTags');
function Tf(e) {
	return Object.getOwnPropertySymbols(e).filter((t) =>
		Object.prototype.propertyIsEnumerable.call(e, t)
	);
}
i(Tf, 'getSymbols');
function _f(e) {
	return e == null
		? e === void 0
			? '[object Undefined]'
			: '[object Null]'
		: Object.prototype.toString.call(e);
}
i(_f, 'getTag');
var vG = '[object RegExp]',
	EG = '[object String]',
	TG = '[object Number]',
	_G = '[object Boolean]',
	Qv = '[object Arguments]',
	wG = '[object Symbol]',
	SG = '[object Date]',
	RG = '[object Map]',
	PG = '[object Set]',
	AG = '[object Array]',
	OG = '[object Function]',
	CG = '[object ArrayBuffer]',
	Td = '[object Object]',
	xG = '[object Error]',
	IG = '[object DataView]',
	NG = '[object Uint8Array]',
	MG = '[object Uint8ClampedArray]',
	qG = '[object Uint16Array]',
	jG = '[object Uint32Array]',
	DG = '[object BigUint64Array]',
	kG = '[object Int8Array]',
	LG = '[object Int16Array]',
	FG = '[object Int32Array]',
	BG = '[object BigInt64Array]',
	JG = '[object Float32Array]',
	$G = '[object Float64Array]';
function hr(e) {
	if (!e || typeof e != 'object') return !1;
	const t = Object.getPrototypeOf(e);
	return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
		? Object.prototype.toString.call(e) === '[object Object]'
		: !1;
}
i(hr, 'isPlainObject');
function Ti(e, t) {
	const r = {},
		n = Object.keys(e);
	for (let o = 0; o < n.length; o++) {
		const s = n[o],
			a = e[s];
		r[s] = t(a, s, e);
	}
	return r;
}
i(Ti, 'mapValues');
function PN(e, t) {
	const r = {},
		n = Object.keys(e);
	for (let o = 0; o < n.length; o++) {
		const s = n[o],
			a = e[s];
		t(a, s) && (r[s] = a);
	}
	return r;
}
i(PN, 'pickBy');
var _d = et($E(), 1);
function AN(e, t) {
	return e === t || (Number.isNaN(e) && Number.isNaN(t));
}
i(AN, 'eq');
function ON(e, t, r) {
	return zo(e, t, void 0, void 0, void 0, void 0, r);
}
i(ON, 'isEqualWith');
function zo(e, t, r, n, o, s, a) {
	const u = a(e, t, r, n, o, s);
	if (u !== void 0) return u;
	if (typeof e == typeof t)
		switch (typeof e) {
			case 'bigint':
			case 'string':
			case 'boolean':
			case 'symbol':
			case 'undefined':
				return e === t;
			case 'number':
				return e === t || Object.is(e, t);
			case 'function':
				return e === t;
			case 'object':
				return ri(e, t, s, a);
		}
	return ri(e, t, s, a);
}
i(zo, 'isEqualWithImpl');
function ri(e, t, r, n) {
	if (Object.is(e, t)) return !0;
	let o = _f(e),
		s = _f(t);
	if ((o === Qv && (o = Td), s === Qv && (s = Td), o !== s)) return !1;
	switch (o) {
		case EG:
			return e.toString() === t.toString();
		case TG: {
			const c = e.valueOf(),
				d = t.valueOf();
			return AN(c, d);
		}
		case _G:
		case SG:
		case wG:
			return Object.is(e.valueOf(), t.valueOf());
		case vG:
			return e.source === t.source && e.flags === t.flags;
		case OG:
			return e === t;
	}
	r = r ?? new Map();
	const a = r.get(e),
		u = r.get(t);
	if (a != null && u != null) return a === t;
	(r.set(e, t), r.set(t, e));
	try {
		switch (o) {
			case RG: {
				if (e.size !== t.size) return !1;
				for (const [c, d] of e.entries())
					if (!t.has(c) || !zo(d, t.get(c), c, e, t, r, n)) return !1;
				return !0;
			}
			case PG: {
				if (e.size !== t.size) return !1;
				const c = Array.from(e.values()),
					d = Array.from(t.values());
				for (let p = 0; p < c.length; p++) {
					const f = c[p],
						m = d.findIndex((y) => zo(f, y, void 0, e, t, r, n));
					if (m === -1) return !1;
					d.splice(m, 1);
				}
				return !0;
			}
			case AG:
			case NG:
			case MG:
			case qG:
			case jG:
			case DG:
			case kG:
			case LG:
			case FG:
			case BG:
			case JG:
			case $G: {
				if (
					(typeof Buffer < 'u' && Buffer.isBuffer(e) !== Buffer.isBuffer(t)) ||
					e.length !== t.length
				)
					return !1;
				for (let c = 0; c < e.length; c++) if (!zo(e[c], t[c], c, e, t, r, n)) return !1;
				return !0;
			}
			case CG:
				return e.byteLength !== t.byteLength ? !1 : ri(new Uint8Array(e), new Uint8Array(t), r, n);
			case IG:
				return e.byteLength !== t.byteLength || e.byteOffset !== t.byteOffset
					? !1
					: ri(new Uint8Array(e), new Uint8Array(t), r, n);
			case xG:
				return e.name === t.name && e.message === t.message;
			case Td: {
				if (!(ri(e.constructor, t.constructor, r, n) || (hr(e) && hr(t)))) return !1;
				const d = [...Object.keys(e), ...Tf(e)],
					p = [...Object.keys(t), ...Tf(t)];
				if (d.length !== p.length) return !1;
				for (let f = 0; f < d.length; f++) {
					const m = d[f],
						y = e[m];
					if (!Object.hasOwn(t, m)) return !1;
					const g = t[m];
					if (!zo(y, g, m, e, t, r, n)) return !1;
				}
				return !0;
			}
			default:
				return !1;
		}
	} finally {
		(r.delete(e), r.delete(t));
	}
}
i(ri, 'areObjectsEqual');
function CN() {}
i(CN, 'noop');
function xN(e, t) {
	return ON(e, t, CN);
}
i(xN, 'isEqual');
var Yn = Symbol('incompatible'),
	wf = i((e, t) => {
		const r = t.type;
		if (e == null || !r || t.mapping) return e;
		switch (r.name) {
			case 'string':
				return String(e);
			case 'enum':
				return e;
			case 'number':
				return Number(e);
			case 'boolean':
				return String(e) === 'true';
			case 'array':
				return !r.value || !Array.isArray(e)
					? Yn
					: e.reduce((n, o, s) => {
							const a = wf(o, { type: r.value });
							return (a !== Yn && (n[s] = a), n);
						}, new Array(e.length));
			case 'object':
				return typeof e == 'string' || typeof e == 'number'
					? e
					: !r.value || typeof e != 'object'
						? Yn
						: Object.entries(e).reduce((n, [o, s]) => {
								const a = wf(s, { type: r.value[o] });
								return a === Yn ? n : Object.assign(n, { [o]: a });
							}, {});
			case 'other': {
				const n = typeof e == 'string' || typeof e == 'number' || typeof e == 'boolean';
				return r.value === 'ReactNode' && n ? e : Yn;
			}
			default:
				return Yn;
		}
	}, 'map'),
	UG = i(
		(e, t) =>
			Object.entries(e).reduce((r, [n, o]) => {
				if (!t[n]) return r;
				const s = wf(o, t[n]);
				return s === Yn ? r : Object.assign(r, { [n]: s });
			}, {}),
		'mapArgsToTypes'
	),
	ru = i(
		(e, t) =>
			Array.isArray(e) && Array.isArray(t)
				? t.reduce((r, n, o) => ((r[o] = ru(e[o], t[o])), r), [...e]).filter((r) => r !== void 0)
				: !hr(e) || !hr(t)
					? t
					: Object.keys({ ...e, ...t }).reduce((r, n) => {
							if (n in t) {
								const o = ru(e[n], t[n]);
								o !== void 0 && (r[n] = o);
							} else r[n] = e[n];
							return r;
						}, {}),
		'combineArgs'
	),
	VG = i(
		(e, t) =>
			Object.entries(t).reduce((r, [n, { options: o }]) => {
				function s() {
					return (n in e && (r[n] = e[n]), r);
				}
				if ((i(s, 'allowArg'), !o)) return s();
				if (!Array.isArray(o))
					return (
						Ye.error(Ee`
        Invalid argType: '${n}.options' should be an array.

        More info: https://storybook.js.org/docs/api/arg-types?ref=error
      `),
						s()
					);
				if (o.some((f) => f && ['object', 'function'].includes(typeof f)))
					return (
						Ye.error(Ee`
        Invalid argType: '${n}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/writing-stories/args?ref=error#mapping-to-complex-arg-values
      `),
						s()
					);
				const a = Array.isArray(e[n]),
					u = a && e[n].findIndex((f) => !o.includes(f)),
					c = a && u === -1;
				if (e[n] === void 0 || o.includes(e[n]) || c) return s();
				const d = a ? `${n}[${u}]` : n,
					p = o.map((f) => (typeof f == 'string' ? `'${f}'` : String(f))).join(', ');
				return (Ye.warn(`Received illegal value for '${d}'. Supported options: ${p}`), r);
			}, {}),
		'validateOptions'
	),
	ks = Symbol('Deeply equal'),
	nu = i((e, t) => {
		if (typeof e != typeof t) return t;
		if (xN(e, t)) return ks;
		if (Array.isArray(e) && Array.isArray(t)) {
			const r = t.reduce((n, o, s) => {
				const a = nu(e[s], o);
				return (a !== ks && (n[s] = a), n);
			}, new Array(t.length));
			return t.length >= e.length ? r : r.concat(new Array(e.length - t.length).fill(void 0));
		}
		return hr(e) && hr(t)
			? Object.keys({ ...e, ...t }).reduce((r, n) => {
					const o = nu(e?.[n], t?.[n]);
					return o === ks ? r : Object.assign(r, { [n]: o });
				}, {})
			: t;
	}, 'deepDiff'),
	IN = 'UNTARGETED';
function NN({ args: e, argTypes: t }) {
	const r = {};
	return (
		Object.entries(e).forEach(([n, o]) => {
			const { target: s = IN } = t[n] || {};
			((r[s] = r[s] || {}), (r[s][n] = o));
		}),
		r
	);
}
i(NN, 'groupArgsByTarget');
function MN(e) {
	return (Object.keys(e).forEach((t) => e[t] === void 0 && delete e[t]), e);
}
i(MN, 'deleteUndefined');
var qN = class {
	constructor() {
		((this.initialArgsByStoryId = {}), (this.argsByStoryId = {}));
	}
	get(t) {
		if (!(t in this.argsByStoryId))
			throw new Error(`No args known for ${t} -- has it been rendered yet?`);
		return this.argsByStoryId[t];
	}
	setInitial(t) {
		if (!this.initialArgsByStoryId[t.id])
			((this.initialArgsByStoryId[t.id] = t.initialArgs),
				(this.argsByStoryId[t.id] = t.initialArgs));
		else if (this.initialArgsByStoryId[t.id] !== t.initialArgs) {
			const r = nu(this.initialArgsByStoryId[t.id], this.argsByStoryId[t.id]);
			((this.initialArgsByStoryId[t.id] = t.initialArgs),
				(this.argsByStoryId[t.id] = t.initialArgs),
				r !== ks && this.updateFromDelta(t, r));
		}
	}
	updateFromDelta(t, r) {
		const n = VG(r, t.argTypes);
		this.argsByStoryId[t.id] = ru(this.argsByStoryId[t.id], n);
	}
	updateFromPersisted(t, r) {
		const n = UG(r, t.argTypes);
		return this.updateFromDelta(t, n);
	}
	update(t, r) {
		if (!(t in this.argsByStoryId))
			throw new Error(`No args known for ${t} -- has it been rendered yet?`);
		this.argsByStoryId[t] = MN({ ...this.argsByStoryId[t], ...r });
	}
};
i(qN, 'ArgsStore');
var HG = qN,
	jN = i(
		(e = {}) =>
			Object.entries(e).reduce(
				(t, [r, { defaultValue: n }]) => (typeof n < 'u' && (t[r] = n), t),
				{}
			),
		'getValuesFromArgTypes'
	),
	DN = class {
		constructor({ globals: t = {}, globalTypes: r = {} }) {
			this.set({ globals: t, globalTypes: r });
		}
		set({ globals: t = {}, globalTypes: r = {} }) {
			const n = this.initialGlobals && nu(this.initialGlobals, this.globals);
			this.allowedGlobalNames = new Set([...Object.keys(t), ...Object.keys(r)]);
			const o = jN(r);
			((this.initialGlobals = { ...o, ...t }),
				(this.globals = this.initialGlobals),
				n && n !== ks && this.updateFromPersisted(n));
		}
		filterAllowedGlobals(t) {
			return Object.entries(t).reduce(
				(r, [n, o]) => (
					this.allowedGlobalNames.has(n)
						? (r[n] = o)
						: Je.warn(
								`Attempted to set a global (${n}) that is not defined in initial globals or globalTypes`
							),
					r
				),
				{}
			);
		}
		updateFromPersisted(t) {
			const r = this.filterAllowedGlobals(t);
			this.globals = { ...this.globals, ...r };
		}
		get() {
			return this.globals;
		}
		update(t) {
			this.globals = { ...this.globals, ...this.filterAllowedGlobals(t) };
			for (const r in t) t[r] === void 0 && (this.globals[r] = this.initialGlobals[r]);
		}
	};
i(DN, 'GlobalsStore');
var GG = DN,
	zG = et($E(), 1),
	WG = (0, zG.default)(1)((e) =>
		Object.values(e).reduce((t, r) => ((t[r.importPath] = t[r.importPath] || r), t), {})
	),
	kN = class {
		constructor({ entries: t } = { v: 5, entries: {} }) {
			this.entries = t;
		}
		entryFromSpecifier(t) {
			const r = Object.values(this.entries);
			if (t === '*') return r[0];
			if (typeof t == 'string')
				return this.entries[t] ? this.entries[t] : r.find((s) => s.id.startsWith(t));
			const { name: n, title: o } = t;
			return r.find((s) => s.name === n && s.title === o);
		}
		storyIdToEntry(t) {
			const r = this.entries[t];
			if (!r) throw new B_({ storyId: t });
			return r;
		}
		importPathToEntry(t) {
			return WG(this.entries)[t];
		}
	};
i(kN, 'StoryIndexStore');
var KG = kN,
	YG = i((e) => (typeof e == 'string' ? { name: e } : e), 'normalizeType'),
	XG = i((e) => (typeof e == 'string' ? { type: e } : e), 'normalizeControl'),
	QG = i((e, t) => {
		const { type: r, control: n, ...o } = e,
			s = { name: t, ...o };
		return (
			r && (s.type = YG(r)),
			n ? (s.control = XG(n)) : n === !1 && (s.control = { disable: !0 }),
			s
		);
	}, 'normalizeInputType'),
	ou = i((e) => Ti(e, QG), 'normalizeInputTypes'),
	De = i((e) => (Array.isArray(e) ? e : e ? [e] : []), 'normalizeArrays'),
	ZG = Ee`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`;
function ni(e, t, r) {
	const n = t,
		o = typeof t == 'function' ? t : null,
		{ story: s } = n;
	s && (Je.debug('deprecated story', s), em(ZG));
	const a = gG(e),
		u = (typeof n != 'function' && n.name) || n.storyName || s?.name || a,
		c = [...De(n.decorators), ...De(s?.decorators)],
		d = { ...s?.parameters, ...n.parameters },
		p = { ...s?.args, ...n.args },
		f = { ...s?.argTypes, ...n.argTypes },
		m = [...De(n.loaders), ...De(s?.loaders)],
		y = [...De(n.beforeEach), ...De(s?.beforeEach)],
		g = [...De(n.afterEach), ...De(s?.afterEach)],
		{ render: E, play: T, tags: b = [], globals: w = {} } = n,
		P = d.__id || hG(r.id, a);
	return {
		moduleExport: t,
		id: P,
		name: u,
		tags: b,
		decorators: c,
		parameters: d,
		args: p,
		argTypes: ou(f),
		loaders: m,
		beforeEach: y,
		afterEach: g,
		globals: w,
		...(E && { render: E }),
		...(o && { userStoryFn: o }),
		...(T && { play: T })
	};
}
i(ni, 'normalizeStory');
function iu(e, t = e.title, r) {
	const { id: n, argTypes: o } = e;
	return {
		id: RN(n || t),
		...e,
		title: t,
		...(o && { argTypes: ou(o) }),
		parameters: { fileName: r, ...e.parameters }
	};
}
i(iu, 'normalizeComponentAnnotations');
var ez = i((e) => {
		const { globals: t, globalTypes: r } = e;
		(t || r) &&
			Je.error(
				'Global args/argTypes can only be set globally',
				JSON.stringify({ globals: t, globalTypes: r })
			);
	}, 'checkGlobals'),
	tz = i((e) => {
		const { options: t } = e;
		t?.storySort && Je.error('The storySort option parameter can only be set globally');
	}, 'checkStorySort'),
	Ha = i((e) => {
		e && (ez(e), tz(e));
	}, 'checkDisallowedParameters');
function LN(e, t, r) {
	const { default: n, __namedExportsOrder: o, ...s } = e,
		a = Object.values(s)[0];
	if (xc(a)) {
		const d = iu(a.meta.input, r, t);
		Ha(d.parameters);
		const p = { meta: d, stories: {}, moduleExports: e };
		return (
			Object.keys(s).forEach((f) => {
				if (tu(f, d)) {
					const m = s[f],
						y = ni(f, m.input, d);
					(Ha(y.parameters),
						(p.stories[y.id] = y),
						SN(m).forEach((g) => {
							const E = g.input.name,
								T = yG(y.id, E);
							((g.input.parameters ??= {}),
								(g.input.parameters.__id = T),
								(p.stories[T] = ni(E, g.input, d)));
						}));
				}
			}),
			(p.projectAnnotations = a.meta.preview.composed),
			p
		);
	}
	const u = iu(n, r, t);
	Ha(u.parameters);
	const c = { meta: u, stories: {}, moduleExports: e };
	return (
		Object.keys(s).forEach((d) => {
			if (tu(d, u)) {
				const p = ni(d, s[d], u);
				(Ha(p.parameters), (c.stories[p.id] = p));
			}
		}),
		c
	);
}
i(LN, 'processCSFFile');
function Fg(e, t, r) {
	const n = r(e);
	return (o) => t(n, o);
}
i(Fg, 'decorateStory');
function Bg({
	componentId: e,
	title: t,
	kind: r,
	id: n,
	name: o,
	story: s,
	parameters: a,
	initialArgs: u,
	argTypes: c,
	...d
} = {}) {
	return d;
}
i(Bg, 'sanitizeStoryContextUpdate');
function Jg(e, t) {
	const r = {},
		n = i(
			(s) => (a) => {
				if (!r.value) throw new Error('Decorated function called without init');
				return ((r.value = { ...r.value, ...Bg(a) }), s(r.value));
			},
			'bindWithContext'
		),
		o = t.reduce((s, a) => Fg(s, a, n), e);
	return (s) => ((r.value = s), o(s));
}
i(Jg, 'defaultDecorateStory');
var _o = i((...e) => {
	const t = {},
		r = e.filter(Boolean),
		n = r.reduce(
			(o, s) => (
				Object.entries(s).forEach(([a, u]) => {
					const c = o[a];
					Array.isArray(u) || typeof c > 'u'
						? (o[a] = u)
						: hr(u) && hr(c)
							? (t[a] = !0)
							: typeof u < 'u' && (o[a] = u);
				}),
				o
			),
			{}
		);
	return (
		Object.keys(t).forEach((o) => {
			const s = r
				.filter(Boolean)
				.map((a) => a[o])
				.filter((a) => typeof a < 'u');
			s.every((a) => hr(a)) ? (n[o] = _o(...s)) : (n[o] = s[s.length - 1]);
		}),
		n
	);
}, 'combineParameters');
function Ic(e, t, r) {
	const { moduleExport: n, id: o, name: s } = e || {},
		a = Ug(e, t, r),
		u = i(async (C) => {
			const R = {};
			for (const _ of [De(r.loaders), De(t.loaders), De(e.loaders)]) {
				if (C.abortSignal.aborted) return R;
				const S = await Promise.all(_.map((D) => D(C)));
				Object.assign(R, ...S);
			}
			return R;
		}, 'applyLoaders'),
		c = i(async (C) => {
			const R = new Array();
			for (const _ of [...De(r.beforeEach), ...De(t.beforeEach), ...De(e.beforeEach)]) {
				if (C.abortSignal.aborted) return R;
				const S = await _(C);
				S && R.push(S);
			}
			return R;
		}, 'applyBeforeEach'),
		d = i(async (C) => {
			const R = [...De(r.afterEach), ...De(t.afterEach), ...De(e.afterEach)].reverse();
			for (const _ of R) {
				if (C.abortSignal.aborted) return;
				await _(C);
			}
		}, 'applyAfterEach'),
		p = i((C) => C.originalStoryFn(C.args, C), 'undecoratedStoryFn'),
		{ applyDecorators: f = Jg, runStep: m } = r,
		y = [...De(e?.decorators), ...De(t?.decorators), ...De(r?.decorators)],
		g = e?.userStoryFn || e?.render || t.render || r.render,
		E = Sw(f)(p, y),
		T = i((C) => E(C), 'unboundStoryFn'),
		b = e?.play ?? t?.play,
		w = Dw(b);
	if (!g && !w) throw new lw({ id: o });
	const P = i((C) => async () => (await C.renderToCanvas(), C.canvas), 'defaultMount'),
		I = e.mount ?? t.mount ?? r.mount ?? P,
		q = r.testingLibraryRender;
	return {
		storyGlobals: {},
		...a,
		moduleExport: n,
		id: o,
		name: s,
		story: s,
		originalStoryFn: g,
		undecoratedStoryFn: p,
		unboundStoryFn: T,
		applyLoaders: u,
		applyBeforeEach: c,
		applyAfterEach: d,
		playFunction: b,
		runStep: m,
		mount: I,
		testingLibraryRender: q,
		renderToCanvas: r.renderToCanvas,
		usesMount: w
	};
}
i(Ic, 'prepareStory');
function $g(e, t, r) {
	return { ...Ug(void 0, e, t), moduleExport: r };
}
i($g, 'prepareMeta');
function Ug(e, t, r) {
	const n = ['dev', 'test'],
		o = te.DOCS_OPTIONS?.autodocs === !0 ? ['autodocs'] : [],
		s = e?.tags?.includes('test-fn') ? ['!autodocs'] : [],
		a = bG(...n, ...o, ...(r.tags ?? []), ...(t.tags ?? []), ...s, ...(e?.tags ?? [])),
		u = _o(r.parameters, t.parameters, e?.parameters),
		{ argTypesEnhancers: c = [], argsEnhancers: d = [] } = r,
		p = _o(r.argTypes, t.argTypes, e?.argTypes);
	if (e) {
		const w = e?.userStoryFn || e?.render || t.render || r.render;
		u.__isArgsStory = w && w.length > 0;
	}
	const f = { ...r.args, ...t.args, ...e?.args },
		m = { ...t.globals, ...e?.globals },
		y = {
			componentId: t.id,
			title: t.title,
			kind: t.title,
			id: e?.id || t.id,
			name: e?.name || '__meta',
			story: e?.name || '__meta',
			component: t.component,
			subcomponents: t.subcomponents,
			tags: a,
			parameters: u,
			initialArgs: f,
			argTypes: p,
			storyGlobals: m
		};
	y.argTypes = c.reduce((w, P) => P({ ...y, argTypes: w }), y.argTypes);
	const g = { ...f };
	y.initialArgs = [...d].reduce((w, P) => ({ ...w, ...P({ ...y, initialArgs: w }) }), g);
	const { name: E, story: T, ...b } = y;
	return b;
}
i(Ug, 'preparePartialAnnotations');
function Vg(e) {
	const { args: t } = e;
	let r = { ...e, allArgs: void 0, argsByTarget: void 0 };
	if (te.FEATURES?.argTypeTargetsV7) {
		const s = NN(e);
		r = { ...e, allArgs: e.args, argsByTarget: s, args: s[IN] || {} };
	}
	const n = Object.entries(r.args).reduce((s, [a, u]) => {
			if (!r.argTypes[a]?.mapping) return ((s[a] = u), s);
			const c = i((d) => {
				const p = r.argTypes[a].mapping;
				return p && d in p ? p[d] : d;
			}, 'mappingFn');
			return ((s[a] = Array.isArray(u) ? u.map(c) : c(u)), s);
		}, {}),
		o = Object.entries(n).reduce((s, [a, u]) => {
			const c = r.argTypes[a] || {};
			return (cJ(c, n, r.globals) && (s[a] = u), s);
		}, {});
	return { ...r, unmappedArgs: t, args: o };
}
i(Vg, 'prepareContext');
var Sf = i((e, t, r) => {
		const n = typeof e;
		switch (n) {
			case 'boolean':
			case 'string':
			case 'number':
			case 'function':
			case 'symbol':
				return { name: n };
		}
		return e
			? r.has(e)
				? (Je.warn(Ee`
        We've detected a cycle in arg '${t}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/essentials/controls#fully-custom-args
      `),
					{ name: 'other', value: 'cyclic object' })
				: (r.add(e),
					Array.isArray(e)
						? {
								name: 'array',
								value: e.length > 0 ? Sf(e[0], t, new Set(r)) : { name: 'other', value: 'unknown' }
							}
						: { name: 'object', value: Ti(e, (s) => Sf(s, t, new Set(r))) })
			: { name: 'object', value: {} };
	}, 'inferType'),
	FN = i((e) => {
		const { id: t, argTypes: r = {}, initialArgs: n = {} } = e,
			o = Ti(n, (a, u) => ({ name: u, type: Sf(a, `${t}.${u}`, new Set()) })),
			s = Ti(r, (a, u) => ({ name: u }));
		return _o(o, s, r);
	}, 'inferArgTypes');
FN.secondPass = !0;
var Zv = i((e, t) => (Array.isArray(t) ? t.includes(e) : e.match(t)), 'matches'),
	BN = i(
		(e, t, r) =>
			!t && !r
				? e
				: e &&
					PN(e, (n, o) => {
						const s = n.name || o.toString();
						return !!(!t || Zv(s, t)) && (!r || !Zv(s, r));
					}),
		'filterArgTypes'
	),
	rz = i((e, t, r) => {
		const { type: n, options: o } = e;
		if (n) {
			if (r.color && r.color.test(t)) {
				const s = n.name;
				if (s === 'string') return { control: { type: 'color' } };
				s !== 'enum' &&
					Je.warn(
						`Addon controls: Control of type color only supports string, received "${s}" instead`
					);
			}
			if (r.date && r.date.test(t)) return { control: { type: 'date' } };
			switch (n.name) {
				case 'array':
					return { control: { type: 'object' } };
				case 'boolean':
					return { control: { type: 'boolean' } };
				case 'string':
					return { control: { type: 'text' } };
				case 'number':
					return { control: { type: 'number' } };
				case 'enum': {
					const { value: s } = n;
					return { control: { type: s?.length <= 5 ? 'radio' : 'select' }, options: s };
				}
				case 'function':
				case 'symbol':
					return null;
				default:
					return { control: { type: o ? 'select' : 'object' } };
			}
		}
	}, 'inferControl'),
	Hg = i((e) => {
		const {
			argTypes: t,
			parameters: {
				__isArgsStory: r,
				controls: { include: n = null, exclude: o = null, matchers: s = {} } = {}
			}
		} = e;
		if (!r) return t;
		const a = BN(t, n, o),
			u = Ti(a, (c, d) => c?.type && rz(c, d.toString(), s));
		return _o(u, a);
	}, 'inferControls');
Hg.secondPass = !0;
function la({
	argTypes: e,
	globalTypes: t,
	argTypesEnhancers: r,
	decorators: n,
	loaders: o,
	beforeEach: s,
	afterEach: a,
	initialGlobals: u,
	...c
}) {
	return {
		...(e && { argTypes: ou(e) }),
		...(t && { globalTypes: ou(t) }),
		decorators: De(n),
		loaders: De(o),
		beforeEach: De(s),
		afterEach: De(a),
		argTypesEnhancers: [...(r || []), FN, Hg],
		initialGlobals: u,
		...c
	};
}
i(la, 'normalizeProjectAnnotations');
var nz = i(
	(e) => async () => {
		const t = [];
		for (const r of e) {
			const n = await r();
			n && t.unshift(n);
		}
		return async () => {
			for (const r of t) await r();
		};
	},
	'composeBeforeAllHooks'
);
function Gg(e) {
	return async (t, r, n) => {
		await e.reduceRight(
			(s, a) => async () => a(t, s, n),
			async () => r(n)
		)();
	};
}
i(Gg, 'composeStepRunners');
function _i(e, t) {
	return e.map((r) => r.default?.[t] ?? r[t]).filter(Boolean);
}
i(_i, 'getField');
function Gr(e, t, r = {}) {
	return _i(e, t).reduce((n, o) => {
		const s = De(o);
		return r.reverseFileOrder ? [...s, ...n] : [...n, ...s];
	}, []);
}
i(Gr, 'getArrayField');
function Rs(e, t) {
	return Object.assign({}, ..._i(e, t));
}
i(Rs, 'getObjectField');
function $o(e, t) {
	return _i(e, t).pop();
}
i($o, 'getSingletonField');
function wo(e) {
	const t = Gr(e, 'argTypesEnhancers'),
		r = _i(e, 'runStep'),
		n = Gr(e, 'beforeAll');
	return {
		parameters: _o(..._i(e, 'parameters')),
		decorators: Gr(e, 'decorators', {
			reverseFileOrder: !(te.FEATURES?.legacyDecoratorFileOrder ?? !1)
		}),
		args: Rs(e, 'args'),
		argsEnhancers: Gr(e, 'argsEnhancers'),
		argTypes: Rs(e, 'argTypes'),
		argTypesEnhancers: [...t.filter((o) => !o.secondPass), ...t.filter((o) => o.secondPass)],
		initialGlobals: Rs(e, 'initialGlobals'),
		globalTypes: Rs(e, 'globalTypes'),
		loaders: Gr(e, 'loaders'),
		beforeAll: nz(n),
		beforeEach: Gr(e, 'beforeEach'),
		afterEach: Gr(e, 'afterEach'),
		render: $o(e, 'render'),
		renderToCanvas: $o(e, 'renderToCanvas'),
		applyDecorators: $o(e, 'applyDecorators'),
		runStep: Gg(r),
		tags: Gr(e, 'tags'),
		mount: $o(e, 'mount'),
		testingLibraryRender: $o(e, 'testingLibraryRender')
	};
}
i(wo, 'composeConfigs');
var oz = 5e3;
function zg() {
	try {
		return (
			!!globalThis.__vitest_browser__ ||
			!!globalThis.window?.navigator?.userAgent?.match(/StorybookTestRunner/)
		);
	} catch {
		return !1;
	}
}
i(zg, 'isTestEnvironment');
function Nc(e = !0) {
	if (!('document' in globalThis && 'createElement' in globalThis.document)) return () => {};
	const t = document.createElement('style');
	((t.textContent = `*, *:before, *:after {
    animation: none !important;
  }`),
		document.head.appendChild(t));
	const r = document.createElement('style');
	return (
		(r.textContent = `*, *:before, *:after {
    animation-delay: 0s !important;
    animation-direction: ${e ? 'reverse' : 'normal'} !important;
    animation-play-state: paused !important;
    transition: none !important;
  }`),
		document.head.appendChild(r),
		document.body.clientHeight,
		document.head.removeChild(t),
		() => {
			r.parentNode?.removeChild(r);
		}
	);
}
i(Nc, 'pauseAnimations');
async function Mc(e) {
	if (
		!(
			'document' in globalThis &&
			'getAnimations' in globalThis.document &&
			'querySelectorAll' in globalThis.document
		)
	)
		return;
	let t = !1;
	await Promise.race([
		new Promise((r) => {
			setTimeout(() => {
				const n = [globalThis.document, ...Wg(globalThis.document)],
					o = i(async () => {
						if (t || e?.aborted) return;
						const s = n
							.flatMap((a) => a?.getAnimations?.() || [])
							.filter((a) => a.playState === 'running' && !JN(a));
						s.length > 0 && (await Promise.all(s.map((a) => a.finished)), await o());
					}, 'checkAnimationsFinished');
				o().then(r);
			}, 100);
		}),
		new Promise((r) =>
			setTimeout(() => {
				((t = !0), r(void 0));
			}, oz)
		)
	]);
}
i(Mc, 'waitForAnimations');
function Wg(e) {
	return [e, ...e.querySelectorAll('*')].reduce(
		(t, r) => ('shadowRoot' in r && r.shadowRoot && t.push(r.shadowRoot, ...Wg(r.shadowRoot)), t),
		[]
	);
}
i(Wg, 'getShadowRoots');
function JN(e) {
	if (e instanceof CSSAnimation && e.effect instanceof KeyframeEffect && e.effect.target) {
		const t = getComputedStyle(e.effect.target, e.effect.pseudoElement),
			r = t.animationName?.split(', ').indexOf(e.animationName);
		return t.animationIterationCount.split(', ')[r] === 'infinite';
	}
	return !1;
}
i(JN, 'isInfiniteAnimation');
var $N = class {
	constructor() {
		this.reports = [];
	}
	async addReport(t) {
		this.reports.push(t);
	}
};
i($N, 'ReporterAPI');
var Kg = $N;
function Yg(e, t, r) {
	return xc(e)
		? { story: e.input, meta: e.meta.input, preview: e.meta.preview.composed }
		: { story: e, meta: wN(t) ? t.input : t, preview: r };
}
i(Yg, 'getCsfFactoryAnnotations');
function UN(e) {
	globalThis.defaultProjectAnnotations = e;
}
i(UN, 'setDefaultProjectAnnotations');
var iz = 'ComposedStory',
	sz = 'Unnamed Story';
function VN(e) {
	return e ? wo([e]) : {};
}
i(VN, 'extractAnnotation');
function HN(e) {
	const t = Array.isArray(e) ? e : [e];
	return (
		(globalThis.globalProjectAnnotations = wo([
			...Lg(),
			globalThis.defaultProjectAnnotations ?? {},
			wo(t.map(VN))
		])),
		globalThis.globalProjectAnnotations ?? {}
	);
}
i(HN, 'setProjectAnnotations');
var En = [];
function Xg(e, t, r, n, o) {
	if (e === void 0) throw new Error('Expected a story but received undefined.');
	t.title = t.title ?? iz;
	const s = iu(t),
		a = o || e.storyName || e.story?.name || e.name || sz,
		u = ni(a, e, s),
		c = la(wo([n ?? globalThis.globalProjectAnnotations ?? {}, r ?? {}])),
		d = Ic(u, s, c),
		f = { ...jN(c.globalTypes), ...c.initialGlobals, ...d.storyGlobals },
		m = new Kg(),
		y = i(() => {
			const P = Vg({
				hooks: new hm(),
				globals: f,
				args: { ...d.initialArgs },
				viewMode: 'story',
				reporting: m,
				loaded: {},
				abortSignal: new AbortController().signal,
				step: i((I, q) => d.runStep(I, q, P), 'step'),
				canvasElement: null,
				canvas: {},
				userEvent: {},
				globalTypes: c.globalTypes,
				...d,
				context: null,
				mount: null
			});
			return (
				(P.parameters.__isPortableStory = !0),
				(P.context = P),
				d.renderToCanvas &&
					(P.renderToCanvas = async () => {
						const I = await d.renderToCanvas?.(
							{
								componentId: d.componentId,
								title: d.title,
								id: d.id,
								name: d.name,
								tags: d.tags,
								showMain: i(() => {}, 'showMain'),
								showError: i((q) => {
									throw new Error(`${q.title}
${q.description}`);
								}, 'showError'),
								showException: i((q) => {
									throw q;
								}, 'showException'),
								forceRemount: !0,
								storyContext: P,
								storyFn: i(() => d.unboundStoryFn(P), 'storyFn'),
								unboundStoryFn: d.unboundStoryFn
							},
							P.canvasElement
						);
						I && En.push(I);
					}),
				(P.mount = d.mount(P)),
				P
			);
		}, 'initializeContext');
	let g;
	const E = i(async (P) => {
			const I = y();
			return (
				(I.canvasElement ??= globalThis?.document?.body),
				g && (I.loaded = g.loaded),
				Object.assign(I, P),
				d.playFunction(I)
			);
		}, 'play'),
		T = i((P) => {
			const I = y();
			return (Object.assign(I, P), WN(d, I));
		}, 'run'),
		b = d.playFunction ? E : void 0;
	return Object.assign(
		i(function (I) {
			const q = y();
			return (
				g && (q.loaded = g.loaded),
				(q.args = { ...q.initialArgs, ...I }),
				d.unboundStoryFn(q)
			);
		}, 'storyFn'),
		{
			id: d.id,
			storyName: a,
			load: i(async () => {
				for (const I of [...En].reverse()) await I();
				En.length = 0;
				const P = y();
				((P.loaded = await d.applyLoaders(P)),
					En.push(...(await d.applyBeforeEach(P)).filter(Boolean)),
					(g = P));
			}, 'load'),
			globals: f,
			args: d.initialArgs,
			parameters: d.parameters,
			argTypes: d.argTypes,
			play: b,
			run: T,
			reporting: m,
			tags: d.tags
		}
	);
}
i(Xg, 'composeStory');
var az = i((e, t, r, n) => Xg(e, t, r, {}, n), 'defaultComposeStory');
function GN(e, t, r = az) {
	const { default: n, __esModule: o, __namedExportsOrder: s, ...a } = e;
	let u = n;
	return Object.entries(a).reduce((d, [p, f]) => {
		const { story: m, meta: y } = Yg(f);
		return (!u && y && (u = y), tu(p, u) ? Object.assign(d, { [p]: r(m, u, t, p) }) : d);
	}, {});
}
i(GN, 'composeStories');
function zN(e) {
	return e.extend({
		mount: i(async ({ mount: t, page: r }, n) => {
			await n(async (o, ...s) => {
				if (!('__pw_type' in o) || ('__pw_type' in o && o.__pw_type !== 'jsx'))
					throw new Error(Ee`
              Portable stories in Playwright CT only work when referencing JSX elements.
              Please use JSX format for your components such as:

              instead of:
              await mount(MyComponent, { props: { foo: 'bar' } })

              do:
              await mount(<MyComponent foo="bar"/>)

              More info: https://storybook.js.org/docs/api/portable-stories/portable-stories-playwright?ref=error
            `);
				const { props: a, ...u } = o;
				await r.evaluate(async (d) => {
					const p = await globalThis.__pwUnwrapObject?.(d);
					return ('__pw_type' in p ? p.type : p)?.load?.();
				}, u);
				const c = await t(o, ...s);
				return (
					await r.evaluate(async (d) => {
						const p = await globalThis.__pwUnwrapObject?.(d),
							f = '__pw_type' in p ? p.type : p,
							m = document.querySelector('#root');
						return f?.play?.({ canvasElement: m });
					}, u),
					c
				);
			});
		}, 'mount')
	});
}
i(zN, 'createPlaywrightTest');
async function WN(e, t) {
	for (const s of [...En].reverse()) await s();
	if (((En.length = 0), !t.canvasElement)) {
		const s = document.createElement('div');
		(globalThis?.document?.body?.appendChild(s),
			(t.canvasElement = s),
			En.push(() => {
				globalThis?.document?.body?.contains(s) && globalThis?.document?.body?.removeChild(s);
			}));
	}
	if (((t.loaded = await e.applyLoaders(t)), t.abortSignal.aborted)) return;
	En.push(...(await e.applyBeforeEach(t)).filter(Boolean));
	const r = e.playFunction,
		n = e.usesMount;
	if ((n || (await t.mount()), t.abortSignal.aborted)) return;
	r &&
		(n ||
			(t.mount = async () => {
				throw new fm({ playFunction: r.toString() });
			}),
		await r(t));
	let o;
	(zg() ? (o = Nc()) : await Mc(t.abortSignal), await e.applyAfterEach(t), await o?.());
}
i(WN, 'runStory');
var eE = 1e3,
	lz = 1e4,
	KN = class {
		constructor(t, r, n) {
			((this.importFn = r),
				(this.storyIndex = new KG(t)),
				(this.projectAnnotations = la(wo([...Lg(), n]))));
			const { initialGlobals: o, globalTypes: s } = this.projectAnnotations;
			((this.args = new HG()),
				(this.userGlobals = new GG({ globals: o, globalTypes: s })),
				(this.hooks = {}),
				(this.cleanupCallbacks = {}),
				(this.processCSFFileWithCache = (0, _d.default)(eE)(LN)),
				(this.prepareMetaWithCache = (0, _d.default)(eE)($g)),
				(this.prepareStoryWithCache = (0, _d.default)(lz)(Ic)));
		}
		setProjectAnnotations(t) {
			this.projectAnnotations = la(t);
			const { initialGlobals: r, globalTypes: n } = t;
			this.userGlobals.set({ globals: r, globalTypes: n });
		}
		async onStoriesChanged({ importFn: t, storyIndex: r }) {
			(t && (this.importFn = t),
				r && (this.storyIndex.entries = r.entries),
				this.cachedCSFFiles && (await this.cacheAllCSFFiles()));
		}
		async storyIdToEntry(t) {
			return this.storyIndex.storyIdToEntry(t);
		}
		async loadCSFFileByStoryId(t) {
			const { importPath: r, title: n } = this.storyIndex.storyIdToEntry(t),
				o = await this.importFn(r);
			return this.processCSFFileWithCache(o, r, n);
		}
		async loadAllCSFFiles() {
			const t = {};
			return (
				Object.entries(this.storyIndex.entries).forEach(([n, { importPath: o }]) => {
					t[o] = n;
				}),
				(
					await Promise.all(
						Object.entries(t).map(async ([n, o]) => ({
							importPath: n,
							csfFile: await this.loadCSFFileByStoryId(o)
						}))
					)
				).reduce((n, { importPath: o, csfFile: s }) => ((n[o] = s), n), {})
			);
		}
		async cacheAllCSFFiles() {
			this.cachedCSFFiles = await this.loadAllCSFFiles();
		}
		preparedMetaFromCSFFile({ csfFile: t }) {
			const r = t.meta;
			return this.prepareMetaWithCache(r, this.projectAnnotations, t.moduleExports.default);
		}
		async loadStory({ storyId: t }) {
			const r = await this.loadCSFFileByStoryId(t);
			return this.storyFromCSFFile({ storyId: t, csfFile: r });
		}
		storyFromCSFFile({ storyId: t, csfFile: r }) {
			const n = r.stories[t];
			if (!n) throw new nw({ storyId: t });
			const o = r.meta,
				s = this.prepareStoryWithCache(n, o, r.projectAnnotations ?? this.projectAnnotations);
			return (this.args.setInitial(s), (this.hooks[s.id] = this.hooks[s.id] || new hm()), s);
		}
		componentStoriesFromCSFFile({ csfFile: t }) {
			return Object.keys(this.storyIndex.entries)
				.filter((r) => !!t.stories[r])
				.map((r) => this.storyFromCSFFile({ storyId: r, csfFile: t }));
		}
		async loadEntry(t) {
			const r = await this.storyIdToEntry(t),
				n = r.type === 'docs' ? r.storiesImports : [],
				[o, ...s] = await Promise.all([
					this.importFn(r.importPath),
					...n.map((a) => {
						const u = this.storyIndex.importPathToEntry(a);
						return this.loadCSFFileByStoryId(u.id);
					})
				]);
			return { entryExports: o, csfFiles: s };
		}
		getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
			const n = this.userGlobals.get(),
				{ initialGlobals: o } = this.userGlobals,
				s = new Kg();
			return Vg({
				...t,
				args: r ? t.initialArgs : this.args.get(t.id),
				initialGlobals: o,
				globalTypes: this.projectAnnotations.globalTypes,
				userGlobals: n,
				reporting: s,
				globals: { ...n, ...t.storyGlobals },
				hooks: this.hooks[t.id]
			});
		}
		addCleanupCallbacks(t, ...r) {
			this.cleanupCallbacks[t.id] = (this.cleanupCallbacks[t.id] || []).concat(r);
		}
		async cleanupStory(t) {
			this.hooks[t.id].clean();
			const r = this.cleanupCallbacks[t.id];
			if (r) for (const n of [...r].reverse()) await n();
			delete this.cleanupCallbacks[t.id];
		}
		extract(t = { includeDocsOnly: !1 }) {
			const { cachedCSFFiles: r } = this;
			if ((console.log('extract: extracting stories', r), !r)) throw new V_();
			const n = Object.entries(this.storyIndex.entries).reduce((o, [s, a]) => {
				if (a.type === 'docs') return o;
				const u = r[a.importPath],
					c = this.storyFromCSFFile({ storyId: s, csfFile: u });
				return (
					(!t.includeDocsOnly && c.parameters.docsOnly) ||
						(o[s] = Object.entries(c).reduce(
							(d, [p, f]) =>
								p === 'story' && a.subtype === 'test'
									? { ...d, story: a.parentName }
									: p === 'moduleExport' || typeof f == 'function'
										? d
										: Array.isArray(f)
											? Object.assign(d, { [p]: f.slice().sort() })
											: Object.assign(d, { [p]: f }),
							{
								args: c.initialArgs,
								globals: {
									...this.userGlobals.initialGlobals,
									...this.userGlobals.globals,
									...c.storyGlobals
								},
								storyId: a.parent ? a.parent : s
							}
						)),
					o
				);
			}, {});
			return (console.log('extract: stories', n), n);
		}
	};
i(KN, 'StoryStore');
var YN = KN;
function XN(e) {
	return e.startsWith('\\\\?\\') ? e : e.replace(/\\/g, '/');
}
i(XN, 'slash');
var uz = i((e) => {
	if (e.length === 0) return e;
	const t = e[e.length - 1],
		r = t?.replace(/(?:[.](?:story|stories))?([.][^.]+)$/i, '');
	if (e.length === 1) return [r];
	const n = e[e.length - 2];
	return r && n && r.toLowerCase() === n.toLowerCase()
		? [...e.slice(0, -2), r]
		: r && (/^(story|stories)([.][^.]+)$/i.test(t) || /^index$/i.test(r))
			? e.slice(0, -1)
			: [...e.slice(0, -1), r];
}, 'sanitize');
function Rf(e) {
	return e
		.flatMap((t) => t.split('/'))
		.filter(Boolean)
		.join('/');
}
i(Rf, 'pathJoin');
var QN = i((e, t, r) => {
		const { directory: n, importPathMatcher: o, titlePrefix: s = '' } = t || {};
		typeof e == 'number' &&
			Ye.warn(Ee`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);
		const a = XN(String(e));
		if (o.exec(a)) {
			if (!r) {
				const u = a.replace(n, '');
				let c = Rf([s, u]).split('/');
				return ((c = uz(c)), c.join('/'));
			}
			return s ? Rf([s, r]) : r;
		}
	}, 'userOrAutoTitleFromSpecifier'),
	cz = i((e, t, r) => {
		for (let n = 0; n < t.length; n += 1) {
			const o = QN(e, t[n], r);
			if (o) return o;
		}
		return r || void 0;
	}, 'userOrAutoTitle'),
	tE = /\s*\/\s*/,
	dz = i(
		(e = {}) =>
			(t, r) => {
				if (t.title === r.title && !e.includeNames) return 0;
				const n = e.method || 'configure';
				let o = e.order || [];
				const s = t.title.trim().split(tE),
					a = r.title.trim().split(tE);
				e.includeNames && (s.push(t.name), a.push(r.name));
				let u = 0;
				for (; s[u] || a[u]; ) {
					if (!s[u]) return -1;
					if (!a[u]) return 1;
					const c = s[u],
						d = a[u];
					if (c !== d) {
						let f = o.indexOf(c),
							m = o.indexOf(d);
						const y = o.indexOf('*');
						return f !== -1 || m !== -1
							? (f === -1 && (y !== -1 ? (f = y) : (f = o.length)),
								m === -1 && (y !== -1 ? (m = y) : (m = o.length)),
								f - m)
							: n === 'configure'
								? 0
								: c.localeCompare(d, e.locales ? e.locales : void 0, {
										numeric: !0,
										sensitivity: 'accent'
									});
					}
					let p = o.indexOf(c);
					(p === -1 && (p = o.indexOf('*')),
						(o = p !== -1 && Array.isArray(o[p + 1]) ? o[p + 1] : []),
						(u += 1));
				}
				return 0;
			},
		'storySort'
	),
	pz = i((e, t, r) => {
		if (t) {
			let n;
			(typeof t == 'function' ? (n = t) : (n = dz(t)), e.sort(n));
		} else e.sort((n, o) => r.indexOf(n.importPath) - r.indexOf(o.importPath));
		return e;
	}, 'sortStoriesCommon'),
	fz = i((e, t, r) => {
		try {
			return pz(e, t, r);
		} catch (n) {
			throw new Error(Ee`
    Error sorting stories with sort parameter ${t}:

    > ${n.message}

    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `);
		}
	}, 'sortStoriesV7'),
	qc = new Error('prepareAborted'),
	{ AbortController: rE } = globalThis;
function Pf(e) {
	try {
		const { name: t = 'Error', message: r = String(e), stack: n } = e;
		return { name: t, message: r, stack: n };
	} catch {
		return { name: 'Error', message: String(e) };
	}
}
i(Pf, 'serializeError');
var ZN = class {
	constructor(t, r, n, o, s, a, u = { autoplay: !0, forceInitialArgs: !1 }, c) {
		((this.channel = t),
			(this.store = r),
			(this.renderToScreen = n),
			(this.callbacks = o),
			(this.id = s),
			(this.viewMode = a),
			(this.renderOptions = u),
			(this.type = 'story'),
			(this.notYetRendered = !0),
			(this.rerenderEnqueued = !1),
			(this.disableKeyListeners = !1),
			(this.teardownRender = i(() => {}, 'teardownRender')),
			(this.torndown = !1),
			(this.abortController = new rE()),
			(this.renderId = Date.now()),
			c && ((this.story = c), (this.phase = 'preparing')));
	}
	async runPhase(t, r, n) {
		((this.phase = r),
			this.channel.emit(fo, { newPhase: this.phase, renderId: this.renderId, storyId: this.id }),
			n && (await n(), this.checkIfAborted(t)));
	}
	checkIfAborted(t) {
		return (
			t.aborted &&
				!['finished', 'aborted', 'errored'].includes(this.phase) &&
				((this.phase = 'aborted'),
				this.channel.emit(fo, { newPhase: this.phase, renderId: this.renderId, storyId: this.id })),
			t.aborted
		);
	}
	async prepare() {
		if (
			(await this.runPhase(this.abortController.signal, 'preparing', async () => {
				this.story = await this.store.loadStory({ storyId: this.id });
			}),
			this.abortController.signal.aborted)
		)
			throw (await this.store.cleanupStory(this.story), qc);
	}
	isEqual(t) {
		return !!(this.id === t.id && this.story && this.story === t.story);
	}
	isPreparing() {
		return ['preparing'].includes(this.phase);
	}
	isPending() {
		return ['loading', 'beforeEach', 'rendering', 'playing', 'afterEach'].includes(this.phase);
	}
	async renderToElement(t) {
		return ((this.canvasElement = t), this.render({ initial: !0, forceRemount: !0 }));
	}
	storyContext() {
		if (!this.story) throw new Error('Cannot call storyContext before preparing');
		const { forceInitialArgs: t } = this.renderOptions;
		return this.store.getStoryContext(this.story, { forceInitialArgs: t });
	}
	async render({ initial: t = !1, forceRemount: r = !1 } = {}) {
		const { canvasElement: n } = this;
		if (!this.story) throw new Error('cannot render when not prepared');
		const o = this.story;
		if (!n) throw new Error('cannot render when canvasElement is unset');
		const {
			id: s,
			componentId: a,
			title: u,
			name: c,
			tags: d,
			applyLoaders: p,
			applyBeforeEach: f,
			applyAfterEach: m,
			unboundStoryFn: y,
			playFunction: g,
			runStep: E
		} = o;
		r && !t && (this.cancelRender(), (this.abortController = new rE()));
		const T = this.abortController.signal;
		let b = !1;
		const w = o.usesMount;
		try {
			const P = {
				...this.storyContext(),
				viewMode: this.viewMode,
				abortSignal: T,
				canvasElement: n,
				loaded: {},
				step: i((H, A) => E(H, A, P), 'step'),
				context: null,
				canvas: {},
				userEvent: {},
				renderToCanvas: i(async () => {
					const H = await this.renderToScreen(I, n);
					((this.teardownRender = H || (() => {})), (b = !0));
				}, 'renderToCanvas'),
				mount: i(async (...H) => {
					this.callbacks.showStoryDuringRender?.();
					let A = null;
					return (
						await this.runPhase(T, 'rendering', async () => {
							A = await o.mount(P)(...H);
						}),
						w && (await this.runPhase(T, 'playing')),
						A
					);
				}, 'mount')
			};
			P.context = P;
			const I = {
				componentId: a,
				title: u,
				kind: u,
				id: s,
				name: c,
				story: c,
				tags: d,
				...this.callbacks,
				showError: i((H) => ((this.phase = 'errored'), this.callbacks.showError(H)), 'showError'),
				showException: i(
					(H) => ((this.phase = 'errored'), this.callbacks.showException(H)),
					'showException'
				),
				forceRemount: r || this.notYetRendered,
				storyContext: P,
				storyFn: i(() => y(P), 'storyFn'),
				unboundStoryFn: y
			};
			if (
				(await this.runPhase(T, 'loading', async () => {
					P.loaded = await p(P);
				}),
				T.aborted)
			)
				return;
			const q = await f(P);
			if (
				(this.store.addCleanupCallbacks(o, ...q),
				this.checkIfAborted(T) ||
					(!b && !w && (await P.mount()), (this.notYetRendered = !1), T.aborted))
			)
				return;
			const C = this.story.parameters?.test?.dangerouslyIgnoreUnhandledErrors === !0,
				R = new Set(),
				_ = i((H) => {
					H.error && R.add(H.error);
				}, 'onError'),
				S = i((H) => {
					H.reason && R.add(H.reason);
				}, 'onUnhandledRejection');
			if (this.renderOptions.autoplay && r && g && this.phase !== 'errored') {
				(window?.addEventListener?.('error', _),
					window?.addEventListener?.('unhandledrejection', S),
					(this.disableKeyListeners = !0));
				try {
					if (
						(w
							? await g(P)
							: ((P.mount = async () => {
									throw new fm({ playFunction: g.toString() });
								}),
								await this.runPhase(T, 'playing', async () => g(P))),
						!b)
					)
						throw new cw();
					(this.checkIfAborted(T),
						!C && R.size > 0
							? await this.runPhase(T, 'errored')
							: await this.runPhase(T, 'played'));
				} catch (H) {
					if (
						(this.callbacks.showStoryDuringRender?.(),
						await this.runPhase(T, 'errored', async () => {
							this.channel.emit(ZE, Pf(H));
						}),
						this.story.parameters.throwPlayFunctionExceptions !== !1)
					)
						throw H;
					console.error(H);
				}
				if (
					(!C && R.size > 0 && this.channel.emit(eT, Array.from(R).map(Pf)),
					(this.disableKeyListeners = !1),
					window?.removeEventListener?.('unhandledrejection', S),
					window?.removeEventListener?.('error', _),
					T.aborted)
				)
					return;
			}
			(await this.runPhase(T, 'completing', async () => {
				zg() ? this.store.addCleanupCallbacks(o, Nc()) : await Mc(T);
			}),
				await this.runPhase(T, 'completed', async () => {
					this.channel.emit(ml, s);
				}),
				this.phase !== 'errored' &&
					(await this.runPhase(T, 'afterEach', async () => {
						await m(P);
					})));
			const D = !C && R.size > 0,
				N = P.reporting.reports.some((H) => H.status === 'failed'),
				V = D || N;
			await this.runPhase(T, 'finished', async () =>
				this.channel.emit(qd, {
					storyId: s,
					status: V ? 'error' : 'success',
					reporters: P.reporting.reports
				})
			);
		} catch (P) {
			((this.phase = 'errored'),
				this.callbacks.showException(P),
				await this.runPhase(T, 'finished', async () =>
					this.channel.emit(qd, { storyId: s, status: 'error', reporters: [] })
				));
		}
		this.rerenderEnqueued && ((this.rerenderEnqueued = !1), this.render());
	}
	async rerender() {
		if (this.isPending() && this.phase !== 'playing') this.rerenderEnqueued = !0;
		else return this.render();
	}
	async remount() {
		return (await this.teardown(), this.render({ forceRemount: !0 }));
	}
	cancelRender() {
		this.abortController.abort();
	}
	cancelPlayFunction() {
		this.phase === 'playing' &&
			(this.abortController.abort(), this.runPhase(this.abortController.signal, 'aborted'));
	}
	async teardown() {
		((this.torndown = !0),
			this.cancelRender(),
			this.story && (await this.store.cleanupStory(this.story)));
		for (let t = 0; t < 3; t += 1) {
			if (!this.isPending()) {
				await this.teardownRender();
				return;
			}
			await new Promise((r) => setTimeout(r, 0));
		}
		(window?.location?.reload?.(), await new Promise(() => {}));
	}
};
i(ZN, 'StoryRender');
var Af = ZN,
	{ fetch: mz } = te,
	hz = './index.json',
	eM = class {
		constructor(t, r, n = ir.getChannel(), o = !0) {
			((this.importFn = t),
				(this.getProjectAnnotations = r),
				(this.channel = n),
				(this.storyRenders = []),
				(this.storeInitializationPromise = new Promise((s, a) => {
					((this.resolveStoreInitializationPromise = s),
						(this.rejectStoreInitializationPromise = a));
				})),
				o && this.initialize());
		}
		get storyStore() {
			return new Proxy(
				{},
				{
					get: i((t, r) => {
						if (this.storyStoreValue)
							return (
								em('Accessing the Story Store is deprecated and will be removed in 9.0'),
								this.storyStoreValue[r]
							);
						throw new iw();
					}, 'get')
				}
			);
		}
		async initialize() {
			this.setupListeners();
			try {
				const t = await this.getProjectAnnotationsOrRenderError();
				(await this.runBeforeAllHook(t), await this.initializeWithProjectAnnotations(t));
				const r = globalThis?.navigator?.userAgent;
				await this.channel.emit(rT, { userAgent: r });
			} catch (t) {
				this.rejectStoreInitializationPromise(t);
			}
		}
		ready() {
			return this.storeInitializationPromise;
		}
		setupListeners() {
			(this.channel.on(lT, this.onStoryIndexChanged.bind(this)),
				this.channel.on(Qf, this.onUpdateGlobals.bind(this)),
				this.channel.on(Zf, this.onUpdateArgs.bind(this)),
				this.channel.on(yT, this.onRequestArgTypesInfo.bind(this)),
				this.channel.on(Yf, this.onResetArgs.bind(this)),
				this.channel.on(Kf, this.onForceReRender.bind(this)),
				this.channel.on(fl, this.onForceRemount.bind(this)),
				this.channel.on(fT, this.onStoryHotUpdated.bind(this)));
		}
		async getProjectAnnotationsOrRenderError() {
			try {
				const t = await this.getProjectAnnotations();
				if (((this.renderToCanvas = t.renderToCanvas), !this.renderToCanvas)) throw new G_();
				return t;
			} catch (t) {
				throw (this.renderPreviewEntryError('Error reading preview.js:', t), t);
			}
		}
		async initializeWithProjectAnnotations(t) {
			this.projectAnnotationsBeforeInitialization = t;
			try {
				const r = await this.getStoryIndexFromServer();
				return this.initializeWithStoryIndex(r);
			} catch (r) {
				throw (this.renderPreviewEntryError('Error loading story index:', r), r);
			}
		}
		async runBeforeAllHook(t) {
			try {
				(await this.beforeAllCleanup?.(), (this.beforeAllCleanup = await t.beforeAll?.()));
			} catch (r) {
				throw (this.renderPreviewEntryError('Error in beforeAll hook:', r), r);
			}
		}
		async getStoryIndexFromServer() {
			const t = await mz(hz);
			if (t.status === 200) return t.json();
			throw new K_({ text: await t.text() });
		}
		initializeWithStoryIndex(t) {
			if (!this.projectAnnotationsBeforeInitialization)
				throw new Error('Cannot call initializeWithStoryIndex until project annotations resolve');
			((this.storyStoreValue = new YN(
				t,
				this.importFn,
				this.projectAnnotationsBeforeInitialization
			)),
				delete this.projectAnnotationsBeforeInitialization,
				this.setInitialGlobals(),
				this.resolveStoreInitializationPromise());
		}
		async setInitialGlobals() {
			this.emitGlobals();
		}
		emitGlobals() {
			if (!this.storyStoreValue) throw new Vt({ methodName: 'emitGlobals' });
			const t = {
				globals: this.storyStoreValue.userGlobals.get() || {},
				globalTypes: this.storyStoreValue.projectAnnotations.globalTypes || {}
			};
			this.channel.emit(oT, t);
		}
		async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
			(delete this.previewEntryError, (this.getProjectAnnotations = t));
			const r = await this.getProjectAnnotationsOrRenderError();
			if ((await this.runBeforeAllHook(r), !this.storyStoreValue)) {
				await this.initializeWithProjectAnnotations(r);
				return;
			}
			(this.storyStoreValue.setProjectAnnotations(r), this.emitGlobals());
		}
		async onStoryIndexChanged() {
			if (
				(delete this.previewEntryError,
				!(!this.storyStoreValue && !this.projectAnnotationsBeforeInitialization))
			)
				try {
					const t = await this.getStoryIndexFromServer();
					if (this.projectAnnotationsBeforeInitialization) {
						this.initializeWithStoryIndex(t);
						return;
					}
					await this.onStoriesChanged({ storyIndex: t });
				} catch (t) {
					throw (this.renderPreviewEntryError('Error loading story index:', t), t);
				}
		}
		async onStoriesChanged({ importFn: t, storyIndex: r }) {
			if (!this.storyStoreValue) throw new Vt({ methodName: 'onStoriesChanged' });
			await this.storyStoreValue.onStoriesChanged({ importFn: t, storyIndex: r });
		}
		async onUpdateGlobals({ globals: t, currentStory: r }) {
			if ((this.storyStoreValue || (await this.storeInitializationPromise), !this.storyStoreValue))
				throw new Vt({ methodName: 'onUpdateGlobals' });
			if ((this.storyStoreValue.userGlobals.update(t), r)) {
				const {
					initialGlobals: n,
					storyGlobals: o,
					userGlobals: s,
					globals: a
				} = this.storyStoreValue.getStoryContext(r);
				this.channel.emit($s, { initialGlobals: n, userGlobals: s, storyGlobals: o, globals: a });
			} else {
				const { initialGlobals: n, globals: o } = this.storyStoreValue.userGlobals;
				this.channel.emit($s, { initialGlobals: n, userGlobals: o, storyGlobals: {}, globals: o });
			}
			await Promise.all(this.storyRenders.map((n) => n.rerender()));
		}
		async onUpdateArgs({ storyId: t, updatedArgs: r }) {
			if (!this.storyStoreValue) throw new Vt({ methodName: 'onUpdateArgs' });
			(this.storyStoreValue.args.update(t, r),
				await Promise.all(
					this.storyRenders
						.filter((n) => n.id === t && !n.renderOptions.forceInitialArgs)
						.map((n) => (n.story && n.story.usesMount ? n.remount() : n.rerender()))
				),
				this.channel.emit(iT, { storyId: t, args: this.storyStoreValue.args.get(t) }));
		}
		async onRequestArgTypesInfo({ id: t, payload: r }) {
			try {
				await this.storeInitializationPromise;
				const n = await this.storyStoreValue?.loadStory(r);
				this.channel.emit(jd, {
					id: t,
					success: !0,
					payload: { argTypes: n?.argTypes || {} },
					error: null
				});
			} catch (n) {
				this.channel.emit(jd, { id: t, success: !1, error: n?.message });
			}
		}
		async onResetArgs({ storyId: t, argNames: r }) {
			if (!this.storyStoreValue) throw new Vt({ methodName: 'onResetArgs' });
			const o =
					this.storyRenders.find((u) => u.id === t)?.story ||
					(await this.storyStoreValue.loadStory({ storyId: t })),
				a = (
					r || [
						...new Set([
							...Object.keys(o.initialArgs),
							...Object.keys(this.storyStoreValue.args.get(t))
						])
					]
				).reduce((u, c) => ((u[c] = o.initialArgs[c]), u), {});
			await this.onUpdateArgs({ storyId: t, updatedArgs: a });
		}
		async onForceReRender() {
			await Promise.all(this.storyRenders.map((t) => t.rerender()));
		}
		async onForceRemount({ storyId: t }) {
			await Promise.all(this.storyRenders.filter((r) => r.id === t).map((r) => r.remount()));
		}
		async onStoryHotUpdated() {
			await Promise.all(this.storyRenders.map((t) => t.cancelPlayFunction()));
		}
		renderStoryToElement(t, r, n, o) {
			if (!this.renderToCanvas || !this.storyStoreValue)
				throw new Vt({ methodName: 'renderStoryToElement' });
			const s = new Af(
				this.channel,
				this.storyStoreValue,
				this.renderToCanvas,
				n,
				t.id,
				'docs',
				o,
				t
			);
			return (
				s.renderToElement(r),
				this.storyRenders.push(s),
				async () => {
					await this.teardownRender(s);
				}
			);
		}
		async teardownRender(t, { viewModeChanged: r } = {}) {
			((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
				await t?.teardown?.({ viewModeChanged: r }));
		}
		async loadStory({ storyId: t }) {
			if (!this.storyStoreValue) throw new Vt({ methodName: 'loadStory' });
			return this.storyStoreValue.loadStory({ storyId: t });
		}
		getStoryContext(t, { forceInitialArgs: r = !1 } = {}) {
			if (!this.storyStoreValue) throw new Vt({ methodName: 'getStoryContext' });
			return this.storyStoreValue.getStoryContext(t, { forceInitialArgs: r });
		}
		async extract(t) {
			if (!this.storyStoreValue) throw new Vt({ methodName: 'extract' });
			if (this.previewEntryError) throw this.previewEntryError;
			return (await this.storyStoreValue.cacheAllCSFFiles(), this.storyStoreValue.extract(t));
		}
		renderPreviewEntryError(t, r) {
			((this.previewEntryError = r), Je.error(t), Je.error(r), this.channel.emit(XE, r));
		}
	};
i(eM, 'Preview');
var tM = eM,
	rM = class {
		constructor(t, r, n, o) {
			((this.channel = t),
				(this.store = r),
				(this.renderStoryToElement = n),
				(this.storyIdByName = i((s) => {
					const a = this.nameToStoryId.get(s);
					if (a) return a;
					throw new Error(`No story found with that name: ${s}`);
				}, 'storyIdByName')),
				(this.componentStories = i(() => this.componentStoriesValue, 'componentStories')),
				(this.componentStoriesFromCSFFile = i(
					(s) => this.store.componentStoriesFromCSFFile({ csfFile: s }),
					'componentStoriesFromCSFFile'
				)),
				(this.storyById = i((s) => {
					if (!s) {
						if (!this.primaryStory)
							throw new Error(
								'No primary story defined for docs entry. Did you forget to use `<Meta>`?'
							);
						return this.primaryStory;
					}
					const a = this.storyIdToCSFFile.get(s);
					if (!a) throw new Error(`Called \`storyById\` for story that was never loaded: ${s}`);
					return this.store.storyFromCSFFile({ storyId: s, csfFile: a });
				}, 'storyById')),
				(this.getStoryContext = i(
					(s) => ({ ...this.store.getStoryContext(s), loaded: {}, viewMode: 'docs' }),
					'getStoryContext'
				)),
				(this.loadStory = i((s) => this.store.loadStory({ storyId: s }), 'loadStory')),
				(this.componentStoriesValue = []),
				(this.storyIdToCSFFile = new Map()),
				(this.exportToStory = new Map()),
				(this.exportsToCSFFile = new Map()),
				(this.nameToStoryId = new Map()),
				(this.attachedCSFFiles = new Set()),
				o.forEach((s, a) => {
					this.referenceCSFFile(s);
				}));
		}
		referenceCSFFile(t) {
			(this.exportsToCSFFile.set(t.moduleExports, t),
				this.exportsToCSFFile.set(t.moduleExports.default, t),
				this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
					const o = t.stories[n.id];
					(this.storyIdToCSFFile.set(o.id, t), this.exportToStory.set(o.moduleExport, n));
				}));
		}
		attachCSFFile(t) {
			if (!this.exportsToCSFFile.has(t.moduleExports))
				throw new Error('Cannot attach a CSF file that has not been referenced');
			if (this.attachedCSFFiles.has(t)) return;
			(this.attachedCSFFiles.add(t),
				this.store.componentStoriesFromCSFFile({ csfFile: t }).forEach((n) => {
					(this.nameToStoryId.set(n.name, n.id),
						this.componentStoriesValue.push(n),
						this.primaryStory || (this.primaryStory = n));
				}));
		}
		referenceMeta(t, r) {
			const n = this.resolveModuleExport(t);
			if (n.type !== 'meta')
				throw new Error(
					'<Meta of={} /> must reference a CSF file module export or meta export. Did you mistakenly reference your component instead of your CSF file?'
				);
			r && this.attachCSFFile(n.csfFile);
		}
		get projectAnnotations() {
			const { projectAnnotations: t } = this.store;
			if (!t)
				throw new Error(
					"Can't get projectAnnotations from DocsContext before they are initialized"
				);
			return t;
		}
		resolveAttachedModuleExportType(t) {
			if (t === 'story') {
				if (!this.primaryStory)
					throw new Error(
						'No primary story attached to this docs file, did you forget to use <Meta of={} />?'
					);
				return { type: 'story', story: this.primaryStory };
			}
			if (this.attachedCSFFiles.size === 0)
				throw new Error(
					'No CSF file attached to this docs file, did you forget to use <Meta of={} />?'
				);
			const r = Array.from(this.attachedCSFFiles)[0];
			if (t === 'meta') return { type: 'meta', csfFile: r };
			const { component: n } = r.meta;
			if (!n)
				throw new Error(
					'Attached CSF file does not defined a component, did you forget to export one?'
				);
			return { type: 'component', component: n };
		}
		resolveModuleExport(t) {
			const r = this.exportsToCSFFile.get(t);
			if (r) return { type: 'meta', csfFile: r };
			const n = this.exportToStory.get(xc(t) ? t.input : t);
			return n ? { type: 'story', story: n } : { type: 'component', component: t };
		}
		resolveOf(t, r = []) {
			let n;
			if (['component', 'meta', 'story'].includes(t)) {
				const o = t;
				n = this.resolveAttachedModuleExportType(o);
			} else n = this.resolveModuleExport(t);
			if (r.length && !r.includes(n.type)) {
				const o = n.type === 'component' ? 'component or unknown' : n.type;
				throw new Error(Ee`Invalid value passed to the 'of' prop. The value was resolved to a '${o}' type but the only types for this block are: ${r.join(', ')}.
        - Did you pass a component to the 'of' prop when the block only supports a story or a meta?
        - ... or vice versa?
        - Did you pass a story, CSF file or meta to the 'of' prop that is not indexed, ie. is not targeted by the 'stories' globs in the main configuration?`);
			}
			switch (n.type) {
				case 'component':
					return { ...n, projectAnnotations: this.projectAnnotations };
				case 'meta':
					return { ...n, preparedMeta: this.store.preparedMetaFromCSFFile({ csfFile: n.csfFile }) };
				case 'story':
				default:
					return n;
			}
		}
	};
i(rM, 'DocsContext');
var Qg = rM,
	nM = class {
		constructor(t, r, n, o) {
			((this.channel = t),
				(this.store = r),
				(this.entry = n),
				(this.callbacks = o),
				(this.type = 'docs'),
				(this.subtype = 'csf'),
				(this.torndown = !1),
				(this.disableKeyListeners = !1),
				(this.preparing = !1),
				(this.id = n.id),
				(this.renderId = Date.now()));
		}
		isPreparing() {
			return this.preparing;
		}
		async prepare() {
			this.preparing = !0;
			const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
			if (this.torndown) throw qc;
			const { importPath: n, title: o } = this.entry,
				s = this.store.processCSFFileWithCache(t, n, o),
				a = Object.keys(s.stories)[0];
			((this.story = this.store.storyFromCSFFile({ storyId: a, csfFile: s })),
				(this.csfFiles = [s, ...r]),
				(this.preparing = !1));
		}
		isEqual(t) {
			return !!(this.id === t.id && this.story && this.story === t.story);
		}
		docsContext(t) {
			if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
			const r = new Qg(this.channel, this.store, t, this.csfFiles);
			return (this.csfFiles.forEach((n) => r.attachCSFFile(n)), r);
		}
		async renderToElement(t, r) {
			if (!this.story || !this.csfFiles) throw new Error('Cannot render docs before preparing');
			const n = this.docsContext(r),
				{ docs: o } = this.story.parameters || {};
			if (!o)
				throw new Error(
					'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed'
				);
			const s = await o.renderer(),
				{ render: a } = s,
				u = i(async () => {
					try {
						(await a(n, o, t), this.channel.emit(Wf, this.id));
					} catch (c) {
						this.callbacks.showException(c);
					}
				}, 'renderDocs');
			return (
				(this.rerender = async () => u()),
				(this.teardownRender = async ({ viewModeChanged: c }) => {
					!c || !t || s.unmount(t);
				}),
				u()
			);
		}
		async teardown({ viewModeChanged: t } = {}) {
			(this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
		}
	};
i(nM, 'CsfDocsRender');
var nE = nM,
	oM = class {
		constructor(t, r, n, o) {
			((this.channel = t),
				(this.store = r),
				(this.entry = n),
				(this.callbacks = o),
				(this.type = 'docs'),
				(this.subtype = 'mdx'),
				(this.torndown = !1),
				(this.disableKeyListeners = !1),
				(this.preparing = !1),
				(this.id = n.id),
				(this.renderId = Date.now()));
		}
		isPreparing() {
			return this.preparing;
		}
		async prepare() {
			this.preparing = !0;
			const { entryExports: t, csfFiles: r = [] } = await this.store.loadEntry(this.id);
			if (this.torndown) throw qc;
			((this.csfFiles = r), (this.exports = t), (this.preparing = !1));
		}
		isEqual(t) {
			return !!(this.id === t.id && this.exports && this.exports === t.exports);
		}
		docsContext(t) {
			if (!this.csfFiles) throw new Error('Cannot render docs before preparing');
			return new Qg(this.channel, this.store, t, this.csfFiles);
		}
		async renderToElement(t, r) {
			if (!this.exports || !this.csfFiles || !this.store.projectAnnotations)
				throw new Error('Cannot render docs before preparing');
			const n = this.docsContext(r),
				{ docs: o } = this.store.projectAnnotations.parameters ?? {};
			if (!o)
				throw new Error(
					'Cannot render a story in viewMode=docs if `@storybook/addon-docs` is not installed'
				);
			const s = { ...o, page: this.exports.default },
				a = await o.renderer(),
				{ render: u } = a,
				c = i(async () => {
					try {
						(await u(n, s, t), this.channel.emit(Wf, this.id));
					} catch (d) {
						this.callbacks.showException(d);
					}
				}, 'renderDocs');
			return (
				(this.rerender = async () => c()),
				(this.teardownRender = async ({ viewModeChanged: d } = {}) => {
					!d || !t || (a.unmount(t), (this.torndown = !0));
				}),
				c()
			);
		}
		async teardown({ viewModeChanged: t } = {}) {
			(this.teardownRender?.({ viewModeChanged: t }), (this.torndown = !0));
		}
	};
i(oM, 'MdxDocsRender');
var oE = oM,
	yz = globalThis;
function iM(e) {
	const t = (e.composedPath && e.composedPath()[0]) || e.target;
	return /input|textarea/i.test(t.tagName) || t.getAttribute('contenteditable') !== null;
}
i(iM, 'focusInInput');
var sM = 'attached-mdx',
	gz = 'unattached-mdx';
function aM({ tags: e }) {
	return e?.includes(gz) || e?.includes(sM);
}
i(aM, 'isMdxEntry');
function ul(e) {
	return e.type === 'story';
}
i(ul, 'isStoryRender');
function lM(e) {
	return e.type === 'docs';
}
i(lM, 'isDocsRender');
function uM(e) {
	return lM(e) && e.subtype === 'csf';
}
i(uM, 'isCsfDocsRender');
var cM = class extends tM {
	constructor(t, r, n, o) {
		(super(t, r, void 0, !1),
			(this.importFn = t),
			(this.getProjectAnnotations = r),
			(this.selectionStore = n),
			(this.view = o),
			this.initialize());
	}
	setupListeners() {
		(super.setupListeners(),
			(yz.onkeydown = this.onKeydown.bind(this)),
			this.channel.on(Xf, this.onSetCurrentStory.bind(this)),
			this.channel.on(mT, this.onUpdateQueryParams.bind(this)),
			this.channel.on(tT, this.onPreloadStories.bind(this)));
	}
	async setInitialGlobals() {
		if (!this.storyStoreValue) throw new Vt({ methodName: 'setInitialGlobals' });
		const { globals: t } = this.selectionStore.selectionSpecifier || {};
		(t && this.storyStoreValue.userGlobals.updateFromPersisted(t), this.emitGlobals());
	}
	async initializeWithStoryIndex(t) {
		return (await super.initializeWithStoryIndex(t), this.selectSpecifiedStory());
	}
	async selectSpecifiedStory() {
		if (!this.storyStoreValue) throw new Vt({ methodName: 'selectSpecifiedStory' });
		if (this.selectionStore.selection) {
			await this.renderSelection();
			return;
		}
		if (!this.selectionStore.selectionSpecifier) {
			this.renderMissingStory();
			return;
		}
		const { storySpecifier: t, args: r } = this.selectionStore.selectionSpecifier,
			n = this.storyStoreValue.storyIndex.entryFromSpecifier(t);
		if (!n) {
			t === '*'
				? this.renderStoryLoadingException(t, new Z_())
				: this.renderStoryLoadingException(t, new tw({ storySpecifier: t.toString() }));
			return;
		}
		const { id: o, type: s } = n;
		(this.selectionStore.setSelection({ storyId: o, viewMode: s }),
			this.channel.emit(cT, this.selectionStore.selection),
			this.channel.emit(Nd, this.selectionStore.selection),
			await this.renderSelection({ persistedArgs: r }));
	}
	async onGetProjectAnnotationsChanged({ getProjectAnnotations: t }) {
		(await super.onGetProjectAnnotationsChanged({ getProjectAnnotations: t }),
			this.selectionStore.selection && this.renderSelection());
	}
	async onStoriesChanged({ importFn: t, storyIndex: r }) {
		(await super.onStoriesChanged({ importFn: t, storyIndex: r }),
			this.selectionStore.selection
				? await this.renderSelection()
				: await this.selectSpecifiedStory());
	}
	onKeydown(t) {
		if (!this.storyRenders.find((r) => r.disableKeyListeners) && !iM(t)) {
			const { altKey: r, ctrlKey: n, metaKey: o, shiftKey: s, key: a, code: u, keyCode: c } = t;
			this.channel.emit(nT, {
				event: { altKey: r, ctrlKey: n, metaKey: o, shiftKey: s, key: a, code: u, keyCode: c }
			});
		}
	}
	async onSetCurrentStory(t) {
		(this.selectionStore.setSelection({ viewMode: 'story', ...t }),
			await this.storeInitializationPromise,
			this.channel.emit(Nd, this.selectionStore.selection),
			this.renderSelection());
	}
	onUpdateQueryParams(t) {
		this.selectionStore.setQueryParams(t);
	}
	async onUpdateGlobals({ globals: t }) {
		const r = (this.currentRender instanceof Af && this.currentRender.story) || void 0;
		(super.onUpdateGlobals({ globals: t, currentStory: r }),
			(this.currentRender instanceof oE || this.currentRender instanceof nE) &&
				(await this.currentRender.rerender?.()));
	}
	async onUpdateArgs({ storyId: t, updatedArgs: r }) {
		super.onUpdateArgs({ storyId: t, updatedArgs: r });
	}
	async onPreloadStories({ ids: t }) {
		(await this.storeInitializationPromise,
			this.storyStoreValue &&
				(await Promise.allSettled(t.map((r) => this.storyStoreValue?.loadEntry(r)))));
	}
	async renderSelection({ persistedArgs: t } = {}) {
		const { renderToCanvas: r } = this;
		if (!this.storyStoreValue || !r) throw new Vt({ methodName: 'renderSelection' });
		const { selection: n } = this.selectionStore;
		if (!n) throw new Error('Cannot call renderSelection as no selection was made');
		const { storyId: o } = n;
		let s;
		try {
			s = await this.storyStoreValue.storyIdToEntry(o);
		} catch (m) {
			(this.currentRender && (await this.teardownRender(this.currentRender)),
				this.renderStoryLoadingException(o, m));
			return;
		}
		const a = this.currentSelection?.storyId !== o,
			u = this.currentRender?.type !== s.type;
		(s.type === 'story'
			? this.view.showPreparingStory({ immediate: u })
			: this.view.showPreparingDocs({ immediate: u }),
			this.currentRender?.isPreparing() && (await this.teardownRender(this.currentRender)));
		let c;
		s.type === 'story'
			? (c = new Af(this.channel, this.storyStoreValue, r, this.mainStoryCallbacks(o), o, 'story'))
			: aM(s)
				? (c = new oE(this.channel, this.storyStoreValue, s, this.mainStoryCallbacks(o)))
				: (c = new nE(this.channel, this.storyStoreValue, s, this.mainStoryCallbacks(o)));
		const d = this.currentSelection;
		this.currentSelection = n;
		const p = this.currentRender;
		this.currentRender = c;
		try {
			await c.prepare();
		} catch (m) {
			(p && (await this.teardownRender(p)), m !== qc && this.renderStoryLoadingException(o, m));
			return;
		}
		const f = !a && p && !c.isEqual(p);
		if (
			(t && ul(c) && (Cr(!!c.story), this.storyStoreValue.args.updateFromPersisted(c.story, t)),
			p && !p.torndown && !a && !f && !u)
		) {
			((this.currentRender = p), this.channel.emit(pT, o), this.view.showMain());
			return;
		}
		if (
			(p && (await this.teardownRender(p, { viewModeChanged: u })),
			d && (a || u) && this.channel.emit(sT, o),
			ul(c))
		) {
			Cr(!!c.story);
			const {
				parameters: m,
				initialArgs: y,
				argTypes: g,
				unmappedArgs: E,
				initialGlobals: T,
				userGlobals: b,
				storyGlobals: w,
				globals: P
			} = this.storyStoreValue.getStoryContext(c.story);
			(this.channel.emit(uT, { id: o, parameters: m, initialArgs: y, argTypes: g, args: E }),
				this.channel.emit($s, { userGlobals: b, storyGlobals: w, globals: P, initialGlobals: T }));
		} else {
			let { parameters: m } = this.storyStoreValue.projectAnnotations;
			const { initialGlobals: y, globals: g } = this.storyStoreValue.userGlobals;
			if (
				(this.channel.emit($s, { globals: g, initialGlobals: y, storyGlobals: {}, userGlobals: g }),
				uM(c) || c.entry.tags?.includes(sM))
			) {
				if (!c.csfFiles) throw new X_({ storyId: o });
				({ parameters: m } = this.storyStoreValue.preparedMetaFromCSFFile({
					csfFile: c.csfFiles[0]
				}));
			}
			this.channel.emit(QE, { id: o, parameters: m });
		}
		ul(c)
			? (Cr(!!c.story),
				this.storyRenders.push(c),
				this.currentRender.renderToElement(this.view.prepareForStory(c.story)))
			: this.currentRender.renderToElement(
					this.view.prepareForDocs(),
					this.renderStoryToElement.bind(this)
				);
	}
	async teardownRender(t, { viewModeChanged: r = !1 } = {}) {
		((this.storyRenders = this.storyRenders.filter((n) => n !== t)),
			await t?.teardown?.({ viewModeChanged: r }));
	}
	mainStoryCallbacks(t) {
		return {
			showStoryDuringRender: i(() => this.view.showStoryDuringRender(), 'showStoryDuringRender'),
			showMain: i(() => this.view.showMain(), 'showMain'),
			showError: i((r) => this.renderError(t, r), 'showError'),
			showException: i((r) => this.renderException(t, r), 'showException')
		};
	}
	renderPreviewEntryError(t, r) {
		(super.renderPreviewEntryError(t, r), this.view.showErrorDisplay(r));
	}
	renderMissingStory() {
		(this.view.showNoPreview(), this.channel.emit(Md));
	}
	renderStoryLoadingException(t, r) {
		(Je.error(r), this.view.showErrorDisplay(r), this.channel.emit(Md, t));
	}
	renderException(t, r) {
		const { name: n = 'Error', message: o = String(r), stack: s } = r,
			a = this.currentRender?.renderId;
		(this.channel.emit(dT, { name: n, message: o, stack: s }),
			this.channel.emit(fo, { newPhase: 'errored', renderId: a, storyId: t }),
			this.view.showErrorDisplay(r),
			Je.error(`Error rendering story '${t}':`),
			Je.error(r));
	}
	renderError(t, { title: r, description: n }) {
		const o = this.currentRender?.renderId;
		(this.channel.emit(aT, { title: r, description: n }),
			this.channel.emit(fo, { newPhase: 'errored', renderId: o, storyId: t }),
			this.view.showErrorDisplay({ message: r, stack: n }),
			Je.error(`Error rendering story ${r}: ${n}`));
	}
};
i(cM, 'PreviewWithSelection');
var dM = cM,
	Of = et(Hf(), 1),
	bz = et(Hf(), 1),
	iE = /^[a-zA-Z0-9 _-]*$/,
	pM = /^-?[0-9]+(\.[0-9]+)?$/,
	vz = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i,
	fM =
		/^(rgba?|hsla?)\(([0-9]{1,3}),\s?([0-9]{1,3})%?,\s?([0-9]{1,3})%?,?\s?([0-9](\.[0-9]{1,2})?)?\)$/i,
	Cf = i(
		(e = '', t) =>
			e === null || e === '' || !iE.test(e)
				? !1
				: t == null || t instanceof Date || typeof t == 'number' || typeof t == 'boolean'
					? !0
					: typeof t == 'string'
						? iE.test(t) || pM.test(t) || vz.test(t) || fM.test(t)
						: Array.isArray(t)
							? t.every((r) => Cf(e, r))
							: hr(t)
								? Object.entries(t).every(([r, n]) => Cf(r, n))
								: !1,
		'validateArgs'
	),
	Ez = {
		delimiter: ';',
		nesting: !0,
		arrayRepeat: !0,
		arrayRepeatSyntax: 'bracket',
		nestingSyntax: 'js',
		valueDeserializer(e) {
			if (e.startsWith('!')) {
				if (e === '!undefined') return;
				if (e === '!null') return null;
				if (e === '!true') return !0;
				if (e === '!false') return !1;
				if (e.startsWith('!date(') && e.endsWith(')'))
					return new Date(e.replaceAll(' ', '+').slice(6, -1));
				if (e.startsWith('!hex(') && e.endsWith(')')) return `#${e.slice(5, -1)}`;
				const t = e.slice(1).match(fM);
				if (t)
					return e.startsWith('!rgba') || e.startsWith('!RGBA')
						? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]}, ${t[5]})`
						: e.startsWith('!hsla') || e.startsWith('!HSLA')
							? `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%, ${t[5]})`
							: e.startsWith('!rgb') || e.startsWith('!RGB')
								? `${t[1]}(${t[2]}, ${t[3]}, ${t[4]})`
								: `${t[1]}(${t[2]}, ${t[3]}%, ${t[4]}%)`;
			}
			return pM.test(e) ? Number(e) : e;
		}
	},
	sE = i((e) => {
		const t = e.split(';').map((r) => r.replace('=', '~').replace(':', '='));
		return Object.entries((0, bz.parse)(t.join(';'), Ez)).reduce(
			(r, [n, o]) =>
				Cf(n, o)
					? Object.assign(r, { [n]: o })
					: (Ye.warn(Ee`
      Omitted potentially unsafe URL args.

      More info: https://storybook.js.org/docs/writing-stories/args#setting-args-through-the-url?ref=error
    `),
						r),
			{}
		);
	}, 'parseArgsParam'),
	{ history: mM, document: Rn } = te;
function hM(e) {
	const t = (e || '').match(/^\/story\/(.+)/);
	if (!t) throw new Error(`Invalid path '${e}',  must start with '/story/'`);
	return t[1];
}
i(hM, 'pathToId');
var yM = i(({ selection: e, extraParams: t }) => {
		const r = Rn?.location.search.slice(1),
			{ path: n, selectedKind: o, selectedStory: s, ...a } = (0, Of.parse)(r);
		return `?${(0, Of.stringify)({ ...a, ...t, ...(e && { id: e.storyId, viewMode: e.viewMode }) })}`;
	}, 'getQueryString'),
	Tz = i((e) => {
		if (!e) return;
		const t = yM({ selection: e }),
			{ hash: r = '' } = Rn.location;
		((Rn.title = e.storyId), mM.replaceState({}, '', `${Rn.location.pathname}${t}${r}`));
	}, 'setPath'),
	_z = i((e) => e != null && typeof e == 'object' && Array.isArray(e) === !1, 'isObject'),
	Ls = i((e) => {
		if (e !== void 0) {
			if (typeof e == 'string') return e;
			if (Array.isArray(e)) return Ls(e[0]);
			if (_z(e)) return Ls(Object.values(e).filter(Boolean));
		}
	}, 'getFirstString'),
	wz = i(() => {
		if (typeof Rn < 'u') {
			const e = Rn.location.search.slice(1),
				t = (0, Of.parse)(e),
				r = typeof t.args == 'string' ? sE(t.args) : void 0,
				n = typeof t.globals == 'string' ? sE(t.globals) : void 0;
			let o = Ls(t.viewMode);
			(typeof o != 'string' || !o.match(/docs|story/)) && (o = 'story');
			const s = Ls(t.path),
				a = s ? hM(s) : Ls(t.id);
			if (a) return { storySpecifier: a, args: r, globals: n, viewMode: o };
		}
		return null;
	}, 'getSelectionSpecifierFromPath'),
	gM = class {
		constructor() {
			this.selectionSpecifier = wz();
		}
		setSelection(t) {
			((this.selection = t), Tz(this.selection));
		}
		setQueryParams(t) {
			const r = yM({ extraParams: t }),
				{ hash: n = '' } = Rn.location;
			mM.replaceState({}, '', `${Rn.location.pathname}${r}${n}`);
		}
	};
i(gM, 'UrlStore');
var bM = gM,
	Sz = et(WL(), 1),
	Rz = et(Hf(), 1),
	{ document: wt } = te,
	aE = 100,
	vM = ((e) => (
		(e.MAIN = 'MAIN'),
		(e.NOPREVIEW = 'NOPREVIEW'),
		(e.PREPARING_STORY = 'PREPARING_STORY'),
		(e.PREPARING_DOCS = 'PREPARING_DOCS'),
		(e.ERROR = 'ERROR'),
		e
	))(vM || {}),
	wd = {
		PREPARING_STORY: 'sb-show-preparing-story',
		PREPARING_DOCS: 'sb-show-preparing-docs',
		MAIN: 'sb-show-main',
		NOPREVIEW: 'sb-show-nopreview',
		ERROR: 'sb-show-errordisplay'
	},
	Sd = { centered: 'sb-main-centered', fullscreen: 'sb-main-fullscreen', padded: 'sb-main-padded' },
	lE = new Sz.default({ escapeXML: !0 }),
	EM = class {
		constructor() {
			if (((this.testing = !1), typeof wt < 'u')) {
				const { __SPECIAL_TEST_PARAMETER__: t } = (0, Rz.parse)(wt.location.search.slice(1));
				switch (t) {
					case 'preparing-story': {
						(this.showPreparingStory(), (this.testing = !0));
						break;
					}
					case 'preparing-docs': {
						(this.showPreparingDocs(), (this.testing = !0));
						break;
					}
				}
			}
		}
		prepareForStory(t) {
			return (
				this.showStory(),
				this.applyLayout(t.parameters.layout),
				(wt.documentElement.scrollTop = 0),
				(wt.documentElement.scrollLeft = 0),
				this.storyRoot()
			);
		}
		storyRoot() {
			return wt.getElementById('storybook-root');
		}
		prepareForDocs() {
			return (
				this.showMain(),
				this.showDocs(),
				this.applyLayout('fullscreen'),
				(wt.documentElement.scrollTop = 0),
				(wt.documentElement.scrollLeft = 0),
				this.docsRoot()
			);
		}
		docsRoot() {
			return wt.getElementById('storybook-docs');
		}
		applyLayout(t = 'padded') {
			if (t === 'none') {
				(wt.body.classList.remove(this.currentLayoutClass), (this.currentLayoutClass = null));
				return;
			}
			this.checkIfLayoutExists(t);
			const r = Sd[t];
			(wt.body.classList.remove(this.currentLayoutClass),
				wt.body.classList.add(r),
				(this.currentLayoutClass = r));
		}
		checkIfLayoutExists(t) {
			Sd[t] ||
				Je.warn(Ee`
          The desired layout: ${t} is not a valid option.
          The possible options are: ${Object.keys(Sd).join(', ')}, none.
        `);
		}
		showMode(t) {
			(clearTimeout(this.preparingTimeout),
				Object.keys(vM).forEach((r) => {
					r === t ? wt.body.classList.add(wd[r]) : wt.body.classList.remove(wd[r]);
				}));
		}
		showErrorDisplay({ message: t = '', stack: r = '' }) {
			let n = t,
				o = r;
			const s = t.split(`
`);
			(s.length > 1 &&
				(([n] = s),
				(o = s
					.slice(1)
					.join(
						`
`
					)
					.replace(/^\n/, ''))),
				(wt.getElementById('error-message').innerHTML = lE.toHtml(n)),
				(wt.getElementById('error-stack').innerHTML = lE.toHtml(o)),
				this.showMode('ERROR'));
		}
		showNoPreview() {
			this.testing ||
				(this.showMode('NOPREVIEW'),
				this.storyRoot()?.setAttribute('hidden', 'true'),
				this.docsRoot()?.setAttribute('hidden', 'true'));
		}
		showPreparingStory({ immediate: t = !1 } = {}) {
			(clearTimeout(this.preparingTimeout),
				t
					? this.showMode('PREPARING_STORY')
					: (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_STORY'), aE)));
		}
		showPreparingDocs({ immediate: t = !1 } = {}) {
			(clearTimeout(this.preparingTimeout),
				t
					? this.showMode('PREPARING_DOCS')
					: (this.preparingTimeout = setTimeout(() => this.showMode('PREPARING_DOCS'), aE)));
		}
		showMain() {
			this.showMode('MAIN');
		}
		showDocs() {
			(this.storyRoot().setAttribute('hidden', 'true'), this.docsRoot().removeAttribute('hidden'));
		}
		showStory() {
			(this.docsRoot().setAttribute('hidden', 'true'), this.storyRoot().removeAttribute('hidden'));
		}
		showStoryDuringRender() {
			wt.body.classList.add(wd.MAIN);
		}
	};
i(EM, 'WebView');
var TM = EM,
	_M = class extends dM {
		constructor(t, r) {
			(super(t, r, new bM(), new TM()),
				(this.importFn = t),
				(this.getProjectAnnotations = r),
				(te.__STORYBOOK_PREVIEW__ = this));
		}
	};
i(_M, 'PreviewWeb');
var Pz = _M,
	{ document: lo } = te,
	Az = [
		'application/javascript',
		'application/ecmascript',
		'application/x-ecmascript',
		'application/x-javascript',
		'text/ecmascript',
		'text/javascript',
		'text/javascript1.0',
		'text/javascript1.1',
		'text/javascript1.2',
		'text/javascript1.3',
		'text/javascript1.4',
		'text/javascript1.5',
		'text/jscript',
		'text/livescript',
		'text/x-ecmascript',
		'text/x-javascript',
		'module'
	],
	Oz = 'script',
	uE = 'scripts-root';
function su() {
	const e = lo.createEvent('Event');
	(e.initEvent('DOMContentLoaded', !0, !0), lo.dispatchEvent(e));
}
i(su, 'simulateDOMContentLoaded');
function wM(e, t, r) {
	const n = lo.createElement('script');
	((n.type = e.type === 'module' ? 'module' : 'text/javascript'),
		e.src ? ((n.onload = t), (n.onerror = t), (n.src = e.src)) : (n.textContent = e.innerText),
		r ? r.appendChild(n) : lo.head.appendChild(n),
		e.parentNode.removeChild(e),
		e.src || t());
}
i(wM, 'insertScript');
function Zg(e, t, r = 0) {
	e[r](() => {
		(r++, r === e.length ? t() : Zg(e, t, r));
	});
}
i(Zg, 'insertScriptsSequentially');
function SM(e) {
	let t = lo.getElementById(uE);
	t ? (t.innerHTML = '') : ((t = lo.createElement('div')), (t.id = uE), lo.body.appendChild(t));
	const r = Array.from(e.querySelectorAll(Oz));
	if (r.length) {
		const n = [];
		(r.forEach((o) => {
			const s = o.getAttribute('type');
			(!s || Az.includes(s)) && n.push((a) => wM(o, a, t));
		}),
			n.length && Zg(n, su, void 0));
	} else su();
}
i(SM, 'simulatePageLoad');
var Rd;
(function (e) {
	((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((Rd = Rd || (Rd = {})));
function RM(e) {
	return (
		e.start +
		e.delimiter +
		e.postDelimiter +
		e.tag +
		e.postTag +
		e.type +
		e.postType +
		e.name +
		e.postName +
		e.description +
		e.end +
		e.lineEnd
	);
}
i(RM, 'join');
function Cz() {
	return (e) =>
		e.source.map(({ tokens: t }) => RM(t)).join(`
`);
}
i(Cz, 'getStringifier');
var xz = et(KL(), 1),
	No = (0, xz.stringifyRules)(),
	Iz = No.JsdocTypeObject;
No.JsdocTypeAny = () => 'any';
No.JsdocTypeObject = (e, t) => `(${Iz(e, t)})`;
No.JsdocTypeOptional = (e, t) => t(e.element);
No.JsdocTypeNullable = (e, t) => t(e.element);
No.JsdocTypeNotNullable = (e, t) => t(e.element);
No.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
var Nz = 'storybook/docs',
	Mz = `${Nz}/snippet-rendered`;
async function PM(e, t) {
	const r = t.parameters?.docs?.source?.transform,
		{ id: n, unmappedArgs: o } = t,
		s = r && e ? r?.(e, t) : e,
		a = s ? await s : void 0;
	ir.getChannel().emit(Mz, { id: n, source: a, args: o });
}
i(PM, 'emitTransformCode');
var ua = { depth: 10, clearOnStoryChange: !0, limit: 50 },
	qz = i((e = {}) => {
		Object.assign(ua, e);
	}, 'configureActions'),
	AM = i((e, t) => {
		const r = Object.getPrototypeOf(e);
		return !r || t(r) ? r : AM(r, t);
	}, 'findProto'),
	jz = i(
		(e) =>
			!!(
				typeof e == 'object' &&
				e &&
				AM(e, (t) => /^Synthetic(?:Base)?Event$/.test(t.constructor.name)) &&
				typeof e.persist == 'function'
			),
		'isReactSyntheticEvent'
	),
	Dz = i((e) => {
		if (jz(e)) {
			const t = Object.create(e.constructor.prototype, Object.getOwnPropertyDescriptors(e));
			t.persist();
			const r = Object.getOwnPropertyDescriptor(t, 'view'),
				n = r?.value;
			return (
				typeof n == 'object' &&
					n?.constructor.name === 'Window' &&
					Object.defineProperty(t, 'view', { ...r, value: Object.create(n.constructor.prototype) }),
				t
			);
		}
		return e;
	}, 'serializeArg');
function Li(e, t = {}) {
	const r = { ...ua, ...t },
		n = i(function (...s) {
			if (t.implicit) {
				const y = (
					'__STORYBOOK_PREVIEW__' in te ? te.__STORYBOOK_PREVIEW__ : void 0
				)?.storyRenders.find((g) => g.phase === 'playing' || g.phase === 'rendering');
				if (y) {
					const g = !globalThis?.FEATURES?.disallowImplicitActionsInRenderV8,
						E = new $_({ phase: y.phase, name: e, deprecated: g });
					if (g) console.warn(E);
					else throw E;
				}
			}
			const a = ir.getChannel(),
				u = Date.now().toString(36) + Math.random().toString(36).substring(2),
				c = 5,
				d = s.map(Dz),
				p = s.length > 1 ? d : d[0],
				f = {
					id: u,
					count: 0,
					data: { name: e, args: p },
					options: { ...r, maxDepth: c + (r.depth || 3) }
				};
			a.emit(Ew, f);
		}, 'actionHandler');
	return ((n.isAction = !0), (n.implicit = t.implicit), n);
}
i(Li, 'action');
var kz = i((...e) => {
		let t = ua,
			r = e;
		(r.length === 1 && Array.isArray(r[0]) && ([r] = r),
			r.length !== 1 && typeof r[r.length - 1] != 'string' && (t = { ...ua, ...r.pop() }));
		let n = r[0];
		(r.length !== 1 || typeof n == 'string') &&
			((n = {}),
			r.forEach((s) => {
				n[s] = s;
			}));
		const o = {};
		return (
			Object.keys(n).forEach((s) => {
				o[s] = Li(n[s], t);
			}),
			o
		);
	}, 'actions'),
	Lz = {
		'@storybook/global': gT,
		'storybook/test': Jw,
		'storybook/actions': vw,
		'storybook/preview-api': Fd,
		'storybook/internal/channels': vT,
		'storybook/internal/client-logger': TT,
		'storybook/internal/core-events': Gf,
		'storybook/internal/types': gw,
		'storybook/internal/preview-errors': j_,
		'storybook/internal/preview-api': Fd
	};
async function OM() {
	const e = new URL(window.location.href);
	if (e.searchParams.get('navigator') !== 'true' || globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__)
		return;
	globalThis.__STORYBOOK_PREVIEW_NAVIGATOR__ = !0;
	const t = await (await fetch('/index.json')).json(),
		r = e.searchParams.get('id');
	if (!r) {
		const n = Object.values(t.entries)[0];
		n &&
			(e.searchParams.set('id', n.id),
			e.searchParams.set('viewMode', n.type),
			(window.location.href = e.toString()));
		return;
	}
	Fz(t, r);
}
i(OM, 'maybeSetupPreviewNavigator');
var Fz = i(async (e, t) => {
		const r = { entries: {} };
		for (const u of Object.values(e.entries)) {
			const c = u.title.split('/');
			let d = r;
			for (const p of c)
				(d.entries || (d.entries = {}),
					d.entries[p]
						? t === u.id && (d.entries[p].isActive = !0)
						: (d.entries[p] = { title: p, isActive: t === u.id, entries: {} }),
					(d = d.entries[p]));
			(d.entries || (d.entries = {}),
				(d.entries[u.name] = {
					id: u.id,
					name: u.name,
					href: `?id=${u.id}&viewMode=${u.type}&navigator=true`,
					isActive: t === u.id
				}));
		}
		const n = i((u) => {
				if ('entries' in u && 'title' in u) {
					const d = u;
					return `
      <li class="sb-navigator-branch">
        <details${d.isActive ? ' open' : ''}>
          <summary class="sb-navigator-title">
            ${d.title}
          </summary>
          <ul class="sb-navigator-entries" aria-label="${d.title}">
            ${Object.values(d.entries).map(n).join('')}
          </ul>
        </details>
      </li>
      `;
				}
				const c = u;
				return `
      <li class="sb-navigator-story-item">
        <a href="${c.href}" 
           class="sb-navigator-story-link${c.isActive ? ' active' : ''}" 
           aria-current="${c.isActive ? 'location' : 'false'}">${c.name}</a>
      </li>
    `;
			}, 'createHtmlForNode'),
			o = Object.values(r.entries).map(n).join(''),
			s = document.createElement('nav');
		((s.id = 'sb-navigator-container'),
			s.setAttribute('role', 'navigation'),
			s.setAttribute('aria-label', 'Story navigation'),
			(s.innerHTML = `
    <ul class="sb-navigator-list">${o}</ul>
  `),
			document.body.insertBefore(s, document.body.firstChild));
		const a = document.createElement('style');
		((a.id = 'sb-navigator-style'),
			(a.textContent = `
    body {
      display: grid !important;
      grid-template-columns: 300px 1fr;
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      margin: 0;

      --text-color: rgb(46, 52, 56);
      --bg-color: rgb(246, 249, 252);

      @media (prefers-color-scheme: dark) {
        --text-color: rgb(201, 205, 207);
        --bg-color: rgb(34, 36, 37);
      }
    }
    #storybook-root, #storybook-docs {
      overflow-y: auto;
      max-height: 100vh;
      max-width: 100%;
    }
    #sb-navigator-container, #sb-navigator-container * {
      box-sizing: border-box;
    }
    #sb-navigator-container {
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid #eee;
        padding: 1rem;
        font-size: 14px;
        color: var(--text-color);
        background-color: var(--bg-color);
        align-self: start;
        z-index: 1000;
    }
    .sb-main-padded #sb-navigator-container {
      margin: -1rem 1rem -1rem -1rem;
    }
    .sb-navigator-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    .sb-navigator-branch {
      list-style-type: none;
    }
    .sb-navigator-item {
      margin-bottom: 15px;
    }
    .sb-navigator-title {
      color: var(--text-color);
      text-decoration: none;
      padding-block: 5px;
      cursor: pointer;
    }
    .sb-navigator-entries {
      padding-left: 15px;
    }
    .sb-navigator-story-item {
      margin-bottom: 8px;
      margin-left: 8px;
    }
    .sb-navigator-story-link {
      color: var(--text-color);
    }
    .sb-navigator-story-link.active {
      font-weight: bold;
      color: rgb(2, 156, 253);
    }
  `),
			document.head.appendChild(a),
			s
				.querySelector('.sb-navigator-story-link.active')
				?.closest('details')
				?.scrollIntoView({ block: 'center' }));
	}, 'setupPreviewNavigator'),
	Bz = et(YL(), 1),
	Pd;
function CM() {
	return (Pd || (Pd = new Bz.default(te.navigator?.userAgent).getBrowserInfo()), Pd);
}
i(CM, 'getBrowserInfo');
function xM(e) {
	return ((e.browserInfo = CM()), e);
}
i(xM, 'prepareForTelemetry');
function IM(e) {
	const t = e.error || e;
	t.fromStorybook && te.sendTelemetryError(t);
}
i(IM, 'errorListener');
function NM({ reason: e }) {
	e.fromStorybook && te.sendTelemetryError(e);
}
i(NM, 'unhandledRejectionListener');
function eb() {
	(w1.forEach((e) => {
		te[bT[e]] = Lz[e];
	}),
		(te.sendTelemetryError = (e) => {
			te.__STORYBOOK_ADDONS_CHANNEL__.emit(hT, xM(e));
		}),
		te.addEventListener('error', IM),
		te.addEventListener('unhandledrejection', NM),
		OM());
}
i(eb, 'setup');
eb();
const { createBrowserChannel: Jz } = __STORYBOOK_MODULE_CHANNELS__,
	{ addons: $z } = __STORYBOOK_MODULE_PREVIEW_API__,
	tb = Jz({ page: 'preview' });
$z.setChannel(tb);
window.__STORYBOOK_ADDONS_CHANNEL__ = tb;
window.CONFIG_TYPE === 'DEVELOPMENT' && (window.__STORYBOOK_SERVER_CHANNEL__ = tb);
var Uz = Object.create,
	jc = Object.defineProperty,
	Vz = Object.getOwnPropertyDescriptor,
	MM = Object.getOwnPropertyNames,
	Hz = Object.getPrototypeOf,
	Gz = Object.prototype.hasOwnProperty,
	O = (e, t) => jc(e, 'name', { value: t, configurable: !0 }),
	b6 = ((e) =>
		typeof require < 'u'
			? require
			: typeof Proxy < 'u'
				? new Proxy(e, { get: (t, r) => (typeof require < 'u' ? require : t)[r] })
				: e)(function (e) {
		if (typeof require < 'u') return require.apply(this, arguments);
		throw Error('Dynamic require of "' + e + '" is not supported');
	}),
	zz = (e, t) =>
		function () {
			return (t || (0, e[MM(e)[0]])((t = { exports: {} }).exports, t), t.exports);
		},
	v6 = (e, t) => {
		for (var r in t) jc(e, r, { get: t[r], enumerable: !0 });
	},
	Wz = (e, t, r, n) => {
		if ((t && typeof t == 'object') || typeof t == 'function')
			for (let o of MM(t))
				!Gz.call(e, o) &&
					o !== r &&
					jc(e, o, { get: () => t[o], enumerable: !(n = Vz(t, o)) || n.enumerable });
		return e;
	},
	Kz = (e, t, r) => (
		(r = e != null ? Uz(Hz(e)) : {}),
		Wz(t || !e || !e.__esModule ? jc(r, 'default', { value: e, enumerable: !0 }) : r, e)
	);
function cl(e) {
	if (!e || typeof e != 'object') return !1;
	const t = Object.getPrototypeOf(e);
	return t === null || t === Object.prototype || Object.getPrototypeOf(t) === null
		? Object.prototype.toString.call(e) === '[object Object]'
		: !1;
}
O(cl, 'isPlainObject');
function Yz(e) {
	return e == null || (typeof e != 'object' && typeof e != 'function');
}
O(Yz, 'isPrimitive');
function Xz(e) {
	return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
O(Xz, 'isTypedArray');
function Qz(e) {
	return Object.getOwnPropertySymbols(e).filter((t) =>
		Object.prototype.propertyIsEnumerable.call(e, t)
	);
}
O(Qz, 'getSymbols');
function Zz(e) {
	return e == null
		? e === void 0
			? '[object Undefined]'
			: '[object Null]'
		: Object.prototype.toString.call(e);
}
O(Zz, 'getTag');
var E6 = '[object RegExp]',
	T6 = '[object String]',
	_6 = '[object Number]',
	w6 = '[object Boolean]',
	S6 = '[object Arguments]',
	R6 = '[object Symbol]',
	P6 = '[object Date]',
	A6 = '[object Map]',
	O6 = '[object Set]',
	C6 = '[object Array]',
	x6 = '[object Function]',
	I6 = '[object ArrayBuffer]',
	N6 = '[object Object]',
	M6 = '[object Error]',
	q6 = '[object DataView]',
	j6 = '[object Uint8Array]',
	D6 = '[object Uint8ClampedArray]',
	k6 = '[object Uint16Array]',
	L6 = '[object Uint32Array]',
	F6 = '[object BigUint64Array]',
	B6 = '[object Int8Array]',
	J6 = '[object Int16Array]',
	$6 = '[object Int32Array]',
	U6 = '[object BigInt64Array]',
	V6 = '[object Float32Array]',
	H6 = '[object Float64Array]',
	eW = zz({
		'../node_modules/jsdoc-type-pratt-parser/dist/index.js'(e, t) {
			(function (r, n) {
				typeof e == 'object' && typeof t < 'u'
					? n(e)
					: typeof define == 'function' && define.amd
						? define(['exports'], n)
						: ((r = typeof globalThis < 'u' ? globalThis : r || self), n((r.jtpp = {})));
			})(e, function (r) {
				function n(l) {
					return l.text !== void 0 && l.text !== ''
						? `'${l.type}' with value '${l.text}'`
						: `'${l.type}'`;
				}
				O(n, 'tokenToString');
				const o = class qM extends Error {
					constructor(h) {
						(super(`No parslet found for token: ${n(h)}`),
							(this.token = h),
							Object.setPrototypeOf(this, qM.prototype));
					}
					getToken() {
						return this.token;
					}
				};
				O(o, 'NoParsletFoundError');
				let s = o;
				const a = class jM extends Error {
					constructor(h) {
						(super(`The parsing ended early. The next token was: ${n(h)}`),
							(this.token = h),
							Object.setPrototypeOf(this, jM.prototype));
					}
					getToken() {
						return this.token;
					}
				};
				O(a, 'EarlyEndOfParseError');
				let u = a;
				const c = class DM extends Error {
					constructor(h, v) {
						let x = `Unexpected type: '${h.type}'.`;
						(v !== void 0 && (x += ` Message: ${v}`),
							super(x),
							Object.setPrototypeOf(this, DM.prototype));
					}
				};
				O(c, 'UnexpectedTypeError');
				let d = c;
				function p(l) {
					return (h) => (h.startsWith(l) ? { type: l, text: l } : null);
				}
				O(p, 'makePunctuationRule');
				function f(l) {
					let h = 0,
						v;
					const x = l[0];
					let F = !1;
					if (x !== "'" && x !== '"') return null;
					for (; h < l.length; ) {
						if ((h++, (v = l[h]), !F && v === x)) {
							h++;
							break;
						}
						F = !F && v === '\\';
					}
					if (v !== x) throw new Error('Unterminated String');
					return l.slice(0, h);
				}
				O(f, 'getQuoted');
				const m = new RegExp(
						'[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
						'u'
					),
					y = new RegExp(
						'[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}',
						'u'
					);
				function g(l) {
					let h = l[0];
					if (!m.test(h)) return null;
					let v = 1;
					do {
						if (((h = l[v]), !y.test(h))) break;
						v++;
					} while (v < l.length);
					return l.slice(0, v);
				}
				O(g, 'getIdentifier');
				const E = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
				function T(l) {
					var h, v;
					return (v = (h = E.exec(l)) === null || h === void 0 ? void 0 : h[0]) !== null &&
						v !== void 0
						? v
						: null;
				}
				O(T, 'getNumber');
				const b = O((l) => {
					const h = g(l);
					return h == null ? null : { type: 'Identifier', text: h };
				}, 'identifierRule');
				function w(l) {
					return (h) => {
						if (!h.startsWith(l)) return null;
						const v = h[l.length];
						return v !== void 0 && y.test(v) ? null : { type: l, text: l };
					};
				}
				O(w, 'makeKeyWordRule');
				const P = O((l) => {
						const h = f(l);
						return h == null ? null : { type: 'StringValue', text: h };
					}, 'stringValueRule'),
					I = O((l) => (l.length > 0 ? null : { type: 'EOF', text: '' }), 'eofRule'),
					q = O((l) => {
						const h = T(l);
						return h === null ? null : { type: 'Number', text: h };
					}, 'numberRule'),
					C = [
						I,
						p('=>'),
						p('('),
						p(')'),
						p('{'),
						p('}'),
						p('['),
						p(']'),
						p('|'),
						p('&'),
						p('<'),
						p('>'),
						p(','),
						p(';'),
						p('*'),
						p('?'),
						p('!'),
						p('='),
						p(':'),
						p('...'),
						p('.'),
						p('#'),
						p('~'),
						p('/'),
						p('@'),
						w('undefined'),
						w('null'),
						w('function'),
						w('this'),
						w('new'),
						w('module'),
						w('event'),
						w('extends'),
						w('external'),
						w('infer'),
						w('typeof'),
						w('keyof'),
						w('readonly'),
						w('import'),
						w('is'),
						w('in'),
						w('asserts'),
						q,
						b,
						P
					],
					R = /^\s*\n\s*/,
					_ = class dl {
						static create(h) {
							const v = this.read(h);
							h = v.text;
							const x = this.read(h);
							return ((h = x.text), new dl(h, void 0, v.token, x.token));
						}
						constructor(h, v, x, F) {
							((this.text = ''),
								(this.text = h),
								(this.previous = v),
								(this.current = x),
								(this.next = F));
						}
						static read(h, v = !1) {
							((v = v || R.test(h)), (h = h.trim()));
							for (const x of C) {
								const F = x(h);
								if (F !== null) {
									const z = Object.assign(Object.assign({}, F), { startOfLine: v });
									return ((h = h.slice(z.text.length)), { text: h, token: z });
								}
							}
							throw new Error('Unexpected Token ' + h);
						}
						advance() {
							const h = dl.read(this.text);
							return new dl(h.text, this.current, this.next, h.token);
						}
					};
				O(_, 'Lexer');
				let S = _;
				function D(l) {
					if (l === void 0) throw new Error('Unexpected undefined');
					if (
						l.type === 'JsdocTypeKeyValue' ||
						l.type === 'JsdocTypeParameterList' ||
						l.type === 'JsdocTypeProperty' ||
						l.type === 'JsdocTypeReadonlyProperty' ||
						l.type === 'JsdocTypeObjectField' ||
						l.type === 'JsdocTypeJsdocObjectField' ||
						l.type === 'JsdocTypeIndexSignature' ||
						l.type === 'JsdocTypeMappedType' ||
						l.type === 'JsdocTypeTypeParameter'
					)
						throw new d(l);
					return l;
				}
				O(D, 'assertRootResult');
				function N(l) {
					return l.type === 'JsdocTypeKeyValue' ? H(l) : D(l);
				}
				O(N, 'assertPlainKeyValueOrRootResult');
				function V(l) {
					return l.type === 'JsdocTypeName' ? l : H(l);
				}
				O(V, 'assertPlainKeyValueOrNameResult');
				function H(l) {
					if (l.type !== 'JsdocTypeKeyValue') throw new d(l);
					return l;
				}
				O(H, 'assertPlainKeyValueResult');
				function A(l) {
					var h;
					if (l.type === 'JsdocTypeVariadic') {
						if (((h = l.element) === null || h === void 0 ? void 0 : h.type) === 'JsdocTypeName')
							return l;
						throw new d(l);
					}
					if (l.type !== 'JsdocTypeNumber' && l.type !== 'JsdocTypeName') throw new d(l);
					return l;
				}
				O(A, 'assertNumberOrVariadicNameResult');
				function L(l) {
					if (
						l.type === 'JsdocTypeTuple' ||
						(l.type === 'JsdocTypeGeneric' && l.meta.brackets === 'square')
					)
						return l;
					throw new d(l);
				}
				O(L, 'assertArrayOrTupleResult');
				function B(l) {
					return l.type === 'JsdocTypeIndexSignature' || l.type === 'JsdocTypeMappedType';
				}
				O(B, 'isSquaredProperty');
				var k;
				(function (l) {
					((l[(l.ALL = 0)] = 'ALL'),
						(l[(l.PARAMETER_LIST = 1)] = 'PARAMETER_LIST'),
						(l[(l.OBJECT = 2)] = 'OBJECT'),
						(l[(l.KEY_VALUE = 3)] = 'KEY_VALUE'),
						(l[(l.INDEX_BRACKETS = 4)] = 'INDEX_BRACKETS'),
						(l[(l.UNION = 5)] = 'UNION'),
						(l[(l.INTERSECTION = 6)] = 'INTERSECTION'),
						(l[(l.PREFIX = 7)] = 'PREFIX'),
						(l[(l.INFIX = 8)] = 'INFIX'),
						(l[(l.TUPLE = 9)] = 'TUPLE'),
						(l[(l.SYMBOL = 10)] = 'SYMBOL'),
						(l[(l.OPTIONAL = 11)] = 'OPTIONAL'),
						(l[(l.NULLABLE = 12)] = 'NULLABLE'),
						(l[(l.KEY_OF_TYPE_OF = 13)] = 'KEY_OF_TYPE_OF'),
						(l[(l.FUNCTION = 14)] = 'FUNCTION'),
						(l[(l.ARROW = 15)] = 'ARROW'),
						(l[(l.ARRAY_BRACKETS = 16)] = 'ARRAY_BRACKETS'),
						(l[(l.GENERIC = 17)] = 'GENERIC'),
						(l[(l.NAME_PATH = 18)] = 'NAME_PATH'),
						(l[(l.PARENTHESIS = 19)] = 'PARENTHESIS'),
						(l[(l.SPECIAL_TYPES = 20)] = 'SPECIAL_TYPES'));
				})(k || (k = {}));
				const K = class {
					constructor(h, v, x) {
						((this.grammar = h),
							typeof v == 'string' ? (this._lexer = S.create(v)) : (this._lexer = v),
							(this.baseParser = x));
					}
					get lexer() {
						return this._lexer;
					}
					parse() {
						const h = this.parseType(k.ALL);
						if (this.lexer.current.type !== 'EOF') throw new u(this.lexer.current);
						return h;
					}
					parseType(h) {
						return D(this.parseIntermediateType(h));
					}
					parseIntermediateType(h) {
						const v = this.tryParslets(null, h);
						if (v === null) throw new s(this.lexer.current);
						return this.parseInfixIntermediateType(v, h);
					}
					parseInfixIntermediateType(h, v) {
						let x = this.tryParslets(h, v);
						for (; x !== null; ) ((h = x), (x = this.tryParslets(h, v)));
						return h;
					}
					tryParslets(h, v) {
						for (const x of this.grammar) {
							const F = x(this, v, h);
							if (F !== null) return F;
						}
						return null;
					}
					consume(h) {
						return (
							Array.isArray(h) || (h = [h]),
							h.includes(this.lexer.current.type) ? ((this._lexer = this.lexer.advance()), !0) : !1
						);
					}
					acceptLexerState(h) {
						this._lexer = h.lexer;
					}
				};
				O(K, 'Parser');
				let X = K;
				function ie(l) {
					return l === '}' || l === 'EOF' || l === '|' || l === ',' || l === ')' || l === '>';
				}
				O(ie, 'isQuestionMarkUnknownType');
				const ae = O((l, h, v) => {
					const x = l.lexer.current.type,
						F = l.lexer.next.type;
					return (v == null && x === '?' && !ie(F)) || (v != null && x === '?')
						? (l.consume('?'),
							v == null
								? {
										type: 'JsdocTypeNullable',
										element: l.parseType(k.NULLABLE),
										meta: { position: 'prefix' }
									}
								: { type: 'JsdocTypeNullable', element: D(v), meta: { position: 'suffix' } })
						: null;
				}, 'nullableParslet');
				function W(l) {
					const h = O((v, x, F) => {
						const z = v.lexer.current.type,
							Z = v.lexer.next.type;
						if (F === null) {
							if ('parsePrefix' in l && l.accept(z, Z)) return l.parsePrefix(v);
						} else if ('parseInfix' in l && l.precedence > x && l.accept(z, Z))
							return l.parseInfix(v, F);
						return null;
					}, 'parslet');
					return (Object.defineProperty(h, 'name', { value: l.name }), h);
				}
				O(W, 'composeParslet');
				const le = W({
						name: 'optionalParslet',
						accept: O((l) => l === '=', 'accept'),
						precedence: k.OPTIONAL,
						parsePrefix: O(
							(l) => (
								l.consume('='),
								{
									type: 'JsdocTypeOptional',
									element: l.parseType(k.OPTIONAL),
									meta: { position: 'prefix' }
								}
							),
							'parsePrefix'
						),
						parseInfix: O(
							(l, h) => (
								l.consume('='),
								{ type: 'JsdocTypeOptional', element: D(h), meta: { position: 'suffix' } }
							),
							'parseInfix'
						)
					}),
					ve = W({
						name: 'numberParslet',
						accept: O((l) => l === 'Number', 'accept'),
						parsePrefix: O((l) => {
							const h = parseFloat(l.lexer.current.text);
							return (l.consume('Number'), { type: 'JsdocTypeNumber', value: h });
						}, 'parsePrefix')
					}),
					de = W({
						name: 'parenthesisParslet',
						accept: O((l) => l === '(', 'accept'),
						parsePrefix: O((l) => {
							if ((l.consume('('), l.consume(')')))
								return { type: 'JsdocTypeParameterList', elements: [] };
							const h = l.parseIntermediateType(k.ALL);
							if (!l.consume(')')) throw new Error('Unterminated parenthesis');
							return h.type === 'JsdocTypeParameterList'
								? h
								: h.type === 'JsdocTypeKeyValue'
									? { type: 'JsdocTypeParameterList', elements: [h] }
									: { type: 'JsdocTypeParenthesis', element: D(h) };
						}, 'parsePrefix')
					}),
					ee = W({
						name: 'specialTypesParslet',
						accept: O(
							(l, h) => (l === '?' && ie(h)) || l === 'null' || l === 'undefined' || l === '*',
							'accept'
						),
						parsePrefix: O((l) => {
							if (l.consume('null')) return { type: 'JsdocTypeNull' };
							if (l.consume('undefined')) return { type: 'JsdocTypeUndefined' };
							if (l.consume('*')) return { type: 'JsdocTypeAny' };
							if (l.consume('?')) return { type: 'JsdocTypeUnknown' };
							throw new Error('Unacceptable token: ' + l.lexer.current.text);
						}, 'parsePrefix')
					}),
					xe = W({
						name: 'notNullableParslet',
						accept: O((l) => l === '!', 'accept'),
						precedence: k.NULLABLE,
						parsePrefix: O(
							(l) => (
								l.consume('!'),
								{
									type: 'JsdocTypeNotNullable',
									element: l.parseType(k.NULLABLE),
									meta: { position: 'prefix' }
								}
							),
							'parsePrefix'
						),
						parseInfix: O(
							(l, h) => (
								l.consume('!'),
								{ type: 'JsdocTypeNotNullable', element: D(h), meta: { position: 'suffix' } }
							),
							'parseInfix'
						)
					});
				function Ie({ allowTrailingComma: l }) {
					return W({
						name: 'parameterListParslet',
						accept: O((h) => h === ',', 'accept'),
						precedence: k.PARAMETER_LIST,
						parseInfix: O((h, v) => {
							const x = [N(v)];
							h.consume(',');
							do
								try {
									const F = h.parseIntermediateType(k.PARAMETER_LIST);
									x.push(N(F));
								} catch (F) {
									if (F instanceof s) break;
									throw F;
								}
							while (h.consume(','));
							if (x.length > 0 && x.slice(0, -1).some((F) => F.type === 'JsdocTypeVariadic'))
								throw new Error('Only the last parameter may be a rest parameter');
							return { type: 'JsdocTypeParameterList', elements: x };
						}, 'parseInfix')
					});
				}
				O(Ie, 'createParameterListParslet');
				const Xe = W({
						name: 'genericParslet',
						accept: O((l, h) => l === '<' || (l === '.' && h === '<'), 'accept'),
						precedence: k.GENERIC,
						parseInfix: O((l, h) => {
							const v = l.consume('.');
							l.consume('<');
							const x = [];
							let F = !1;
							if (l.consume('infer')) {
								F = !0;
								const z = l.parseIntermediateType(k.SYMBOL);
								if (z.type !== 'JsdocTypeName')
									throw new d(
										z,
										'A typescript asserts always has to have a name on the left side.'
									);
								x.push(z);
							} else
								do x.push(l.parseType(k.PARAMETER_LIST));
								while (l.consume(','));
							if (!l.consume('>')) throw new Error('Unterminated generic parameter list');
							return Object.assign(
								Object.assign(
									{ type: 'JsdocTypeGeneric', left: D(h), elements: x },
									F ? { infer: !0 } : {}
								),
								{ meta: { brackets: 'angle', dot: v } }
							);
						}, 'parseInfix')
					}),
					rt = W({
						name: 'unionParslet',
						accept: O((l) => l === '|', 'accept'),
						precedence: k.UNION,
						parseInfix: O((l, h) => {
							l.consume('|');
							const v = [];
							do v.push(l.parseType(k.UNION));
							while (l.consume('|'));
							return { type: 'JsdocTypeUnion', elements: [D(h), ...v] };
						}, 'parseInfix')
					}),
					$ = [ae, le, ve, de, ee, xe, Ie({ allowTrailingComma: !0 }), Xe, rt, le];
				function Q({ allowSquareBracketsOnAnyType: l, allowJsdocNamePaths: h, pathGrammar: v }) {
					return O(function (F, z, Z) {
						if (Z == null || z >= k.NAME_PATH) return null;
						const ce = F.lexer.current.type,
							Re = F.lexer.next.type;
						if (
							!(
								(ce === '.' && Re !== '<') ||
								(ce === '[' && (l || Z.type === 'JsdocTypeName')) ||
								(h && (ce === '~' || ce === '#'))
							)
						)
							return null;
						let ke,
							Br = !1;
						F.consume('.')
							? (ke = 'property')
							: F.consume('[')
								? ((ke = 'property-brackets'), (Br = !0))
								: F.consume('~')
									? (ke = 'inner')
									: (F.consume('#'), (ke = 'instance'));
						const us = v !== null ? new X(v, F.lexer, F) : F,
							it = us.parseIntermediateType(k.NAME_PATH);
						F.acceptLexerState(us);
						let ur;
						switch (it.type) {
							case 'JsdocTypeName':
								ur = { type: 'JsdocTypeProperty', value: it.value, meta: { quote: void 0 } };
								break;
							case 'JsdocTypeNumber':
								ur = {
									type: 'JsdocTypeProperty',
									value: it.value.toString(10),
									meta: { quote: void 0 }
								};
								break;
							case 'JsdocTypeStringValue':
								ur = { type: 'JsdocTypeProperty', value: it.value, meta: { quote: it.meta.quote } };
								break;
							case 'JsdocTypeSpecialNamePath':
								if (it.specialType === 'event') ur = it;
								else
									throw new d(
										it,
										"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'"
									);
								break;
							default:
								throw new d(
									it,
									"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'"
								);
						}
						if (Br && !F.consume(']')) {
							const cs = F.lexer.current;
							throw new Error(
								`Unterminated square brackets. Next token is '${cs.type}' with text '${cs.text}'`
							);
						}
						return { type: 'JsdocTypeNamePath', left: D(Z), right: ur, pathType: ke };
					}, 'namePathParslet');
				}
				O(Q, 'createNamePathParslet');
				function re({ allowedAdditionalTokens: l }) {
					return W({
						name: 'nameParslet',
						accept: O(
							(h) => h === 'Identifier' || h === 'this' || h === 'new' || l.includes(h),
							'accept'
						),
						parsePrefix: O((h) => {
							const { type: v, text: x } = h.lexer.current;
							return (h.consume(v), { type: 'JsdocTypeName', value: x });
						}, 'parsePrefix')
					});
				}
				O(re, 'createNameParslet');
				const oe = W({
					name: 'stringValueParslet',
					accept: O((l) => l === 'StringValue', 'accept'),
					parsePrefix: O((l) => {
						const h = l.lexer.current.text;
						return (
							l.consume('StringValue'),
							{
								type: 'JsdocTypeStringValue',
								value: h.slice(1, -1),
								meta: { quote: h[0] === "'" ? 'single' : 'double' }
							}
						);
					}, 'parsePrefix')
				});
				function ne({ pathGrammar: l, allowedTypes: h }) {
					return W({
						name: 'specialNamePathParslet',
						accept: O((v) => h.includes(v), 'accept'),
						parsePrefix: O((v) => {
							const x = v.lexer.current.type;
							if ((v.consume(x), !v.consume(':'))) return { type: 'JsdocTypeName', value: x };
							let F,
								z = v.lexer.current;
							if (v.consume('StringValue'))
								F = {
									type: 'JsdocTypeSpecialNamePath',
									value: z.text.slice(1, -1),
									specialType: x,
									meta: { quote: z.text[0] === "'" ? 'single' : 'double' }
								};
							else {
								let Re = '';
								const Te = ['Identifier', '@', '/'];
								for (; Te.some((ke) => v.consume(ke)); ) ((Re += z.text), (z = v.lexer.current));
								F = {
									type: 'JsdocTypeSpecialNamePath',
									value: Re,
									specialType: x,
									meta: { quote: void 0 }
								};
							}
							const Z = new X(l, v.lexer, v),
								ce = Z.parseInfixIntermediateType(F, k.ALL);
							return (v.acceptLexerState(Z), D(ce));
						}, 'parsePrefix')
					});
				}
				O(ne, 'createSpecialNamePathParslet');
				const pe = [
						re({ allowedAdditionalTokens: ['external', 'module'] }),
						oe,
						ve,
						Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: null })
					],
					ye = [...pe, ne({ allowedTypes: ['event'], pathGrammar: pe })];
				function fe(l) {
					let h;
					if (l.type === 'JsdocTypeParameterList') h = l.elements;
					else if (l.type === 'JsdocTypeParenthesis') h = [l.element];
					else throw new d(l);
					return h.map((v) => N(v));
				}
				O(fe, 'getParameters');
				function ze(l) {
					const h = fe(l);
					if (h.some((v) => v.type === 'JsdocTypeKeyValue'))
						throw new Error('No parameter should be named');
					return h;
				}
				O(ze, 'getUnnamedParameters');
				function pt({
					allowNamedParameters: l,
					allowNoReturnType: h,
					allowWithoutParenthesis: v,
					allowNewAsFunctionKeyword: x
				}) {
					return W({
						name: 'functionParslet',
						accept: O((F, z) => F === 'function' || (x && F === 'new' && z === '('), 'accept'),
						parsePrefix: O((F) => {
							const z = F.consume('new');
							F.consume('function');
							const Z = F.lexer.current.type === '(';
							if (!Z) {
								if (!v) throw new Error('function is missing parameter list');
								return { type: 'JsdocTypeName', value: 'function' };
							}
							let ce = {
								type: 'JsdocTypeFunction',
								parameters: [],
								arrow: !1,
								constructor: z,
								parenthesis: Z
							};
							const Re = F.parseIntermediateType(k.FUNCTION);
							if (l === void 0) ce.parameters = ze(Re);
							else {
								if (z && Re.type === 'JsdocTypeFunction' && Re.arrow)
									return ((ce = Re), (ce.constructor = !0), ce);
								ce.parameters = fe(Re);
								for (const Te of ce.parameters)
									if (Te.type === 'JsdocTypeKeyValue' && !l.includes(Te.key))
										throw new Error(
											`only allowed named parameters are ${l.join(', ')} but got ${Te.type}`
										);
							}
							if (F.consume(':')) ce.returnType = F.parseType(k.PREFIX);
							else if (!h) throw new Error('function is missing return type');
							return ce;
						}, 'parsePrefix')
					});
				}
				O(pt, 'createFunctionParslet');
				function vt({ allowPostfix: l, allowEnclosingBrackets: h }) {
					return W({
						name: 'variadicParslet',
						accept: O((v) => v === '...', 'accept'),
						precedence: k.PREFIX,
						parsePrefix: O((v) => {
							v.consume('...');
							const x = h && v.consume('[');
							try {
								const F = v.parseType(k.PREFIX);
								if (x && !v.consume(']'))
									throw new Error("Unterminated variadic type. Missing ']'");
								return {
									type: 'JsdocTypeVariadic',
									element: D(F),
									meta: { position: 'prefix', squareBrackets: x }
								};
							} catch (F) {
								if (F instanceof s) {
									if (x) throw new Error('Empty square brackets for variadic are not allowed.');
									return {
										type: 'JsdocTypeVariadic',
										meta: { position: void 0, squareBrackets: !1 }
									};
								} else throw F;
							}
						}, 'parsePrefix'),
						parseInfix: l
							? (v, x) => (
									v.consume('...'),
									{
										type: 'JsdocTypeVariadic',
										element: D(x),
										meta: { position: 'suffix', squareBrackets: !1 }
									}
								)
							: void 0
					});
				}
				O(vt, 'createVariadicParslet');
				const Ft = W({
						name: 'symbolParslet',
						accept: O((l) => l === '(', 'accept'),
						precedence: k.SYMBOL,
						parseInfix: O((l, h) => {
							if (h.type !== 'JsdocTypeName')
								throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
							l.consume('(');
							const v = { type: 'JsdocTypeSymbol', value: h.value };
							if (!l.consume(')')) {
								const x = l.parseIntermediateType(k.SYMBOL);
								if (((v.element = A(x)), !l.consume(')')))
									throw new Error('Symbol does not end after value');
							}
							return v;
						}, 'parseInfix')
					}),
					ft = W({
						name: 'arrayBracketsParslet',
						precedence: k.ARRAY_BRACKETS,
						accept: O((l, h) => l === '[' && h === ']', 'accept'),
						parseInfix: O(
							(l, h) => (
								l.consume('['),
								l.consume(']'),
								{
									type: 'JsdocTypeGeneric',
									left: { type: 'JsdocTypeName', value: 'Array' },
									elements: [D(h)],
									meta: { brackets: 'square', dot: !1 }
								}
							),
							'parseInfix'
						)
					});
				function Et({ objectFieldGrammar: l, allowKeyTypes: h }) {
					return W({
						name: 'objectParslet',
						accept: O((v) => v === '{', 'accept'),
						parsePrefix: O((v) => {
							v.consume('{');
							const x = { type: 'JsdocTypeObject', meta: { separator: 'comma' }, elements: [] };
							if (!v.consume('}')) {
								let F;
								const z = new X(l, v.lexer, v);
								for (;;) {
									z.acceptLexerState(v);
									let Z = z.parseIntermediateType(k.OBJECT);
									(v.acceptLexerState(z),
										Z === void 0 && h && (Z = v.parseIntermediateType(k.OBJECT)));
									let ce = !1;
									if (
										(Z.type === 'JsdocTypeNullable' && ((ce = !0), (Z = Z.element)),
										Z.type === 'JsdocTypeNumber' ||
											Z.type === 'JsdocTypeName' ||
											Z.type === 'JsdocTypeStringValue')
									) {
										let Te;
										(Z.type === 'JsdocTypeStringValue' && (Te = Z.meta.quote),
											x.elements.push({
												type: 'JsdocTypeObjectField',
												key: Z.value.toString(),
												right: void 0,
												optional: ce,
												readonly: !1,
												meta: { quote: Te }
											}));
									} else if (
										Z.type === 'JsdocTypeObjectField' ||
										Z.type === 'JsdocTypeJsdocObjectField'
									)
										x.elements.push(Z);
									else throw new d(Z);
									if (v.lexer.current.startOfLine)
										((F = 'linebreak'), v.consume(',') || v.consume(';'));
									else if (v.consume(',')) F = 'comma';
									else if (v.consume(';')) F = 'semicolon';
									else break;
									if (v.lexer.current.type === '}') break;
								}
								if (
									((x.meta.separator = F ?? 'comma'),
									F === 'linebreak' && (x.meta.propertyIndent = '  '),
									!v.consume('}'))
								)
									throw new Error("Unterminated record type. Missing '}'");
							}
							return x;
						}, 'parsePrefix')
					});
				}
				O(Et, 'createObjectParslet');
				function Tt({
					allowSquaredProperties: l,
					allowKeyTypes: h,
					allowReadonly: v,
					allowOptional: x
				}) {
					return W({
						name: 'objectFieldParslet',
						precedence: k.KEY_VALUE,
						accept: O((F) => F === ':', 'accept'),
						parseInfix: O((F, z) => {
							var Z;
							let ce = !1,
								Re = !1;
							(x && z.type === 'JsdocTypeNullable' && ((ce = !0), (z = z.element)),
								v && z.type === 'JsdocTypeReadonlyProperty' && ((Re = !0), (z = z.element)));
							const Te = (Z = F.baseParser) !== null && Z !== void 0 ? Z : F;
							if (
								(Te.acceptLexerState(F),
								z.type === 'JsdocTypeNumber' ||
									z.type === 'JsdocTypeName' ||
									z.type === 'JsdocTypeStringValue' ||
									B(z))
							) {
								if (B(z) && !l) throw new d(z);
								Te.consume(':');
								let ke;
								z.type === 'JsdocTypeStringValue' && (ke = z.meta.quote);
								const Br = Te.parseType(k.KEY_VALUE);
								return (
									F.acceptLexerState(Te),
									{
										type: 'JsdocTypeObjectField',
										key: B(z) ? z : z.value.toString(),
										right: Br,
										optional: ce,
										readonly: Re,
										meta: { quote: ke }
									}
								);
							} else {
								if (!h) throw new d(z);
								Te.consume(':');
								const ke = Te.parseType(k.KEY_VALUE);
								return (
									F.acceptLexerState(Te),
									{ type: 'JsdocTypeJsdocObjectField', left: D(z), right: ke }
								);
							}
						}, 'parseInfix')
					});
				}
				O(Tt, 'createObjectFieldParslet');
				function _t({ allowOptional: l, allowVariadic: h }) {
					return W({
						name: 'keyValueParslet',
						precedence: k.KEY_VALUE,
						accept: O((v) => v === ':', 'accept'),
						parseInfix: O((v, x) => {
							let F = !1,
								z = !1;
							if (
								(l && x.type === 'JsdocTypeNullable' && ((F = !0), (x = x.element)),
								h &&
									x.type === 'JsdocTypeVariadic' &&
									x.element !== void 0 &&
									((z = !0), (x = x.element)),
								x.type !== 'JsdocTypeName')
							)
								throw new d(x);
							v.consume(':');
							const Z = v.parseType(k.KEY_VALUE);
							return {
								type: 'JsdocTypeKeyValue',
								key: x.value,
								right: Z,
								optional: F,
								variadic: z
							};
						}, 'parseInfix')
					});
				}
				O(_t, 'createKeyValueParslet');
				const Un = [
						...$,
						pt({
							allowWithoutParenthesis: !0,
							allowNamedParameters: ['this', 'new'],
							allowNoReturnType: !0,
							allowNewAsFunctionKeyword: !1
						}),
						oe,
						ne({ allowedTypes: ['module', 'external', 'event'], pathGrammar: ye }),
						vt({ allowEnclosingBrackets: !0, allowPostfix: !0 }),
						re({ allowedAdditionalTokens: ['keyof'] }),
						Ft,
						ft,
						Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye })
					],
					Bi = [
						...Un,
						Et({
							objectFieldGrammar: [
								re({ allowedAdditionalTokens: ['typeof', 'module', 'in'] }),
								Tt({
									allowSquaredProperties: !1,
									allowKeyTypes: !0,
									allowOptional: !1,
									allowReadonly: !1
								}),
								...Un
							],
							allowKeyTypes: !0
						}),
						_t({ allowOptional: !0, allowVariadic: !0 })
					],
					Vn = W({
						name: 'typeOfParslet',
						accept: O((l) => l === 'typeof', 'accept'),
						parsePrefix: O(
							(l) => (
								l.consume('typeof'),
								{ type: 'JsdocTypeTypeof', element: l.parseType(k.KEY_OF_TYPE_OF) }
							),
							'parsePrefix'
						)
					}),
					Ji = [
						re({
							allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']
						}),
						ae,
						le,
						oe,
						ve,
						Tt({
							allowSquaredProperties: !1,
							allowKeyTypes: !1,
							allowOptional: !1,
							allowReadonly: !1
						})
					],
					$i = [
						...$,
						Et({ allowKeyTypes: !1, objectFieldGrammar: Ji }),
						re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
						Vn,
						pt({
							allowWithoutParenthesis: !1,
							allowNamedParameters: ['this', 'new'],
							allowNoReturnType: !0,
							allowNewAsFunctionKeyword: !1
						}),
						vt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
						re({ allowedAdditionalTokens: ['keyof'] }),
						ne({ allowedTypes: ['module'], pathGrammar: ye }),
						Q({ allowSquareBracketsOnAnyType: !1, allowJsdocNamePaths: !0, pathGrammar: ye }),
						_t({ allowOptional: !1, allowVariadic: !1 }),
						Ft
					],
					Ui = W({
						name: 'assertsParslet',
						accept: O((l) => l === 'asserts', 'accept'),
						parsePrefix: O((l) => {
							l.consume('asserts');
							const h = l.parseIntermediateType(k.SYMBOL);
							if (h.type !== 'JsdocTypeName')
								throw new d(h, 'A typescript asserts always has to have a name on the left side.');
							return l.consume('is')
								? { type: 'JsdocTypeAsserts', left: h, right: D(l.parseIntermediateType(k.INFIX)) }
								: { type: 'JsdocTypeAssertsPlain', element: h };
						}, 'parsePrefix')
					});
				function Hn({ allowQuestionMark: l }) {
					return W({
						name: 'tupleParslet',
						accept: O((h) => h === '[', 'accept'),
						parsePrefix: O((h) => {
							h.consume('[');
							const v = { type: 'JsdocTypeTuple', elements: [] };
							if (h.consume(']')) return v;
							const x = h.parseIntermediateType(k.ALL);
							if (
								(x.type === 'JsdocTypeParameterList'
									? x.elements[0].type === 'JsdocTypeKeyValue'
										? (v.elements = x.elements.map(H))
										: (v.elements = x.elements.map(D))
									: x.type === 'JsdocTypeKeyValue'
										? (v.elements = [H(x)])
										: (v.elements = [D(x)]),
								!h.consume(']'))
							)
								throw new Error("Unterminated '['");
							if (v.elements.some((F) => F.type === 'JsdocTypeUnknown'))
								throw new Error('Question mark in tuple not allowed');
							return v;
						}, 'parsePrefix')
					});
				}
				O(Hn, 'createTupleParslet');
				const Vi = W({
						name: 'keyOfParslet',
						accept: O((l) => l === 'keyof', 'accept'),
						parsePrefix: O(
							(l) => (
								l.consume('keyof'),
								{ type: 'JsdocTypeKeyof', element: D(l.parseType(k.KEY_OF_TYPE_OF)) }
							),
							'parsePrefix'
						)
					}),
					Hi = W({
						name: 'importParslet',
						accept: O((l) => l === 'import', 'accept'),
						parsePrefix: O((l) => {
							if ((l.consume('import'), !l.consume('(')))
								throw new Error('Missing parenthesis after import keyword');
							const h = l.parseType(k.PREFIX);
							if (h.type !== 'JsdocTypeStringValue')
								throw new Error('Only string values are allowed as paths for imports');
							if (!l.consume(')'))
								throw new Error('Missing closing parenthesis after import keyword');
							return { type: 'JsdocTypeImport', element: h };
						}, 'parsePrefix')
					}),
					Gi = W({
						name: 'readonlyPropertyParslet',
						accept: O((l) => l === 'readonly', 'accept'),
						parsePrefix: O(
							(l) => (
								l.consume('readonly'),
								{ type: 'JsdocTypeReadonlyProperty', element: l.parseIntermediateType(k.KEY_VALUE) }
							),
							'parsePrefix'
						)
					}),
					zi = W({
						name: 'arrowFunctionParslet',
						precedence: k.ARROW,
						accept: O((l) => l === '=>', 'accept'),
						parseInfix: O(
							(l, h) => (
								l.consume('=>'),
								{
									type: 'JsdocTypeFunction',
									parameters: fe(h).map(V),
									arrow: !0,
									constructor: !1,
									parenthesis: !0,
									returnType: l.parseType(k.OBJECT)
								}
							),
							'parseInfix'
						)
					}),
					Wi = W({
						name: 'genericArrowFunctionParslet',
						accept: O((l) => l === '<', 'accept'),
						parsePrefix: O((l) => {
							const h = [];
							l.consume('<');
							do {
								let x,
									F = l.parseIntermediateType(k.SYMBOL);
								if (
									(F.type === 'JsdocTypeOptional' && ((F = F.element), (x = l.parseType(k.SYMBOL))),
									F.type !== 'JsdocTypeName')
								)
									throw new d(F);
								let z;
								l.consume('extends') &&
									((z = l.parseType(k.SYMBOL)),
									z.type === 'JsdocTypeOptional' && ((z = z.element), (x = l.parseType(k.SYMBOL))));
								const Z = { type: 'JsdocTypeTypeParameter', name: F };
								if (
									(z !== void 0 && (Z.constraint = z),
									x !== void 0 && (Z.defaultValue = x),
									h.push(Z),
									l.consume('>'))
								)
									break;
							} while (l.consume(','));
							const v = l.parseIntermediateType(k.SYMBOL);
							return ((v.typeParameters = h), v);
						}, 'parsePrefix')
					}),
					Ki = W({
						name: 'intersectionParslet',
						accept: O((l) => l === '&', 'accept'),
						precedence: k.INTERSECTION,
						parseInfix: O((l, h) => {
							l.consume('&');
							const v = [];
							do v.push(l.parseType(k.INTERSECTION));
							while (l.consume('&'));
							return { type: 'JsdocTypeIntersection', elements: [D(h), ...v] };
						}, 'parseInfix')
					}),
					Yi = W({
						name: 'predicateParslet',
						precedence: k.INFIX,
						accept: O((l) => l === 'is', 'accept'),
						parseInfix: O((l, h) => {
							if (h.type !== 'JsdocTypeName')
								throw new d(
									h,
									'A typescript predicate always has to have a name on the left side.'
								);
							return (
								l.consume('is'),
								{ type: 'JsdocTypePredicate', left: h, right: D(l.parseIntermediateType(k.INFIX)) }
							);
						}, 'parseInfix')
					}),
					Xi = W({
						name: 'objectSquareBracketPropertyParslet',
						accept: O((l) => l === '[', 'accept'),
						parsePrefix: O((l) => {
							if (l.baseParser === void 0) throw new Error('Only allowed inside object grammar');
							l.consume('[');
							const h = l.lexer.current.text;
							l.consume('Identifier');
							let v;
							if (l.consume(':')) {
								const x = l.baseParser;
								(x.acceptLexerState(l),
									(v = {
										type: 'JsdocTypeIndexSignature',
										key: h,
										right: x.parseType(k.INDEX_BRACKETS)
									}),
									l.acceptLexerState(x));
							} else if (l.consume('in')) {
								const x = l.baseParser;
								(x.acceptLexerState(l),
									(v = {
										type: 'JsdocTypeMappedType',
										key: h,
										right: x.parseType(k.ARRAY_BRACKETS)
									}),
									l.acceptLexerState(x));
							} else throw new Error("Missing ':' or 'in' inside square bracketed property.");
							if (!l.consume(']')) throw new Error('Unterminated square brackets');
							return v;
						}, 'parsePrefix')
					}),
					Qi = W({
						name: 'readonlyArrayParslet',
						accept: O((l) => l === 'readonly', 'accept'),
						parsePrefix: O(
							(l) => (
								l.consume('readonly'),
								{ type: 'JsdocTypeReadonlyArray', element: L(l.parseIntermediateType(k.ALL)) }
							),
							'parsePrefix'
						)
					}),
					Zi = W({
						name: 'conditionalParslet',
						precedence: k.INFIX,
						accept: O((l) => l === 'extends', 'accept'),
						parseInfix: O((l, h) => {
							l.consume('extends');
							const v = l.parseType(k.KEY_OF_TYPE_OF).element,
								x = l.parseType(k.INFIX);
							return (
								l.consume(':'),
								{
									type: 'JsdocTypeConditional',
									checksType: D(h),
									extendsType: v,
									trueType: x,
									falseType: l.parseType(k.INFIX)
								}
							);
						}, 'parseInfix')
					}),
					es = [
						Gi,
						re({
							allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']
						}),
						ae,
						le,
						oe,
						ve,
						Tt({
							allowSquaredProperties: !0,
							allowKeyTypes: !1,
							allowOptional: !0,
							allowReadonly: !0
						}),
						Xi
					],
					ts = [
						...$,
						Et({ allowKeyTypes: !1, objectFieldGrammar: es }),
						Qi,
						Vn,
						Vi,
						Hi,
						oe,
						pt({
							allowWithoutParenthesis: !0,
							allowNoReturnType: !1,
							allowNamedParameters: ['this', 'new', 'args'],
							allowNewAsFunctionKeyword: !0
						}),
						Hn({ allowQuestionMark: !1 }),
						vt({ allowEnclosingBrackets: !1, allowPostfix: !1 }),
						Ui,
						Zi,
						re({ allowedAdditionalTokens: ['event', 'external', 'in'] }),
						ne({ allowedTypes: ['module'], pathGrammar: ye }),
						ft,
						zi,
						Wi,
						Q({ allowSquareBracketsOnAnyType: !0, allowJsdocNamePaths: !1, pathGrammar: ye }),
						Ki,
						Yi,
						_t({ allowVariadic: !0, allowOptional: !0 })
					];
				function kr(l, h) {
					switch (h) {
						case 'closure':
							return new X($i, l).parse();
						case 'jsdoc':
							return new X(Bi, l).parse();
						case 'typescript':
							return new X(ts, l).parse();
					}
				}
				O(kr, 'parse');
				function Gn(l, h = ['typescript', 'closure', 'jsdoc']) {
					let v;
					for (const x of h)
						try {
							return kr(l, x);
						} catch (F) {
							v = F;
						}
					throw v;
				}
				O(Gn, 'tryParse');
				function Y(l, h) {
					const v = l[h.type];
					if (v === void 0)
						throw new Error(`In this set of transform rules exists no rule for type ${h.type}.`);
					return v(h, (x) => Y(l, x));
				}
				O(Y, 'transform');
				function ue(l) {
					throw new Error(
						'This transform is not available. Are you trying the correct parsing mode?'
					);
				}
				O(ue, 'notAvailableTransform');
				function Xt(l) {
					const h = { params: [] };
					for (const v of l.parameters)
						v.type === 'JsdocTypeKeyValue'
							? v.key === 'this'
								? (h.this = v.right)
								: v.key === 'new'
									? (h.new = v.right)
									: h.params.push(v)
							: h.params.push(v);
					return h;
				}
				O(Xt, 'extractSpecialParams');
				function lr(l, h, v) {
					return l === 'prefix' ? v + h : h + v;
				}
				O(lr, 'applyPosition');
				function nt(l, h) {
					switch (h) {
						case 'double':
							return `"${l}"`;
						case 'single':
							return `'${l}'`;
						case void 0:
							return l;
					}
				}
				O(nt, 'quote');
				function zn() {
					return {
						JsdocTypeParenthesis: O(
							(l, h) => `(${l.element !== void 0 ? h(l.element) : ''})`,
							'JsdocTypeParenthesis'
						),
						JsdocTypeKeyof: O((l, h) => `keyof ${h(l.element)}`, 'JsdocTypeKeyof'),
						JsdocTypeFunction: O((l, h) => {
							var v;
							if (l.arrow) {
								if (l.returnType === void 0) throw new Error('Arrow function needs a return type.');
								let x = `${l.typeParameters !== void 0 ? `<${(v = l.typeParameters.map(h).join(', ')) !== null && v !== void 0 ? v : ''}>` : ''}(${l.parameters.map(h).join(', ')}) => ${h(l.returnType)}`;
								return (l.constructor && (x = 'new ' + x), x);
							} else {
								let x = l.constructor ? 'new' : 'function';
								return (
									l.parenthesis &&
										((x += `(${l.parameters.map(h).join(', ')})`),
										l.returnType !== void 0 && (x += `: ${h(l.returnType)}`)),
									x
								);
							}
						}, 'JsdocTypeFunction'),
						JsdocTypeName: O((l) => l.value, 'JsdocTypeName'),
						JsdocTypeTuple: O((l, h) => `[${l.elements.map(h).join(', ')}]`, 'JsdocTypeTuple'),
						JsdocTypeVariadic: O(
							(l, h) =>
								l.meta.position === void 0 ? '...' : lr(l.meta.position, h(l.element), '...'),
							'JsdocTypeVariadic'
						),
						JsdocTypeNamePath: O((l, h) => {
							const v = h(l.left),
								x = h(l.right);
							switch (l.pathType) {
								case 'inner':
									return `${v}~${x}`;
								case 'instance':
									return `${v}#${x}`;
								case 'property':
									return `${v}.${x}`;
								case 'property-brackets':
									return `${v}[${x}]`;
							}
						}, 'JsdocTypeNamePath'),
						JsdocTypeStringValue: O((l) => nt(l.value, l.meta.quote), 'JsdocTypeStringValue'),
						JsdocTypeAny: O(() => '*', 'JsdocTypeAny'),
						JsdocTypeGeneric: O((l, h) => {
							if (l.meta.brackets === 'square') {
								const v = l.elements[0],
									x = h(v);
								return v.type === 'JsdocTypeUnion' || v.type === 'JsdocTypeIntersection'
									? `(${x})[]`
									: `${x}[]`;
							} else
								return `${h(l.left)}${l.meta.dot ? '.' : ''}<${l.infer === !0 ? 'infer ' : ''}${l.elements.map(h).join(', ')}>`;
						}, 'JsdocTypeGeneric'),
						JsdocTypeImport: O((l, h) => `import(${h(l.element)})`, 'JsdocTypeImport'),
						JsdocTypeObjectField: O((l, h) => {
							let v = '';
							return (
								l.readonly && (v += 'readonly '),
								typeof l.key == 'string' ? (v += nt(l.key, l.meta.quote)) : (v += h(l.key)),
								l.optional && (v += '?'),
								l.right === void 0 ? v : v + `: ${h(l.right)}`
							);
						}, 'JsdocTypeObjectField'),
						JsdocTypeJsdocObjectField: O(
							(l, h) => `${h(l.left)}: ${h(l.right)}`,
							'JsdocTypeJsdocObjectField'
						),
						JsdocTypeKeyValue: O((l, h) => {
							let v = l.key;
							return (
								l.optional && (v += '?'),
								l.variadic && (v = '...' + v),
								l.right === void 0 ? v : v + `: ${h(l.right)}`
							);
						}, 'JsdocTypeKeyValue'),
						JsdocTypeSpecialNamePath: O(
							(l) => `${l.specialType}:${nt(l.value, l.meta.quote)}`,
							'JsdocTypeSpecialNamePath'
						),
						JsdocTypeNotNullable: O(
							(l, h) => lr(l.meta.position, h(l.element), '!'),
							'JsdocTypeNotNullable'
						),
						JsdocTypeNull: O(() => 'null', 'JsdocTypeNull'),
						JsdocTypeNullable: O(
							(l, h) => lr(l.meta.position, h(l.element), '?'),
							'JsdocTypeNullable'
						),
						JsdocTypeNumber: O((l) => l.value.toString(), 'JsdocTypeNumber'),
						JsdocTypeObject: O((l, h) => {
							var v, x;
							return `{${
								(l.meta.separator === 'linebreak' && l.elements.length > 1
									? `
` + ((v = l.meta.propertyIndent) !== null && v !== void 0 ? v : '')
									: '') +
								l.elements.map(h).join(
									l.meta.separator === 'comma'
										? ', '
										: l.meta.separator === 'linebreak'
											? `
` + ((x = l.meta.propertyIndent) !== null && x !== void 0 ? x : '')
											: '; '
								) +
								(l.meta.separator === 'linebreak' && l.elements.length > 1
									? `
`
									: '')
							}}`;
						}, 'JsdocTypeObject'),
						JsdocTypeOptional: O(
							(l, h) => lr(l.meta.position, h(l.element), '='),
							'JsdocTypeOptional'
						),
						JsdocTypeSymbol: O(
							(l, h) => `${l.value}(${l.element !== void 0 ? h(l.element) : ''})`,
							'JsdocTypeSymbol'
						),
						JsdocTypeTypeof: O((l, h) => `typeof ${h(l.element)}`, 'JsdocTypeTypeof'),
						JsdocTypeUndefined: O(() => 'undefined', 'JsdocTypeUndefined'),
						JsdocTypeUnion: O((l, h) => l.elements.map(h).join(' | '), 'JsdocTypeUnion'),
						JsdocTypeUnknown: O(() => '?', 'JsdocTypeUnknown'),
						JsdocTypeIntersection: O(
							(l, h) => l.elements.map(h).join(' & '),
							'JsdocTypeIntersection'
						),
						JsdocTypeProperty: O((l) => nt(l.value, l.meta.quote), 'JsdocTypeProperty'),
						JsdocTypePredicate: O((l, h) => `${h(l.left)} is ${h(l.right)}`, 'JsdocTypePredicate'),
						JsdocTypeIndexSignature: O(
							(l, h) => `[${l.key}: ${h(l.right)}]`,
							'JsdocTypeIndexSignature'
						),
						JsdocTypeMappedType: O((l, h) => `[${l.key} in ${h(l.right)}]`, 'JsdocTypeMappedType'),
						JsdocTypeAsserts: O(
							(l, h) => `asserts ${h(l.left)} is ${h(l.right)}`,
							'JsdocTypeAsserts'
						),
						JsdocTypeReadonlyArray: O(
							(l, h) => `readonly ${h(l.element)}`,
							'JsdocTypeReadonlyArray'
						),
						JsdocTypeAssertsPlain: O((l, h) => `asserts ${h(l.element)}`, 'JsdocTypeAssertsPlain'),
						JsdocTypeConditional: O(
							(l, h) =>
								`${h(l.checksType)} extends ${h(l.extendsType)} ? ${h(l.trueType)} : ${h(l.falseType)}`,
							'JsdocTypeConditional'
						),
						JsdocTypeTypeParameter: O(
							(l, h) =>
								`${h(l.name)}${l.constraint !== void 0 ? ` extends ${h(l.constraint)}` : ''}${l.defaultValue !== void 0 ? ` = ${h(l.defaultValue)}` : ''}`,
							'JsdocTypeTypeParameter'
						)
					};
				}
				O(zn, 'stringifyRules');
				const Xc = zn();
				function rs(l) {
					return Y(Xc, l);
				}
				O(rs, 'stringify');
				const Qc = [
					'null',
					'true',
					'false',
					'break',
					'case',
					'catch',
					'class',
					'const',
					'continue',
					'debugger',
					'default',
					'delete',
					'do',
					'else',
					'export',
					'extends',
					'finally',
					'for',
					'function',
					'if',
					'import',
					'in',
					'instanceof',
					'new',
					'return',
					'super',
					'switch',
					'this',
					'throw',
					'try',
					'typeof',
					'var',
					'void',
					'while',
					'with',
					'yield'
				];
				function ot(l) {
					const h = { type: 'NameExpression', name: l };
					return (Qc.includes(l) && (h.reservedWord = !0), h);
				}
				O(ot, 'makeName');
				const Zc = {
					JsdocTypeOptional: O((l, h) => {
						const v = h(l.element);
						return ((v.optional = !0), v);
					}, 'JsdocTypeOptional'),
					JsdocTypeNullable: O((l, h) => {
						const v = h(l.element);
						return ((v.nullable = !0), v);
					}, 'JsdocTypeNullable'),
					JsdocTypeNotNullable: O((l, h) => {
						const v = h(l.element);
						return ((v.nullable = !1), v);
					}, 'JsdocTypeNotNullable'),
					JsdocTypeVariadic: O((l, h) => {
						if (l.element === void 0)
							throw new Error('dots without value are not allowed in catharsis mode');
						const v = h(l.element);
						return ((v.repeatable = !0), v);
					}, 'JsdocTypeVariadic'),
					JsdocTypeAny: O(() => ({ type: 'AllLiteral' }), 'JsdocTypeAny'),
					JsdocTypeNull: O(() => ({ type: 'NullLiteral' }), 'JsdocTypeNull'),
					JsdocTypeStringValue: O((l) => ot(nt(l.value, l.meta.quote)), 'JsdocTypeStringValue'),
					JsdocTypeUndefined: O(() => ({ type: 'UndefinedLiteral' }), 'JsdocTypeUndefined'),
					JsdocTypeUnknown: O(() => ({ type: 'UnknownLiteral' }), 'JsdocTypeUnknown'),
					JsdocTypeFunction: O((l, h) => {
						const v = Xt(l),
							x = { type: 'FunctionType', params: v.params.map(h) };
						return (
							v.this !== void 0 && (x.this = h(v.this)),
							v.new !== void 0 && (x.new = h(v.new)),
							l.returnType !== void 0 && (x.result = h(l.returnType)),
							x
						);
					}, 'JsdocTypeFunction'),
					JsdocTypeGeneric: O(
						(l, h) => ({
							type: 'TypeApplication',
							applications: l.elements.map((v) => h(v)),
							expression: h(l.left)
						}),
						'JsdocTypeGeneric'
					),
					JsdocTypeSpecialNamePath: O(
						(l) => ot(l.specialType + ':' + nt(l.value, l.meta.quote)),
						'JsdocTypeSpecialNamePath'
					),
					JsdocTypeName: O(
						(l) => (l.value !== 'function' ? ot(l.value) : { type: 'FunctionType', params: [] }),
						'JsdocTypeName'
					),
					JsdocTypeNumber: O((l) => ot(l.value.toString()), 'JsdocTypeNumber'),
					JsdocTypeObject: O((l, h) => {
						const v = { type: 'RecordType', fields: [] };
						for (const x of l.elements)
							x.type !== 'JsdocTypeObjectField' && x.type !== 'JsdocTypeJsdocObjectField'
								? v.fields.push({ type: 'FieldType', key: h(x), value: void 0 })
								: v.fields.push(h(x));
						return v;
					}, 'JsdocTypeObject'),
					JsdocTypeObjectField: O((l, h) => {
						if (typeof l.key != 'string')
							throw new Error('Index signatures and mapped types are not supported');
						return {
							type: 'FieldType',
							key: ot(nt(l.key, l.meta.quote)),
							value: l.right === void 0 ? void 0 : h(l.right)
						};
					}, 'JsdocTypeObjectField'),
					JsdocTypeJsdocObjectField: O(
						(l, h) => ({ type: 'FieldType', key: h(l.left), value: h(l.right) }),
						'JsdocTypeJsdocObjectField'
					),
					JsdocTypeUnion: O(
						(l, h) => ({ type: 'TypeUnion', elements: l.elements.map((v) => h(v)) }),
						'JsdocTypeUnion'
					),
					JsdocTypeKeyValue: O(
						(l, h) => ({
							type: 'FieldType',
							key: ot(l.key),
							value: l.right === void 0 ? void 0 : h(l.right)
						}),
						'JsdocTypeKeyValue'
					),
					JsdocTypeNamePath: O((l, h) => {
						const v = h(l.left);
						let x;
						l.right.type === 'JsdocTypeSpecialNamePath'
							? (x = h(l.right).name)
							: (x = nt(l.right.value, l.right.meta.quote));
						const F = l.pathType === 'inner' ? '~' : l.pathType === 'instance' ? '#' : '.';
						return ot(`${v.name}${F}${x}`);
					}, 'JsdocTypeNamePath'),
					JsdocTypeSymbol: O((l) => {
						let h = '',
							v = l.element,
							x = !1;
						return (
							v?.type === 'JsdocTypeVariadic' &&
								(v.meta.position === 'prefix' ? (h = '...') : (x = !0), (v = v.element)),
							v?.type === 'JsdocTypeName'
								? (h += v.value)
								: v?.type === 'JsdocTypeNumber' && (h += v.value.toString()),
							x && (h += '...'),
							ot(`${l.value}(${h})`)
						);
					}, 'JsdocTypeSymbol'),
					JsdocTypeParenthesis: O((l, h) => h(D(l.element)), 'JsdocTypeParenthesis'),
					JsdocTypeMappedType: ue,
					JsdocTypeIndexSignature: ue,
					JsdocTypeImport: ue,
					JsdocTypeKeyof: ue,
					JsdocTypeTuple: ue,
					JsdocTypeTypeof: ue,
					JsdocTypeIntersection: ue,
					JsdocTypeProperty: ue,
					JsdocTypePredicate: ue,
					JsdocTypeAsserts: ue,
					JsdocTypeReadonlyArray: ue,
					JsdocTypeAssertsPlain: ue,
					JsdocTypeConditional: ue,
					JsdocTypeTypeParameter: ue
				};
				function ns(l) {
					return Y(Zc, l);
				}
				O(ns, 'catharsisTransform');
				function mt(l) {
					switch (l) {
						case void 0:
							return 'none';
						case 'single':
							return 'single';
						case 'double':
							return 'double';
					}
				}
				O(mt, 'getQuoteStyle');
				function os(l) {
					switch (l) {
						case 'inner':
							return 'INNER_MEMBER';
						case 'instance':
							return 'INSTANCE_MEMBER';
						case 'property':
							return 'MEMBER';
						case 'property-brackets':
							return 'MEMBER';
					}
				}
				O(os, 'getMemberType');
				function Lr(l, h) {
					return h.length === 2
						? { type: l, left: h[0], right: h[1] }
						: { type: l, left: h[0], right: Lr(l, h.slice(1)) };
				}
				O(Lr, 'nestResults');
				const ed = {
					JsdocTypeOptional: O(
						(l, h) => ({
							type: 'OPTIONAL',
							value: h(l.element),
							meta: {
								syntax: l.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'
							}
						}),
						'JsdocTypeOptional'
					),
					JsdocTypeNullable: O(
						(l, h) => ({
							type: 'NULLABLE',
							value: h(l.element),
							meta: {
								syntax:
									l.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'
							}
						}),
						'JsdocTypeNullable'
					),
					JsdocTypeNotNullable: O(
						(l, h) => ({
							type: 'NOT_NULLABLE',
							value: h(l.element),
							meta: { syntax: l.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG' }
						}),
						'JsdocTypeNotNullable'
					),
					JsdocTypeVariadic: O((l, h) => {
						const v = {
							type: 'VARIADIC',
							meta: {
								syntax:
									l.meta.position === 'prefix'
										? 'PREFIX_DOTS'
										: l.meta.position === 'suffix'
											? 'SUFFIX_DOTS'
											: 'ONLY_DOTS'
							}
						};
						return (l.element !== void 0 && (v.value = h(l.element)), v);
					}, 'JsdocTypeVariadic'),
					JsdocTypeName: O((l) => ({ type: 'NAME', name: l.value }), 'JsdocTypeName'),
					JsdocTypeTypeof: O(
						(l, h) => ({ type: 'TYPE_QUERY', name: h(l.element) }),
						'JsdocTypeTypeof'
					),
					JsdocTypeTuple: O(
						(l, h) => ({ type: 'TUPLE', entries: l.elements.map(h) }),
						'JsdocTypeTuple'
					),
					JsdocTypeKeyof: O(
						(l, h) => ({ type: 'KEY_QUERY', value: h(l.element) }),
						'JsdocTypeKeyof'
					),
					JsdocTypeImport: O(
						(l) => ({
							type: 'IMPORT',
							path: {
								type: 'STRING_VALUE',
								quoteStyle: mt(l.element.meta.quote),
								string: l.element.value
							}
						}),
						'JsdocTypeImport'
					),
					JsdocTypeUndefined: O(() => ({ type: 'NAME', name: 'undefined' }), 'JsdocTypeUndefined'),
					JsdocTypeAny: O(() => ({ type: 'ANY' }), 'JsdocTypeAny'),
					JsdocTypeFunction: O((l, h) => {
						const v = Xt(l),
							x = {
								type: l.arrow ? 'ARROW' : 'FUNCTION',
								params: v.params.map((F) => {
									if (F.type === 'JsdocTypeKeyValue') {
										if (F.right === void 0)
											throw new Error(
												"Function parameter without ':' is not expected to be 'KEY_VALUE'"
											);
										return { type: 'NAMED_PARAMETER', name: F.key, typeName: h(F.right) };
									} else return h(F);
								}),
								new: null,
								returns: null
							};
						return (
							v.this !== void 0 ? (x.this = h(v.this)) : l.arrow || (x.this = null),
							v.new !== void 0 && (x.new = h(v.new)),
							l.returnType !== void 0 && (x.returns = h(l.returnType)),
							x
						);
					}, 'JsdocTypeFunction'),
					JsdocTypeGeneric: O((l, h) => {
						const v = {
							type: 'GENERIC',
							subject: h(l.left),
							objects: l.elements.map(h),
							meta: {
								syntax:
									l.meta.brackets === 'square'
										? 'SQUARE_BRACKET'
										: l.meta.dot
											? 'ANGLE_BRACKET_WITH_DOT'
											: 'ANGLE_BRACKET'
							}
						};
						return (
							l.meta.brackets === 'square' &&
								l.elements[0].type === 'JsdocTypeFunction' &&
								!l.elements[0].parenthesis &&
								(v.objects[0] = { type: 'NAME', name: 'function' }),
							v
						);
					}, 'JsdocTypeGeneric'),
					JsdocTypeObjectField: O((l, h) => {
						if (typeof l.key != 'string')
							throw new Error('Index signatures and mapped types are not supported');
						if (l.right === void 0)
							return {
								type: 'RECORD_ENTRY',
								key: l.key,
								quoteStyle: mt(l.meta.quote),
								value: null,
								readonly: !1
							};
						let v = h(l.right);
						return (
							l.optional &&
								(v = { type: 'OPTIONAL', value: v, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
							{
								type: 'RECORD_ENTRY',
								key: l.key.toString(),
								quoteStyle: mt(l.meta.quote),
								value: v,
								readonly: !1
							}
						);
					}, 'JsdocTypeObjectField'),
					JsdocTypeJsdocObjectField: O(() => {
						throw new Error('Keys may not be typed in jsdoctypeparser.');
					}, 'JsdocTypeJsdocObjectField'),
					JsdocTypeKeyValue: O((l, h) => {
						if (l.right === void 0)
							return {
								type: 'RECORD_ENTRY',
								key: l.key,
								quoteStyle: 'none',
								value: null,
								readonly: !1
							};
						let v = h(l.right);
						return (
							l.optional &&
								(v = { type: 'OPTIONAL', value: v, meta: { syntax: 'SUFFIX_KEY_QUESTION_MARK' } }),
							{ type: 'RECORD_ENTRY', key: l.key, quoteStyle: 'none', value: v, readonly: !1 }
						);
					}, 'JsdocTypeKeyValue'),
					JsdocTypeObject: O((l, h) => {
						const v = [];
						for (const x of l.elements)
							(x.type === 'JsdocTypeObjectField' || x.type === 'JsdocTypeJsdocObjectField') &&
								v.push(h(x));
						return { type: 'RECORD', entries: v };
					}, 'JsdocTypeObject'),
					JsdocTypeSpecialNamePath: O((l) => {
						if (l.specialType !== 'module')
							throw new Error(
								`jsdoctypeparser does not support type ${l.specialType} at this point.`
							);
						return {
							type: 'MODULE',
							value: { type: 'FILE_PATH', quoteStyle: mt(l.meta.quote), path: l.value }
						};
					}, 'JsdocTypeSpecialNamePath'),
					JsdocTypeNamePath: O((l, h) => {
						let v = !1,
							x,
							F;
						l.right.type === 'JsdocTypeSpecialNamePath' && l.right.specialType === 'event'
							? ((v = !0), (x = l.right.value), (F = mt(l.right.meta.quote)))
							: ((x = l.right.value), (F = mt(l.right.meta.quote)));
						const z = {
							type: os(l.pathType),
							owner: h(l.left),
							name: x,
							quoteStyle: F,
							hasEventPrefix: v
						};
						if (z.owner.type === 'MODULE') {
							const Z = z.owner;
							return ((z.owner = z.owner.value), (Z.value = z), Z);
						} else return z;
					}, 'JsdocTypeNamePath'),
					JsdocTypeUnion: O((l, h) => Lr('UNION', l.elements.map(h)), 'JsdocTypeUnion'),
					JsdocTypeParenthesis: O(
						(l, h) => ({ type: 'PARENTHESIS', value: h(D(l.element)) }),
						'JsdocTypeParenthesis'
					),
					JsdocTypeNull: O(() => ({ type: 'NAME', name: 'null' }), 'JsdocTypeNull'),
					JsdocTypeUnknown: O(() => ({ type: 'UNKNOWN' }), 'JsdocTypeUnknown'),
					JsdocTypeStringValue: O(
						(l) => ({ type: 'STRING_VALUE', quoteStyle: mt(l.meta.quote), string: l.value }),
						'JsdocTypeStringValue'
					),
					JsdocTypeIntersection: O(
						(l, h) => Lr('INTERSECTION', l.elements.map(h)),
						'JsdocTypeIntersection'
					),
					JsdocTypeNumber: O(
						(l) => ({ type: 'NUMBER_VALUE', number: l.value.toString() }),
						'JsdocTypeNumber'
					),
					JsdocTypeSymbol: ue,
					JsdocTypeProperty: ue,
					JsdocTypePredicate: ue,
					JsdocTypeMappedType: ue,
					JsdocTypeIndexSignature: ue,
					JsdocTypeAsserts: ue,
					JsdocTypeReadonlyArray: ue,
					JsdocTypeAssertsPlain: ue,
					JsdocTypeConditional: ue,
					JsdocTypeTypeParameter: ue
				};
				function is(l) {
					return Y(ed, l);
				}
				O(is, 'jtpTransform');
				function ss() {
					return {
						JsdocTypeIntersection: O(
							(l, h) => ({ type: 'JsdocTypeIntersection', elements: l.elements.map(h) }),
							'JsdocTypeIntersection'
						),
						JsdocTypeGeneric: O(
							(l, h) => ({
								type: 'JsdocTypeGeneric',
								left: h(l.left),
								elements: l.elements.map(h),
								meta: { dot: l.meta.dot, brackets: l.meta.brackets }
							}),
							'JsdocTypeGeneric'
						),
						JsdocTypeNullable: O((l) => l, 'JsdocTypeNullable'),
						JsdocTypeUnion: O(
							(l, h) => ({ type: 'JsdocTypeUnion', elements: l.elements.map(h) }),
							'JsdocTypeUnion'
						),
						JsdocTypeUnknown: O((l) => l, 'JsdocTypeUnknown'),
						JsdocTypeUndefined: O((l) => l, 'JsdocTypeUndefined'),
						JsdocTypeTypeof: O(
							(l, h) => ({ type: 'JsdocTypeTypeof', element: h(l.element) }),
							'JsdocTypeTypeof'
						),
						JsdocTypeSymbol: O((l, h) => {
							const v = { type: 'JsdocTypeSymbol', value: l.value };
							return (l.element !== void 0 && (v.element = h(l.element)), v);
						}, 'JsdocTypeSymbol'),
						JsdocTypeOptional: O(
							(l, h) => ({
								type: 'JsdocTypeOptional',
								element: h(l.element),
								meta: { position: l.meta.position }
							}),
							'JsdocTypeOptional'
						),
						JsdocTypeObject: O(
							(l, h) => ({
								type: 'JsdocTypeObject',
								meta: { separator: 'comma' },
								elements: l.elements.map(h)
							}),
							'JsdocTypeObject'
						),
						JsdocTypeNumber: O((l) => l, 'JsdocTypeNumber'),
						JsdocTypeNull: O((l) => l, 'JsdocTypeNull'),
						JsdocTypeNotNullable: O(
							(l, h) => ({
								type: 'JsdocTypeNotNullable',
								element: h(l.element),
								meta: { position: l.meta.position }
							}),
							'JsdocTypeNotNullable'
						),
						JsdocTypeSpecialNamePath: O((l) => l, 'JsdocTypeSpecialNamePath'),
						JsdocTypeObjectField: O(
							(l, h) => ({
								type: 'JsdocTypeObjectField',
								key: l.key,
								right: l.right === void 0 ? void 0 : h(l.right),
								optional: l.optional,
								readonly: l.readonly,
								meta: l.meta
							}),
							'JsdocTypeObjectField'
						),
						JsdocTypeJsdocObjectField: O(
							(l, h) => ({ type: 'JsdocTypeJsdocObjectField', left: h(l.left), right: h(l.right) }),
							'JsdocTypeJsdocObjectField'
						),
						JsdocTypeKeyValue: O(
							(l, h) => ({
								type: 'JsdocTypeKeyValue',
								key: l.key,
								right: l.right === void 0 ? void 0 : h(l.right),
								optional: l.optional,
								variadic: l.variadic
							}),
							'JsdocTypeKeyValue'
						),
						JsdocTypeImport: O(
							(l, h) => ({ type: 'JsdocTypeImport', element: h(l.element) }),
							'JsdocTypeImport'
						),
						JsdocTypeAny: O((l) => l, 'JsdocTypeAny'),
						JsdocTypeStringValue: O((l) => l, 'JsdocTypeStringValue'),
						JsdocTypeNamePath: O((l) => l, 'JsdocTypeNamePath'),
						JsdocTypeVariadic: O((l, h) => {
							const v = {
								type: 'JsdocTypeVariadic',
								meta: { position: l.meta.position, squareBrackets: l.meta.squareBrackets }
							};
							return (l.element !== void 0 && (v.element = h(l.element)), v);
						}, 'JsdocTypeVariadic'),
						JsdocTypeTuple: O(
							(l, h) => ({ type: 'JsdocTypeTuple', elements: l.elements.map(h) }),
							'JsdocTypeTuple'
						),
						JsdocTypeName: O((l) => l, 'JsdocTypeName'),
						JsdocTypeFunction: O((l, h) => {
							const v = {
								type: 'JsdocTypeFunction',
								arrow: l.arrow,
								parameters: l.parameters.map(h),
								constructor: l.constructor,
								parenthesis: l.parenthesis
							};
							return (l.returnType !== void 0 && (v.returnType = h(l.returnType)), v);
						}, 'JsdocTypeFunction'),
						JsdocTypeKeyof: O(
							(l, h) => ({ type: 'JsdocTypeKeyof', element: h(l.element) }),
							'JsdocTypeKeyof'
						),
						JsdocTypeParenthesis: O(
							(l, h) => ({ type: 'JsdocTypeParenthesis', element: h(l.element) }),
							'JsdocTypeParenthesis'
						),
						JsdocTypeProperty: O((l) => l, 'JsdocTypeProperty'),
						JsdocTypePredicate: O(
							(l, h) => ({ type: 'JsdocTypePredicate', left: h(l.left), right: h(l.right) }),
							'JsdocTypePredicate'
						),
						JsdocTypeIndexSignature: O(
							(l, h) => ({ type: 'JsdocTypeIndexSignature', key: l.key, right: h(l.right) }),
							'JsdocTypeIndexSignature'
						),
						JsdocTypeMappedType: O(
							(l, h) => ({ type: 'JsdocTypeMappedType', key: l.key, right: h(l.right) }),
							'JsdocTypeMappedType'
						),
						JsdocTypeAsserts: O(
							(l, h) => ({ type: 'JsdocTypeAsserts', left: h(l.left), right: h(l.right) }),
							'JsdocTypeAsserts'
						),
						JsdocTypeReadonlyArray: O(
							(l, h) => ({ type: 'JsdocTypeReadonlyArray', element: h(l.element) }),
							'JsdocTypeReadonlyArray'
						),
						JsdocTypeAssertsPlain: O(
							(l, h) => ({ type: 'JsdocTypeAssertsPlain', element: h(l.element) }),
							'JsdocTypeAssertsPlain'
						),
						JsdocTypeConditional: O(
							(l, h) => ({
								type: 'JsdocTypeConditional',
								checksType: h(l.checksType),
								extendsType: h(l.extendsType),
								trueType: h(l.trueType),
								falseType: h(l.falseType)
							}),
							'JsdocTypeConditional'
						),
						JsdocTypeTypeParameter: O(
							(l, h) => ({
								type: 'JsdocTypeTypeParameter',
								name: h(l.name),
								constraint: l.constraint !== void 0 ? h(l.constraint) : void 0,
								defaultValue: l.defaultValue !== void 0 ? h(l.defaultValue) : void 0
							}),
							'JsdocTypeTypeParameter'
						)
					};
				}
				O(ss, 'identityTransformRules');
				const as = {
					JsdocTypeAny: [],
					JsdocTypeFunction: ['parameters', 'returnType'],
					JsdocTypeGeneric: ['left', 'elements'],
					JsdocTypeImport: [],
					JsdocTypeIndexSignature: ['right'],
					JsdocTypeIntersection: ['elements'],
					JsdocTypeKeyof: ['element'],
					JsdocTypeKeyValue: ['right'],
					JsdocTypeMappedType: ['right'],
					JsdocTypeName: [],
					JsdocTypeNamePath: ['left', 'right'],
					JsdocTypeNotNullable: ['element'],
					JsdocTypeNull: [],
					JsdocTypeNullable: ['element'],
					JsdocTypeNumber: [],
					JsdocTypeObject: ['elements'],
					JsdocTypeObjectField: ['right'],
					JsdocTypeJsdocObjectField: ['left', 'right'],
					JsdocTypeOptional: ['element'],
					JsdocTypeParenthesis: ['element'],
					JsdocTypeSpecialNamePath: [],
					JsdocTypeStringValue: [],
					JsdocTypeSymbol: ['element'],
					JsdocTypeTuple: ['elements'],
					JsdocTypeTypeof: ['element'],
					JsdocTypeUndefined: [],
					JsdocTypeUnion: ['elements'],
					JsdocTypeUnknown: [],
					JsdocTypeVariadic: ['element'],
					JsdocTypeProperty: [],
					JsdocTypePredicate: ['left', 'right'],
					JsdocTypeAsserts: ['left', 'right'],
					JsdocTypeReadonlyArray: ['element'],
					JsdocTypeAssertsPlain: ['element'],
					JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],
					JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue']
				};
				function Fr(l, h, v, x, F) {
					x?.(l, h, v);
					const z = as[l.type];
					for (const Z of z) {
						const ce = l[Z];
						if (ce !== void 0)
							if (Array.isArray(ce)) for (const Re of ce) Fr(Re, l, Z, x, F);
							else Fr(ce, l, Z, x, F);
					}
					F?.(l, h, v);
				}
				O(Fr, '_traverse');
				function ls(l, h, v) {
					Fr(l, void 0, void 0, h, v);
				}
				(O(ls, 'traverse'),
					(r.catharsisTransform = ns),
					(r.identityTransformRules = ss),
					(r.jtpTransform = is),
					(r.parse = kr),
					(r.stringify = rs),
					(r.stringifyRules = zn),
					(r.transform = Y),
					(r.traverse = ls),
					(r.tryParse = Gn),
					(r.visitorKeys = as));
			});
		}
	});
const { UnknownArgTypesError: z6 } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__,
	{ UnknownArgTypesError: W6 } = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
var tW = ['null', 'undefined'];
function Dc(e) {
	return tW.some((t) => t === e);
}
O(Dc, 'isDefaultValueBlacklisted');
var rW = O((e) => {
	if (!e) return '';
	if (typeof e == 'string') return e;
	throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, 'str');
function rb(e) {
	return !!e.__docgenInfo;
}
O(rb, 'hasDocgen');
function nW(e) {
	return e != null && Object.keys(e).length > 0;
}
O(nW, 'isValidDocgenSection');
function oW(e, t) {
	return rb(e) ? e.__docgenInfo[t] : null;
}
O(oW, 'getDocgenSection');
function kM(e) {
	return rb(e) ? rW(e.__docgenInfo.description) : '';
}
O(kM, 'getDocgenDescription');
var Pn;
(function (e) {
	((e.start = '/**'), (e.nostart = '/***'), (e.delim = '*'), (e.end = '*/'));
})((Pn = Pn || (Pn = {})));
function LM(e) {
	return /^\s+$/.test(e);
}
O(LM, 'isSpace');
function FM(e) {
	const t = e.match(/\r+$/);
	return t == null ? ['', e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];
}
O(FM, 'splitCR');
function uo(e) {
	const t = e.match(/^\s+/);
	return t == null ? ['', e] : [e.slice(0, t[0].length), e.slice(t[0].length)];
}
O(uo, 'splitSpace');
function BM(e) {
	return e.split(/\n/);
}
O(BM, 'splitLines');
function JM(e = {}) {
	return Object.assign(
		{ tag: '', name: '', type: '', optional: !1, description: '', problems: [], source: [] },
		e
	);
}
O(JM, 'seedSpec');
function $M(e = {}) {
	return Object.assign(
		{
			start: '',
			delimiter: '',
			postDelimiter: '',
			tag: '',
			postTag: '',
			name: '',
			postName: '',
			type: '',
			postType: '',
			description: '',
			end: '',
			lineEnd: ''
		},
		e
	);
}
O($M, 'seedTokens');
var iW = /^@\S+/;
function UM({ fence: e = '```' } = {}) {
	const t = VM(e),
		r = O((n, o) => (t(n) ? !o : o), 'toggleFence');
	return O(function (o) {
		const s = [[]];
		let a = !1;
		for (const u of o)
			(iW.test(u.tokens.description) && !a ? s.push([u]) : s[s.length - 1].push(u),
				(a = r(u.tokens.description, a)));
		return s;
	}, 'parseBlock');
}
O(UM, 'getParser');
function VM(e) {
	return typeof e == 'string' ? (t) => t.split(e).length % 2 === 0 : e;
}
O(VM, 'getFencer');
function HM({ startLine: e = 0, markers: t = Pn } = {}) {
	let r = null,
		n = e;
	return O(function (s) {
		let a = s;
		const u = $M();
		if (
			(([u.lineEnd, a] = FM(a)),
			([u.start, a] = uo(a)),
			r === null &&
				a.startsWith(t.start) &&
				!a.startsWith(t.nostart) &&
				((r = []),
				(u.delimiter = a.slice(0, t.start.length)),
				(a = a.slice(t.start.length)),
				([u.postDelimiter, a] = uo(a))),
			r === null)
		)
			return (n++, null);
		const c = a.trimRight().endsWith(t.end);
		if (
			(u.delimiter === '' &&
				a.startsWith(t.delim) &&
				!a.startsWith(t.end) &&
				((u.delimiter = t.delim), (a = a.slice(t.delim.length)), ([u.postDelimiter, a] = uo(a))),
			c)
		) {
			const d = a.trimRight();
			((u.end = a.slice(d.length - t.end.length)), (a = d.slice(0, -t.end.length)));
		}
		if (((u.description = a), r.push({ number: n, source: s, tokens: u }), n++, c)) {
			const d = r.slice();
			return ((r = null), d);
		}
		return null;
	}, 'parseSource');
}
O(HM, 'getParser');
function GM({ tokenizers: e }) {
	return O(function (r) {
		var n;
		let o = JM({ source: r });
		for (const s of e)
			if (
				((o = s(o)),
				!((n = o.problems[o.problems.length - 1]) === null || n === void 0) && n.critical)
			)
				break;
		return o;
	}, 'parseSpec');
}
O(GM, 'getParser');
function zM() {
	return (e) => {
		const { tokens: t } = e.source[0],
			r = t.description.match(/\s*(@(\S+))(\s*)/);
		return r === null
			? (e.problems.push({
					code: 'spec:tag:prefix',
					message: 'tag should start with "@" symbol',
					line: e.source[0].number,
					critical: !0
				}),
				e)
			: ((t.tag = r[1]),
				(t.postTag = r[3]),
				(t.description = t.description.slice(r[0].length)),
				(e.tag = r[2]),
				e);
	};
}
O(zM, 'tagTokenizer');
function WM(e = 'compact') {
	const t = KM(e);
	return (r) => {
		let n = 0,
			o = [];
		for (const [u, { tokens: c }] of r.source.entries()) {
			let d = '';
			if (u === 0 && c.description[0] !== '{') return r;
			for (const p of c.description)
				if ((p === '{' && n++, p === '}' && n--, (d += p), n === 0)) break;
			if ((o.push([c, d]), n === 0)) break;
		}
		if (n !== 0)
			return (
				r.problems.push({
					code: 'spec:type:unpaired-curlies',
					message: 'unpaired curlies',
					line: r.source[0].number,
					critical: !0
				}),
				r
			);
		const s = [],
			a = o[0][0].postDelimiter.length;
		for (const [u, [c, d]] of o.entries())
			((c.type = d),
				u > 0 &&
					((c.type = c.postDelimiter.slice(a) + d),
					(c.postDelimiter = c.postDelimiter.slice(0, a))),
				([c.postType, c.description] = uo(c.description.slice(d.length))),
				s.push(c.type));
		return (
			(s[0] = s[0].slice(1)),
			(s[s.length - 1] = s[s.length - 1].slice(0, -1)),
			(r.type = t(s)),
			r
		);
	};
}
O(WM, 'typeTokenizer');
var sW = O((e) => e.trim(), 'trim');
function KM(e) {
	return e === 'compact'
		? (t) => t.map(sW).join('')
		: e === 'preserve'
			? (t) =>
					t.join(`
`)
			: e;
}
O(KM, 'getJoiner');
var aW = O((e) => e && e.startsWith('"') && e.endsWith('"'), 'isQuoted');
function YM() {
	const e = O((t, { tokens: r }, n) => (r.type === '' ? t : n), 'typeEnd');
	return (t) => {
		const { tokens: r } = t.source[t.source.reduce(e, 0)],
			n = r.description.trimLeft(),
			o = n.split('"');
		if (o.length > 1 && o[0] === '' && o.length % 2 === 1)
			return (
				(t.name = o[1]),
				(r.name = `"${o[1]}"`),
				([r.postName, r.description] = uo(n.slice(r.name.length))),
				t
			);
		let s = 0,
			a = '',
			u = !1,
			c;
		for (const p of n) {
			if (s === 0 && LM(p)) break;
			(p === '[' && s++, p === ']' && s--, (a += p));
		}
		if (s !== 0)
			return (
				t.problems.push({
					code: 'spec:name:unpaired-brackets',
					message: 'unpaired brackets',
					line: t.source[0].number,
					critical: !0
				}),
				t
			);
		const d = a;
		if (a[0] === '[' && a[a.length - 1] === ']') {
			((u = !0), (a = a.slice(1, -1)));
			const p = a.split('=');
			if (((a = p[0].trim()), p[1] !== void 0 && (c = p.slice(1).join('=').trim()), a === ''))
				return (
					t.problems.push({
						code: 'spec:name:empty-name',
						message: 'empty name',
						line: t.source[0].number,
						critical: !0
					}),
					t
				);
			if (c === '')
				return (
					t.problems.push({
						code: 'spec:name:empty-default',
						message: 'empty default value',
						line: t.source[0].number,
						critical: !0
					}),
					t
				);
			if (!aW(c) && /=(?!>)/.test(c))
				return (
					t.problems.push({
						code: 'spec:name:invalid-default',
						message: 'invalid default value syntax',
						line: t.source[0].number,
						critical: !0
					}),
					t
				);
		}
		return (
			(t.optional = u),
			(t.name = a),
			(r.name = d),
			c !== void 0 && (t.default = c),
			([r.postName, r.description] = uo(n.slice(r.name.length))),
			t
		);
	};
}
O(YM, 'nameTokenizer');
function XM(e = 'compact', t = Pn) {
	const r = nb(e);
	return (n) => ((n.description = r(n.source, t)), n);
}
O(XM, 'descriptionTokenizer');
function nb(e) {
	return e === 'compact' ? QM : e === 'preserve' ? ZM : e;
}
O(nb, 'getJoiner');
function QM(e, t = Pn) {
	return e
		.map(({ tokens: { description: r } }) => r.trim())
		.filter((r) => r !== '')
		.join(' ');
}
O(QM, 'compactJoiner');
var lW = O((e, { tokens: t }, r) => (t.type === '' ? e : r), 'lineNo'),
	uW = O(
		({ tokens: e }) => (e.delimiter === '' ? e.start : e.postDelimiter.slice(1)) + e.description,
		'getDescription'
	);
function ZM(e, t = Pn) {
	if (e.length === 0) return '';
	e[0].tokens.description === '' && e[0].tokens.delimiter === t.start && (e = e.slice(1));
	const r = e[e.length - 1];
	return (
		r !== void 0 &&
			r.tokens.description === '' &&
			r.tokens.end.endsWith(t.end) &&
			(e = e.slice(0, -1)),
		(e = e.slice(e.reduce(lW, 0))),
		e.map(uW).join(`
`)
	);
}
O(ZM, 'preserveJoiner');
function eq({
	startLine: e = 0,
	fence: t = '```',
	spacing: r = 'compact',
	markers: n = Pn,
	tokenizers: o = [zM(), WM(r), YM(), XM(r)]
} = {}) {
	if (e < 0 || e % 1 > 0) throw new Error('Invalid startLine');
	const s = HM({ startLine: e, markers: n }),
		a = UM({ fence: t }),
		u = GM({ tokenizers: o }),
		c = nb(r);
	return function (d) {
		const p = [];
		for (const f of BM(d)) {
			const m = s(f);
			if (m === null) continue;
			const y = a(m),
				g = y.slice(1).map(u);
			p.push({
				description: c(y[0], n),
				tags: g,
				source: m,
				problems: g.reduce((E, T) => E.concat(T.problems), [])
			});
		}
		return p;
	};
}
O(eq, 'getParser');
function tq(e) {
	return (
		e.start +
		e.delimiter +
		e.postDelimiter +
		e.tag +
		e.postTag +
		e.type +
		e.postType +
		e.name +
		e.postName +
		e.description +
		e.end +
		e.lineEnd
	);
}
O(tq, 'join');
function cW() {
	return (e) =>
		e.source.map(({ tokens: t }) => tq(t)).join(`
`);
}
O(cW, 'getStringifier');
function rq(e, t = {}) {
	return eq(t)(e);
}
O(rq, 'parse');
var ob = Kz(eW(), 1);
function nq(e) {
	return e != null && e.includes('@');
}
O(nq, 'containsJsDoc');
function oq(e) {
	const n =
			`/**
` +
			(e ?? '')
				.split(
					`
`
				)
				.map((s) => ` * ${s}`).join(`
`) +
			`
*/`,
		o = rq(n, { spacing: 'preserve' });
	if (!o || o.length === 0) throw new Error('Cannot parse JSDoc tags.');
	return o[0];
}
O(oq, 'parse');
var dW = { tags: ['param', 'arg', 'argument', 'returns', 'ignore', 'deprecated'] },
	pW = O((e, t = dW) => {
		if (!nq(e)) return { includesJsDoc: !1, ignore: !1 };
		const r = oq(e),
			n = iq(r, t.tags);
		return n.ignore
			? { includesJsDoc: !0, ignore: !0 }
			: { includesJsDoc: !0, ignore: !1, description: r.description.trim(), extractedTags: n };
	}, 'parseJsDoc');
function iq(e, t) {
	const r = { params: null, deprecated: null, returns: null, ignore: !1 };
	for (const n of e.tags)
		if (!(t !== void 0 && !t.includes(n.tag)))
			if (n.tag === 'ignore') {
				r.ignore = !0;
				break;
			} else
				switch (n.tag) {
					case 'param':
					case 'arg':
					case 'argument': {
						const o = aq(n);
						o != null && (r.params == null && (r.params = []), r.params.push(o));
						break;
					}
					case 'deprecated': {
						const o = lq(n);
						o != null && (r.deprecated = o);
						break;
					}
					case 'returns': {
						const o = uq(n);
						o != null && (r.returns = o);
						break;
					}
				}
	return r;
}
O(iq, 'extractJsDocTags');
function sq(e) {
	return e.replace(/[\.-]$/, '');
}
O(sq, 'normaliseParamName');
function aq(e) {
	if (!e.name || e.name === '-') return null;
	const t = ab(e.type);
	return {
		name: e.name,
		type: t,
		description: sb(e.description),
		getPrettyName: O(() => sq(e.name), 'getPrettyName'),
		getTypeName: O(() => (t ? lb(t) : null), 'getTypeName')
	};
}
O(aq, 'extractParam');
function lq(e) {
	return e.name ? ib(e.name, e.description) : null;
}
O(lq, 'extractDeprecated');
function ib(e, t) {
	const r = e === '' ? t : `${e} ${t}`;
	return sb(r);
}
O(ib, 'joinNameAndDescription');
function sb(e) {
	const t = e.replace(/^- /g, '').trim();
	return t === '' ? null : t;
}
O(sb, 'normaliseDescription');
function uq(e) {
	const t = ab(e.type);
	return t
		? {
				type: t,
				description: ib(e.name, e.description),
				getTypeName: O(() => lb(t), 'getTypeName')
			}
		: null;
}
O(uq, 'extractReturns');
var Jn = (0, ob.stringifyRules)(),
	fW = Jn.JsdocTypeObject;
Jn.JsdocTypeAny = () => 'any';
Jn.JsdocTypeObject = (e, t) => `(${fW(e, t)})`;
Jn.JsdocTypeOptional = (e, t) => t(e.element);
Jn.JsdocTypeNullable = (e, t) => t(e.element);
Jn.JsdocTypeNotNullable = (e, t) => t(e.element);
Jn.JsdocTypeUnion = (e, t) => e.elements.map(t).join('|');
function ab(e) {
	try {
		return (0, ob.parse)(e, 'typescript');
	} catch {
		return null;
	}
}
O(ab, 'extractType');
function lb(e) {
	return (0, ob.transform)(Jn, e);
}
O(lb, 'extractTypeName');
var mW = 90,
	hW = 50;
function ub(e) {
	return e.length > mW;
}
O(ub, 'isTooLongForTypeSummary');
function cq(e) {
	return e.length > hW;
}
O(cq, 'isTooLongForDefaultValueSummary');
function ct(e, t) {
	return e === t ? { summary: e } : { summary: e, detail: t };
}
O(ct, 'createSummaryValue');
function yW(e, t) {
	if (e != null) {
		const { value: r } = e;
		if (!Dc(r)) return cq(r) ? ct(t?.name, r) : ct(r);
	}
	return null;
}
O(yW, 'createDefaultValue');
function cb({ name: e, value: t, elements: r, raw: n }) {
	return t ?? (r != null ? r.map(cb).join(' | ') : (n ?? e));
}
O(cb, 'generateUnionElement');
function dq({ name: e, raw: t, elements: r }) {
	return r != null ? ct(r.map(cb).join(' | ')) : t != null ? ct(t.replace(/^\|\s*/, '')) : ct(e);
}
O(dq, 'generateUnion');
function pq({ type: e, raw: t }) {
	return t != null ? ct(t) : ct(e);
}
O(pq, 'generateFuncSignature');
function fq({ type: e, raw: t }) {
	return t != null ? (ub(t) ? ct(e, t) : ct(t)) : ct(e);
}
O(fq, 'generateObjectSignature');
function mq(e) {
	const { type: t } = e;
	return t === 'object' ? fq(e) : pq(e);
}
O(mq, 'generateSignature');
function hq({ name: e, raw: t }) {
	return t != null ? (ub(t) ? ct(e, t) : ct(t)) : ct(e);
}
O(hq, 'generateDefault');
function gW(e) {
	if (e == null) return null;
	switch (e.name) {
		case 'union':
			return dq(e);
		case 'signature':
			return mq(e);
		default:
			return hq(e);
	}
}
O(gW, 'createType');
function bW({ defaultValue: e }) {
	if (e != null) {
		const { value: t } = e;
		if (!Dc(t)) return ct(t);
	}
	return null;
}
O(bW, 'createDefaultValue');
function vW({ tsType: e, required: t }) {
	if (e == null) return null;
	let r = e.name;
	return (
		t || (r = r.replace(' | undefined', '')),
		ct(['Array', 'Record', 'signature'].includes(e.name) ? e.raw : r)
	);
}
O(vW, 'createType');
function yq(e) {
	return e != null ? ct(e.name) : null;
}
O(yq, 'createType');
function gq(e) {
	const { computed: t, func: r } = e;
	return typeof t > 'u' && typeof r > 'u';
}
O(gq, 'isReactDocgenTypescript');
function bq(e) {
	return e
		? e.name === 'string'
			? !0
			: e.name === 'enum'
				? Array.isArray(e.value) &&
					e.value.every(
						({ value: t }) => typeof t == 'string' && t[0] === '"' && t[t.length - 1] === '"'
					)
				: !1
		: !1;
}
O(bq, 'isStringValued');
function vq(e, t) {
	if (e != null) {
		const { value: r } = e;
		if (!Dc(r)) return gq(e) && bq(t) ? ct(JSON.stringify(r)) : ct(r);
	}
	return null;
}
O(vq, 'createDefaultValue');
function EW(e, t, r) {
	const { description: n, required: o, defaultValue: s } = r;
	return { name: e, type: yq(t), required: o, description: n, defaultValue: vq(s, t) };
}
O(EW, 'createBasicPropDef');
function TW(e, t) {
	if (t?.includesJsDoc) {
		const { description: r, extractedTags: n } = t;
		r != null && (e.description = t.description);
		const o = {
			...n,
			params: n?.params?.map((s) => ({ name: s.getPrettyName(), description: s.description }))
		};
		Object.values(o).filter(Boolean).length > 0 && (e.jsDocTags = o);
	}
	return e;
}
O(TW, 'applyJsDocResult');
function _W(e, t, r, n) {
	const o = pW(t.description);
	return o.includesJsDoc && o.ignore
		? null
		: { propDef: n(e, t, o), jsDocTags: o.extractedTags, docgenInfo: t, typeSystem: r };
}
O(_W, 'extractProp');
function wW(e) {
	return e != null ? kM(e) : '';
}
O(wW, 'extractComponentDescription');
var Eq = O((...e) => {
		const t = {},
			r = e.filter(Boolean),
			n = r.reduce(
				(o, s) => (
					Object.entries(s).forEach(([a, u]) => {
						const c = o[a];
						Array.isArray(u) || typeof c > 'u'
							? (o[a] = u)
							: cl(u) && cl(c)
								? (t[a] = !0)
								: typeof u < 'u' && (o[a] = u);
					}),
					o
				),
				{}
			);
		return (
			Object.keys(t).forEach((o) => {
				const s = r
					.filter(Boolean)
					.map((a) => a[o])
					.filter((a) => typeof a < 'u');
				s.every((a) => cl(a)) ? (n[o] = Eq(...s)) : (n[o] = s[s.length - 1]);
			}),
			n
		);
	}, 'combineParameters'),
	SW = O((e) => {
		const {
				component: t,
				argTypes: r,
				parameters: { docs: n = {} }
			} = e,
			{ extractArgTypes: o } = n;
		if (!o || !t) return r;
		const s = o(t);
		return s ? Eq(s, r) : r;
	}, 'enhanceArgTypes'),
	RW = 'storybook/docs',
	K6 = `${RW}/snippet-rendered`,
	xf = ((e) => ((e.AUTO = 'auto'), (e.CODE = 'code'), (e.DYNAMIC = 'dynamic'), e))(xf || {});
const PW = {
	'./src/lib/components/atoms/AspectRatio.stories.svelte': () =>
		se(
			() => import('./AspectRatio.stories-DLSwTcuM.js'),
			__vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Avatar.stories.svelte': () =>
		se(
			() => import('./Avatar.stories-s2Yo3Vo8.js'),
			__vite__mapDeps([8, 1, 2, 9, 4, 5, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Badge.stories.svelte': () =>
		se(
			() => import('./Badge.stories-ByIlSobt.js'),
			__vite__mapDeps([10, 1, 2, 11, 4, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Button.stories.svelte': () =>
		se(
			() => import('./Button.stories-CuXy82RP.js'),
			__vite__mapDeps([12, 1, 2, 13, 3, 4, 5, 14, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Card.stories.svelte': () =>
		se(
			() => import('./Card.stories-BjzbGYQf.js'),
			__vite__mapDeps([15, 1, 2, 16, 3, 4, 5, 14, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Checkbox.stories.svelte': () =>
		se(
			() => import('./Checkbox.stories-CT2gzcze.js'),
			__vite__mapDeps([17, 1, 2, 3, 4, 5, 18, 19, 6, 20, 21, 22, 23, 24, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Chip.stories.svelte': () =>
		se(
			() => import('./Chip.stories-HbmuNntz.js'),
			__vite__mapDeps([25, 1, 2, 26, 3, 4, 5, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/FormInput.stories.svelte': () =>
		se(
			() => import('./FormInput.stories-D4SUjneU.js'),
			__vite__mapDeps([27, 1, 2, 28, 3, 4, 5, 23, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/FormTextarea.stories.svelte': () =>
		se(
			() => import('./FormTextarea.stories-BpLJCSMg.js'),
			__vite__mapDeps([29, 1, 2, 30, 3, 4, 5, 23, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Heading.stories.svelte': () =>
		se(
			() => import('./Heading.stories-CknTxXt_.js'),
			__vite__mapDeps([31, 1, 2, 32, 3, 4, 5, 14, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Icon.stories.svelte': () =>
		se(
			() => import('./Icon.stories-Pl0LsnSH.js'),
			__vite__mapDeps([33, 1, 2, 34, 3, 4, 5, 14, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/IconButton.stories.svelte': () =>
		se(
			() => import('./IconButton.stories-CZVfYJS1.js'),
			__vite__mapDeps([35, 1, 2, 36, 3, 4, 5, 34, 14, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/KeyboardShortcut.stories.svelte': () =>
		se(
			() => import('./KeyboardShortcut.stories-DykHV1xA.js'),
			__vite__mapDeps([37, 1, 2, 38, 39, 4, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Label.stories.svelte': () =>
		se(
			() => import('./Label.stories-CAeMGELq.js'),
			__vite__mapDeps([40, 1, 2, 24, 3, 4, 5, 6, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Loading.stories.svelte': () =>
		se(
			() => import('./Loading.stories-DTBDRL9w.js'),
			__vite__mapDeps([41, 1, 2, 42, 4, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/LoadingOverlay.stories.svelte': () =>
		se(
			() => import('./LoadingOverlay.stories-DvC68hSl.js'),
			__vite__mapDeps([43, 1, 2, 44, 45, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Meter.stories.svelte': () =>
		se(
			() => import('./Meter.stories-KrrQloTg.js'),
			__vite__mapDeps([46, 1, 2, 3, 4, 5, 6, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/PinInput.stories.svelte': () =>
		se(
			() => import('./PinInput.stories-DX-ccyOe.js'),
			__vite__mapDeps([47, 1, 2, 48, 39, 3, 4, 5, 18, 49, 50, 6, 51, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Progress.stories.svelte': () =>
		se(
			() => import('./Progress.stories-dAN89FFo.js'),
			__vite__mapDeps([52, 1, 2, 3, 4, 5, 6, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/RadioGroup.stories.svelte': () =>
		se(
			() => import('./RadioGroup.stories-YxsuGkkH.js'),
			__vite__mapDeps([53, 1, 2, 3, 4, 5, 18, 19, 6, 54, 21, 20, 22, 23, 51, 24, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/ScrollArea.stories.svelte': () =>
		se(
			() => import('./ScrollArea.stories-9nf11pH9.js'),
			__vite__mapDeps([55, 1, 2, 3, 4, 5, 18, 19, 56, 6, 50, 57, 49, 39, 7, 58]),
			import.meta.url
		),
	'./src/lib/components/atoms/Separator.stories.svelte': () =>
		se(
			() => import('./Separator.stories-s9AoVv4d.js'),
			__vite__mapDeps([59, 1, 2, 3, 4, 5, 6, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Slider.stories.svelte': () =>
		se(
			() => import('./Slider.stories-LzSAGrQm.js'),
			__vite__mapDeps([60, 1, 2, 3, 4, 5, 18, 19, 6, 20, 61, 62, 50, 21, 51, 39, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/SplitButton.stories.svelte': () =>
		se(
			() => import('./SplitButton.stories-O5kFaZuO.js'),
			__vite__mapDeps([
				63, 1, 2, 64, 39, 4, 13, 3, 5, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 66, 48, 18, 49, 50, 6,
				51, 28, 23, 30, 36, 44, 45, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 7
			]),
			import.meta.url
		),
	'./src/lib/components/atoms/StatusPill.stories.svelte': () =>
		se(
			() => import('./StatusPill.stories-CLnBhhl8.js'),
			__vite__mapDeps([71, 1, 2, 66, 4, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Switch.stories.svelte': () =>
		se(
			() => import('./Switch.stories-BkYPAsFZ.js'),
			__vite__mapDeps([72, 1, 2, 3, 4, 5, 18, 19, 6, 21, 22, 23, 51, 24, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Tabs.stories.ts': () =>
		se(() => import('./Tabs.stories-BBTvJ6Ne.js'), [], import.meta.url),
	'./src/lib/components/atoms/Text.stories.svelte': () =>
		se(
			() => import('./Text.stories-CNAGVoNW.js'),
			__vite__mapDeps([73, 1, 2, 65, 3, 4, 5, 14, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/Toggle.stories.svelte': () =>
		se(
			() => import('./Toggle.stories-DRUuQLOM.js'),
			__vite__mapDeps([74, 1, 2, 3, 4, 5, 6, 51, 7]),
			import.meta.url
		),
	'./src/lib/components/atoms/ToggleGroup.stories.svelte': () =>
		se(
			() => import('./ToggleGroup.stories-QqWbJsRc.js'),
			__vite__mapDeps([75, 1, 2, 3, 4, 5, 18, 19, 6, 54, 21, 20, 51, 7, 70]),
			import.meta.url
		),
	'./src/lib/components/atoms/Tooltip.stories.svelte': () =>
		se(
			() => import('./Tooltip.stories-DxRYWHip.js'),
			__vite__mapDeps([
				76, 1, 2, 18, 19, 20, 6, 4, 67, 51, 21, 50, 61, 54, 57, 62, 68, 56, 3, 5, 69, 13, 14, 7
			]),
			import.meta.url
		),
	'./src/lib/components/organisms/Accordion.stories.ts': () =>
		se(() => import('./Accordion.stories-BqQMdxYD.js'), [], import.meta.url),
	'./src/lib/components/organisms/Dialog.stories.svelte': () =>
		se(
			() => import('./Dialog.stories-CYuy5rO-.js'),
			__vite__mapDeps([
				77, 1, 2, 78, 3, 4, 5, 6, 51, 18, 19, 67, 20, 21, 50, 61, 54, 57, 69, 13, 14, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/inbox/components/InboxCard.stories.svelte': () =>
		se(
			() => import('./InboxCard.stories-Brf8F2Sk.js'),
			__vite__mapDeps([
				79, 1, 2, 13, 3, 4, 5, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 39, 66, 48, 18, 49, 50, 6, 51,
				28, 23, 30, 36, 44, 45, 64, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/ActionItemsList.stories.svelte': () =>
		se(
			() => import('./ActionItemsList.stories-9Jr0dLlq.js'),
			__vite__mapDeps([80, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/AgendaItemView.stories.svelte': () =>
		se(
			() => import('./AgendaItemView.stories-B-6gwCpT.js'),
			__vite__mapDeps([81, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/AttendeeSelector.stories.svelte': () =>
		se(
			() => import('./AttendeeSelector.stories-DuJsRcbJ.js'),
			__vite__mapDeps([82, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/CreateMeetingModal.stories.svelte': () =>
		se(
			() => import('./CreateMeetingModal.stories-DLXRU5sL.js'),
			__vite__mapDeps([83, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/DecisionsList.stories.svelte': () =>
		se(
			() => import('./DecisionsList.stories-BwXIKDEQ.js'),
			__vite__mapDeps([84, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/MeetingCard.stories.svelte': () =>
		se(
			() => import('./MeetingCard.stories-CJJ1d3hL.js'),
			__vite__mapDeps([
				85, 1, 2, 39, 3, 4, 5, 13, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 66, 48, 18, 49, 50, 6, 51,
				28, 23, 30, 36, 44, 45, 64, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/SecretaryConfirmationDialog.stories.svelte': () =>
		se(
			() => import('./SecretaryConfirmationDialog.stories-C8lB6Bpa.js'),
			__vite__mapDeps([86, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/SecretarySelector.stories.svelte': () =>
		se(
			() => import('./SecretarySelector.stories-Bd3LNQaN.js'),
			__vite__mapDeps([87, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/meetings/components/TodayMeetingCard.stories.svelte': () =>
		se(
			() => import('./TodayMeetingCard.stories-B_X5eh0a.js'),
			__vite__mapDeps([
				88, 1, 2, 39, 3, 4, 5, 13, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 66, 48, 18, 49, 50, 6, 51,
				28, 23, 30, 36, 44, 45, 64, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/CategoryHeader.stories.svelte': () =>
		se(
			() => import('./CategoryHeader.stories-BFUg6THq.js'),
			__vite__mapDeps([
				89, 1, 2, 13, 3, 4, 5, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 39, 66, 48, 18, 49, 50, 6, 51,
				28, 23, 30, 36, 44, 45, 64, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 90, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/CircleDetailHeader.stories.svelte': () =>
		se(
			() => import('./CircleDetailHeader.stories-CN5j4fki.js'),
			__vite__mapDeps([
				91, 1, 2, 13, 3, 4, 5, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 39, 66, 48, 18, 49, 50, 6, 51,
				28, 23, 30, 36, 44, 45, 64, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 90, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/CircleDetailPanel.stories.svelte': () =>
		se(
			() => import('./CircleDetailPanel.stories-CBTgvMgo.js'),
			__vite__mapDeps([92, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/CircleMembersPanel.stories.svelte': () =>
		se(
			() => import('./CircleMembersPanel.stories-CjEb7HOF.js'),
			__vite__mapDeps([93, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/CircleRolesPanel.stories.svelte': () =>
		se(
			() => import('./CircleRolesPanel.stories-Bkh7uqWn.js'),
			__vite__mapDeps([94, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/CreateCircleModal.stories.svelte': () =>
		se(
			() => import('./CreateCircleModal.stories-BlzAbEhx.js'),
			__vite__mapDeps([
				95, 1, 2, 39, 3, 4, 5, 23, 78, 6, 51, 18, 19, 67, 20, 21, 50, 61, 54, 57, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/OrgChart.stories.svelte': () =>
		se(
			() => import('./OrgChart.stories-CT2HEemn.js'),
			__vite__mapDeps([96, 1, 7]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/PanelBreadcrumbBar.stories.svelte': () =>
		se(
			() => import('./PanelBreadcrumbBar.stories-Du-ee3g6.js'),
			__vite__mapDeps([97, 1, 2, 3, 4, 5, 7]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/RoleCard.stories.svelte': () =>
		se(
			() => import('./RoleCard.stories-B2w7XVD-.js'),
			__vite__mapDeps([
				98, 1, 2, 13, 3, 4, 5, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 39, 66, 48, 18, 49, 50, 6, 51,
				28, 23, 30, 36, 44, 45, 64, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 90, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/RoleDetailHeader.stories.svelte': () =>
		se(
			() => import('./RoleDetailHeader.stories-D4dQ7PMK.js'),
			__vite__mapDeps([
				99, 1, 2, 13, 3, 4, 5, 14, 16, 11, 26, 34, 65, 32, 9, 42, 38, 39, 66, 48, 18, 49, 50, 6, 51,
				28, 23, 30, 36, 44, 45, 64, 67, 20, 19, 21, 61, 54, 57, 68, 56, 69, 70, 90, 7
			]),
			import.meta.url
		),
	'./src/lib/modules/org-chart/components/RoleDetailPanel.stories.svelte': () =>
		se(
			() => import('./RoleDetailPanel.stories-BJ3v613_.js'),
			__vite__mapDeps([100, 1, 7]),
			import.meta.url
		),
	'./src/stories/Introduction.mdx': () =>
		se(
			() => import('./Introduction-CA4zggUZ.js'),
			__vite__mapDeps([101, 102, 7, 103]),
			import.meta.url
		),
	'./src/stories/TokenReference.mdx': () =>
		se(
			() => import('./TokenReference-Bs-CDuYl.js'),
			__vite__mapDeps([104, 102, 7, 103]),
			import.meta.url
		)
};
async function AW(e) {
	return await PW[e]();
}
var Tq = Object.defineProperty,
	dt = (e, t) => Tq(e, 'name', { value: t, configurable: !0 }),
	OW = (e, t) => {
		for (var r in t) Tq(e, r, { get: t[r], enumerable: !0 });
	};
const CW = '5';
typeof window < 'u' && ((window.__svelte ??= {}).v ??= new Set()).add(CW);
const Y6 = 1,
	X6 = 2,
	Q6 = 4,
	Z6 = 8,
	e8 = 16,
	xW = 1,
	IW = 2,
	NW = 4,
	MW = 8,
	qW = 16,
	t8 = 1,
	r8 = 2,
	n8 = 4,
	_q = 1,
	jW = 2,
	St = Symbol(),
	o8 = 'http://www.w3.org/1999/xhtml',
	i8 = 'http://www.w3.org/2000/svg',
	s8 = '@attach',
	wq = !1;
var DW = Array.isArray,
	kW = Array.prototype.indexOf,
	LW = Array.from,
	FW = Object.defineProperty,
	An = Object.getOwnPropertyDescriptor,
	BW = Object.getOwnPropertyDescriptors,
	JW = Object.prototype,
	$W = Array.prototype,
	Sq = Object.getPrototypeOf,
	cE = Object.isExtensible;
function ys(e) {
	return typeof e == 'function';
}
const a8 = () => {};
function l8(e) {
	return e();
}
function UW(e) {
	for (var t = 0; t < e.length; t++) e[t]();
}
function Rq() {
	var e,
		t,
		r = new Promise((n, o) => {
			((e = n), (t = o));
		});
	return { promise: r, resolve: e, reject: t };
}
function VW(e, t, r = !1) {
	return e === void 0 ? (r ? t() : t) : e;
}
const Ct = 2,
	kc = 4,
	Lc = 8,
	cn = 16,
	dn = 32,
	$n = 64,
	Fc = 128,
	yr = 512,
	Pt = 1024,
	kt = 2048,
	pn = 4096,
	Ir = 8192,
	On = 16384,
	db = 32768,
	Dn = 65536,
	dE = 1 << 17,
	Pq = 1 << 18,
	Mo = 1 << 19,
	Aq = 1 << 20,
	ca = 32768,
	If = 1 << 21,
	pb = 1 << 22,
	Cn = 1 << 23,
	nn = Symbol('$state'),
	Oq = Symbol('legacy props'),
	u8 = Symbol(''),
	Wo = new (class extends Error {
		name = 'StaleReactionError';
		message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
	})();
function Cq(e) {
	throw new Error('https://svelte.dev/e/lifecycle_outside_component');
}
function HW() {
	throw new Error('https://svelte.dev/e/async_derived_orphan');
}
function GW(e) {
	throw new Error('https://svelte.dev/e/effect_in_teardown');
}
function zW() {
	throw new Error('https://svelte.dev/e/effect_in_unowned_derived');
}
function WW(e) {
	throw new Error('https://svelte.dev/e/effect_orphan');
}
function KW() {
	throw new Error('https://svelte.dev/e/effect_update_depth_exceeded');
}
function YW(e) {
	throw new Error('https://svelte.dev/e/props_invalid_value');
}
function XW() {
	throw new Error('https://svelte.dev/e/state_descriptors_fixed');
}
function QW() {
	throw new Error('https://svelte.dev/e/state_prototype_fixed');
}
function ZW() {
	throw new Error('https://svelte.dev/e/state_unsafe_mutation');
}
function eK() {
	throw new Error('https://svelte.dev/e/svelte_boundary_reset_onerror');
}
function d8() {
	console.warn('https://svelte.dev/e/select_multiple_invalid_value');
}
function tK() {
	console.warn('https://svelte.dev/e/svelte_boundary_reset_noop');
}
function xq(e) {
	return e === this.v;
}
function rK(e, t) {
	return e != e
		? t == t
		: e !== t || (e !== null && typeof e == 'object') || typeof e == 'function';
}
function Iq(e) {
	return !rK(e, this.v);
}
let Fi = !1,
	nK = !1;
function p8() {
	Fi = !0;
}
let Ge = null;
function wi(e) {
	Ge = e;
}
function Nq(e) {
	return $c().get(e);
}
function Mq(e, t) {
	return ($c().set(e, t), t);
}
function f8(e) {
	return $c().has(e);
}
function m8() {
	return $c();
}
function Bc(e, t = !1, r) {
	Ge = {
		p: Ge,
		i: !1,
		c: null,
		e: null,
		s: e,
		x: null,
		l: Fi && !t ? { s: null, u: null, $: [] } : null
	};
}
function Jc(e) {
	var t = Ge,
		r = t.e;
	if (r !== null) {
		t.e = null;
		for (var n of r) Xq(n);
	}
	return ((t.i = !0), (Ge = t.p), {});
}
function ja() {
	return !Fi || (Ge !== null && Ge.l === null);
}
function $c(e) {
	return (Ge === null && Cq(), (Ge.c ??= new Map(oK(Ge) || void 0)));
}
function oK(e) {
	let t = e.p;
	for (; t !== null; ) {
		const r = t.c;
		if (r !== null) return r;
		t = t.p;
	}
	return null;
}
let to = [];
function qq() {
	var e = to;
	((to = []), UW(e));
}
function Da(e) {
	if (to.length === 0 && !Fs) {
		var t = to;
		queueMicrotask(() => {
			t === to && qq();
		});
	}
	to.push(e);
}
function iK() {
	for (; to.length > 0; ) qq();
}
function jq(e) {
	var t = Me;
	if (t === null) return ((Ae.f |= Cn), e);
	if ((t.f & db) === 0) {
		if ((t.f & Fc) === 0) throw e;
		t.b.error(e);
	} else Si(e, t);
}
function Si(e, t) {
	for (; t !== null; ) {
		if ((t.f & Fc) !== 0)
			try {
				t.b.error(e);
				return;
			} catch (r) {
				e = r;
			}
		t = t.parent;
	}
	throw e;
}
const Ga = new Set();
let Qe = null,
	Ad = null,
	zt = null,
	Sr = [],
	Uc = null,
	Nf = !1,
	Fs = !1;
class mr {
	committed = !1;
	current = new Map();
	previous = new Map();
	#e = new Set();
	#t = new Set();
	#r = 0;
	#n = 0;
	#l = null;
	#s = [];
	#a = [];
	skipped_effects = new Set();
	is_fork = !1;
	process(t) {
		((Sr = []), (Ad = null), this.apply());
		var r = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] };
		for (const n of t) this.#o(n, r);
		(this.is_fork || this.#u(),
			this.#n > 0 || this.is_fork
				? (this.#i(r.effects), this.#i(r.render_effects), this.#i(r.block_effects))
				: ((Ad = this),
					(Qe = null),
					pE(r.render_effects),
					pE(r.effects),
					(Ad = null),
					this.#l?.resolve()),
			(zt = null));
	}
	#o(t, r) {
		t.f ^= Pt;
		for (var n = t.first; n !== null; ) {
			var o = n.f,
				s = (o & (dn | $n)) !== 0,
				a = s && (o & Pt) !== 0,
				u = a || (o & Ir) !== 0 || this.skipped_effects.has(n);
			if (
				((n.f & Fc) !== 0 &&
					n.b?.is_pending() &&
					(r = { parent: r, effect: n, effects: [], render_effects: [], block_effects: [] }),
				!u && n.fn !== null)
			) {
				s
					? (n.f ^= Pt)
					: (o & kc) !== 0
						? r.effects.push(n)
						: La(n) && ((n.f & cn) !== 0 && r.block_effects.push(n), pa(n));
				var c = n.first;
				if (c !== null) {
					n = c;
					continue;
				}
			}
			var d = n.parent;
			for (n = n.next; n === null && d !== null; )
				(d === r.effect &&
					(this.#i(r.effects), this.#i(r.render_effects), this.#i(r.block_effects), (r = r.parent)),
					(n = d.next),
					(d = d.parent));
		}
	}
	#i(t) {
		for (const r of t) (((r.f & kt) !== 0 ? this.#s : this.#a).push(r), Ot(r, Pt));
	}
	capture(t, r) {
		(this.previous.has(t) || this.previous.set(t, r),
			(t.f & Cn) === 0 && (this.current.set(t, t.v), zt?.set(t, t.v)));
	}
	activate() {
		((Qe = this), this.apply());
	}
	deactivate() {
		Qe === this && ((Qe = null), (zt = null));
	}
	flush() {
		if ((this.activate(), Sr.length > 0)) {
			if ((Dq(), Qe !== null && Qe !== this)) return;
		} else this.#r === 0 && this.process([]);
		this.deactivate();
	}
	discard() {
		for (const t of this.#t) t(this);
		this.#t.clear();
	}
	#u() {
		if (this.#n === 0) {
			for (const t of this.#e) t();
			this.#e.clear();
		}
		this.#r === 0 && this.#c();
	}
	#c() {
		if (Ga.size > 1) {
			this.previous.clear();
			var t = zt,
				r = !0,
				n = { parent: null, effect: null, effects: [], render_effects: [], block_effects: [] };
			for (const o of Ga) {
				if (o === this) {
					r = !1;
					continue;
				}
				const s = [];
				for (const [u, c] of this.current) {
					if (o.current.has(u))
						if (r && c !== o.current.get(u)) o.current.set(u, c);
						else continue;
					s.push(u);
				}
				if (s.length === 0) continue;
				const a = [...o.current.keys()].filter((u) => !this.current.has(u));
				if (a.length > 0) {
					const u = new Set(),
						c = new Map();
					for (const d of s) kq(d, a, u, c);
					if (Sr.length > 0) {
						((Qe = o), o.apply());
						for (const d of Sr) o.#o(d, n);
						((Sr = []), o.deactivate());
					}
				}
			}
			((Qe = null), (zt = t));
		}
		((this.committed = !0), Ga.delete(this));
	}
	increment(t) {
		((this.#r += 1), t && (this.#n += 1));
	}
	decrement(t) {
		((this.#r -= 1), t && (this.#n -= 1), this.revive());
	}
	revive() {
		for (const t of this.#s) (Ot(t, kt), So(t));
		for (const t of this.#a) (Ot(t, pn), So(t));
		((this.#s = []), (this.#a = []), this.flush());
	}
	oncommit(t) {
		this.#e.add(t);
	}
	ondiscard(t) {
		this.#t.add(t);
	}
	settled() {
		return (this.#l ??= Rq()).promise;
	}
	static ensure() {
		if (Qe === null) {
			const t = (Qe = new mr());
			(Ga.add(Qe),
				Fs ||
					mr.enqueue(() => {
						Qe === t && t.flush();
					}));
		}
		return Qe;
	}
	static enqueue(t) {
		Da(t);
	}
	apply() {}
}
function sK(e) {
	var t = Fs;
	Fs = !0;
	try {
		for (var r; ; ) {
			if ((iK(), Sr.length === 0 && (Qe?.flush(), Sr.length === 0))) return ((Uc = null), r);
			Dq();
		}
	} finally {
		Fs = t;
	}
}
function Dq() {
	var e = co;
	Nf = !0;
	try {
		var t = 0;
		for (yE(!0); Sr.length > 0; ) {
			var r = mr.ensure();
			if (t++ > 1e3) {
				var n, o;
				aK();
			}
			(r.process(Sr), xn.clear());
		}
	} finally {
		((Nf = !1), yE(e), (Uc = null));
	}
}
function aK() {
	try {
		KW();
	} catch (e) {
		Si(e, Uc);
	}
}
let zr = null;
function pE(e) {
	var t = e.length;
	if (t !== 0) {
		for (var r = 0; r < t; ) {
			var n = e[r++];
			if (
				(n.f & (On | Ir)) === 0 &&
				La(n) &&
				((zr = new Set()),
				pa(n),
				n.deps === null &&
					n.first === null &&
					n.nodes_start === null &&
					(n.teardown === null && n.ac === null ? ej(n) : (n.fn = null)),
				zr?.size > 0)
			) {
				xn.clear();
				for (const o of zr) {
					if ((o.f & (On | Ir)) !== 0) continue;
					const s = [o];
					let a = o.parent;
					for (; a !== null; ) (zr.has(a) && (zr.delete(a), s.push(a)), (a = a.parent));
					for (let u = s.length - 1; u >= 0; u--) {
						const c = s[u];
						(c.f & (On | Ir)) === 0 && pa(c);
					}
				}
				zr.clear();
			}
		}
		zr = null;
	}
}
function kq(e, t, r, n) {
	if (!r.has(e) && (r.add(e), e.reactions !== null))
		for (const o of e.reactions) {
			const s = o.f;
			(s & Ct) !== 0
				? kq(o, t, r, n)
				: (s & (pb | cn)) !== 0 && (s & kt) === 0 && Lq(o, t, n) && (Ot(o, kt), So(o));
		}
}
function Lq(e, t, r) {
	const n = r.get(e);
	if (n !== void 0) return n;
	if (e.deps !== null)
		for (const o of e.deps) {
			if (t.includes(o)) return !0;
			if ((o.f & Ct) !== 0 && Lq(o, t, r)) return (r.set(o, !0), !0);
		}
	return (r.set(e, !1), !1);
}
function So(e) {
	for (var t = (Uc = e); t.parent !== null; ) {
		t = t.parent;
		var r = t.f;
		if (Nf && t === Me && (r & cn) !== 0 && (r & Pq) === 0) return;
		if ((r & ($n | dn)) !== 0) {
			if ((r & Pt) === 0) return;
			t.f ^= Pt;
		}
	}
	Sr.push(t);
}
function lK(e) {
	let t = 0,
		r = ka(0),
		n;
	return () => {
		zc() &&
			(Pe(r),
			_K(
				() => (
					t === 0 && (n = mb(() => e(() => Bs(r)))),
					(t += 1),
					() => {
						Da(() => {
							((t -= 1), t === 0 && (n?.(), (n = void 0), Bs(r)));
						});
					}
				)
			));
	};
}
var uK = Dn | Mo | Fc;
function Fq(e, t, r) {
	new cK(e, t, r);
}
class cK {
	parent;
	#e = !1;
	#t;
	#r = null;
	#n;
	#l;
	#s;
	#a = null;
	#o = null;
	#i = null;
	#u = null;
	#c = null;
	#f = 0;
	#d = 0;
	#m = !1;
	#p = null;
	#v = lK(
		() => (
			(this.#p = ka(this.#f)),
			() => {
				this.#p = null;
			}
		)
	);
	constructor(t, r, n) {
		((this.#t = t),
			(this.#n = r),
			(this.#l = n),
			(this.parent = Me.b),
			(this.#e = !!this.#n.pending),
			(this.#s = Wc(() => {
				Me.b = this;
				{
					var o = this.#g();
					try {
						this.#a = Wr(() => n(o));
					} catch (s) {
						this.error(s);
					}
					this.#d > 0 ? this.#y() : (this.#e = !1);
				}
				return () => {
					this.#c?.remove();
				};
			}, uK)));
	}
	#E() {
		try {
			this.#a = Wr(() => this.#l(this.#t));
		} catch (t) {
			this.error(t);
		}
		this.#e = !1;
	}
	#T() {
		const t = this.#n.pending;
		t &&
			((this.#o = Wr(() => t(this.#t))),
			mr.enqueue(() => {
				var r = this.#g();
				((this.#a = this.#h(() => (mr.ensure(), Wr(() => this.#l(r))))),
					this.#d > 0
						? this.#y()
						: (Js(this.#o, () => {
								this.#o = null;
							}),
							(this.#e = !1)));
			}));
	}
	#g() {
		var t = this.#t;
		return (this.#e && ((this.#c = Ri()), this.#t.before(this.#c), (t = this.#c)), t);
	}
	is_pending() {
		return this.#e || (!!this.parent && this.parent.is_pending());
	}
	has_pending_snippet() {
		return !!this.#n.pending;
	}
	#h(t) {
		var r = Me,
			n = Ae,
			o = Ge;
		(Mr(this.#s), Mt(this.#s), wi(this.#s.ctx));
		try {
			return t();
		} catch (s) {
			return (jq(s), null);
		} finally {
			(Mr(r), Mt(n), wi(o));
		}
	}
	#y() {
		const t = this.#n.pending;
		(this.#a !== null &&
			((this.#u = document.createDocumentFragment()),
			this.#u.append(this.#c),
			nj(this.#a, this.#u)),
			this.#o === null && (this.#o = Wr(() => t(this.#t))));
	}
	#b(t) {
		if (!this.has_pending_snippet()) {
			this.parent && this.parent.#b(t);
			return;
		}
		((this.#d += t),
			this.#d === 0 &&
				((this.#e = !1),
				this.#o &&
					Js(this.#o, () => {
						this.#o = null;
					}),
				this.#u && (this.#t.before(this.#u), (this.#u = null))));
	}
	update_pending_count(t) {
		(this.#b(t), (this.#f += t), this.#p && lu(this.#p, this.#f));
	}
	get_effect_pending() {
		return (this.#v(), Pe(this.#p));
	}
	error(t) {
		var r = this.#n.onerror;
		let n = this.#n.failed;
		if (this.#m || (!r && !n)) throw t;
		(this.#a && (qt(this.#a), (this.#a = null)),
			this.#o && (qt(this.#o), (this.#o = null)),
			this.#i && (qt(this.#i), (this.#i = null)));
		var o = !1,
			s = !1;
		const a = () => {
			if (o) {
				tK();
				return;
			}
			((o = !0),
				s && eK(),
				mr.ensure(),
				(this.#f = 0),
				this.#i !== null &&
					Js(this.#i, () => {
						this.#i = null;
					}),
				(this.#e = this.has_pending_snippet()),
				(this.#a = this.#h(() => ((this.#m = !1), Wr(() => this.#l(this.#t))))),
				this.#d > 0 ? this.#y() : (this.#e = !1));
		};
		var u = Ae;
		try {
			(Mt(null), (s = !0), r?.(t, a), (s = !1));
		} catch (c) {
			Si(c, this.#s && this.#s.parent);
		} finally {
			Mt(u);
		}
		n &&
			Da(() => {
				this.#i = this.#h(() => {
					(mr.ensure(), (this.#m = !0));
					try {
						return Wr(() => {
							n(
								this.#t,
								() => t,
								() => a
							);
						});
					} catch (c) {
						return (Si(c, this.#s.parent), null);
					} finally {
						this.#m = !1;
					}
				});
			});
	}
}
function dK(e, t, r, n) {
	const o = ja() ? Vc : Bq;
	if (r.length === 0 && e.length === 0) {
		n(t.map(o));
		return;
	}
	var s = Qe,
		a = Me,
		u = pK();
	function c() {
		Promise.all(r.map((d) => fK(d)))
			.then((d) => {
				u();
				try {
					n([...t.map(o), ...d]);
				} catch (p) {
					(a.f & On) === 0 && Si(p, a);
				}
				(s?.deactivate(), au());
			})
			.catch((d) => {
				Si(d, a);
			});
	}
	e.length > 0
		? Promise.all(e).then(() => {
				u();
				try {
					return c();
				} finally {
					(s?.deactivate(), au());
				}
			})
		: c();
}
function pK() {
	var e = Me,
		t = Ae,
		r = Ge,
		n = Qe;
	return function (s = !0) {
		(Mr(e), Mt(t), wi(r), s && n?.activate());
	};
}
function au() {
	(Mr(null), Mt(null), wi(null));
}
function Vc(e) {
	var t = Ct | kt,
		r = Ae !== null && (Ae.f & Ct) !== 0 ? Ae : null;
	return (
		Me !== null && (Me.f |= Mo),
		{
			ctx: Ge,
			deps: null,
			effects: null,
			equals: xq,
			f: t,
			fn: e,
			reactions: null,
			rv: 0,
			v: St,
			wv: 0,
			parent: r ?? Me,
			ac: null
		}
	);
}
function fK(e, t) {
	let r = Me;
	r === null && HW();
	var n = r.b,
		o = void 0,
		s = ka(St),
		a = !Ae,
		u = new Map();
	return (
		TK(() => {
			var c = Rq();
			o = c.promise;
			try {
				Promise.resolve(e())
					.then(c.resolve, c.reject)
					.then(() => {
						(d === Qe && d.committed && d.deactivate(), au());
					});
			} catch (m) {
				(c.reject(m), au());
			}
			var d = Qe;
			if (a) {
				var p = !n.is_pending();
				(n.update_pending_count(1), d.increment(p), u.get(d)?.reject(Wo), u.delete(d), u.set(d, c));
			}
			const f = (m, y = void 0) => {
				if ((d.activate(), y)) y !== Wo && ((s.f |= Cn), lu(s, y));
				else {
					((s.f & Cn) !== 0 && (s.f ^= Cn), lu(s, m));
					for (const [g, E] of u) {
						if ((u.delete(g), g === d)) break;
						E.reject(Wo);
					}
				}
				a && (n.update_pending_count(-1), d.decrement(p));
			};
			c.promise.then(f, (m) => f(null, m || 'unknown'));
		}),
		Kq(() => {
			for (const c of u.values()) c.reject(Wo);
		}),
		new Promise((c) => {
			function d(p) {
				function f() {
					p === o ? c(s) : d(o);
				}
				p.then(f, f);
			}
			d(o);
		})
	);
}
function pl(e) {
	const t = Vc(e);
	return (oj(t), t);
}
function Bq(e) {
	const t = Vc(e);
	return ((t.equals = Iq), t);
}
function Jq(e) {
	var t = e.effects;
	if (t !== null) {
		e.effects = null;
		for (var r = 0; r < t.length; r += 1) qt(t[r]);
	}
}
function mK(e) {
	for (var t = e.parent; t !== null; ) {
		if ((t.f & Ct) === 0) return t;
		t = t.parent;
	}
	return null;
}
function fb(e) {
	var t,
		r = Me;
	Mr(mK(e));
	try {
		((e.f &= ~ca), Jq(e), (t = lj(e)));
	} finally {
		Mr(r);
	}
	return t;
}
function $q(e) {
	var t = fb(e);
	if ((e.equals(t) || ((e.v = t), (e.wv = sj())), !qo))
		if (zt !== null) zc() && zt.set(e, e.v);
		else {
			var r = (e.f & yr) === 0 ? pn : Pt;
			Ot(e, r);
		}
}
let Mf = new Set();
const xn = new Map();
let Uq = !1;
function ka(e, t) {
	var r = { f: 0, v: e, reactions: null, equals: xq, rv: 0, wv: 0 };
	return r;
}
function Ue(e, t) {
	const r = ka(e);
	return (oj(r), r);
}
function h8(e, t = !1, r = !0) {
	const n = ka(e);
	return (
		t || (n.equals = Iq),
		Fi && r && Ge !== null && Ge.l !== null && (Ge.l.s ??= []).push(n),
		n
	);
}
function Ve(e, t, r = !1) {
	Ae !== null &&
		(!Or || (Ae.f & dE) !== 0) &&
		ja() &&
		(Ae.f & (Ct | cn | pb | dE)) !== 0 &&
		!on?.includes(e) &&
		ZW();
	let n = r ? ro(t) : t;
	return lu(e, n);
}
function lu(e, t) {
	if (!e.equals(t)) {
		var r = e.v;
		(qo ? xn.set(e, t) : xn.set(e, r), (e.v = t));
		var n = mr.ensure();
		(n.capture(e, r),
			(e.f & Ct) !== 0 && ((e.f & kt) !== 0 && fb(e), Ot(e, (e.f & yr) !== 0 ? Pt : pn)),
			(e.wv = sj()),
			Vq(e, kt),
			ja() &&
				Me !== null &&
				(Me.f & Pt) !== 0 &&
				(Me.f & (dn | $n)) === 0 &&
				(er === null ? AK([e]) : er.push(e)),
			!n.is_fork && Mf.size > 0 && !Uq && hK());
	}
	return t;
}
function hK() {
	Uq = !1;
	const e = Array.from(Mf);
	for (const t of e) ((t.f & Pt) !== 0 && Ot(t, pn), La(t) && pa(t));
	Mf.clear();
}
function Bs(e) {
	Ve(e, e.v + 1);
}
function Vq(e, t) {
	var r = e.reactions;
	if (r !== null)
		for (var n = ja(), o = r.length, s = 0; s < o; s++) {
			var a = r[s],
				u = a.f;
			if (!(!n && a === Me)) {
				var c = (u & kt) === 0;
				if ((c && Ot(a, t), (u & Ct) !== 0)) {
					var d = a;
					(zt?.delete(d), (u & ca) === 0 && (u & yr && (a.f |= ca), Vq(d, pn)));
				} else c && ((u & cn) !== 0 && zr !== null && zr.add(a), So(a));
			}
		}
}
function ro(e) {
	if (typeof e != 'object' || e === null || nn in e) return e;
	const t = Sq(e);
	if (t !== JW && t !== $W) return e;
	var r = new Map(),
		n = DW(e),
		o = Ue(0),
		s = po,
		a = (u) => {
			if (po === s) return u();
			var c = Ae,
				d = po;
			(Mt(null), bE(s));
			var p = u();
			return (Mt(c), bE(d), p);
		};
	return (
		n && r.set('length', Ue(e.length)),
		new Proxy(e, {
			defineProperty(u, c, d) {
				(!('value' in d) || d.configurable === !1 || d.enumerable === !1 || d.writable === !1) &&
					XW();
				var p = r.get(c);
				return (
					p === void 0
						? (p = a(() => {
								var f = Ue(d.value);
								return (r.set(c, f), f);
							}))
						: Ve(p, d.value, !0),
					!0
				);
			},
			deleteProperty(u, c) {
				var d = r.get(c);
				if (d === void 0) {
					if (c in u) {
						const p = a(() => Ue(St));
						(r.set(c, p), Bs(o));
					}
				} else (Ve(d, St), Bs(o));
				return !0;
			},
			get(u, c, d) {
				if (c === nn) return e;
				var p = r.get(c),
					f = c in u;
				if (
					(p === void 0 &&
						(!f || An(u, c)?.writable) &&
						((p = a(() => {
							var y = ro(f ? u[c] : St),
								g = Ue(y);
							return g;
						})),
						r.set(c, p)),
					p !== void 0)
				) {
					var m = Pe(p);
					return m === St ? void 0 : m;
				}
				return Reflect.get(u, c, d);
			},
			getOwnPropertyDescriptor(u, c) {
				var d = Reflect.getOwnPropertyDescriptor(u, c);
				if (d && 'value' in d) {
					var p = r.get(c);
					p && (d.value = Pe(p));
				} else if (d === void 0) {
					var f = r.get(c),
						m = f?.v;
					if (f !== void 0 && m !== St)
						return { enumerable: !0, configurable: !0, value: m, writable: !0 };
				}
				return d;
			},
			has(u, c) {
				if (c === nn) return !0;
				var d = r.get(c),
					p = (d !== void 0 && d.v !== St) || Reflect.has(u, c);
				if (d !== void 0 || (Me !== null && (!p || An(u, c)?.writable))) {
					d === void 0 &&
						((d = a(() => {
							var m = p ? ro(u[c]) : St,
								y = Ue(m);
							return y;
						})),
						r.set(c, d));
					var f = Pe(d);
					if (f === St) return !1;
				}
				return p;
			},
			set(u, c, d, p) {
				var f = r.get(c),
					m = c in u;
				if (n && c === 'length')
					for (var y = d; y < f.v; y += 1) {
						var g = r.get(y + '');
						g !== void 0 ? Ve(g, St) : y in u && ((g = a(() => Ue(St))), r.set(y + '', g));
					}
				if (f === void 0)
					(!m || An(u, c)?.writable) && ((f = a(() => Ue(void 0))), Ve(f, ro(d)), r.set(c, f));
				else {
					m = f.v !== St;
					var E = a(() => ro(d));
					Ve(f, E);
				}
				var T = Reflect.getOwnPropertyDescriptor(u, c);
				if ((T?.set && T.set.call(p, d), !m)) {
					if (n && typeof c == 'string') {
						var b = r.get('length'),
							w = Number(c);
						Number.isInteger(w) && w >= b.v && Ve(b, w + 1);
					}
					Bs(o);
				}
				return !0;
			},
			ownKeys(u) {
				Pe(o);
				var c = Reflect.ownKeys(u).filter((f) => {
					var m = r.get(f);
					return m === void 0 || m.v !== St;
				});
				for (var [d, p] of r) p.v !== St && !(d in u) && c.push(d);
				return c;
			},
			setPrototypeOf() {
				QW();
			}
		})
	);
}
function fE(e) {
	try {
		if (e !== null && typeof e == 'object' && nn in e) return e[nn];
	} catch {}
	return e;
}
function y8(e, t) {
	return Object.is(fE(e), fE(t));
}
var mE, Hq, Gq, zq;
function yK() {
	if (mE === void 0) {
		((mE = window), (Hq = /Firefox/.test(navigator.userAgent)));
		var e = Element.prototype,
			t = Node.prototype,
			r = Text.prototype;
		((Gq = An(t, 'firstChild').get),
			(zq = An(t, 'nextSibling').get),
			cE(e) &&
				((e.__click = void 0),
				(e.__className = void 0),
				(e.__attributes = null),
				(e.__style = void 0),
				(e.__e = void 0)),
			cE(r) && (r.__t = void 0));
	}
}
function Ri(e = '') {
	return document.createTextNode(e);
}
function Xr(e) {
	return Gq.call(e);
}
function Hc(e) {
	return zq.call(e);
}
function g8(e, t) {
	return Xr(e);
}
function Ko(e, t = !1) {
	{
		var r = Xr(e);
		return r instanceof Comment && r.data === '' ? Hc(r) : r;
	}
}
function b8(e, t = 1, r = !1) {
	let n = e;
	for (; t--; ) n = Hc(n);
	return n;
}
function v8(e) {
	e.textContent = '';
}
function gK() {
	return !1;
}
function E8(e, t) {
	if (t) {
		const r = document.body;
		((e.autofocus = !0),
			Da(() => {
				document.activeElement === r && e.focus();
			}));
	}
}
let hE = !1;
function bK() {
	hE ||
		((hE = !0),
		document.addEventListener(
			'reset',
			(e) => {
				Promise.resolve().then(() => {
					if (!e.defaultPrevented) for (const t of e.target.elements) t.__on_r?.();
				});
			},
			{ capture: !0 }
		));
}
function Gc(e) {
	var t = Ae,
		r = Me;
	(Mt(null), Mr(null));
	try {
		return e();
	} finally {
		(Mt(t), Mr(r));
	}
}
function T8(e, t, r, n = r) {
	e.addEventListener(t, () => Gc(r));
	const o = e.__on_r;
	(o
		? (e.__on_r = () => {
				(o(), n(!0));
			})
		: (e.__on_r = () => n(!0)),
		bK());
}
function Wq(e) {
	(Me === null && (Ae === null && WW(), zW()), qo && GW());
}
function vK(e, t) {
	var r = t.last;
	r === null ? (t.last = t.first = e) : ((r.next = e), (e.prev = r), (t.last = e));
}
function vr(e, t, r, n = !0) {
	var o = Me;
	o !== null && (o.f & Ir) !== 0 && (e |= Ir);
	var s = {
		ctx: Ge,
		deps: null,
		nodes_start: null,
		nodes_end: null,
		f: e | kt | yr,
		first: null,
		fn: t,
		last: null,
		next: null,
		parent: o,
		b: o && o.b,
		prev: null,
		teardown: null,
		transitions: null,
		wv: 0,
		ac: null
	};
	if (r)
		try {
			(pa(s), (s.f |= db));
		} catch (c) {
			throw (qt(s), c);
		}
	else t !== null && So(s);
	if (n) {
		var a = s;
		if (
			(r &&
				a.deps === null &&
				a.teardown === null &&
				a.nodes_start === null &&
				a.first === a.last &&
				(a.f & Mo) === 0 &&
				((a = a.first), (e & cn) !== 0 && (e & Dn) !== 0 && a !== null && (a.f |= Dn)),
			a !== null &&
				((a.parent = o),
				o !== null && vK(a, o),
				Ae !== null && (Ae.f & Ct) !== 0 && (e & $n) === 0))
		) {
			var u = Ae;
			(u.effects ??= []).push(a);
		}
	}
	return s;
}
function zc() {
	return Ae !== null && !Or;
}
function Kq(e) {
	const t = vr(Lc, null, !1);
	return (Ot(t, Pt), (t.teardown = e), t);
}
function Yq(e) {
	Wq();
	var t = Me.f,
		r = !Ae && (t & dn) !== 0 && (t & db) === 0;
	if (r) {
		var n = Ge;
		(n.e ??= []).push(e);
	} else return Xq(e);
}
function Xq(e) {
	return vr(kc | Aq, e, !1);
}
function _8(e) {
	return (Wq(), vr(Lc | Aq, e, !0));
}
function w8(e) {
	mr.ensure();
	const t = vr($n | Mo, e, !0);
	return () => {
		qt(t);
	};
}
function EK(e) {
	mr.ensure();
	const t = vr($n | Mo, e, !0);
	return (r = {}) =>
		new Promise((n) => {
			r.outro
				? Js(t, () => {
						(qt(t), n(void 0));
					})
				: (qt(t), n(void 0));
		});
}
function S8(e) {
	return vr(kc, e, !1);
}
function TK(e) {
	return vr(pb | Mo, e, !0);
}
function _K(e, t = 0) {
	return vr(Lc | t, e, !0);
}
function R8(e, t = [], r = [], n = [], o = !1) {
	dK(n, t, r, (s) => {
		vr(o ? kc : Lc, () => e(...s.map(Pe)), !0);
	});
}
function Wc(e, t = 0) {
	var r = vr(cn | t, e, !0);
	return r;
}
function Wr(e, t = !0) {
	return vr(dn | Mo, e, !0, t);
}
function Qq(e) {
	var t = e.teardown;
	if (t !== null) {
		const r = qo,
			n = Ae;
		(gE(!0), Mt(null));
		try {
			t.call(null);
		} finally {
			(gE(r), Mt(n));
		}
	}
}
function Zq(e, t = !1) {
	var r = e.first;
	for (e.first = e.last = null; r !== null; ) {
		const o = r.ac;
		o !== null &&
			Gc(() => {
				o.abort(Wo);
			});
		var n = r.next;
		((r.f & $n) !== 0 ? (r.parent = null) : qt(r, t), (r = n));
	}
}
function wK(e) {
	for (var t = e.first; t !== null; ) {
		var r = t.next;
		((t.f & dn) === 0 && qt(t), (t = r));
	}
}
function qt(e, t = !0) {
	var r = !1;
	((t || (e.f & Pq) !== 0) &&
		e.nodes_start !== null &&
		e.nodes_end !== null &&
		(SK(e.nodes_start, e.nodes_end), (r = !0)),
		Zq(e, t && !r),
		uu(e, 0),
		Ot(e, On));
	var n = e.transitions;
	if (n !== null) for (const s of n) s.stop();
	Qq(e);
	var o = e.parent;
	(o !== null && o.first !== null && ej(e),
		(e.next =
			e.prev =
			e.teardown =
			e.ctx =
			e.deps =
			e.fn =
			e.nodes_start =
			e.nodes_end =
			e.ac =
				null));
}
function SK(e, t) {
	for (; e !== null; ) {
		var r = e === t ? null : Hc(e);
		(e.remove(), (e = r));
	}
}
function ej(e) {
	var t = e.parent,
		r = e.prev,
		n = e.next;
	(r !== null && (r.next = n),
		n !== null && (n.prev = r),
		t !== null && (t.first === e && (t.first = n), t.last === e && (t.last = r)));
}
function Js(e, t, r = !0) {
	var n = [];
	(tj(e, n, !0),
		RK(n, () => {
			(r && qt(e), t && t());
		}));
}
function RK(e, t) {
	var r = e.length;
	if (r > 0) {
		var n = () => --r || t();
		for (var o of e) o.out(n);
	} else t();
}
function tj(e, t, r) {
	if ((e.f & Ir) === 0) {
		if (((e.f ^= Ir), e.transitions !== null))
			for (const a of e.transitions) (a.is_global || r) && t.push(a);
		for (var n = e.first; n !== null; ) {
			var o = n.next,
				s = (n.f & Dn) !== 0 || ((n.f & dn) !== 0 && (e.f & cn) !== 0);
			(tj(n, t, s ? r : !1), (n = o));
		}
	}
}
function PK(e) {
	rj(e, !0);
}
function rj(e, t) {
	if ((e.f & Ir) !== 0) {
		((e.f ^= Ir), (e.f & Pt) === 0 && (Ot(e, kt), So(e)));
		for (var r = e.first; r !== null; ) {
			var n = r.next,
				o = (r.f & Dn) !== 0 || (r.f & dn) !== 0;
			(rj(r, o ? t : !1), (r = n));
		}
		if (e.transitions !== null) for (const s of e.transitions) (s.is_global || t) && s.in();
	}
}
function nj(e, t) {
	for (var r = e.nodes_start, n = e.nodes_end; r !== null; ) {
		var o = r === n ? null : Hc(r);
		(t.append(r), (r = o));
	}
}
let co = !1;
function yE(e) {
	co = e;
}
let qo = !1;
function gE(e) {
	qo = e;
}
let Ae = null,
	Or = !1;
function Mt(e) {
	Ae = e;
}
let Me = null;
function Mr(e) {
	Me = e;
}
let on = null;
function oj(e) {
	Ae !== null && (on === null ? (on = [e]) : on.push(e));
}
let It = null,
	$t = 0,
	er = null;
function AK(e) {
	er = e;
}
let ij = 1,
	da = 0,
	po = da;
function bE(e) {
	po = e;
}
function sj() {
	return ++ij;
}
function La(e) {
	var t = e.f;
	if ((t & kt) !== 0) return !0;
	if ((t & Ct && (e.f &= ~ca), (t & pn) !== 0)) {
		var r = e.deps;
		if (r !== null)
			for (var n = r.length, o = 0; o < n; o++) {
				var s = r[o];
				if ((La(s) && $q(s), s.wv > e.wv)) return !0;
			}
		(t & yr) !== 0 && zt === null && Ot(e, Pt);
	}
	return !1;
}
function aj(e, t, r = !0) {
	var n = e.reactions;
	if (n !== null && !on?.includes(e))
		for (var o = 0; o < n.length; o++) {
			var s = n[o];
			(s.f & Ct) !== 0
				? aj(s, t, !1)
				: t === s && (r ? Ot(s, kt) : (s.f & Pt) !== 0 && Ot(s, pn), So(s));
		}
}
function lj(e) {
	var t = It,
		r = $t,
		n = er,
		o = Ae,
		s = on,
		a = Ge,
		u = Or,
		c = po,
		d = e.f;
	((It = null),
		($t = 0),
		(er = null),
		(Ae = (d & (dn | $n)) === 0 ? e : null),
		(on = null),
		wi(e.ctx),
		(Or = !1),
		(po = ++da),
		e.ac !== null &&
			(Gc(() => {
				e.ac.abort(Wo);
			}),
			(e.ac = null)));
	try {
		e.f |= If;
		var p = e.fn,
			f = p(),
			m = e.deps;
		if (It !== null) {
			var y;
			if ((uu(e, $t), m !== null && $t > 0))
				for (m.length = $t + It.length, y = 0; y < It.length; y++) m[$t + y] = It[y];
			else e.deps = m = It;
			if (co && zc() && (e.f & yr) !== 0)
				for (y = $t; y < m.length; y++) (m[y].reactions ??= []).push(e);
		} else m !== null && $t < m.length && (uu(e, $t), (m.length = $t));
		if (ja() && er !== null && !Or && m !== null && (e.f & (Ct | pn | kt)) === 0)
			for (y = 0; y < er.length; y++) aj(er[y], e);
		return (
			o !== null && o !== e && (da++, er !== null && (n === null ? (n = er) : n.push(...er))),
			(e.f & Cn) !== 0 && (e.f ^= Cn),
			f
		);
	} catch (g) {
		return jq(g);
	} finally {
		((e.f ^= If), (It = t), ($t = r), (er = n), (Ae = o), (on = s), wi(a), (Or = u), (po = c));
	}
}
function OK(e, t) {
	let r = t.reactions;
	if (r !== null) {
		var n = kW.call(r, e);
		if (n !== -1) {
			var o = r.length - 1;
			o === 0 ? (r = t.reactions = null) : ((r[n] = r[o]), r.pop());
		}
	}
	r === null &&
		(t.f & Ct) !== 0 &&
		(It === null || !It.includes(t)) &&
		(Ot(t, pn), (t.f & yr) !== 0 && ((t.f ^= yr), (t.f &= ~ca)), Jq(t), uu(t, 0));
}
function uu(e, t) {
	var r = e.deps;
	if (r !== null) for (var n = t; n < r.length; n++) OK(e, r[n]);
}
function pa(e) {
	var t = e.f;
	if ((t & On) === 0) {
		Ot(e, Pt);
		var r = Me,
			n = co;
		((Me = e), (co = !0));
		try {
			((t & cn) !== 0 ? wK(e) : Zq(e), Qq(e));
			var o = lj(e);
			((e.teardown = typeof o == 'function' ? o : null), (e.wv = ij));
			var s;
			wq && nK && (e.f & kt) !== 0 && e.deps;
		} finally {
			((co = n), (Me = r));
		}
	}
}
async function vE() {
	(await Promise.resolve(), sK());
}
function Pe(e) {
	var t = e.f,
		r = (t & Ct) !== 0;
	if (Ae !== null && !Or) {
		var n = Me !== null && (Me.f & On) !== 0;
		if (!n && !on?.includes(e)) {
			var o = Ae.deps;
			if ((Ae.f & If) !== 0)
				e.rv < da &&
					((e.rv = da),
					It === null && o !== null && o[$t] === e
						? $t++
						: It === null
							? (It = [e])
							: It.includes(e) || It.push(e));
			else {
				(Ae.deps ??= []).push(e);
				var s = e.reactions;
				s === null ? (e.reactions = [Ae]) : s.includes(Ae) || s.push(Ae);
			}
		}
	}
	if (qo) {
		if (xn.has(e)) return xn.get(e);
		if (r) {
			var a = e,
				u = a.v;
			return (
				(((a.f & Pt) === 0 && a.reactions !== null) || cj(a)) && (u = fb(a)),
				xn.set(a, u),
				u
			);
		}
	} else if (r) {
		if (((a = e), zt?.has(a))) return zt.get(a);
		(La(a) && $q(a), co && zc() && (a.f & yr) === 0 && uj(a));
	} else if (zt?.has(e)) return zt.get(e);
	if ((e.f & Cn) !== 0) throw e.v;
	return e.v;
}
function uj(e) {
	if (e.deps !== null) {
		e.f ^= yr;
		for (const t of e.deps)
			((t.reactions ??= []).push(e), (t.f & Ct) !== 0 && (t.f & yr) === 0 && uj(t));
	}
}
function cj(e) {
	if (e.v === St) return !0;
	if (e.deps === null) return !1;
	for (const t of e.deps) if (xn.has(t) || ((t.f & Ct) !== 0 && cj(t))) return !0;
	return !1;
}
function mb(e) {
	var t = Or;
	try {
		return ((Or = !0), e());
	} finally {
		Or = t;
	}
}
const CK = -7169;
function Ot(e, t) {
	e.f = (e.f & CK) | t;
}
function P8(e) {
	if (!(typeof e != 'object' || !e || e instanceof EventTarget)) {
		if (nn in e) qf(e);
		else if (!Array.isArray(e))
			for (let t in e) {
				const r = e[t];
				typeof r == 'object' && r && nn in r && qf(r);
			}
	}
}
function qf(e, t = new Set()) {
	if (typeof e == 'object' && e !== null && !(e instanceof EventTarget) && !t.has(e)) {
		(t.add(e), e instanceof Date && e.getTime());
		for (let n in e)
			try {
				qf(e[n], t);
			} catch {}
		const r = Sq(e);
		if (
			r !== Object.prototype &&
			r !== Array.prototype &&
			r !== Map.prototype &&
			r !== Set.prototype &&
			r !== Date.prototype
		) {
			const n = BW(r);
			for (let o in n) {
				const s = n[o].get;
				if (s)
					try {
						s.call(e);
					} catch {}
			}
		}
	}
}
const dj = new Set(),
	jf = new Set();
function pj(e, t, r, n = {}) {
	function o(s) {
		if ((n.capture || Ps.call(t, s), !s.cancelBubble)) return Gc(() => r?.call(this, s));
	}
	return (
		e.startsWith('pointer') || e.startsWith('touch') || e === 'wheel'
			? Da(() => {
					t.addEventListener(e, o, n);
				})
			: t.addEventListener(e, o, n),
		o
	);
}
function A8(e, t, r, n = {}) {
	var o = pj(t, e, r, n);
	return () => {
		e.removeEventListener(t, o, n);
	};
}
function O8(e, t, r, n, o) {
	var s = { capture: n, passive: o },
		a = pj(e, t, r, s);
	(t === document.body || t === window || t === document || t instanceof HTMLMediaElement) &&
		Kq(() => {
			t.removeEventListener(e, a, s);
		});
}
function C8(e) {
	for (var t = 0; t < e.length; t++) dj.add(e[t]);
	for (var r of jf) r(e);
}
let EE = null;
function Ps(e) {
	var t = this,
		r = t.ownerDocument,
		n = e.type,
		o = e.composedPath?.() || [],
		s = o[0] || e.target;
	EE = e;
	var a = 0,
		u = EE === e && e.__root;
	if (u) {
		var c = o.indexOf(u);
		if (c !== -1 && (t === document || t === window)) {
			e.__root = t;
			return;
		}
		var d = o.indexOf(t);
		if (d === -1) return;
		c <= d && (a = c);
	}
	if (((s = o[a] || e.target), s !== t)) {
		FW(e, 'currentTarget', {
			configurable: !0,
			get() {
				return s || r;
			}
		});
		var p = Ae,
			f = Me;
		(Mt(null), Mr(null));
		try {
			for (var m, y = []; s !== null; ) {
				var g = s.assignedSlot || s.parentNode || s.host || null;
				try {
					var E = s['__' + n];
					E != null && (!s.disabled || e.target === s) && E.call(s, e);
				} catch (T) {
					m ? y.push(T) : (m = T);
				}
				if (e.cancelBubble || g === t || g === null) break;
				s = g;
			}
			if (m) {
				for (let T of y)
					queueMicrotask(() => {
						throw T;
					});
				throw m;
			}
		} finally {
			((e.__root = t), delete e.currentTarget, Mt(p), Mr(f));
		}
	}
}
function fj(e) {
	var t = document.createElement('template');
	return ((t.innerHTML = e.replaceAll('<!>', '<!---->')), t.content);
}
function Pi(e, t) {
	var r = Me;
	r.nodes_start === null && ((r.nodes_start = e), (r.nodes_end = t));
}
function xK(e, t) {
	var r = (t & _q) !== 0,
		n = (t & jW) !== 0,
		o,
		s = !e.startsWith('<!>');
	return () => {
		o === void 0 && ((o = fj(s ? e : '<!>' + e)), r || (o = Xr(o)));
		var a = n || Hq ? document.importNode(o, !0) : o.cloneNode(!0);
		if (r) {
			var u = Xr(a),
				c = a.lastChild;
			Pi(u, c);
		} else Pi(a, a);
		return a;
	};
}
function IK(e, t, r = 'svg') {
	var n = !e.startsWith('<!>'),
		o = (t & _q) !== 0,
		s = `<${r}>${n ? e : '<!>' + e}</${r}>`,
		a;
	return () => {
		if (!a) {
			var u = fj(s),
				c = Xr(u);
			if (o) for (a = document.createDocumentFragment(); Xr(c); ) a.appendChild(Xr(c));
			else a = Xr(c);
		}
		var d = a.cloneNode(!0);
		if (o) {
			var p = Xr(d),
				f = d.lastChild;
			Pi(p, f);
		} else Pi(d, d);
		return d;
	};
}
function x8(e, t) {
	return IK(e, t, 'svg');
}
function I8(e = '') {
	{
		var t = Ri(e + '');
		return (Pi(t, t), t);
	}
}
function Yo() {
	var e = document.createDocumentFragment(),
		t = document.createComment(''),
		r = Ri();
	return (e.append(t, r), Pi(t, r), e);
}
function no(e, t) {
	e !== null && e.before(t);
}
function N8() {
	return (((window.__svelte ??= {}).uid ??= 1), `c${window.__svelte.uid++}`);
}
function M8(e) {
	return e.endsWith('capture') && e !== 'gotpointercapture' && e !== 'lostpointercapture';
}
const NK = [
	'beforeinput',
	'click',
	'change',
	'dblclick',
	'contextmenu',
	'focusin',
	'focusout',
	'input',
	'keydown',
	'keyup',
	'mousedown',
	'mousemove',
	'mouseout',
	'mouseover',
	'mouseup',
	'pointerdown',
	'pointermove',
	'pointerout',
	'pointerover',
	'pointerup',
	'touchend',
	'touchmove',
	'touchstart'
];
function q8(e) {
	return NK.includes(e);
}
const MK = {
	formnovalidate: 'formNoValidate',
	ismap: 'isMap',
	nomodule: 'noModule',
	playsinline: 'playsInline',
	readonly: 'readOnly',
	defaultvalue: 'defaultValue',
	defaultchecked: 'defaultChecked',
	srcobject: 'srcObject',
	novalidate: 'noValidate',
	allowfullscreen: 'allowFullscreen',
	disablepictureinpicture: 'disablePictureInPicture',
	disableremoteplayback: 'disableRemotePlayback'
};
function j8(e) {
	return ((e = e.toLowerCase()), MK[e] ?? e);
}
const qK = ['touchstart', 'touchmove'];
function jK(e) {
	return qK.includes(e);
}
let Df = !0;
function D8(e) {
	Df = e;
}
function k8(e, t) {
	var r = t == null ? '' : typeof t == 'object' ? t + '' : t;
	r !== (e.__t ??= e.nodeValue) && ((e.__t = r), (e.nodeValue = r + ''));
}
function DK(e, t) {
	return kK(e, t);
}
const ko = new Map();
function kK(e, { target: t, anchor: r, props: n = {}, events: o, context: s, intro: a = !0 }) {
	yK();
	var u = new Set(),
		c = (f) => {
			for (var m = 0; m < f.length; m++) {
				var y = f[m];
				if (!u.has(y)) {
					u.add(y);
					var g = jK(y);
					t.addEventListener(y, Ps, { passive: g });
					var E = ko.get(y);
					E === void 0
						? (document.addEventListener(y, Ps, { passive: g }), ko.set(y, 1))
						: ko.set(y, E + 1);
				}
			}
		};
	(c(LW(dj)), jf.add(c));
	var d = void 0,
		p = EK(() => {
			var f = r ?? t.appendChild(Ri());
			return (
				Fq(f, { pending: () => {} }, (m) => {
					if (s) {
						Bc({});
						var y = Ge;
						y.c = s;
					}
					(o && (n.$$events = o), (Df = a), (d = e(m, n) || {}), (Df = !0), s && Jc());
				}),
				() => {
					for (var m of u) {
						t.removeEventListener(m, Ps);
						var y = ko.get(m);
						--y === 0 ? (document.removeEventListener(m, Ps), ko.delete(m)) : ko.set(m, y);
					}
					(jf.delete(c), f !== r && f.parentNode?.removeChild(f));
				}
			);
		});
	return (kf.set(d, p), d);
}
let kf = new WeakMap();
function LK(e, t) {
	const r = kf.get(e);
	return r ? (kf.delete(e), r(t)) : Promise.resolve();
}
class hb {
	anchor;
	#e = new Map();
	#t = new Map();
	#r = new Map();
	#n = !0;
	constructor(t, r = !0) {
		((this.anchor = t), (this.#n = r));
	}
	#l = () => {
		var t = Qe;
		if (this.#e.has(t)) {
			var r = this.#e.get(t),
				n = this.#t.get(r);
			if (n) PK(n);
			else {
				var o = this.#r.get(r);
				o &&
					(this.#t.set(r, o.effect),
					this.#r.delete(r),
					o.fragment.lastChild.remove(),
					this.anchor.before(o.fragment),
					(n = o.effect));
			}
			for (const [s, a] of this.#e) {
				if ((this.#e.delete(s), s === t)) break;
				const u = this.#r.get(a);
				u && (qt(u.effect), this.#r.delete(a));
			}
			for (const [s, a] of this.#t) {
				if (s === r) continue;
				const u = () => {
					if (Array.from(this.#e.values()).includes(s)) {
						var d = document.createDocumentFragment();
						(nj(a, d), d.append(Ri()), this.#r.set(s, { effect: a, fragment: d }));
					} else qt(a);
					this.#t.delete(s);
				};
				this.#n || !n ? Js(a, u, !1) : u();
			}
		}
	};
	#s = (t) => {
		this.#e.delete(t);
		const r = Array.from(this.#e.values());
		for (const [n, o] of this.#r) r.includes(n) || (qt(o.effect), this.#r.delete(n));
	};
	ensure(t, r) {
		var n = Qe,
			o = gK();
		if (r && !this.#t.has(t) && !this.#r.has(t))
			if (o) {
				var s = document.createDocumentFragment(),
					a = Ri();
				(s.append(a), this.#r.set(t, { effect: Wr(() => r(a)), fragment: s }));
			} else
				this.#t.set(
					t,
					Wr(() => r(this.anchor))
				);
		if ((this.#e.set(n, t), o)) {
			for (const [u, c] of this.#t)
				u === t ? n.skipped_effects.delete(c) : n.skipped_effects.add(c);
			for (const [u, c] of this.#r)
				u === t ? n.skipped_effects.delete(c.effect) : n.skipped_effects.add(c.effect);
			(n.oncommit(this.#l), n.ondiscard(this.#s));
		} else this.#l();
	}
}
function FK(e, t, ...r) {
	var n = new hb(e);
	Wc(() => {
		const o = t() ?? null;
		n.ensure(o, o && ((s) => o(s, ...r)));
	}, Dn);
}
function mj(e) {
	(Ge === null && Cq(),
		Fi && Ge.l !== null
			? BK(Ge).m.push(e)
			: Yq(() => {
					const t = mb(e);
					if (typeof t == 'function') return t;
				}));
}
function BK(e) {
	var t = e.l;
	return (t.u ??= { a: [], b: [], m: [] });
}
function JK(e, t, r = !1) {
	var n = new hb(e),
		o = r ? Dn : 0;
	function s(a, u) {
		n.ensure(a, u);
	}
	Wc(() => {
		var a = !1;
		(t((u, c = !0) => {
			((a = !0), s(c, u));
		}),
			a || s(!1, null));
	}, o);
}
function Od(e, t, r) {
	var n = new hb(e);
	Wc(() => {
		var o = t() ?? null;
		n.ensure(o, o && ((s) => r(s, o)));
	}, Dn);
}
let za = !1;
function $K(e) {
	var t = za;
	try {
		return ((za = !1), [e(), za]);
	} finally {
		za = t;
	}
}
const UK = {
	get(e, t) {
		if (!e.exclude.includes(t)) return e.props[t];
	},
	set(e, t) {
		return !1;
	},
	getOwnPropertyDescriptor(e, t) {
		if (!e.exclude.includes(t) && t in e.props)
			return { enumerable: !0, configurable: !0, value: e.props[t] };
	},
	has(e, t) {
		return e.exclude.includes(t) ? !1 : t in e.props;
	},
	ownKeys(e) {
		return Reflect.ownKeys(e.props).filter((t) => !e.exclude.includes(t));
	}
};
function L8(e, t, r) {
	return new Proxy({ props: e, exclude: t }, UK);
}
const VK = {
	get(e, t) {
		let r = e.props.length;
		for (; r--; ) {
			let n = e.props[r];
			if ((ys(n) && (n = n()), typeof n == 'object' && n !== null && t in n)) return n[t];
		}
	},
	set(e, t, r) {
		let n = e.props.length;
		for (; n--; ) {
			let o = e.props[n];
			ys(o) && (o = o());
			const s = An(o, t);
			if (s && s.set) return (s.set(r), !0);
		}
		return !1;
	},
	getOwnPropertyDescriptor(e, t) {
		let r = e.props.length;
		for (; r--; ) {
			let n = e.props[r];
			if ((ys(n) && (n = n()), typeof n == 'object' && n !== null && t in n)) {
				const o = An(n, t);
				return (o && !o.configurable && (o.configurable = !0), o);
			}
		}
	},
	has(e, t) {
		if (t === nn || t === Oq) return !1;
		for (let r of e.props) if ((ys(r) && (r = r()), r != null && t in r)) return !0;
		return !1;
	},
	ownKeys(e) {
		const t = [];
		for (let r of e.props)
			if ((ys(r) && (r = r()), !!r)) {
				for (const n in r) t.includes(n) || t.push(n);
				for (const n of Object.getOwnPropertySymbols(r)) t.includes(n) || t.push(n);
			}
		return t;
	}
};
function Cd(...e) {
	return new Proxy({ props: e }, VK);
}
function HK(e, t, r, n) {
	var o = !Fi || (r & IW) !== 0,
		s = (r & MW) !== 0,
		a = (r & qW) !== 0,
		u = n,
		c = !0,
		d = () => (c && ((c = !1), (u = a ? mb(n) : n)), u),
		p;
	if (s) {
		var f = nn in e || Oq in e;
		p = An(e, t)?.set ?? (f && t in e ? (P) => (e[t] = P) : void 0);
	}
	var m,
		y = !1;
	(s ? ([m, y] = $K(() => e[t])) : (m = e[t]),
		m === void 0 && n !== void 0 && ((m = d()), p && (o && YW(), p(m))));
	var g;
	if (
		(o
			? (g = () => {
					var P = e[t];
					return P === void 0 ? d() : ((c = !0), P);
				})
			: (g = () => {
					var P = e[t];
					return (P !== void 0 && (u = void 0), P === void 0 ? u : P);
				}),
		o && (r & NW) === 0)
	)
		return g;
	if (p) {
		var E = e.$$legacy;
		return function (P, I) {
			return arguments.length > 0 ? ((!o || !I || E || y) && p(I ? g() : P), P) : g();
		};
	}
	var T = !1,
		b = ((r & xW) !== 0 ? Vc : Bq)(() => ((T = !1), g()));
	s && Pe(b);
	var w = Me;
	return function (P, I) {
		if (arguments.length > 0) {
			const q = I ? Pe(b) : o && s ? ro(P) : P;
			return (Ve(b, q), (T = !0), u !== void 0 && (u = q), P);
		}
		return (qo && T) || (w.f & On) !== 0 ? b.v : Pe(b);
	};
}
function hj(e, t) {
	Bc(t, !0);
	let r = pl(() =>
		Object.fromEntries(Object.entries(t.props).filter(([u]) => !u.startsWith('event_')))
	);
	var n = Yo(),
		o = Ko(n);
	{
		var s = (u) => {
				var c = Yo(),
					d = Ko(c);
				(Od(
					d,
					() => t.decorator.Component,
					(p, f) => {
						f(
							p,
							Cd(() => t.decorator.props, {
								children: (m, y) => {
									var g = Yo(),
										E = Ko(g);
									(Od(
										E,
										() => t.Component,
										(T, b) => {
											b(
												T,
												Cd(() => Pe(r))
											);
										}
									),
										no(m, g));
								},
								$$slots: { default: !0 }
							})
						);
					}
				),
					no(u, c));
			},
			a = (u) => {
				var c = Yo(),
					d = Ko(c);
				(Od(
					d,
					() => t.Component,
					(p, f) => {
						f(
							p,
							Cd(() => Pe(r))
						);
					}
				),
					no(u, c));
			};
		JK(o, (u) => {
			t.decorator ? u(s) : u(a, !1);
		});
	}
	(no(e, n), Jc());
}
function GK(e) {
	for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
	var n = Array.from(typeof e == 'string' ? [e] : e);
	n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '');
	var o = n.reduce(function (u, c) {
		var d = c.match(/\n([\t ]+|(?!\s).)/g);
		return d
			? u.concat(
					d.map(function (p) {
						var f, m;
						return (m = (f = p.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !==
							null && m !== void 0
							? m
							: 0;
					})
				)
			: u;
	}, []);
	if (o.length) {
		var s = new RegExp(
			`
[	 ]{` +
				Math.min.apply(Math, o) +
				'}',
			'g'
		);
		n = n.map(function (u) {
			return u.replace(
				s,
				`
`
			);
		});
	}
	n[0] = n[0].replace(/^\r?\n/, '');
	var a = n[0];
	return (
		t.forEach(function (u, c) {
			var d = a.match(/(?:^|\n)( *)$/),
				p = d ? d[1] : '',
				f = u;
			(typeof u == 'string' &&
				u.includes(`
`) &&
				(f = String(u)
					.split(
						`
`
					)
					.map(function (m, y) {
						return y === 0 ? m : '' + p + m;
					}).join(`
`)),
				(a += f + n[c + 1]));
		}),
		a
	);
}
var zK = xK('<div id="sb-pending-async-component-notice">Pending async component...</div>');
function WK(e, t) {
	Bc(t, !0);
	let r = pl(() => t.storyFn()),
		n = pl(() => Pe(r).Component),
		o = pl(() => VW(Pe(r).props, () => ({}), !0));
	Yq(() => {
		Pe(n) ||
			t.showError({
				title: `Expecting a Svelte component from the story: "${t.name}" of "${t.title}".`,
				description: GK`
        Did you forget to return the Svelte component configuration from the story?
        Use "() => ({ Component: YourComponent, props: {} })"
        when defining the story.
      `
			});
	});
	var s = Yo(),
		a = Ko(s);
	(Fq(
		a,
		{
			pending: (c) => {
				var d = zK();
				no(c, d);
			}
		},
		(c) => {
			hj(c, {
				get Component() {
					return Pe(n);
				},
				get props() {
					return Pe(o);
				}
			});
		}
	),
		no(e, s),
		Jc());
}
const KK = (e) => ro(e);
var YK = {};
OW(YK, {
	applyDecorators: () => gb,
	argTypesEnhancers: () => Tj,
	mount: () => vj,
	parameters: () => Ej,
	render: () => bj,
	renderToCanvas: () => yb
});
const { logger: XK } = __STORYBOOK_MODULE_CLIENT_LOGGER__;
function yj(e, t) {
	return t ? t.find((r) => r.name === e) != null : !1;
}
dt(yj, 'hasKeyword');
var QK = dt((e) => {
		try {
			const t = e.__docgen;
			if (t) return ZK(t);
		} catch (t) {
			XK.log(`Error extracting argTypes: ${t}`);
		}
		return {};
	}, 'extractArgTypes'),
	ZK = dt((e) => {
		const t = {};
		return (
			e.data &&
				e.data.forEach((r) => {
					t[r.name] = {
						...e5(r.type),
						name: r.name,
						description: r.description || void 0,
						type: {
							required: yj('required', r.keywords || []),
							name: r.type?.text === '{}' ? 'object' : r.type?.text
						},
						table: {
							type: { summary: r.type?.text },
							defaultValue: { summary: r.defaultValue },
							category: 'properties'
						}
					};
				}),
			e.events &&
				e.events.forEach((r) => {
					t[`event_${r.name}`] = {
						name: r.name,
						action: r.name,
						control: !1,
						...(r.description ? { description: r.description } : {}),
						table: { category: 'events' }
					};
				}),
			e.slots &&
				e.slots.forEach((r) => {
					t[`slot_${r.name}`] = {
						name: r.name,
						control: !1,
						description: [r.description, r.params?.map((n) => `\`${n.name}\``).join(' ')].filter(
							(n) => n
						).join(`

`),
						table: { category: 'slots' }
					};
				}),
			t
		);
	}, 'createArgTypes'),
	e5 = dt((e) => {
		if (!e) return null;
		if (e.kind === 'type')
			switch (e.type) {
				case 'string':
					return { control: { type: 'text' } };
				case 'any':
					return { control: { type: 'object' } };
				default:
					return { control: { type: e.type } };
			}
		else if (e.kind === 'union') {
			if (
				Array.isArray(e.type) &&
				!e.type.some(
					(t) => t.kind !== 'const' || !['string', 'number', 'null', 'undefined'].includes(t.type)
				)
			) {
				const t = e.type.map((r) => r.value);
				return { control: { type: 'radio' }, options: t };
			}
		} else if (e.kind === 'function') return { control: null };
		return null;
	}, 'parseTypeToControl');
function gj(e) {
	return e?.__docgen?.description || '';
}
dt(gj, 'extractComponentDescription');
const { RESET_STORY_ARGS: t5 } = __STORYBOOK_MODULE_CORE_EVENTS__,
	{ addons: r5 } = __STORYBOOK_MODULE_PREVIEW_API__;
var Lf = new Set();
r5.getChannel().on(t5, ({ storyId: e }) => {
	Lf.add(e);
});
var Wa = new Map();
async function yb(
	{ storyFn: e, title: t, name: r, showMain: n, showError: o, storyContext: s, forceRemount: a },
	u
) {
	function c(f) {
		const { mountedComponent: m } = Wa.get(f) ?? {};
		m && (LK(m), Wa.delete(f));
	}
	dt(c, 'unmount');
	const d = Wa.get(u);
	let p = a;
	if ((Lf.has(s.id) && ((p = !0), Lf.delete(s.id)), p && c(u), !d || p)) {
		const f = KK({ storyFn: e, storyContext: s, name: r, title: t, showError: o }),
			m = DK(WK, { target: u, props: f });
		(Wa.set(u, { mountedComponent: m, props: f }), await vE());
	} else
		(Object.assign(d.props, { storyFn: e, storyContext: s, name: r, title: t, showError: o }),
			await vE());
	return (
		n(),
		() => {
			c(u);
		}
	);
}
dt(yb, 'renderToCanvas');
var bj = dt((e, t) => {
	const { id: r, component: n } = t;
	if (!n)
		throw new Error(
			`Unable to render story ${r} as the component annotation is missing from the default export`
		);
	return { Component: n, props: e };
}, 'render');
const { sanitizeStoryContextUpdate: n5 } = __STORYBOOK_MODULE_PREVIEW_API__;
function Ff(e) {
	return e && typeof e == 'object' && 'default' in e ? e.default : e;
}
dt(Ff, 'unWrap');
function Bf(e, t, r) {
	const n = Ff(t),
		o = r && Ff(r);
	let s;
	return (
		!n || Object.keys(n).length === 0
			? (s = { Component: e.component })
			: n.Component
				? (s = n)
				: (s = { Component: n }),
		o ? { Component: hj, props: { ...o, decorator: s } } : { ...s, argTypes: e.argTypes }
	);
}
dt(Bf, 'prepareStory');
function gb(e, t) {
	return t.reduce(
		(r, n) => (o) => {
			let s;
			const a = n((u) => ((s = r({ ...o, ...n5(u) })), s), o);
			return (s || (s = r(o)), a === s ? s : Bf(o, a, s));
		},
		(r) => Bf(r, e(r))
	);
}
dt(gb, 'decorateStory');
var vj = dt(
		(e) => async (t, r) => (
			t && (e.originalStoryFn = () => ({ Component: t, props: r && 'props' in r ? r?.props : r })),
			await e.renderToCanvas(),
			e.canvas
		),
		'mount'
	),
	Ej = {
		renderer: 'svelte',
		docs: { story: { inline: !0 }, extractArgTypes: QK, extractComponentDescription: gj }
	},
	Tj = [SW];
const o5 = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				applyDecorators: gb,
				argTypesEnhancers: Tj,
				mount: vj,
				parameters: Ej,
				render: bj,
				renderToCanvas: yb
			},
			Symbol.toStringTag,
			{ value: 'Module' }
		)
	),
	{ deprecate: i5 } = __STORYBOOK_MODULE_CLIENT_LOGGER__,
	{ emitTransformCode: s5, useEffect: a5, useRef: l5 } = __STORYBOOK_MODULE_PREVIEW_API__;
var u5 = dt((e) => {
	const t = e?.parameters.docs?.source,
		r = e?.parameters.__isArgsStory;
	return (e?.tags ?? []).some((n) => n.startsWith('svelte-csf'))
		? !0
		: t?.type === xf.DYNAMIC
			? !1
			: !r || t?.code || t?.type === xf.CODE;
}, 'skipSourceRender');
function _j(e, t, r) {
	if (t == null) return null;
	const n = r[e];
	return (n && n.defaultValue === t) || (n && n.action)
		? null
		: t === !0
			? e
			: typeof t == 'string'
				? `${e}=${JSON.stringify(t)}`
				: typeof t == 'function'
					? `${e}={<handler>}`
					: `${e}={${JSON.stringify(t)}}`;
}
dt(_j, 'toSvelteProperty');
function wj(e) {
	if (e == null) return null;
	const { __docgen: t = {} } = e;
	let { name: r } = t;
	return r ? (r.endsWith('.svelte') && (r = r.substring(0, r.length - 7)), r) : e.name;
}
dt(wj, 'getComponentName');
function Sj(e, t, r, n) {
	const o = wj(e);
	if (!o) return null;
	const s = Object.entries(t)
			.filter(([p]) => p !== n)
			.map(([p, f]) => _j(p, f, r))
			.filter((p) => p),
		a = s.join(' '),
		u = a.length > 50,
		c = n ? t[n] : null,
		d = u
			? `<${o}
  ${s.join(`
  `)}`
			: `<${o} ${a}`;
	return c
		? `${d}>
    ${c}
</${o}>`
		: `${d}/>`;
}
dt(Sj, 'generateSvelteSource');
function Rj(e) {
	const { __docgen: t } = e || {};
	return t
		? t.keywords?.find((n) => n.name === 'wrapper')
			? {
					wrapper: !0,
					slotProperty: t.data?.find((n) => n.keywords.find((o) => o.name === 'slot'))?.name
				}
			: { wrapper: !1 }
		: { wrapper: !1 };
}
dt(Rj, 'getWrapperProperties');
var c5 = dt((e, t) => {
		const r = u5(t),
			n = e(),
			o = l5(void 0);
		return (
			a5(() => {
				if (r) return;
				const { parameters: s = {}, args: a = {}, component: u } = t || {};
				let { Component: c } = t.originalStoryFn(a, t);
				const { wrapper: d, slotProperty: p } = Rj(c);
				d &&
					(s.component &&
						i5('parameters.component is deprecated. Using context.component instead.'),
					(c = u));
				const f = Sj(c, a, t?.argTypes, p);
				f && o.current !== f && (s5(f, t), (o.current = f));
			}),
			n
		);
	}, 'sourceDecorator'),
	d5 = [c5];
const p5 = Object.freeze(
	Object.defineProperty({ __proto__: null, decorators: d5 }, Symbol.toStringTag, {
		value: 'Module'
	})
);
var Pj = Object.defineProperty,
	xt = (e, t) => Pj(e, 'name', { value: t, configurable: !0 }),
	f5 = (e, t) => {
		for (var r in t) Pj(e, r, { get: t[r], enumerable: !0 });
	};
async function m5(...e) {
	const t = new CustomEvent('storybook:goto', { detail: e });
	window.dispatchEvent(t);
}
xt(m5, 'goto');
function Aj(e) {
	Mq('after-navigate-args', e);
}
xt(Aj, 'setAfterNavigateArgument');
function h5(e) {
	const t = Nq('after-navigate-args');
	mj(() => {
		e && e instanceof Function && e(t);
	});
}
xt(h5, 'afterNavigate');
function y5() {}
xt(y5, 'onNavigate');
function g5() {}
xt(g5, 'beforeNavigate');
function b5() {}
xt(b5, 'disableScrollHandling');
async function v5(...e) {
	const t = new CustomEvent('storybook:invalidate', { detail: e });
	window.dispatchEvent(t);
}
xt(v5, 'invalidate');
async function E5() {
	const e = new CustomEvent('storybook:invalidateAll');
	window.dispatchEvent(e);
}
xt(E5, 'invalidateAll');
function T5() {}
xt(T5, 'preloadCode');
function _5() {}
xt(_5, 'preloadData');
async function w5(...e) {
	const t = new CustomEvent('storybook:pushState', { detail: e });
	window.dispatchEvent(t);
}
xt(w5, 'pushState');
async function S5(...e) {
	const t = new CustomEvent('storybook:replaceState', { detail: e });
	window.dispatchEvent(t);
}
xt(S5, 'replaceState');
function Kc(e) {
	return [
		{
			subscribe(t) {
				const r = Nq(e);
				return (t(r), () => {});
			}
		},
		(t) => {
			Mq(e, t);
		}
	];
}
xt(Kc, 'createMockedStore');
var [R5, P5] = Kc('page-ctx'),
	[A5, O5] = Kc('navigating-ctx'),
	[Oj, C5] = Kc('updated-ctx');
Oj.check = () => {};
function x5() {
	return { page: R5, navigating: A5, updated: Oj };
}
xt(x5, 'getStores');
const { action: TE } = __STORYBOOK_MODULE_ACTIONS__;
function I5(e, t) {
	Bc(t, !0);
	const r = HK(t, 'svelteKitParameters', 19, () => ({}));
	(P5(r()?.stores?.page),
		O5(r()?.stores?.navigating),
		C5(r()?.stores?.updated),
		Aj(r()?.navigation?.afterNavigate));
	const n = (a) => (typeof a == 'function' ? { callback: a, asRegex: !1 } : a);
	mj(() => {
		const a = (p) => {
			const m = p.composedPath().findLast((y) => y instanceof HTMLElement && y.tagName === 'A');
			if (m && m instanceof HTMLAnchorElement) {
				const y = m.getAttribute('href');
				if (!y) return;
				p.preventDefault();
				const g = () => TE('navigate')(y, p);
				if (!r().hrefs) {
					g();
					return;
				}
				let E = !0;
				(Object.entries(r().hrefs).forEach(([T, b]) => {
					const { callback: w, asRegex: P } = n(b);
					(P ? new RegExp(T).test(y) : y === T) && ((E = !1), w?.(y, p));
				}),
					E && g());
			}
		};
		function u(p, f, m) {
			const y = [];
			return (
				f.forEach((g) => {
					const E = r()[p]?.[g] && r()[p][g] instanceof Function;
					if (E || m) {
						const T = ({ detail: w = [] }) => {
								const P = Array.isArray(w) ? w : [];
								(E ? r()[p][g] : TE(g))(...P);
							},
							b = `storybook:${g}`;
						(y.push({ eventType: b, listener: T }), window.addEventListener(b, T));
					}
				}),
				() => {
					y.forEach(({ eventType: g, listener: E }) => {
						window.removeEventListener(g, E);
					});
				}
			);
		}
		const c = u(
				'navigation',
				['goto', 'invalidate', 'invalidateAll', 'pushState', 'replaceState'],
				!0
			),
			d = u('forms', ['enhance']);
		return (
			window.addEventListener('click', a),
			() => {
				(window.removeEventListener('click', a), c(), d());
			}
		);
	});
	var o = Yo(),
		s = Ko(o);
	(FK(s, () => t.children), no(e, o), Jc());
}
const { fn: N5 } = __STORYBOOK_MODULE_TEST__,
	Rt = {
		data: {},
		form: null,
		error: null,
		params: {},
		route: { id: null },
		state: {},
		status: -1,
		url: new URL(location.origin)
	};
let _E = Ue(Rt.data),
	wE = Ue(Rt.form),
	SE = Ue(Rt.error),
	RE = Ue(Rt.params),
	PE = Ue(Rt.route),
	AE = Ue(Rt.state),
	OE = Ue(Rt.status),
	CE = Ue(Rt.url),
	fn = {
		get data() {
			return Pe(_E);
		},
		set data(e) {
			Ve(_E, e);
		},
		get form() {
			return Pe(wE);
		},
		set form(e) {
			Ve(wE, e);
		},
		get error() {
			return Pe(SE);
		},
		set error(e) {
			Ve(SE, e);
		},
		get params() {
			return Pe(RE);
		},
		set params(e) {
			Ve(RE, e);
		},
		get route() {
			return Pe(PE);
		},
		set route(e) {
			Ve(PE, e);
		},
		get state() {
			return Pe(AE);
		},
		set state(e) {
			Ve(AE, e);
		},
		get status() {
			return Pe(OE);
		},
		set status(e) {
			Ve(OE, e);
		},
		get url() {
			return Pe(CE);
		},
		set url(e) {
			Ve(CE, e);
		}
	};
function M5(e = {}) {
	((fn.data = e.data ?? Rt.data),
		(fn.form = e.form ?? Rt.form),
		(fn.error = e.error ?? Rt.error),
		(fn.params = e.params ?? Rt.params),
		(fn.route = e.route ?? Rt.route),
		(fn.state = e.state ?? Rt.state),
		(fn.status = e.status ?? Rt.status),
		(fn.url = e.url ?? Rt.url));
}
const nr = { from: null, to: null, type: null, willUnload: null, delta: null, complete: null };
let xE = Ue(nr.from),
	IE = Ue(nr.to),
	NE = Ue(nr.type),
	ME = Ue(nr.willUnload),
	qE = Ue(nr.delta),
	jE = Ue(nr.complete),
	Lo = {
		get from() {
			return Pe(xE);
		},
		set from(e) {
			Ve(xE, e);
		},
		get to() {
			return Pe(IE);
		},
		set to(e) {
			Ve(IE, e);
		},
		get type() {
			return Pe(NE);
		},
		set type(e) {
			Ve(NE, e);
		},
		get willUnload() {
			return Pe(ME);
		},
		set willUnload(e) {
			Ve(ME, e);
		},
		get delta() {
			return Pe(qE);
		},
		set delta(e) {
			Ve(qE, e);
		},
		get complete() {
			return Pe(jE);
		},
		set complete(e) {
			Ve(jE, e);
		}
	};
function q5(e = {}) {
	((Lo.from = e.from ?? nr.from),
		(Lo.to = e.to ?? nr.to),
		(Lo.type = e.type ?? nr.type),
		(Lo.willUnload = e.willUnload ?? nr.willUnload),
		(Lo.delta = e.delta ?? nr.delta),
		(Lo.complete = e.complete ?? nr.complete));
}
let xd = Ue(!1),
	j5 = {
		get current() {
			return Pe(xd);
		},
		set current(e) {
			Ve(xd, e);
		},
		check: N5(() => Promise.resolve(Pe(xd)))
	};
function D5(e = {}) {
	j5.current = e.current ?? !1;
}
var k5 = {};
f5(k5, { beforeEach: () => xj, decorators: () => Cj });
var L5 = xt((e, t) => {
		const r = t.parameters?.sveltekit_experimental ?? {};
		return { Component: I5, props: { svelteKitParameters: r } };
	}, 'svelteKitMocksDecorator'),
	Cj = [L5],
	xj = xt(async (e) => {
		const t = e.parameters?.sveltekit_experimental ?? {};
		(M5(t?.state?.page), q5(t?.state?.navigating), D5(t?.state?.updated));
	}, 'beforeEach');
const F5 = Object.freeze(
	Object.defineProperty({ __proto__: null, beforeEach: xj, decorators: Cj }, Symbol.toStringTag, {
		value: 'Module'
	})
);
var B5 = Object.create,
	Yc = Object.defineProperty,
	J5 = Object.getOwnPropertyDescriptor,
	Ij = Object.getOwnPropertyNames,
	$5 = Object.getPrototypeOf,
	U5 = Object.prototype.hasOwnProperty,
	DE = (e, t) => Yc(e, 'name', { value: t, configurable: !0 }),
	F8 = ((e) =>
		typeof require < 'u'
			? require
			: typeof Proxy < 'u'
				? new Proxy(e, { get: (t, r) => (typeof require < 'u' ? require : t)[r] })
				: e)(function (e) {
		if (typeof require < 'u') return require.apply(this, arguments);
		throw Error('Dynamic require of "' + e + '" is not supported');
	}),
	B8 = (e, t) =>
		function () {
			return (t || (0, e[Ij(e)[0]])((t = { exports: {} }).exports, t), t.exports);
		},
	V5 = (e, t) => {
		for (var r in t) Yc(e, r, { get: t[r], enumerable: !0 });
	},
	H5 = (e, t, r, n) => {
		if ((t && typeof t == 'object') || typeof t == 'function')
			for (let o of Ij(t))
				!U5.call(e, o) &&
					o !== r &&
					Yc(e, o, { get: () => t[o], enumerable: !(n = J5(t, o)) || n.enumerable });
		return e;
	},
	J8 = (e, t, r) => (
		(r = e != null ? B5($5(e)) : {}),
		H5(Yc(r, 'default', { value: e, enumerable: !0 }), e)
	),
	G5 = {};
V5(G5, { parameters: () => Nj });
var z5 = Object.entries(globalThis.TAGS_OPTIONS ?? {}).reduce((e, t) => {
		const [r, n] = t;
		return (n.excludeFromDocsStories && (e[r] = !0), e);
	}, {}),
	Nj = {
		docs: {
			renderer: DE(async () => {
				const { DocsRenderer: e } = await se(
					async () => {
						const { DocsRenderer: t } = await import('./DocsRenderer-HT7GNKAR-DtRZCYoH.js');
						return { DocsRenderer: t };
					},
					__vite__mapDeps([105, 7, 102]),
					import.meta.url
				);
				return new e();
			}, 'renderer'),
			stories: {
				filter: DE(
					(e) => (e.tags || []).filter((r) => z5[r]).length === 0 && !e.parameters.docs?.disable,
					'filter'
				)
			}
		}
	};
const W5 = Object.freeze(
		Object.defineProperty({ __proto__: null, parameters: Nj }, Symbol.toStringTag, {
			value: 'Module'
		})
	),
	K5 = {
		parameters: {
			controls: { matchers: { color: /(background|color)$/i, date: /Date$/ } },
			docs: { toc: !0, story: { inline: !1 } },
			options: { storySort: { order: ['Docs', ['Introduction', 'Token Reference'], '*'] } }
		}
	},
	Y5 = Object.freeze(
		Object.defineProperty({ __proto__: null, default: K5 }, Symbol.toStringTag, { value: 'Module' })
	);
eb();
const { composeConfigs: X5, PreviewWeb: Q5 } = __STORYBOOK_MODULE_PREVIEW_API__,
	Z5 = (e = []) => {
		const t = [e[0] ?? o5, e[1] ?? p5, e[2] ?? F5, e[3] ?? W5, e[4] ?? Y5];
		return X5(t);
	};
window.__STORYBOOK_PREVIEW__ = window.__STORYBOOK_PREVIEW__ || new Q5(AW, Z5);
window.__STORYBOOK_STORY_STORE__ =
	window.__STORYBOOK_STORY_STORE__ || window.__STORYBOOK_PREVIEW__.storyStore;
export {
	e8 as $,
	T8 as A,
	vE as B,
	Qe as C,
	Ad as D,
	C8 as E,
	Yo as F,
	Yq as G,
	J8 as H,
	B8 as I,
	Kz as J,
	Ri as K,
	Wc as L,
	Bq as M,
	gK as N,
	Y6 as O,
	X6 as P,
	lu as Q,
	Wr as R,
	nn as S,
	h8 as T,
	ka as U,
	Q6 as V,
	LW as W,
	DW as X,
	PK as Y,
	Js as Z,
	DE as _,
	Ko as a,
	w8 as a$,
	Ir as a0,
	qt as a1,
	Z6 as a2,
	Hc as a3,
	tj as a4,
	v8 as a5,
	RK as a6,
	Me as a7,
	Ve as a8,
	Od as a9,
	A8 as aA,
	_8 as aB,
	ro as aC,
	mj as aD,
	ja as aE,
	m8 as aF,
	DK as aG,
	LK as aH,
	JW as aI,
	Df as aJ,
	cn as aK,
	db as aL,
	n8 as aM,
	t8 as aN,
	r8 as aO,
	Gc as aP,
	ys as aQ,
	Ge as aR,
	UW as aS,
	l8 as aT,
	P8 as aU,
	Vc as aV,
	p8 as aW,
	K6 as aX,
	xf as aY,
	po as aZ,
	Bs as a_,
	O8 as aa,
	Ue as ab,
	O as ac,
	zz as ad,
	N8 as ae,
	d8 as af,
	y8 as ag,
	Kq as ah,
	dK as ai,
	s8 as aj,
	M8 as ak,
	pj as al,
	E8 as am,
	j8 as an,
	St as ao,
	o8 as ap,
	Sq as aq,
	u8 as ar,
	q8 as as,
	BW as at,
	Dn as au,
	hb as av,
	i8 as aw,
	Pi as ax,
	D8 as ay,
	lK as az,
	no as b,
	cl as b0,
	Yz as b1,
	Xz as b2,
	Qz as b3,
	Zz as b4,
	L6 as b5,
	k6 as b6,
	D6 as b7,
	j6 as b8,
	R6 as b9,
	T6 as ba,
	O6 as bb,
	E6 as bc,
	N6 as bd,
	_6 as be,
	A6 as bf,
	$6 as bg,
	J6 as bh,
	B6 as bi,
	H6 as bj,
	V6 as bk,
	P6 as bl,
	w6 as bm,
	q6 as bn,
	I6 as bo,
	C6 as bp,
	S6 as bq,
	x6 as br,
	M6 as bs,
	U6 as bt,
	F6 as bu,
	b6 as bv,
	Eq as bw,
	v6 as bx,
	GK as by,
	F8 as bz,
	Jc as c,
	Cd as d,
	g8 as e,
	xK as f,
	x8 as g,
	HK as h,
	R8 as i,
	k8 as j,
	FK as k,
	S8 as l,
	JK as m,
	a8 as n,
	L8 as o,
	Bc as p,
	Da as q,
	_K as r,
	b8 as s,
	I8 as t,
	mb as u,
	Pe as v,
	pl as w,
	f8 as x,
	Nq as y,
	Mq as z
};
